//===----------------------------------------------------------------------===//
//
// Part of the Viper project, under the GNU GPL v3.
// See LICENSE for license information.
//
//===----------------------------------------------------------------------===//
///
/// @file Sema_Runtime.cpp
/// @brief Runtime function registration for the Zia semantic analyzer.
///
/// @details This file implements the initialization of runtime function bindings
/// for the Zia semantic analyzer. It bridges the IL-layer RuntimeRegistry with
/// the Zia type system, enabling full type-checking of runtime function calls.
///
/// ## Registration Process
///
/// The initRuntimeFunctions() method performs three phases of registration:
///
/// ### Phase 1: Runtime Class Types
///
/// Registers each runtime class (e.g., "Viper.String", "Viper.File") as a
/// type in the Zia type registry. This enables the semantic analyzer to
/// recognize expressions like `new Viper.Graphics.Canvas(...)` and property
/// accesses like `canvas.Width`.
///
/// ### Phase 2: Methods and Properties from RuntimeRegistry
///
/// For each runtime class in the catalog:
///
/// 1. **Methods**: Parses the signature string (e.g., "str(i64,i64)") and
///    registers the function with full parameter type information. This
///    enables the semantic analyzer to validate argument types at compile time.
///
/// 2. **Properties**: Registers getter and setter functions. Getters are
///    zero-parameter functions returning the property type. Setters are
///    void functions taking the property type as a parameter.
///
/// ### Phase 3: Runtime Aliases (ZiaRuntimeExterns.inc)
///
/// Includes the generated ZiaRuntimeExterns.inc file which contains RT_ALIAS
/// entries from runtime.def. These are standalone functions not associated
/// with a class, such as `Viper.Time.SleepMs`. These use a simpler registration
/// format with return type only (no parameter validation).
///
/// ## Type Conversion
///
/// The RuntimeAdapter functions (toZiaType, toZiaParamTypes) convert IL-layer
/// type representations to Zia semantic types:
///
/// - ILScalarType::I64 → types::integer()
/// - ILScalarType::F64 → types::number()
/// - ILScalarType::Bool → types::boolean()
/// - ILScalarType::String → types::string()
/// - ILScalarType::Object → types::ptr()
/// - ILScalarType::Void → types::voidType()
///
/// ## Example Registration
///
/// For `Viper.String.Substring` with signature "str(i64,i64)":
///
/// ```cpp
/// // Parsed signature: returnType=String, params=[I64, I64]
/// defineExternFunction(
///     "Viper.String.Substring",  // extern target name
///     types::string(),           // return type
///     {types::integer(), types::integer()}  // parameter types
/// );
/// ```
///
/// This enables the semantic analyzer to verify that calls like:
/// ```zia
/// var s = "hello".Substring(0, 3)  // OK: Integer arguments
/// var s = "hello".Substring("a")   // ERROR: String argument, expected Integer
/// ```
///
/// ## Thread Safety
///
/// This function is called once during Sema initialization before any
/// concurrent access. The RuntimeRegistry itself is thread-safe and immutable.
///
/// @see RuntimeAdapter.hpp - Type conversion between IL and Zia types
/// @see il::runtime::RuntimeRegistry - Source of runtime signatures
/// @see Sema::defineExternFunction - Registers extern functions in symbol table
/// @see ZiaRuntimeExterns.inc - Generated alias registrations
///
//===----------------------------------------------------------------------===//

#include "frontends/zia/RuntimeAdapter.hpp"
#include "frontends/zia/Sema.hpp"
#include "il/runtime/classes/RuntimeClasses.hpp"

namespace il::frontends::zia
{

/// @brief Initializes all runtime function bindings for semantic analysis.
///
/// @details This method populates the Zia semantic analyzer's symbol table
/// with extern declarations for all runtime functions. It uses the unified
/// RuntimeRegistry to ensure signature information is consistent with other
/// frontends.
///
/// The registration happens in three phases:
///
/// 1. **Type Registration**: Each runtime class is registered as a named type,
///    enabling `new ClassName()` expressions and type annotations.
///
/// 2. **Method/Property Registration**: For each class, all methods and
///    properties are registered with full type signatures. Methods get their
///    signature from parseRuntimeSignature(); properties get separate getter
///    and setter registrations.
///
/// 3. **Alias Registration**: The ZiaRuntimeExterns.inc file is included to
///    register standalone functions (RT_ALIAS entries) that aren't part of
///    a class.
///
/// ## Error Handling
///
/// Methods with unparseable signatures (isValid() returns false) are silently
/// skipped. This is acceptable because:
/// - The signature format is well-defined and generated by rtgen
/// - Invalid signatures indicate a bug in runtime.def, not user code
/// - The method simply won't be available for use
///
/// ## Performance
///
/// This function is called once during Sema construction. The cost is O(n*m)
/// where n is the number of runtime classes and m is the average number of
/// methods/properties per class. With the current runtime library (~150
/// classes, ~2000 methods), this takes negligible time.
///
void Sema::initRuntimeFunctions()
{
    // Access the singleton RuntimeRegistry which contains all parsed signatures
    const auto &registry = il::runtime::RuntimeRegistry::instance();
    const auto &catalog = registry.rawCatalog();

    //==========================================================================
    // Phase 1: Register runtime class types
    //==========================================================================
    // Each runtime class becomes a named type in the Zia type registry.
    // This enables type checking for:
    // - Variable declarations: `var f: Viper.File`
    // - Constructor calls: `new Viper.File("path.txt")`
    // - Type comparisons and casts
    for (const auto &cls : catalog)
    {
        typeRegistry_[cls.qname] = types::runtimeClass(cls.qname);
    }

    //==========================================================================
    // Phase 2: Register methods and properties with full signatures
    //==========================================================================
    for (const auto &cls : catalog)
    {
        //----------------------------------------------------------------------
        // Register all methods for this class
        //----------------------------------------------------------------------
        for (const auto &m : cls.methods)
        {
            // Parse the signature string (e.g., "str(i64,i64)") into structured form
            auto sig = il::runtime::parseRuntimeSignature(m.signature ? m.signature : "");
            if (!sig.isValid())
                continue; // Skip methods with unparseable signatures

            // Convert IL types to Zia types
            TypeRef returnType = toZiaType(sig.returnType);
            if (sig.isOptionalReturn)
                returnType = types::optional(returnType);
            std::vector<TypeRef> paramTypes = toZiaParamTypes(sig);

            // Register the extern function with full type information
            defineExternFunction(m.target ? m.target : "", returnType, paramTypes);
        }

        //----------------------------------------------------------------------
        // Register property getters and setters
        //----------------------------------------------------------------------
        for (const auto &p : cls.properties)
        {
            // Convert the property's IL type to a Zia type
            auto propType = toZiaType(il::runtime::mapILToken(p.type ? p.type : ""));

            // Register getter: no parameters, returns property type
            // Example: Viper.String.get_Length() -> Integer
            if (p.getter)
            {
                defineExternFunction(p.getter, propType, {});
            }

            // Register setter: takes property type, returns void
            // Example: Viper.GUI.Widget.set_Visible(Boolean) -> void
            if (p.setter)
            {
                defineExternFunction(p.setter, types::voidType(), {propType});
            }
        }
    }

    //==========================================================================
    // Phase 3: Include generated aliases from runtime.def
    //==========================================================================
    // The ZiaRuntimeExterns.inc file is generated by rtgen from runtime.def.
    // It contains RT_ALIAS entries for standalone functions like:
    // - Viper.Time.SleepMs(i64)
    // - Viper.Convert.IntToStr(i64) -> str
    //
    // These use the older registration format (return type only, no param types)
    // for backward compatibility. The class methods registered above already
    // have full parameter type information.
#include "il/runtime/ZiaRuntimeExterns.inc"
}

} // namespace il::frontends::zia
