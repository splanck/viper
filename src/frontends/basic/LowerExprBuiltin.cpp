//===----------------------------------------------------------------------===//
//
// Part of the Viper project, under the MIT License.
// See LICENSE for license information.
//
//===----------------------------------------------------------------------===//
//
// Implements the lowering engine that translates BASIC builtin calls to IL.
// The module consumes the declarative builtin registry, selects the correct
// lowering variant, and emits control-flow or runtime helper invocations as
// required.  String builtins are delegated to the specialised string lowering
// context while other builtins fall back to rule-driven emission.
//
//===----------------------------------------------------------------------===//

/// @file
/// @brief Lowering helpers for BASIC builtin expressions.
/// @details `BuiltinExprLowering` interprets the rule tables generated by the
///          builtin registry, handling argument coercions, runtime helper
///          requests, and diagnostic reporting when unsupported variants are
///          encountered.

#include "frontends/basic/LowerExprBuiltin.hpp"

#include "frontends/basic/DiagnosticEmitter.hpp"
#include "frontends/basic/lower/common/BuiltinUtils.hpp"

#include <algorithm>
#include <array>
#include <cassert>
#include <cstdint>
#include <limits>
#include <string>
#include <string_view>
#include <utility>

namespace il::frontends::basic
{
using il::core::BasicBlock;
using il::core::Function;
using il::core::Opcode;
using il::core::Value;
using IlType = il::core::Type;
using IlKind = IlType::Kind;

namespace
{
constexpr std::string_view kDiagMissingBuiltinEmitter = "B4004";

/// @brief Translate a builtin enumerator into its dense table index.
///
/// @param builtin Builtin enumerator value.
/// @return Zero-based index suitable for array access.
constexpr std::size_t builtinIndex(BuiltinCallExpr::Builtin builtin) noexcept
{
    return static_cast<std::size_t>(builtin);
}

/// @brief Generate the dispatch table mapping builtin ordinals to emitters.
///
/// @details Populates the table with the default rule-driven emitter and then
///          overrides entries for builtins that require bespoke lowering logic.
///
/// @return Array of emitter function pointers aligned with the builtin enum.
constexpr auto makeBuiltinEmitterTable()
{
    using Lowering = BuiltinExprLowering;
    std::array<Lowering::EmitFn, builtinIndex(BuiltinCallExpr::Builtin::Loc) + 1> table{};
    table.fill(&Lowering::emitRuleDrivenBuiltin);
    table[builtinIndex(BuiltinCallExpr::Builtin::Eof)] = &Lowering::emitEofBuiltin;
    table[builtinIndex(BuiltinCallExpr::Builtin::Lof)] = &Lowering::emitLofBuiltin;
    table[builtinIndex(BuiltinCallExpr::Builtin::Loc)] = &Lowering::emitLocBuiltin;
    return table;
}

constexpr auto kBuiltinEmitters = makeBuiltinEmitterTable();
} // namespace

/// @brief Construct a lowering facade bound to a specific lowering driver.
///
/// @param lowerer Owning lowering engine responsible for emitting IL.
BuiltinExprLowering::BuiltinExprLowering(Lowerer &lowerer) noexcept : lowerer_(&lowerer) {}

/// @brief Lower a builtin call by dispatching to the correct emitter.
///
/// @details The dispatcher first selects an emitter from the static table,
///          falling back to an "unsupported" stub when no emitter is available
///          so that diagnostic machinery can report the missing handler.
///
/// @param expr AST node describing the builtin invocation.
/// @return Lowered r-value representing the builtin's result.
Lowerer::RVal BuiltinExprLowering::lower(const BuiltinCallExpr &expr)
{
    Lowerer &self = *lowerer_;
    const auto idx = builtinIndex(expr.builtin);
    EmitFn emitter = idx < kBuiltinEmitters.size() ? kBuiltinEmitters[idx] : nullptr;
    if (!emitter)
        emitter = &emitUnsupportedBuiltin;
    return emitter(self, expr);
}

/// @brief Lower a builtin using the declarative rule tables.
///
/// @details The rule-driven path constructs a @ref lower::BuiltinLowerContext
///          and looks up the builtin name in the registry exposed by
///          `BuiltinUtils`.  Each registered family (string, math, conversions)
///          delegates to a focused helper, while unregistered names fall back
///          to the generic rule-driven lowering routine.
///
/// @param lowerer Owning lowering engine.
/// @param call AST node representing the builtin invocation.
/// @return Lowered r-value implementing the builtin semantics.
Lowerer::RVal BuiltinExprLowering::emitRuleDrivenBuiltin(Lowerer &lowerer,
                                                         const BuiltinCallExpr &call)
{
    return lower::common::lowerBuiltinCall(lowerer, call);
}

/// @brief Lower the LOF builtin, handling runtime error propagation.
///
/// @details LOF queries the runtime for the length of an open file channel.
///          The lowering routine normalises the channel argument, emits the
///          runtime call, and synthesises control flow that traps when the
///          runtime reports an error code.  The resulting value is the length on
///          success.
///
/// @param lowerer Owning lowering engine.
/// @param expr AST node describing the builtin invocation.
/// @return Lowered r-value representing the file length.
Lowerer::RVal BuiltinExprLowering::emitLofBuiltin(Lowerer &lowerer, const BuiltinCallExpr &expr)
{
    lowerer.requireLofCh();
    if (expr.args.empty() || !expr.args[0])
        return {Value::constInt(0), IlType(IlKind::I64)};

    Lowerer::RVal channel = lowerer.lowerExpr(*expr.args[0]);
    channel = lowerer.normalizeChannelToI32(std::move(channel), expr.loc);

    lowerer.curLoc = expr.loc;
    Value raw32 = lowerer.emitCallRet(IlType(IlKind::I32), "rt_lof_ch", {channel.value});

    Value rawI64 = raw32;
    {
        Value scratch = lowerer.emitAlloca(sizeof(int64_t));
        lowerer.emitStore(IlType(IlKind::I64), scratch, Value::constInt(0));
        lowerer.emitStore(IlType(IlKind::I32), scratch, raw32);
        rawI64 = lowerer.emitLoad(IlType(IlKind::I64), scratch);
    }

    // --- begin: sign-extend 32->64 for LOF ---
    {
        Value shl =
            lowerer.emitBinary(Opcode::Shl, IlType(IlKind::I64), rawI64, Value::constInt(32));
        rawI64 = lowerer.emitBinary(Opcode::AShr, IlType(IlKind::I64), shl, Value::constInt(32));
    }
    // --- end: sign-extend 32->64 for LOF ---

    Lowerer::ProcedureContext &ctx = lowerer.context();
    Function *func = ctx.function();
    BasicBlock *origin = ctx.current();
    if (func && origin)
    {
        std::size_t originIdx = static_cast<std::size_t>(origin - &func->blocks[0]);
        Lowerer::BlockNamer *blockNamer = ctx.blockNames().namer();
        std::string failLbl =
            blockNamer ? blockNamer->generic("lof_err") : lowerer.mangler.block("lof_err");
        std::string contLbl =
            blockNamer ? blockNamer->generic("lof_cont") : lowerer.mangler.block("lof_cont");

        std::size_t failIdx = func->blocks.size();
        lowerer.builder->addBlock(*func, failLbl);
        std::size_t contIdx = func->blocks.size();
        lowerer.builder->addBlock(*func, contLbl);

        BasicBlock *failBlk = &func->blocks[failIdx];
        BasicBlock *contBlk = &func->blocks[contIdx];

        ctx.setCurrent(&func->blocks[originIdx]);
        lowerer.curLoc = expr.loc;

        // --- begin: LOF error predicate (negative return => error) ---
        {
            // Extract sign bit: arithmetic shift right by 63.
            Value sign =
                lowerer.emitBinary(Opcode::AShr, IlType(IlKind::I64), rawI64, Value::constInt(63));
            Value isError =
                lowerer.emitBinary(Opcode::ICmpNe, lowerer.ilBoolTy(), sign, Value::constInt(0));
            lowerer.emitCBr(isError, failBlk, contBlk);
        }
        // --- end: LOF error predicate ---

        ctx.setCurrent(failBlk);
        lowerer.curLoc = expr.loc;
        Value negCode = lowerer.emitISub(Value::constInt(0), rawI64);
        Value err32 = lowerer.emitCommon(expr.loc).narrow_to(negCode, 64, 32);
        lowerer.emitTrapFromErr(err32);

        ctx.setCurrent(contBlk);
    }

    lowerer.curLoc = expr.loc;
    Lowerer::RVal widened{raw32, IlType(IlKind::I32)};
    widened = lowerer.ensureI64(std::move(widened), expr.loc);
    return widened;
}

/// @brief Lower the EOF builtin with structured error handling.
///
/// @details EOF returns a boolean flag but can also signal runtime errors via
///          sentinel values.  The lowering routine emits the runtime call,
///          constructs control flow that traps on error, and widens the result
///          back to I64 to satisfy BASIC semantics.
///
/// @param lowerer Owning lowering engine.
/// @param expr AST node describing the builtin invocation.
/// @return Lowered r-value representing the EOF flag.
Lowerer::RVal BuiltinExprLowering::emitEofBuiltin(Lowerer &lowerer, const BuiltinCallExpr &expr)
{
    lowerer.requireEofCh();
    if (expr.args.empty() || !expr.args[0])
        return {Value::constInt(0), IlType(IlKind::I64)};

    Lowerer::RVal channel = lowerer.lowerExpr(*expr.args[0]);
    channel = lowerer.normalizeChannelToI32(std::move(channel), expr.loc);

    lowerer.curLoc = expr.loc;
    Value raw = lowerer.emitCallRet(IlType(IlKind::I32), "rt_eof_ch", {channel.value});

    // Normalise the runtime's 32-bit error code to i64 prior to any equality
    // comparisons to keep parity with emitRuntimeErrCheck's widened checks.
    Value rawI64 = raw;
    {
        Value scratch = lowerer.emitAlloca(sizeof(int64_t));
        lowerer.emitStore(IlType(IlKind::I64), scratch, Value::constInt(0));
        lowerer.emitStore(IlType(IlKind::I32), scratch, raw);
        rawI64 = lowerer.emitLoad(IlType(IlKind::I64), scratch);
    }
    // --- begin: sign-extend 32->64 for EOF ---
    {
        // rawI64 currently holds the zero-extended 32-bit return.
        // Make it signed by (x << 32) >> 32 using arithmetic shift.
        Value shl =
            lowerer.emitBinary(Opcode::Shl, IlType(IlKind::I64), rawI64, Value::constInt(32));
        rawI64 = lowerer.emitBinary(Opcode::AShr, IlType(IlKind::I64), shl, Value::constInt(32));
    }
    // --- end: sign-extend 32->64 for EOF ---

    Lowerer::ProcedureContext &ctx = lowerer.context();
    Function *func = ctx.function();
    BasicBlock *origin = ctx.current();
    if (func && origin)
    {
        std::size_t originIdx = static_cast<std::size_t>(origin - &func->blocks[0]);
        Lowerer::BlockNamer *blockNamer = ctx.blockNames().namer();
        std::string failLbl =
            blockNamer ? blockNamer->generic("eof_err") : lowerer.mangler.block("eof_err");
        std::string contLbl =
            blockNamer ? blockNamer->generic("eof_cont") : lowerer.mangler.block("eof_cont");

        std::size_t failIdx = func->blocks.size();
        lowerer.builder->addBlock(*func, failLbl);
        std::size_t contIdx = func->blocks.size();
        lowerer.builder->addBlock(*func, contLbl);

        BasicBlock *failBlk = &func->blocks[failIdx];
        BasicBlock *contBlk = &func->blocks[contIdx];

        ctx.setCurrent(&func->blocks[originIdx]);
        lowerer.curLoc = expr.loc;
        // --- begin: EOF error predicate via i64 logical masks ---
        {
            // rawI64 is the sign-extended 64-bit value from rt_eof_ch (I32 -> I64).
            // Error iff (raw != 0) && (raw != -1). Do this by building BASIC-style
            // logical masks (-1 for true, 0 for false) and ANDing them in i64.

            Value notZero =
                lowerer.emitBinary(Opcode::ICmpNe, lowerer.ilBoolTy(), rawI64, Value::constInt(0));
            Value notNegOne =
                lowerer.emitBinary(Opcode::ICmpNe, lowerer.ilBoolTy(), rawI64, Value::constInt(-1));

            // i1 -> i64 BASIC logical masks: true -> -1, false -> 0
            Value m1 = lowerer.emitBasicLogicalI64(notZero);
            Value m2 = lowerer.emitBasicLogicalI64(notNegOne);

            // Bitwise AND (i64), then compare with 0 to get an i1 for cbr
            Value both = lowerer.emitCommon(expr.loc).logical_and(m1, m2);
            Value isError =
                lowerer.emitBinary(Opcode::ICmpNe, lowerer.ilBoolTy(), both, Value::constInt(0));

            lowerer.emitCBr(isError, failBlk, contBlk);
        }
        // --- end: EOF error predicate via i64 logical masks ---

        ctx.setCurrent(failBlk);
        lowerer.curLoc = expr.loc;
        lowerer.emitTrapFromErr(raw);

        ctx.setCurrent(contBlk);
    }

    lowerer.curLoc = expr.loc;
    return {rawI64, IlType(IlKind::I64)};
}

/// @brief Lower the LOC builtin that reports the current file position.
///
/// @details LOC mirrors LOF's control-flow handling: it normalises the channel
///          number, emits the runtime call, and traps when the helper returns an
///          error.  The resulting value is the current record pointer.
///
/// @param lowerer Owning lowering engine.
/// @param expr AST node describing the builtin invocation.
/// @return Lowered r-value representing the current file position.
Lowerer::RVal BuiltinExprLowering::emitLocBuiltin(Lowerer &lowerer, const BuiltinCallExpr &expr)
{
    lowerer.requireLocCh();
    if (expr.args.empty() || !expr.args[0])
        return {Value::constInt(0), IlType(IlKind::I64)};

    Lowerer::RVal channel = lowerer.lowerExpr(*expr.args[0]);
    channel = lowerer.normalizeChannelToI32(std::move(channel), expr.loc);

    lowerer.curLoc = expr.loc;
    Value raw32 = lowerer.emitCallRet(IlType(IlKind::I32), "rt_loc_ch", {channel.value});

    Value rawI64 = raw32;
    {
        Value scratch = lowerer.emitAlloca(sizeof(int64_t));
        lowerer.emitStore(IlType(IlKind::I64), scratch, Value::constInt(0));
        lowerer.emitStore(IlType(IlKind::I32), scratch, raw32);
        rawI64 = lowerer.emitLoad(IlType(IlKind::I64), scratch);
    }

    // --- begin: sign-extend 32->64 for LOC ---
    {
        Value shl =
            lowerer.emitBinary(Opcode::Shl, IlType(IlKind::I64), rawI64, Value::constInt(32));
        rawI64 = lowerer.emitBinary(Opcode::AShr, IlType(IlKind::I64), shl, Value::constInt(32));
    }
    // --- end: sign-extend 32->64 for LOC ---

    Lowerer::ProcedureContext &ctx = lowerer.context();
    Function *func = ctx.function();
    BasicBlock *origin = ctx.current();
    if (func && origin)
    {
        std::size_t originIdx = static_cast<std::size_t>(origin - &func->blocks[0]);
        Lowerer::BlockNamer *blockNamer = ctx.blockNames().namer();
        std::string failLbl =
            blockNamer ? blockNamer->generic("loc_err") : lowerer.mangler.block("loc_err");
        std::string contLbl =
            blockNamer ? blockNamer->generic("loc_cont") : lowerer.mangler.block("loc_cont");

        std::size_t failIdx = func->blocks.size();
        lowerer.builder->addBlock(*func, failLbl);
        std::size_t contIdx = func->blocks.size();
        lowerer.builder->addBlock(*func, contLbl);

        BasicBlock *failBlk = &func->blocks[failIdx];
        BasicBlock *contBlk = &func->blocks[contIdx];

        ctx.setCurrent(&func->blocks[originIdx]);
        lowerer.curLoc = expr.loc;
        // --- begin: LOC error predicate (negative return => error) ---
        {
            Value sign =
                lowerer.emitBinary(Opcode::AShr, IlType(IlKind::I64), rawI64, Value::constInt(63));
            Value isError =
                lowerer.emitBinary(Opcode::ICmpNe, lowerer.ilBoolTy(), sign, Value::constInt(0));
            lowerer.emitCBr(isError, failBlk, contBlk);
        }
        // --- end: LOC error predicate ---

        ctx.setCurrent(failBlk);
        lowerer.curLoc = expr.loc;
        Value negCode = lowerer.emitISub(Value::constInt(0), rawI64);
        Value err32 = lowerer.emitCommon(expr.loc).narrow_to(negCode, 64, 32);
        lowerer.emitTrapFromErr(err32);

        ctx.setCurrent(contBlk);
    }

    lowerer.curLoc = expr.loc;
    Lowerer::RVal widened{raw32, IlType(IlKind::I32)};
    widened = lowerer.ensureI64(std::move(widened), expr.loc);
    return widened;
}

/// @brief Fallback emitter used when no lowering rule exists for a builtin.
///
/// @details Emits a diagnostic (when possible) so missing emitters surface
///          during compilation and returns a dummy integer value.
///
/// @param lowerer Owning lowering engine.
/// @param expr AST node describing the builtin invocation.
/// @return Placeholder integer result.
Lowerer::RVal BuiltinExprLowering::emitUnsupportedBuiltin(Lowerer &lowerer,
                                                          const BuiltinCallExpr &expr)
{
    if (auto *diag = lowerer.diagnosticEmitter())
    {
        // This path should never trigger when the registry is complete, but provide a
        // diagnostic so accidental omissions still surface during lowering.
        lowerer.curLoc = expr.loc;
        diag->emit(il::support::Severity::Error,
                   std::string(kDiagMissingBuiltinEmitter),
                   lowerer.curLoc,
                   0,
                   "no emitter registered for builtin call");
    }

    return {Value::constInt(0), IlType(IlKind::I64)};
}

/// @brief Lower a builtin call through the rule-driven lowering engine.
///
/// @param expr Builtin call expression awaiting lowering.
/// @return Resulting lowered value.
Lowerer::RVal Lowerer::lowerBuiltinCall(const BuiltinCallExpr &expr)
{
    BuiltinExprLowering lowering(*this);
    return lowering.lower(expr);
}

/// @brief Convenience wrapper that lowers a builtin call using an explicit lowerer.
///
/// @param lowerer Lowering engine to use for emission.
/// @param expr Builtin call expression awaiting lowering.
/// @return Result of the lowering operation.
Lowerer::RVal lowerBuiltinCall(Lowerer &lowerer, const BuiltinCallExpr &expr)
{
    BuiltinExprLowering lowering(lowerer);
    return lowering.lower(expr);
}

} // namespace il::frontends::basic
