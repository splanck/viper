// File: src/frontends/basic/LowerStmt_Control.cpp
// License: MIT License. See LICENSE in the project root for full license information.
// Purpose: Implements control-flow lowering helpers for BASIC statements,
//          covering conditionals, loops, and GOTO/GOSUB constructs.
// Key invariants: Helpers manipulate the active Lowerer context to build
//                 deterministic block graphs while respecting loop/handler
//                 stacks.
// Ownership/Lifetime: Operates on Lowerer without owning AST nodes or IL state.
// Links: docs/codemap.md

#include "frontends/basic/Lowerer.hpp"
#include "frontends/basic/SelectCaseLowering.hpp"

#include <cassert>

using namespace il::core;

namespace il::frontends::basic
{

Lowerer::IfBlocks Lowerer::emitIfBlocks(size_t conds)
{
    ProcedureContext &ctx = context();
    Function *func = ctx.function();
    assert(func && ctx.current());
    BlockNamer *blockNamer = ctx.blockNames().namer();
    size_t curIdx = static_cast<size_t>(ctx.current() - &func->blocks[0]);
    size_t start = func->blocks.size();
    unsigned firstId = 0;
    for (size_t i = 0; i < conds; ++i)
    {
        unsigned id = blockNamer ? blockNamer->nextIf() : static_cast<unsigned>(i);
        if (i == 0)
            firstId = id;
        std::string testLbl = blockNamer ? blockNamer->generic("if_test")
                                         : mangler.block("if_test_" + std::to_string(i));
        std::string thenLbl = blockNamer ? blockNamer->ifThen(id)
                                         : mangler.block("if_then_" + std::to_string(i));
        builder->addBlock(*func, testLbl);
        builder->addBlock(*func, thenLbl);
    }
    std::string elseLbl = blockNamer ? blockNamer->ifElse(firstId) : mangler.block("if_else");
    std::string endLbl = blockNamer ? blockNamer->ifEnd(firstId) : mangler.block("if_exit");
    builder->addBlock(*func, elseLbl);
    builder->addBlock(*func, endLbl);
    ctx.setCurrent(&func->blocks[curIdx]);
    std::vector<size_t> testIdx(conds);
    std::vector<size_t> thenIdx(conds);
    for (size_t i = 0; i < conds; ++i)
    {
        testIdx[i] = start + 2 * i;
        thenIdx[i] = start + 2 * i + 1;
    }
    size_t elseIdx = start + 2 * conds;
    size_t exitIdx = start + 2 * conds + 1;
    return {std::move(testIdx), std::move(thenIdx), elseIdx, exitIdx};
}

/// @brief Lower the conditional branch used by an IF arm.
/// @param cond Expression providing the truth value.
/// @param testBlk Block that evaluates the condition.
/// @param thenBlk Destination when the condition is true.
/// @param falseBlk Destination when the condition is false.
/// @param loc Source location for diagnostics.
/// @details Moves @ref cur to @p testBlk, converts the expression to an I1 if
///          necessary, and emits a conditional branch that targets @p thenBlk
///          or @p falseBlk. @ref curLoc is refreshed so diagnostics generated by
///          failed conversions or runtime checks report @p loc.
void Lowerer::lowerIfCondition(const Expr &cond,
                               BasicBlock *testBlk,
                               BasicBlock *thenBlk,
                               BasicBlock *falseBlk,
                               il::support::SourceLoc loc)
{
    context().setCurrent(testBlk);
    lowerCondBranch(cond, thenBlk, falseBlk, loc);
}

/// @brief Lower the body of a single IF or ELSE branch.
/// @param stmt Statement executed when the branch is taken (may be null).
/// @param thenBlk Block that holds the branch body.
/// @param exitBlk Merge block for fall-through control flow.
/// @param loc Source location for diagnostics.
/// @return @c true when the branch falls through to @p exitBlk.
/// @details Positions @ref cur at @p thenBlk, lowers the branch body if
///          present, and emits an explicit jump to @p exitBlk when the lowered
///          code left the block unterminated. The helper sets @ref curLoc before
///          emitting the merge branch, ensuring diagnostics attribute to
///          @p loc.
bool Lowerer::lowerIfBranch(const Stmt *stmt,
                            BasicBlock *thenBlk,
                            BasicBlock *exitBlk,
                            il::support::SourceLoc loc)
{
    context().setCurrent(thenBlk);
    if (stmt)
        lowerStmt(*stmt);
    BasicBlock *current = context().current();
    if (current && !current->terminated)
    {
        curLoc = loc;
        emitBr(exitBlk);
        return true;
    }
    return false;
}

/// Control helpers follow the invariant that CtrlState::after references the
/// surviving merge/done block. Helpers clear it when the merge block is erased
/// to keep terminator management localized.
Lowerer::CtrlState Lowerer::emitIf(const IfStmt &stmt)
{
    CtrlState state{};
    auto &ctx = context();
    auto *func = ctx.function();
    auto *current = ctx.current();
    if (!func || !current)
        return state;

    const size_t conds = 1 + stmt.elseifs.size();
    IfBlocks blocks = emitIfBlocks(conds);

    std::vector<const Expr *> condExprs;
    std::vector<const Stmt *> thenStmts;
    condExprs.reserve(conds);
    thenStmts.reserve(conds);
    condExprs.push_back(stmt.cond.get());
    thenStmts.push_back(stmt.then_branch.get());
    for (const auto &e : stmt.elseifs)
    {
        condExprs.push_back(e.cond.get());
        thenStmts.push_back(e.then_branch.get());
    }

    func = ctx.function();
    curLoc = stmt.loc;
    emitBr(&func->blocks[blocks.tests[0]]);

    bool fallthrough = false;
    for (size_t i = 0; i < conds; ++i)
    {
        func = ctx.function();
        auto *testBlk = &func->blocks[blocks.tests[i]];
        auto *thenBlk = &func->blocks[blocks.thens[i]];
        auto *falseBlk = (i + 1 < conds) ? &func->blocks[blocks.tests[i + 1]]
                                         : &func->blocks[blocks.elseIdx];
        lowerIfCondition(*condExprs[i], testBlk, thenBlk, falseBlk, stmt.loc);

        func = ctx.function();
        thenBlk = &func->blocks[blocks.thens[i]];
        auto *exitBlk = &func->blocks[blocks.exitIdx];
        fallthrough = lowerIfBranch(thenStmts[i], thenBlk, exitBlk, stmt.loc) || fallthrough;
    }

    func = ctx.function();
    auto *elseBlk = &func->blocks[blocks.elseIdx];
    auto *exitBlk = &func->blocks[blocks.exitIdx];
    fallthrough = lowerIfBranch(stmt.else_branch.get(), elseBlk, exitBlk, stmt.loc) || fallthrough;

    if (!fallthrough)
    {
        func->blocks.pop_back();
        func = ctx.function();
        ctx.setCurrent(&func->blocks[blocks.elseIdx]);
        state.cur = ctx.current();
        state.after = nullptr;
        state.fallthrough = false;
        return state;
    }

    ctx.setCurrent(&func->blocks[blocks.exitIdx]);
    state.cur = ctx.current();
    state.after = state.cur;
    state.fallthrough = true;
    return state;
}

/// @brief Lower an IF/ELSEIF/ELSE cascade.
/// @param stmt IF statement containing branches and optional else.
void Lowerer::lowerIf(const IfStmt &stmt)
{
    CtrlState state = emitIf(stmt);
    if (state.cur)
        context().setCurrent(state.cur);
}

/// @brief Lower statements forming a loop body until a terminator is hit.
/// @param body Sequence of statements comprising the loop body.
/// @details Iterates @p body and delegates to @ref lowerStmt while respecting
///          the current block's termination state. When @ref cur becomes null
///          or terminated the helper stops lowering additional statements.
void Lowerer::lowerLoopBody(const std::vector<StmtPtr> &body)
{
    for (const auto &stmt : body)
    {
        if (!stmt)
            continue;
        lowerStmt(*stmt);
        BasicBlock *current = context().current();
        if (!current || current->terminated)
            break;
    }
}

/// @brief Lower a WHILE loop into head/body/done blocks.
/// @param stmt WHILE statement describing the loop structure.
Lowerer::CtrlState Lowerer::emitWhile(const WhileStmt &stmt)
{
    CtrlState state{};
    auto &ctx = context();
    auto *func = ctx.function();
    auto *current = ctx.current();
    if (!func || !current)
        return state;

    BlockNamer *blockNamer = ctx.blockNames().namer();
    size_t start = func->blocks.size();
    unsigned id = blockNamer ? blockNamer->nextWhile() : 0;
    std::string headLbl = blockNamer ? blockNamer->whileHead(id) : mangler.block("loop_head");
    std::string bodyLbl = blockNamer ? blockNamer->whileBody(id) : mangler.block("loop_body");
    std::string doneLbl = blockNamer ? blockNamer->whileEnd(id) : mangler.block("done");
    builder->addBlock(*func, headLbl);
    builder->addBlock(*func, bodyLbl);
    builder->addBlock(*func, doneLbl);

    func = ctx.function();
    size_t headIdx = start;
    size_t bodyIdx = start + 1;
    size_t doneIdx = start + 2;
    auto *head = &func->blocks[headIdx];
    auto *body = &func->blocks[bodyIdx];
    auto *done = &func->blocks[doneIdx];
    state.after = done;

    ctx.loopState().push(done);

    curLoc = stmt.loc;
    emitBr(head);

    func = ctx.function();
    head = &func->blocks[headIdx];
    body = &func->blocks[bodyIdx];
    done = &func->blocks[doneIdx];

    ctx.setCurrent(head);
    curLoc = stmt.loc;
    lowerCondBranch(*stmt.cond, body, done, stmt.loc);

    func = ctx.function();
    body = &func->blocks[bodyIdx];
    done = &func->blocks[doneIdx];

    ctx.setCurrent(body);
    lowerLoopBody(stmt.body);
    auto *bodyCur = ctx.current();
    bool exitTaken = ctx.loopState().taken();
    bool term = bodyCur && bodyCur->terminated;
    if (!term)
    {
        func = ctx.function();
        head = &func->blocks[headIdx];
        curLoc = stmt.loc;
        emitBr(head);
    }

    func = ctx.function();
    done = &func->blocks[doneIdx];
    ctx.loopState().refresh(done);
    ctx.setCurrent(done);
    done->terminated = exitTaken ? false : term;
    ctx.loopState().pop();

    state.cur = ctx.current();
    state.after = state.cur;
    state.fallthrough = !done->terminated;
    return state;
}

/// @brief Lower a WHILE loop into head/body/done blocks.
/// @param stmt WHILE statement describing the loop structure.
void Lowerer::lowerWhile(const WhileStmt &stmt)
{
    CtrlState state = emitWhile(stmt);
    if (state.cur)
        context().setCurrent(state.cur);
}

Lowerer::CtrlState Lowerer::emitDo(const DoStmt &stmt)
{
    CtrlState state{};
    auto &ctx = context();
    auto *func = ctx.function();
    auto *current = ctx.current();
    if (!func || !current)
        return state;

    BlockNamer *blockNamer = ctx.blockNames().namer();
    size_t start = func->blocks.size();
    unsigned id = blockNamer ? blockNamer->nextDo() : 0;
    std::string headLbl = blockNamer ? blockNamer->doHead(id) : mangler.block("do_head");
    std::string bodyLbl = blockNamer ? blockNamer->doBody(id) : mangler.block("do_body");
    std::string doneLbl = blockNamer ? blockNamer->doEnd(id) : mangler.block("do_done");
    builder->addBlock(*func, headLbl);
    builder->addBlock(*func, bodyLbl);
    builder->addBlock(*func, doneLbl);

    func = ctx.function();
    size_t headIdx = start;
    size_t bodyIdx = start + 1;
    size_t doneIdx = start + 2;
    auto *done = &func->blocks[doneIdx];
    state.after = done;

    ctx.loopState().push(done);

    auto emitHead = [&]() {
        func = ctx.function();
        func->blocks[headIdx].label = headLbl;
        func->blocks[bodyIdx].label = bodyLbl;
        auto *head = &func->blocks[headIdx];
        ctx.setCurrent(head);
        curLoc = stmt.loc;
        if (stmt.condKind == DoStmt::CondKind::None)
        {
            emitBr(&func->blocks[bodyIdx]);
            return;
        }
        assert(stmt.cond && "DO loop missing condition for conditional form");
        auto *body = &func->blocks[bodyIdx];
        auto *doneBlk = &func->blocks[doneIdx];
        if (stmt.condKind == DoStmt::CondKind::While)
        {
            lowerCondBranch(*stmt.cond, body, doneBlk, stmt.loc);
        }
        else
        {
            lowerCondBranch(*stmt.cond, doneBlk, body, stmt.loc);
        }
    };

    func = ctx.function();
    switch (stmt.testPos)
    {
        case DoStmt::TestPos::Pre:
            curLoc = stmt.loc;
            func->blocks[headIdx].label = headLbl;
            emitBr(&func->blocks[headIdx]);
            emitHead();
            ctx.setCurrent(&func->blocks[bodyIdx]);
            break;
        case DoStmt::TestPos::Post:
            curLoc = stmt.loc;
            func->blocks[bodyIdx].label = bodyLbl;
            emitBr(&func->blocks[bodyIdx]);
            ctx.setCurrent(&func->blocks[bodyIdx]);
            break;
    }

    lowerLoopBody(stmt.body);
    auto *bodyCur = ctx.current();
    bool exitTaken = ctx.loopState().taken();
    bool term = bodyCur && bodyCur->terminated;

    if (!term)
    {
        curLoc = stmt.loc;
        func = ctx.function();
        func->blocks[headIdx].label = headLbl;
        emitBr(&func->blocks[headIdx]);
    }

    if (stmt.testPos == DoStmt::TestPos::Post)
        emitHead();

    func = ctx.function();
    func->blocks[doneIdx].label = doneLbl;
    done = &func->blocks[doneIdx];
    ctx.loopState().refresh(done);
    ctx.setCurrent(done);
    const bool postTest = stmt.testPos == DoStmt::TestPos::Post;
    if (postTest)
    {
        // FIX: Do not branch to a synthetic "next line" block from post-test DO…LOOP.
        //      Leaving 'done' open allows the statement sequencer to attach the correct
        //      fallthrough (either the next statement’s block or the function exit),
        //      preventing empty synthetic blocks at end-of-program.
        done->terminated = false;
    }
    else
    {
        done->terminated = exitTaken ? false : term;
    }
    ctx.loopState().pop();

    state.cur = ctx.current();
    state.after = state.cur;
    state.fallthrough = postTest ? true : !done->terminated;
    return state;
}

void Lowerer::lowerDo(const DoStmt &stmt)
{
    CtrlState state = emitDo(stmt);
    if (state.cur)
        context().setCurrent(state.cur);
}

/// @brief Create the block layout shared by FOR loops.
/// @param varStep Whether the loop has a variable (runtime) step expression.
/// @return Descriptor pointing to the inserted head/body/inc/done blocks.
/// @details Appends the necessary blocks to @ref func using deterministic names
///          and restores @ref cur to the block active before allocation. When
///          @p varStep is @c true the helper adds both positive and negative
///          heads so the loop can branch based on the computed step sign.
Lowerer::ForBlocks Lowerer::setupForBlocks(bool varStep)
{
    ProcedureContext &ctx = context();
    Function *func = ctx.function();
    assert(func && ctx.current());
    BlockNamer *blockNamer = ctx.blockNames().namer();
    size_t curIdx = static_cast<size_t>(ctx.current() - &func->blocks[0]);
    size_t base = func->blocks.size();
    unsigned id = blockNamer ? blockNamer->nextFor() : 0;
    ForBlocks fb;
    if (varStep)
    {
        std::string headPosLbl =
            blockNamer ? blockNamer->generic("for_head_pos") : mangler.block("for_head_pos");
        std::string headNegLbl =
            blockNamer ? blockNamer->generic("for_head_neg") : mangler.block("for_head_neg");
        builder->addBlock(*func, headPosLbl);
        builder->addBlock(*func, headNegLbl);
        fb.headPosIdx = base;
        fb.headNegIdx = base + 1;
        base += 2;
    }
    else
    {
        std::string headLbl = blockNamer ? blockNamer->forHead(id) : mangler.block("for_head");
        builder->addBlock(*func, headLbl);
        fb.headIdx = base;
        base += 1;
    }
    std::string bodyLbl = blockNamer ? blockNamer->forBody(id) : mangler.block("for_body");
    std::string incLbl = blockNamer ? blockNamer->forInc(id) : mangler.block("for_inc");
    std::string doneLbl = blockNamer ? blockNamer->forEnd(id) : mangler.block("for_done");
    builder->addBlock(*func, bodyLbl);
    builder->addBlock(*func, incLbl);
    builder->addBlock(*func, doneLbl);
    fb.bodyIdx = base;
    fb.incIdx = base + 1;
    fb.doneIdx = base + 2;
    ctx.setCurrent(&func->blocks[curIdx]);
    return fb;
}

/// @brief Lower a FOR loop whose STEP is a compile-time constant.
/// @param stmt Source FOR statement.
/// @param slot Storage slot for the induction variable.
/// @param end Evaluated end expression.
/// @param step Evaluated step expression.
/// @param stepConst Constant integer value of @p step.
/// @details Builds the canonical head/body/inc/done blocks and compares the
///          induction variable against the end bound using @c SCmpLE or
///          @c SCmpGE depending on the sign of @p stepConst. When the body does
///          not terminate it advances the induction variable via
///          @ref emitForStep and loops back to the head. The helper mutates
///          @ref cur as control moves across the loop blocks and tags emitted
///          instructions with @ref curLoc for diagnostics.
void Lowerer::lowerForConstStep(
    const ForStmt &stmt, Value slot, RVal end, RVal step, int64_t stepConst)
{
    ForBlocks fb = setupForBlocks(false);
    ProcedureContext &ctx = context();
    Function *func = ctx.function();
    assert(func && "lowerForConstStep requires an active function");
    size_t doneIdx = fb.doneIdx;
    BasicBlock *done = &func->blocks[doneIdx];
    ctx.loopState().push(done);
    curLoc = stmt.loc;
    emitBr(&func->blocks[fb.headIdx]);
    ctx.setCurrent(&func->blocks[fb.headIdx]);
    curLoc = stmt.loc;
    Value curVal = emitLoad(Type(Type::Kind::I64), slot);
    Opcode cmp = stepConst >= 0 ? Opcode::SCmpLE : Opcode::SCmpGE;
    curLoc = stmt.loc;
    Value cond = emitBinary(cmp, Type(Type::Kind::I1), curVal, end.value);
    curLoc = stmt.loc;
    emitCBr(cond, &func->blocks[fb.bodyIdx], &func->blocks[fb.doneIdx]);
    ctx.setCurrent(&func->blocks[fb.bodyIdx]);
    lowerLoopBody(stmt.body);
    BasicBlock *current = ctx.current();
    bool exitTaken = ctx.loopState().taken();
    bool term = current && current->terminated;
    if (!term)
    {
        curLoc = stmt.loc;
        emitBr(&func->blocks[fb.incIdx]);
        ctx.setCurrent(&func->blocks[fb.incIdx]);
        curLoc = stmt.loc;
        emitForStep(slot, step.value);
        curLoc = stmt.loc;
        emitBr(&func->blocks[fb.headIdx]);
    }
    done = &func->blocks[doneIdx];
    ctx.loopState().refresh(done);
    ctx.setCurrent(done);
    done->terminated = exitTaken ? false : term;
    ctx.loopState().pop();
}

/// @brief Lower a FOR loop whose STEP expression is evaluated at runtime.
/// @param stmt Source FOR statement.
/// @param slot Storage slot for the induction variable.
/// @param end Evaluated end expression.
/// @param step Evaluated step expression.
/// @details Computes the step sign, emits a branch to either the non-negative or
///          negative comparison head, and shares a single body/inc/done chain.
///          The method mutates @ref cur as it traverses these blocks and
///          updates @ref curLoc before each comparison and branch to preserve
///          accurate diagnostics.
void Lowerer::lowerForVarStep(const ForStmt &stmt, Value slot, RVal end, RVal step)
{
    curLoc = stmt.loc;
    Value stepNonNeg =
        emitBinary(Opcode::SCmpGE, Type(Type::Kind::I1), step.value, Value::constInt(0));
    ForBlocks fb = setupForBlocks(true);
    ProcedureContext &ctx = context();
    Function *func = ctx.function();
    assert(func && "lowerForVarStep requires an active function");
    size_t doneIdx = fb.doneIdx;
    BasicBlock *done = &func->blocks[doneIdx];
    ctx.loopState().push(done);
    curLoc = stmt.loc;
    emitCBr(stepNonNeg, &func->blocks[fb.headPosIdx], &func->blocks[fb.headNegIdx]);
    ctx.setCurrent(&func->blocks[fb.headPosIdx]);
    curLoc = stmt.loc;
    Value curVal = emitLoad(Type(Type::Kind::I64), slot);
    curLoc = stmt.loc;
    Value cmpPos = emitBinary(Opcode::SCmpLE, Type(Type::Kind::I1), curVal, end.value);
    curLoc = stmt.loc;
    emitCBr(cmpPos, &func->blocks[fb.bodyIdx], &func->blocks[fb.doneIdx]);
    ctx.setCurrent(&func->blocks[fb.headNegIdx]);
    curLoc = stmt.loc;
    curVal = emitLoad(Type(Type::Kind::I64), slot);
    curLoc = stmt.loc;
    Value cmpNeg = emitBinary(Opcode::SCmpGE, Type(Type::Kind::I1), curVal, end.value);
    curLoc = stmt.loc;
    emitCBr(cmpNeg, &func->blocks[fb.bodyIdx], &func->blocks[fb.doneIdx]);
    ctx.setCurrent(&func->blocks[fb.bodyIdx]);
    lowerLoopBody(stmt.body);
    BasicBlock *current = ctx.current();
    bool exitTaken = ctx.loopState().taken();
    bool term = current && current->terminated;
    if (!term)
    {
        curLoc = stmt.loc;
        emitBr(&func->blocks[fb.incIdx]);
        ctx.setCurrent(&func->blocks[fb.incIdx]);
        curLoc = stmt.loc;
        emitForStep(slot, step.value);
        curLoc = stmt.loc;
        emitCBr(stepNonNeg, &func->blocks[fb.headPosIdx], &func->blocks[fb.headNegIdx]);
    }
    done = &func->blocks[doneIdx];
    ctx.loopState().refresh(done);
    ctx.setCurrent(done);
    done->terminated = exitTaken ? false : term;
    ctx.loopState().pop();
}

Lowerer::CtrlState Lowerer::emitFor(const ForStmt &stmt, Value slot, RVal end, RVal step)
{
    CtrlState state{};
    lowerForVarStep(stmt, slot, end, step);
    state.cur = context().current();
    state.after = state.cur;
    state.fallthrough = state.cur && !state.cur->terminated;
    return state;
}

/// @brief Lower a BASIC FOR statement.
/// @param stmt Parsed FOR statement containing bounds and optional step.
/// @details Evaluates the start/end/step expressions once, stores the initial
///          value into the induction slot, and forwards to the sign-sensitive
///          lowering that selects the positive or negative branch at runtime.
///          The helper updates @ref curLoc for each emitted instruction and
///          leaves @ref cur at the block chosen by the delegated lowering
///          routine.
void Lowerer::lowerFor(const ForStmt &stmt)
{
    RVal start = lowerScalarExpr(*stmt.start);
    RVal end = lowerScalarExpr(*stmt.end);
    RVal step = stmt.step ? lowerScalarExpr(*stmt.step)
                          : RVal{Value::constInt(1), Type(Type::Kind::I64)};
    const auto *info = findSymbol(stmt.var);
    assert(info && info->slotId);
    Value slot = Value::temp(*info->slotId);
    curLoc = stmt.loc;
    emitStore(Type(Type::Kind::I64), slot, start.value);

    CtrlState state = emitFor(stmt, slot, end, step);
    if (state.cur)
        context().setCurrent(state.cur);
}

Lowerer::CtrlState Lowerer::emitSelect(const SelectCaseStmt &stmt)
{
    CtrlState state{};
    SelectCaseLowering lowering(*this);
    lowering.lower(stmt);
    state.cur = context().current();
    state.after = state.cur;
    state.fallthrough = state.cur && !state.cur->terminated;
    return state;
}

/// @brief Handle a NEXT marker.
/// @param next NEXT statement (ignored).
/// @details The lowering pipeline already encodes loop back-edges inside FOR
///          lowering, so NEXT does not emit IL and leaves @ref cur untouched.
void Lowerer::lowerNext(const NextStmt &next)
{
    (void)next;
}

void Lowerer::lowerExit(const ExitStmt &stmt)
{
    ProcedureContext &ctx = context();
    BasicBlock *target = ctx.loopState().current();
    curLoc = stmt.loc;
    if (!target)
    {
        emitTrap();
        return;
    }
    emitBr(target);
    ctx.loopState().markTaken();
}

void Lowerer::lowerGosub(const GosubStmt &stmt)
{
    ProcedureContext &ctx = context();
    Function *func = ctx.function();
    BasicBlock *current = ctx.current();
    if (!func || !current)
        return;

    ensureGosubStack();

    auto &gosubState = ctx.gosub();
    auto contIndex = gosubState.indexFor(&stmt);
    if (!contIndex)
        contIndex = gosubState.registerContinuation(&stmt, ctx.exitIndex());

    curLoc = stmt.loc;
    Value sp = emitLoad(Type(Type::Kind::I64), gosubState.spSlot());

    auto &lineBlocks = ctx.blockNames().lineBlocks();
    auto destIt = lineBlocks.find(stmt.targetLine);
    if (destIt == lineBlocks.end())
        return;

    BlockNamer *blockNamer = ctx.blockNames().namer();
    std::string overflowLbl = blockNamer ? blockNamer->generic("gosub_overflow")
                                         : mangler.block("gosub_overflow");
    std::string pushLbl = blockNamer ? blockNamer->generic("gosub_push")
                                     : mangler.block("gosub_push");

    size_t curIdx = static_cast<size_t>(current - &func->blocks[0]);
    size_t overflowIdx = func->blocks.size();
    builder->addBlock(*func, overflowLbl);
    size_t pushIdx = func->blocks.size();
    builder->addBlock(*func, pushLbl);

    func = ctx.function();
    BasicBlock *overflowBlk = &func->blocks[overflowIdx];
    BasicBlock *pushBlk = &func->blocks[pushIdx];
    current = &func->blocks[curIdx];
    ctx.setCurrent(current);

    Value limit = Value::constInt(kGosubStackDepth);
    Value overflow = emitBinary(Opcode::SCmpGE, ilBoolTy(), sp, limit);
    emitCBr(overflow, overflowBlk, pushBlk);

    ctx.setCurrent(overflowBlk);
    curLoc = stmt.loc;
    requireTrap();
    std::string overflowMsg = getStringLabel("gosub: stack overflow");
    Value overflowStr = emitConstStr(overflowMsg);
    emitCall("rt_trap", {overflowStr});
    emitTrap();

    ctx.setCurrent(pushBlk);
    curLoc = stmt.loc;

    Value offset = emitBinary(Opcode::IMulOvf, Type(Type::Kind::I64), sp, Value::constInt(4));
    Value slotPtr = emitBinary(Opcode::GEP, Type(Type::Kind::Ptr), gosubState.stackSlot(), offset);
    emitStore(Type(Type::Kind::I32),
              slotPtr,
              Value::constInt(static_cast<long long>(*contIndex)));

    Value nextSp = emitBinary(Opcode::IAddOvf, Type(Type::Kind::I64), sp, Value::constInt(1));
    emitStore(Type(Type::Kind::I64), gosubState.spSlot(), nextSp);

    BasicBlock *target = &func->blocks[destIt->second];
    emitBr(target);
}

/// @brief Lower a GOTO jump.
/// @param stmt GOTO statement naming a BASIC line label.
/// @details Looks up the destination basic block recorded during statement
///          discovery and emits an unconditional branch. @ref curLoc is set so
///          diagnostics reference the jump site, and the resulting branch marks
///          the current block as terminated.
void Lowerer::lowerGoto(const GotoStmt &stmt)
{
    auto &lineBlocks = context().blockNames().lineBlocks();
    auto it = lineBlocks.find(stmt.target);
    if (it != lineBlocks.end())
    {
        curLoc = stmt.loc;
        Function *func = context().function();
        assert(func && "lowerGoto requires an active function");
        emitBr(&func->blocks[it->second]);
    }
}

void Lowerer::lowerGosubReturn(const ReturnStmt &stmt)
{
    ProcedureContext &ctx = context();
    Function *func = ctx.function();
    BasicBlock *current = ctx.current();
    if (!func || !current)
        return;

    ensureGosubStack();

    auto &gosubState = ctx.gosub();

    curLoc = stmt.loc;
    Value sp = emitLoad(Type(Type::Kind::I64), gosubState.spSlot());

    BlockNamer *blockNamer = ctx.blockNames().namer();
    std::string emptyLbl = blockNamer ? blockNamer->generic("gosub_ret_empty")
                                      : mangler.block("gosub_ret_empty");
    std::string contLbl = blockNamer ? blockNamer->generic("gosub_ret_cont")
                                     : mangler.block("gosub_ret_cont");

    size_t curIdx = static_cast<size_t>(current - &func->blocks[0]);
    size_t emptyIdx = func->blocks.size();
    builder->addBlock(*func, emptyLbl);
    size_t contIdx = func->blocks.size();
    builder->addBlock(*func, contLbl);

    func = ctx.function();
    BasicBlock *emptyBlk = &func->blocks[emptyIdx];
    BasicBlock *contBlk = &func->blocks[contIdx];
    current = &func->blocks[curIdx];
    ctx.setCurrent(current);

    Value isEmpty = emitBinary(Opcode::ICmpEq, ilBoolTy(), sp, Value::constInt(0));
    emitCBr(isEmpty, emptyBlk, contBlk);

    ctx.setCurrent(emptyBlk);
    curLoc = stmt.loc;
    requireTrap();
    std::string emptyMsg = getStringLabel("gosub: empty return stack");
    Value emptyStr = emitConstStr(emptyMsg);
    emitCall("rt_trap", {emptyStr});
    emitTrap();

    ctx.setCurrent(contBlk);
    curLoc = stmt.loc;

    Value nextSp = emitBinary(Opcode::ISubOvf, Type(Type::Kind::I64), sp, Value::constInt(1));
    emitStore(Type(Type::Kind::I64), gosubState.spSlot(), nextSp);

    Value offset = emitBinary(Opcode::IMulOvf, Type(Type::Kind::I64), nextSp, Value::constInt(4));
    Value slotPtr = emitBinary(Opcode::GEP, Type(Type::Kind::Ptr), gosubState.stackSlot(), offset);
    Value idxVal = emitLoad(Type(Type::Kind::I32), slotPtr);

    std::string invalidLbl = blockNamer ? blockNamer->generic("gosub_ret_invalid")
                                        : mangler.block("gosub_ret_invalid");
    size_t invalidIdx = func->blocks.size();
    builder->addBlock(*func, invalidLbl);
    func = ctx.function();
    BasicBlock *invalidBlk = &func->blocks[invalidIdx];

    Instr sw;
    sw.op = Opcode::SwitchI32;
    sw.type = Type(Type::Kind::Void);
    sw.operands.push_back(idxVal);
    if (invalidBlk->label.empty())
        invalidBlk->label = nextFallbackBlockLabel();
    sw.labels.push_back(invalidBlk->label);
    sw.brArgs.push_back({});

    const auto &continuations = gosubState.continuations();
    for (unsigned i = 0; i < continuations.size(); ++i)
    {
        sw.operands.push_back(Value::constInt(static_cast<long long>(i)));
        BasicBlock *target = &func->blocks[continuations[i]];
        if (target->label.empty())
            target->label = nextFallbackBlockLabel();
        sw.labels.push_back(target->label);
        sw.brArgs.emplace_back();
    }
    sw.loc = stmt.loc;
    contBlk->instructions.push_back(std::move(sw));
    contBlk->terminated = true;

    ctx.setCurrent(invalidBlk);
    curLoc = stmt.loc;
    emitTrap();
}

void Lowerer::lowerOnErrorGoto(const OnErrorGoto &stmt)
{
    ProcedureContext &ctx = context();
    Function *func = ctx.function();
    BasicBlock *current = ctx.current();
    if (!func || !current)
        return;

    curLoc = stmt.loc;

    if (stmt.toZero)
    {
        clearActiveErrorHandler();
        return;
    }

    clearActiveErrorHandler();

    BasicBlock *handler = ensureErrorHandlerBlock(stmt.target);
    emitEhPush(handler);

    size_t idx = static_cast<size_t>(handler - &func->blocks[0]);
    ctx.errorHandlers().setActive(true);
    ctx.errorHandlers().setActiveIndex(idx);
    ctx.errorHandlers().setActiveLine(stmt.target);
}

void Lowerer::lowerResume(const Resume &stmt)
{
    ProcedureContext &ctx = context();
    Function *func = ctx.function();
    if (!func)
        return;

    std::optional<size_t> handlerIndex;

    auto &handlersByLine = ctx.errorHandlers().blocks();
    if (auto it = handlersByLine.find(stmt.line); it != handlersByLine.end())
    {
        handlerIndex = it->second;
    }
    else if (auto active = ctx.errorHandlers().activeIndex())
    {
        handlerIndex = *active;
    }

    if (!handlerIndex || *handlerIndex >= func->blocks.size())
        return;

    BasicBlock &handlerBlock = func->blocks[*handlerIndex];
    if (handlerBlock.terminated)
        return;

    if (handlerBlock.params.size() < 2)
        return;

    unsigned tokId = handlerBlock.params[1].id;
    if (func->valueNames.size() <= tokId)
        func->valueNames.resize(tokId + 1);
    if (func->valueNames[tokId].empty())
        func->valueNames[tokId] = handlerBlock.params[1].name;

    Value resumeTok = Value::temp(tokId);

    Instr instr;
    instr.type = Type(Type::Kind::Void);
    instr.loc = curLoc;
    instr.operands.push_back(resumeTok);

    switch (stmt.mode)
    {
        case Resume::Mode::Same:
            instr.op = Opcode::ResumeSame;
            break;
        case Resume::Mode::Next:
            instr.op = Opcode::ResumeNext;
            break;
        case Resume::Mode::Label:
        {
            instr.op = Opcode::ResumeLabel;
            auto &lineBlocks = ctx.blockNames().lineBlocks();
            auto targetIt = lineBlocks.find(stmt.target);
            if (targetIt == lineBlocks.end())
                return;
            size_t targetIdx = targetIt->second;
            if (targetIdx >= func->blocks.size())
                return;
            instr.labels.push_back(func->blocks[targetIdx].label);
            break;
        }
    }

    handlerBlock.instructions.push_back(std::move(instr));
    handlerBlock.terminated = true;
}

/// @brief Lower an END statement.
/// @param stmt END statement closing the program.
/// @details Emits a return from the current block so execution does not fall
///          through to subsequent statements. The return uses @ref curLoc for
///          diagnostics and leaves the block terminated immediately.
void Lowerer::lowerEnd(const EndStmt &stmt)
{
    curLoc = stmt.loc;
    emitRet(Value::constInt(0));
}

} // namespace il::frontends::basic

