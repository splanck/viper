//===----------------------------------------------------------------------===//
//
// Part of the Viper project, under the MIT License.
// See LICENSE for license information.
//
//===----------------------------------------------------------------------===//
// File: src/frontends/basic/diag/BasicDiag.cpp
// Purpose: Auto-generated lookup tables for BASIC diagnostics.
// Key invariants: Table order matches BasicDiagId enum values.
// Ownership/Lifetime: Stores static arrays for format/severity metadata.
// Links: scripts/spec/diagnostics.yaml
//
// NOTE: This file is auto-generated by scripts/gen_diagnostics.py. Do not edit manually.

#include "viper/diag/BasicDiag.hpp"

#include <array>
#include <cassert>
#include <string>

namespace il::frontends::basic::diag
{

namespace
{
    struct Entry
    {
        il::support::Severity severity;
        std::string_view format;
    };

    constexpr std::array<Entry, static_cast<std::size_t>(BasicDiagId::Count)> kEntries = {
        Entry{il::support::Severity::Error, "unknown variable '{name}'{suggestion}"},
        Entry{il::support::Severity::Error, "unknown array '{name}'"},
        Entry{il::support::Severity::Error, "variable '{name}' is not an array"},
        Entry{il::support::Severity::Error, "index type mismatch"},
        Entry{il::support::Severity::Warning, "narrowing conversion from FLOAT to INT in array index"},
        Entry{il::support::Severity::Warning, "index out of bounds"},
        Entry{il::support::Severity::Warning, "narrowing conversion from FLOAT to INT in assignment"},
        Entry{il::support::Severity::Warning, "narrowing conversion from FLOAT to INT in array assignment"},
        Entry{il::support::Severity::Warning, "narrowing conversion from FLOAT to INT in array size"},
        Entry{il::support::Severity::Error, "array size must be non-negative"},
    };

} // namespace

std::string_view getFormat(BasicDiagId id)
{
    const auto index = static_cast<std::size_t>(id);
    assert(index < kEntries.size());
    return kEntries[index].format;
}

il::support::Severity getSeverity(BasicDiagId id)
{
    const auto index = static_cast<std::size_t>(id);
    assert(index < kEntries.size());
    return kEntries[index].severity;
}

std::string formatMessage(BasicDiagId id, std::initializer_list<Replacement> replacements)
{
    std::string message(getFormat(id));
    for (const auto &replacement : replacements)
    {
        const std::string placeholder = std::string("{") + std::string(replacement.key) + "}";
        std::size_t pos = 0;
        while ((pos = message.find(placeholder, pos)) != std::string::npos)
        {
            message.replace(pos, placeholder.size(), replacement.value);
            pos += replacement.value.size();
        }
    }
    return message;
}

} // namespace il::frontends::basic::diag

