//===----------------------------------------------------------------------===//
//
// Part of the Viper project, under the GNU GPL v3.
// See LICENSE for license information.
//
//===----------------------------------------------------------------------===//
///
/// @file RuntimeClasses.cpp
/// @brief Builds the runtime class catalog and provides unified registry access.
///
/// @details This file implements the runtime class catalog infrastructure that
/// enables all Viper frontends to access runtime function signatures. It serves
/// two primary purposes:
///
/// ## 1. Catalog Construction
///
/// The runtime class catalog is built by macro-expanding the declarative table
/// in `RuntimeClasses.inc` (generated by `rtgen` from `runtime.def`). This
/// produces a static vector of RuntimeClass descriptors containing:
///
/// - Class metadata (qualified name, type ID, constructor)
/// - Property descriptors (name, type, getter/setter targets)
/// - Method descriptors (name, signature string, extern target)
///
/// ## 2. RuntimeRegistry Implementation
///
/// The RuntimeRegistry singleton provides O(1) lookup for runtime methods and
/// properties by building hash indexes over the catalog. It also parses the
/// signature strings into structured `ParsedSignature` objects that frontends
/// can map to their native type systems.
///
/// ## Signature String Format
///
/// Runtime signatures use a compact format: `ret(args)` where:
/// - `ret` is the return type: i64, f64, i1, str, obj, void
/// - `args` is a comma-separated list of parameter types (may be empty)
/// - The receiver (self/this) is implicit and NOT included in args
///
/// Examples:
/// - `"str(i64,i64)"` - String.Substring(start, length) returns string
/// - `"i64()"` - String.Length getter returns integer
/// - `"void(str)"` - StringBuilder.Append(text) returns void
/// - `"i1()"` - File.Exists() returns boolean
///
/// ## Thread Safety
///
/// The catalog and registry are built using function-local statics with
/// guaranteed thread-safe initialization (C++11 magic statics). Once built,
/// all data is immutable and safe for concurrent access.
///
/// ## Usage Flow
///
/// ```
/// runtime.def  →  rtgen  →  RuntimeClasses.inc  →  runtimeClassCatalog()
///                                                         ↓
///                                               RuntimeRegistry::instance()
///                                                         ↓
///                                               findMethod() / findProperty()
///                                                         ↓
///                                               ParsedSignature (ILScalarType)
///                                                         ↓
///                                               Frontend adapter (toZiaType, etc.)
/// ```
///
/// @invariant The catalog is built once and is immutable after construction.
/// @invariant All string fields point to static string literals.
/// @invariant Registry lookups are case-insensitive.
///
/// @see RuntimeClasses.hpp - Type definitions and interface documentation
/// @see RuntimeClasses.inc - Generated class descriptors (from runtime.def)
/// @see runtime.def - Source of truth for runtime function definitions
///
//===----------------------------------------------------------------------===//

#include "il/runtime/classes/RuntimeClasses.hpp"

#include <algorithm>
#include <cctype>
#include <utility>

namespace il::runtime
{

//===----------------------------------------------------------------------===//
/// @name Catalog Construction Macros
/// @brief Helper macros for expanding RuntimeClasses.inc into C++ descriptors.
/// @{
//===----------------------------------------------------------------------===//

namespace
{

/// @brief Constructs a RuntimeProperty descriptor from .inc parameters.
/// @details This macro is invoked by the generated RuntimeClasses.inc file
/// to create property descriptors. The readonly flag is automatically set
/// based on whether the setter pointer is null.
#define RUNTIME_PROP(_name, _type, _getter, _setter)                                               \
    ::il::runtime::RuntimeProperty                                                                 \
    {                                                                                              \
        (_name), (_type), (_getter), (_setter), ((_setter) == nullptr)                             \
    }

/// @brief Constructs a vector of RuntimeProperty descriptors.
/// @details Wraps multiple RUNTIME_PROP() invocations into a std::vector.
#define RUNTIME_PROPS(...)                                                                         \
    std::vector<::il::runtime::RuntimeProperty>                                                    \
    {                                                                                              \
        __VA_ARGS__                                                                                \
    }

/// @brief Constructs a RuntimeMethod descriptor from .inc parameters.
/// @details Creates a method descriptor with name, signature string, and
/// canonical extern target name.
#define RUNTIME_METHOD(_name, _sig, _target)                                                       \
    ::il::runtime::RuntimeMethod                                                                   \
    {                                                                                              \
        (_name), (_sig), (_target)                                                                 \
    }

/// @brief Constructs a vector of RuntimeMethod descriptors.
/// @details Wraps multiple RUNTIME_METHOD() invocations into a std::vector.
#define RUNTIME_METHODS(...)                                                                       \
    std::vector<::il::runtime::RuntimeMethod>                                                      \
    {                                                                                              \
        __VA_ARGS__                                                                                \
    }

/// @brief Constructs a complete RuntimeClass and adds it to the catalog.
/// @details This macro is the main entry point for RuntimeClasses.inc. Each
/// invocation creates a RuntimeClass with all its metadata, properties, and
/// methods, then emplaces it into the catalog vector being constructed.
#define RUNTIME_CLASS(_qname, _typeId, _layout, _ctor, _props, _methods)                           \
    catalog.emplace_back(::il::runtime::RuntimeClass{(_qname),                                     \
                                                     (_layout),                                    \
                                                     (_ctor),                                      \
                                                     ::il::runtime::RuntimeTypeId::_typeId,        \
                                                     (_props),                                     \
                                                     (_methods)});

} // anonymous namespace

/// @}

//===----------------------------------------------------------------------===//
/// @name Catalog Access
/// @{
//===----------------------------------------------------------------------===//

/// @brief Returns the process-wide immutable runtime class catalog.
///
/// @details This function builds the catalog exactly once using a function-local
/// static initialized by a lambda. The lambda expands RuntimeClasses.inc using
/// the macros defined above, producing a vector of RuntimeClass descriptors.
///
/// The catalog is built lazily on first access and is guaranteed to be
/// thread-safe by C++11 magic statics. After construction, the catalog is
/// completely immutable—no methods or properties can be added or modified.
///
/// ## Performance
///
/// - First call: O(n) where n is the number of runtime classes
/// - Subsequent calls: O(1) (returns cached reference)
///
/// ## Memory Layout
///
/// The catalog vector owns all RuntimeClass objects. Each RuntimeClass owns
/// its property and method vectors. All string pointers (qname, getter, etc.)
/// point to static string literals embedded in the binary.
///
/// @return Const reference to the runtime class catalog vector.
///
/// @note The returned reference is valid for the lifetime of the program.
///
const std::vector<RuntimeClass> &runtimeClassCatalog()
{
    static const std::vector<RuntimeClass> catalog_init = []
    {
        std::vector<RuntimeClass> catalog;
        catalog.reserve(8); // Initial capacity; grows as classes are added

// Expand runtime class declarations generated by rtgen from runtime.def.
// Each RUNTIME_CLASS macro invocation adds one RuntimeClass to the catalog.
#include "il/runtime/RuntimeClasses.inc"

        return catalog;
    }();
    return catalog_init;
}

/// @brief Finds a runtime class by its fully-qualified name.
///
/// @details Performs a case-insensitive linear search through the catalog to
/// find a class matching the given qualified name. This is used during semantic
/// analysis to verify that a type name refers to a valid runtime class.
///
/// ## Case Insensitivity
///
/// The comparison converts both the query and catalog names to uppercase
/// character by character. This allows users to write `viper.string` or
/// `Viper.STRING` and still match `Viper.String`.
///
/// ## Performance
///
/// O(n * m) where n is the number of classes and m is the average name length.
/// For the current catalog size (~150 classes), this is fast enough. If the
/// catalog grows significantly, consider adding a hash index.
///
/// @param qname The fully-qualified class name to search for (e.g., "Viper.String").
///
/// @return Pointer to the matching RuntimeClass, or nullptr if not found.
///         The returned pointer is valid for the lifetime of the program.
///
const RuntimeClass *findRuntimeClassByQName(std::string_view qname)
{
    const auto &catalog = runtimeClassCatalog();
    for (const auto &c : catalog)
    {
        std::string_view cname{c.qname};

        // Quick length check before expensive character comparison
        if (qname.size() != cname.size())
        {
            continue;
        }

        // Case-insensitive comparison using std::equal with a custom comparator
        bool match = std::equal(qname.begin(),
                                qname.end(),
                                cname.begin(),
                                cname.end(),
                                [](char a, char b)
                                {
                                    return std::toupper(static_cast<unsigned char>(a)) ==
                                           std::toupper(static_cast<unsigned char>(b));
                                });
        if (match)
        {
            return &c;
        }
    }
    return nullptr;
}

/// @}

//===----------------------------------------------------------------------===//
/// @name Signature Parsing
/// @brief Parse IL signature strings into structured ILScalarType values.
/// @{
//===----------------------------------------------------------------------===//

/// @brief Maps an IL type token string to its corresponding ILScalarType.
///
/// @details This function converts the compact type tokens used in signature
/// strings to the ILScalarType enumeration. The mapping is:
///
/// | Token | ILScalarType | Description                    |
/// |-------|--------------|--------------------------------|
/// | i64   | I64          | 64-bit signed integer          |
/// | f64   | F64          | 64-bit floating point          |
/// | i1    | Bool         | Boolean (true/false)           |
/// | str   | String       | String reference               |
/// | void  | Void         | No value (procedures)          |
/// | obj   | Object       | Runtime class instance pointer |
/// | ptr   | Object       | Alias for obj                  |
///
/// Unrecognized tokens return Unknown, which signals a parse error.
///
/// @param tok The type token from a signature string (e.g., "i64", "str").
///
/// @return The corresponding ILScalarType, or Unknown if not recognized.
///
ILScalarType mapILToken(std::string_view tok)
{
    // Direct string comparisons are fast for these short tokens.
    // Using a switch on the first character would add complexity
    // without meaningful performance benefit.
    if (tok == "i64")
        return ILScalarType::I64;
    if (tok == "f64")
        return ILScalarType::F64;
    if (tok == "i1")
        return ILScalarType::Bool;
    if (tok == "str")
        return ILScalarType::String;
    if (tok == "void")
        return ILScalarType::Void;
    if (tok == "obj" || tok == "ptr")
        return ILScalarType::Object;
    return ILScalarType::Unknown;
}

/// @brief Parses a signature string into a structured ParsedSignature.
///
/// @details Signature strings follow the format `ret(args)` where:
/// - `ret` is the return type token (i64, f64, i1, str, obj, void)
/// - `args` is a comma-separated list of parameter type tokens
///
/// The receiver (self/this pointer for methods) is NOT included in the
/// signature—it is handled implicitly by the calling convention.
///
/// ## Parsing Algorithm
///
/// 1. Find the parentheses that delimit return type from parameters
/// 2. Extract and trim the return type token
/// 3. Parse the parameter list, splitting on commas and trimming whitespace
/// 4. Map each token to ILScalarType using mapILToken()
///
/// ## Error Handling
///
/// If the signature is malformed (missing parentheses, etc.), the function
/// returns a ParsedSignature with returnType = Unknown. Callers should check
/// isValid() before using the result.
///
/// ## Examples
///
/// ```cpp
/// auto sig1 = parseRuntimeSignature("str(i64,i64)");
/// // sig1.returnType = String, sig1.params = [I64, I64]
///
/// auto sig2 = parseRuntimeSignature("i64()");
/// // sig2.returnType = I64, sig2.params = []
///
/// auto sig3 = parseRuntimeSignature("void(str)");
/// // sig3.returnType = Void, sig3.params = [String]
/// ```
///
/// @param sig The signature string to parse.
///
/// @return Parsed signature with return type and parameter types.
///         Check isValid() to verify successful parsing.
///
ParsedSignature parseRuntimeSignature(std::string_view sig)
{
    ParsedSignature result;

    // Find the parentheses delimiting return type from parameters.
    // Expected format: "ret(args)" where args may be empty.
    auto lparen = sig.find('(');
    auto rparen = sig.rfind(')');
    if (lparen == std::string_view::npos || rparen == std::string_view::npos || rparen < lparen)
    {
        // Malformed signature—return with Unknown type to signal error
        return result;
    }

    // Extract and trim the return type token (everything before '(')
    std::string_view retTok = sig.substr(0, lparen);
    while (!retTok.empty() && std::isspace(static_cast<unsigned char>(retTok.front())))
        retTok.remove_prefix(1);
    while (!retTok.empty() && std::isspace(static_cast<unsigned char>(retTok.back())))
        retTok.remove_suffix(1);

    result.returnType = mapILToken(retTok);

    // Extract the parameter list (everything between parentheses)
    std::string_view args = sig.substr(lparen + 1, rparen - lparen - 1);

    // Parse comma-separated parameter tokens
    std::size_t pos = 0;
    while (pos < args.size())
    {
        // Skip leading whitespace and commas
        while (pos < args.size() && (args[pos] == ' ' || args[pos] == ','))
            ++pos;
        if (pos >= args.size())
            break;

        // Extract token (sequence of non-space, non-comma characters)
        std::size_t start = pos;
        while (pos < args.size() && args[pos] != ',' &&
               !std::isspace(static_cast<unsigned char>(args[pos])))
            ++pos;

        std::string_view tok = args.substr(start, pos - start);
        if (!tok.empty())
            result.params.push_back(mapILToken(tok));
    }

    return result;
}

/// @}

//===----------------------------------------------------------------------===//
/// @name RuntimeRegistry Implementation
/// @brief Singleton registry with hash-indexed method and property lookup.
/// @{
//===----------------------------------------------------------------------===//

/// @brief Converts a string_view to lowercase for case-insensitive keys.
///
/// @details Creates a new string with all ASCII characters converted to
/// lowercase. This is used to build case-insensitive hash keys for the
/// registry indexes.
///
/// @param s The string to convert.
/// @return New lowercase string.
///
std::string RuntimeRegistry::toLower(std::string_view s)
{
    std::string out;
    out.reserve(s.size());
    for (unsigned char c : s)
        out.push_back(static_cast<char>(std::tolower(c)));
    return out;
}

/// @brief Builds a hash key for method lookup: "class|method#arity".
///
/// @details The key format enables O(1) lookup while supporting method
/// overloading by arity. The pipe and hash separators are chosen to be
/// unlikely to appear in identifiers.
///
/// Example: "viper.string|substring#2" for String.Substring(start, length)
///
/// @param cls The fully-qualified class name.
/// @param method The method name.
/// @param arity The number of explicit parameters (excluding receiver).
/// @return The hash key string.
///
std::string RuntimeRegistry::methodKey(std::string_view cls,
                                       std::string_view method,
                                       std::size_t arity)
{
    std::string key;
    key.reserve(cls.size() + method.size() + 16);
    key.append(toLower(cls));
    key.push_back('|');
    key.append(toLower(method));
    key.push_back('#');
    key.append(std::to_string(arity));
    return key;
}

/// @brief Builds a hash key for property lookup: "class.property".
///
/// @details Simpler than method keys since properties don't have overloads.
///
/// Example: "viper.string.length" for String.Length
///
/// @param cls The fully-qualified class name.
/// @param prop The property name.
/// @return The hash key string.
///
std::string RuntimeRegistry::propertyKey(std::string_view cls, std::string_view prop)
{
    std::string key;
    key.reserve(cls.size() + prop.size() + 2);
    key.append(toLower(cls));
    key.push_back('.');
    key.append(toLower(prop));
    return key;
}

/// @brief Builds a hash key for direct function lookup by canonical name.
///
/// @details Simply lowercases the full function name for case-insensitive
/// lookup. Used when callers know the exact extern target name.
///
/// Example: "viper.string.substring" for direct lookup
///
/// @param name The canonical extern function name.
/// @return The hash key string.
///
std::string RuntimeRegistry::functionKey(std::string_view name)
{
    return toLower(name);
}

/// @brief Constructs the registry and builds all indexes.
///
/// @details Called exactly once when RuntimeRegistry::instance() is first
/// accessed. Iterates through the entire catalog and builds hash indexes
/// for methods, properties, and functions.
///
RuntimeRegistry::RuntimeRegistry()
{
    buildIndexes();
}

/// @brief Populates the method, property, and function hash indexes.
///
/// @details Iterates through all classes in the catalog and:
///
/// 1. For each method:
///    - Parses the signature string into a ParsedSignature
///    - Creates a ParsedMethod with name, target, and parsed signature
///    - Indexes by "class|method#arity" for lookup by class/method/arity
///    - Indexes by canonical target name for direct function lookup
///
/// 2. For each property:
///    - Creates a ParsedProperty with name, type, and getter/setter targets
///    - Indexes by "class.property" for lookup by class/property
///    - Indexes getter and setter as functions for direct lookup
///
/// ## Performance
///
/// Building the indexes is O(n * m) where n is the number of classes and m
/// is the average number of methods/properties per class. This happens once
/// at startup and enables O(1) lookups thereafter.
///
void RuntimeRegistry::buildIndexes()
{
    const auto &catalog = runtimeClassCatalog();

    for (const auto &cls : catalog)
    {
        const char *qname = cls.qname;

        // Index all methods for this class
        for (const auto &m : cls.methods)
        {
            // Parse the signature string into structured form
            ParsedSignature sig = parseRuntimeSignature(m.signature ? m.signature : "");
            if (!sig.isValid())
                continue; // Skip methods with unparseable signatures

            // Build the ParsedMethod descriptor
            ParsedMethod pm;
            pm.name = m.name;
            pm.target = m.target;
            pm.signature = std::move(sig);

            // Index by class|method#arity for findMethod() lookups
            methodIndex_[methodKey(qname, m.name, pm.signature.arity())] = pm;

            // Index by canonical function name for findFunction() lookups
            if (m.target)
                functionIndex_[functionKey(m.target)] = pm.signature;
        }

        // Index all properties for this class
        for (const auto &p : cls.properties)
        {
            // Build the ParsedProperty descriptor
            ParsedProperty pp;
            pp.name = p.name;
            pp.type = mapILToken(p.type ? p.type : "");
            pp.getter = p.getter;
            pp.setter = p.setter;
            pp.readonly = p.readonly;

            // Index by class.property for findProperty() lookups
            propertyIndex_[propertyKey(qname, p.name)] = pp;

            // Index getter as a zero-parameter function returning the property type
            if (p.getter)
            {
                ParsedSignature getterSig;
                getterSig.returnType = pp.type;
                // Getter takes only the receiver (no explicit params)
                functionIndex_[functionKey(p.getter)] = getterSig;
            }

            // Index setter as a void function taking the property type
            if (p.setter)
            {
                ParsedSignature setterSig;
                setterSig.returnType = ILScalarType::Void;
                setterSig.params.push_back(pp.type);
                functionIndex_[functionKey(p.setter)] = setterSig;
            }
        }
    }
}

/// @brief Returns the singleton RuntimeRegistry instance.
///
/// @details Uses a function-local static for thread-safe lazy initialization.
/// The registry is built on first access and persists for the program lifetime.
///
/// @return Const reference to the singleton instance.
///
const RuntimeRegistry &RuntimeRegistry::instance()
{
    static RuntimeRegistry reg;
    return reg;
}

/// @brief Finds a method by class name, method name, and parameter count.
///
/// @details Performs an O(1) hash lookup using a key combining all three
/// parameters. This supports method overloading by arity—different methods
/// with the same name but different parameter counts are stored separately.
///
/// ## Example
///
/// ```cpp
/// auto method = registry.findMethod("Viper.String", "Substring", 2);
/// if (method) {
///     // method->signature.returnType == ILScalarType::String
///     // method->signature.params == [ILScalarType::I64, ILScalarType::I64]
/// }
/// ```
///
/// @param classQName The fully-qualified class name (e.g., "Viper.String").
/// @param methodName The method name (e.g., "Substring").
/// @param arity The number of explicit parameters (excluding receiver).
///
/// @return The parsed method info if found, std::nullopt otherwise.
///
std::optional<ParsedMethod> RuntimeRegistry::findMethod(std::string_view classQName,
                                                        std::string_view methodName,
                                                        std::size_t arity) const
{
    auto it = methodIndex_.find(methodKey(classQName, methodName, arity));
    if (it == methodIndex_.end())
        return std::nullopt;
    return it->second;
}

/// @brief Finds a property by class name and property name.
///
/// @details Performs an O(1) hash lookup. Returns the property's type and
/// getter/setter information.
///
/// ## Example
///
/// ```cpp
/// auto prop = registry.findProperty("Viper.String", "Length");
/// if (prop) {
///     // prop->type == ILScalarType::I64
///     // prop->getter == "Viper.String.get_Length"
///     // prop->readonly == true
/// }
/// ```
///
/// @param classQName The fully-qualified class name.
/// @param propertyName The property name.
///
/// @return The parsed property info if found, std::nullopt otherwise.
///
std::optional<ParsedProperty> RuntimeRegistry::findProperty(std::string_view classQName,
                                                            std::string_view propertyName) const
{
    auto it = propertyIndex_.find(propertyKey(classQName, propertyName));
    if (it == propertyIndex_.end())
        return std::nullopt;
    return it->second;
}

/// @brief Finds a function's signature by its canonical extern name.
///
/// @details Performs an O(1) hash lookup by the full extern target name.
/// This is useful when you know the exact function name (e.g., from the
/// lowerer when generating extern calls).
///
/// ## Example
///
/// ```cpp
/// auto sig = registry.findFunction("Viper.String.Substring");
/// if (sig) {
///     // sig->returnType == ILScalarType::String
///     // sig->params == [ILScalarType::I64, ILScalarType::I64]
/// }
/// ```
///
/// @param canonicalName The full extern function name.
///
/// @return The parsed signature if found, std::nullopt otherwise.
///
std::optional<ParsedSignature> RuntimeRegistry::findFunction(std::string_view canonicalName) const
{
    auto it = functionIndex_.find(functionKey(canonicalName));
    if (it == functionIndex_.end())
        return std::nullopt;
    return it->second;
}

/// @brief Lists available overloads of a method for diagnostic messages.
///
/// @details When a method call has the wrong number of arguments, this function
/// provides a list of available arities to help the user understand what
/// signatures are valid.
///
/// ## Example
///
/// If Substring exists with arities 1 and 2, calling this with methodName
/// "Substring" returns ["Substring/1", "Substring/2"].
///
/// @param classQName The fully-qualified class name.
/// @param methodName The method name.
///
/// @return List of strings like "MethodName/arity" for each available overload.
///
std::vector<std::string> RuntimeRegistry::methodCandidates(std::string_view classQName,
                                                           std::string_view methodName) const
{
    std::vector<std::string> out;

    // Build the prefix we're searching for: "class|method#"
    std::string prefix;
    prefix.reserve(classQName.size() + methodName.size() + 2);
    prefix.append(toLower(classQName));
    prefix.push_back('|');
    prefix.append(toLower(methodName));
    prefix.push_back('#');

    // Scan all method keys for matching prefix
    // (A trie would be more efficient but this is only used for error messages)
    for (const auto &p : methodIndex_)
    {
        const std::string &k = p.first;
        if (k.rfind(prefix, 0) == 0) // Starts with prefix
        {
            // Extract the arity from after the '#'
            auto pos = k.rfind('#');
            std::string ar = pos != std::string::npos ? k.substr(pos + 1) : std::string("?");
            out.push_back(std::string(methodName) + "/" + ar);
        }
    }
    return out;
}

/// @brief Returns the raw runtime class catalog.
///
/// @details Provides direct access to the underlying catalog vector for
/// callers that need to iterate all classes (e.g., to register type names).
///
/// @return Const reference to the catalog vector.
///
const std::vector<RuntimeClass> &RuntimeRegistry::rawCatalog() const
{
    return runtimeClassCatalog();
}

/// @}

} // namespace il::runtime
