//===----------------------------------------------------------------------===//
//
// Part of the Viper project, under the MIT License.
// See LICENSE in the project root for license information.
//
//===----------------------------------------------------------------------===//
//
// Purpose: Translate BASIC runtime file mode descriptors into platform
//          specific strings and flag combinations while exposing borrowing
//          helpers for runtime-managed string paths.
// Key invariants: Mode conversion routines never return partially initialised
//                 dataâ€”callers receive either a fully populated flag set or a
//                 `false`/`NULL` result.  Borrowed string views remain valid only
//                 for the lifetime of the originating @ref ViperString handle.
// Ownership/Lifetime: The utilities borrow underlying string buffers without
//                     copying; callers must manage reference counts on
//                     @ref ViperString objects and respect the borrowed view
//                     semantics.
//
//===----------------------------------------------------------------------===//

/// @file
/// @brief File path and mode string helpers for the Viper runtime.
/// @details Offers conversions from BASIC runtime mode enumerations to C
///          `fopen`-style strings, converts textual modes into `open` flag
///          combinations, and surfaces view helpers that preserve the lifetime
///          semantics of @ref ViperString handles.

#include "rt_file_path.h"
#include "rt_file.h"

#include "rt_heap.h"
#include "rt_internal.h"

#include <fcntl.h>

#ifndef O_CLOEXEC
#define O_CLOEXEC 0
#endif

/// @brief Map a BASIC runtime file mode enumeration to a C stdio mode string.
/// @details Converts the runtime specific @ref RT_F_* enumerators to the
///          canonical mode strings understood by `fopen`.  Unsupported modes
///          yield `NULL` so the caller can signal an invalid combination.
/// @param mode BASIC runtime mode flag from the `RT_F_*` enumeration.
/// @return A null-terminated C string describing the desired mode, or `NULL`
///         when the mode is invalid.
const char *rt_file_mode_string(int32_t mode)
{
    switch (mode)
    {
        case RT_F_INPUT:
            return "r";
        case RT_F_OUTPUT:
            return "w";
        case RT_F_APPEND:
            return "a";
        case RT_F_BINARY:
            return "rb+";
        case RT_F_RANDOM:
            return "rb+";
        default:
            return NULL;
    }
}

/// @brief Convert a textual file mode description into platform `open` flags.
/// @details Parses the `fopen`-style mode string generated by
///          @ref rt_file_mode_string (or provided by user code) and produces the
///          appropriate combination of flags for the low-level `open` call.  The
///          helper enforces canonical options, handles platform specific binary
///          markers, and records the result in @p flags_out.
/// @param mode Null-terminated mode string to parse.
/// @param flags_out Output pointer that receives the computed flag bitmask. It
///                  must be non-null or the function fails.
/// @return `true` when the mode string is valid and the flags were written;
///         otherwise `false`.
bool rt_file_mode_to_flags(const char *mode, int32_t basic_mode, int *flags_out)
{
    if (flags_out)
        *flags_out = 0;
    if (!mode || !mode[0] || !flags_out)
        return false;

    int flags = 0;
    switch (mode[0])
    {
        case 'r':
            flags = O_RDONLY;
            break;
        case 'w':
            flags = O_WRONLY | O_CREAT | O_TRUNC;
            break;
        case 'a':
            flags = O_WRONLY | O_CREAT | O_APPEND;
            break;
        default:
            return false;
    }

    bool plus = false;
    bool binary = false;
    for (const char *p = mode + 1; *p; ++p)
    {
        if (*p == '+')
            plus = true;
        else if (*p == 'b')
            binary = true;
        else if (*p == 't')
            continue;
        else
            return false;
    }

    if (plus)
    {
        flags &= ~(O_RDONLY | O_WRONLY);
        flags |= O_RDWR;
    }
    if (basic_mode == RT_F_BINARY || basic_mode == RT_F_RANDOM)
        flags |= O_CREAT;
#if defined(_WIN32)
    if (binary)
    {
#if defined(O_BINARY)
        flags |= O_BINARY;
#elif defined(_O_BINARY)
        flags |= _O_BINARY;
#endif
    }
#else
    (void)binary;
#endif
    flags |= O_CLOEXEC;

    *flags_out = flags;
    return true;
}

/// @brief Obtain a borrowed C string view from a @ref ViperString path value.
/// @details Validates the @p path handle and, when successful, updates
///          @p out_path to point at the underlying UTF-8 character buffer.
///          Ownership is not transferred; callers must ensure the
///          @ref ViperString remains alive for the duration of the borrow.
/// @param path Runtime string handle describing a filesystem path.
/// @param out_path Optional output pointer updated to the borrowed C string.
/// @return `true` when the path handle is valid, otherwise `false`.
bool rt_file_path_from_vstr(const ViperString *path, const char **out_path)
{
    if (out_path)
        *out_path = NULL;
    if (!path || !path->data)
        return false;
    if (out_path)
        *out_path = path->data;
    return true;
}

/// @brief Provide a byte-oriented view over a @ref ViperString buffer.
/// @details Extracts a pointer to the underlying string data and reports its
///          length without copying.  Heap-backed strings derive their length via
///          @ref rt_heap_len, while literal strings return the stored
///          @ref ViperString::literal_len value.  Callers must not mutate the
///          returned data.
/// @param s Runtime string handle to view.
/// @param data_out Optional output pointer updated to the raw byte buffer.
/// @return The number of bytes referenced by the string, or zero when the
///         handle is invalid.
size_t rt_file_string_view(const ViperString *s, const uint8_t **data_out)
{
    if (data_out)
        *data_out = NULL;
    if (!s || !s->data)
        return 0;
    if (data_out)
        *data_out = (const uint8_t *)s->data;
    if (s->heap)
        return rt_heap_len(s->data);
    return s->literal_len;
}
