//===----------------------------------------------------------------------===//
//
// Part of the Viper project, under the GNU GPL v3.
// See LICENSE for license information.
//
//===----------------------------------------------------------------------===//
//
// File: src/runtime/rt_math.h
// Purpose: Runtime library mathematical function API for BASIC programs.
// Key invariants: All floating-point operations use IEEE-754 double precision.
//                 Unchecked variants may return NaN/INF on domain errors;
//                 checked variants (in rt_numeric.h) trap instead.
// Ownership: Thin wrappers around platform math libraries; no heap allocation.
// Lifetime: Stateless functions; no managed resources.
// Links: rt_numeric.h (checked variants), docs/runtime-math.md
//
// This file declares the runtime library's mathematical function API, providing
// portable implementations of standard math operations for BASIC programs. These
// functions are invoked from IL code generated by the BASIC frontend when users
// call built-in math functions like SIN, COS, SQR, ABS, SGN, etc.
//
// The runtime math API serves several purposes:
//
// 1. Platform Abstraction: Provides consistent math behavior across all targets
//    (x86-64, ARM, WebAssembly) by wrapping platform-specific math libraries
//    with a uniform C ABI.
//
// 2. Error Handling: Implements BASIC's error semantics for domain errors, overflow,
//    and invalid operations. Unlike C's math library which uses errno or NaN,
//    these functions trap on error conditions, allowing BASIC's ON ERROR mechanism
//    to catch and handle exceptional cases.
//
// 3. Type Specialization: Provides both integer and floating-point variants for
//    functions like abs() and sgn(), matching BASIC's type system requirements
//    and avoiding unnecessary conversions.
//
// Mathematical Functions Provided:
//
// Transcendental Functions:
// - Trigonometric: rt_sin, rt_cos, rt_tan, rt_atan
// - Exponential: rt_exp, rt_log
// - Power/Root: rt_sqrt (in rt_numeric.h as rt_sqrt_chk_f64)
//
// Numeric Functions:
// - Sign: rt_sgn_i64 (returns -1/0/+1), rt_sgn_f64
// - Absolute value: rt_abs_i64, rt_abs_f64
// - Rounding: rt_floor, rt_ceil (explicit rounding direction)
//
// Design Philosophy:
// These functions intentionally mirror C99 math library signatures for easy
// implementation on platforms with standard math support. The rt_ prefix
// distinguishes runtime functions from system functions and provides a clear
// namespace for runtime APIs.
//
// Error Handling Contract:
// All functions that can encounter domain errors (sqrt of negative, log of zero)
// have "_chk" variants that validate inputs and trap on errors. The basic
// functions declared here assume valid inputs for performance; checked variants
// are in rt_numeric.h.
//
// Implementation Notes:
// Most functions are thin wrappers around platform math libraries (libm on Unix,
// MSVCRT on Windows). The wrappers ensure consistent behavior across platforms
// and provide the extern "C" ABI required by IL's calling convention.
//
// Precision and Accuracy:
// All floating-point operations use IEEE-754 double precision (f64 in IL).
// BASIC's SINGLE type is currently promoted to DOUBLE during lowering, so all
// runtime math operates at double precision.
//
//===----------------------------------------------------------------------===//

#pragma once

#include <stdint.h>

#ifdef __cplusplus
extern "C"
{
#endif

    /// @brief Compute the square root of a double value.
    /// @details Implements BASIC's SQR over double-precision values. Delegates to
    ///          the platform libm. For trapping on negative inputs, use the checked
    ///          variant rt_sqrt_chk_f64 in rt_numeric.h.
    /// @param x Input value (must be non-negative for a real result).
    /// @return sqrt(x); may return NaN for negative inputs (unchecked variant).
    double rt_sqrt(double x);

    /// @brief Compute the floor of a double value (largest integer <= x).
    /// @details Provides explicit downward rounding by wrapping the platform's
    ///          floor() function with C ABI.
    /// @param x Input value.
    /// @return Floor of x as a double.
    double rt_floor(double x);

    /// @brief Compute the ceiling of a double value (smallest integer >= x).
    /// @details Provides explicit upward rounding by wrapping the platform's
    ///          ceil() function with C ABI.
    /// @param x Input value.
    /// @return Ceiling of x as a double.
    double rt_ceil(double x);

    /// @brief Compute the sine of an angle in radians.
    /// @details Wraps the platform's sin() for BASIC trigonometric support.
    /// @param x Angle in radians.
    /// @return sin(x).
    double rt_sin(double x);

    /// @brief Compute the cosine of an angle in radians.
    /// @details Wraps the platform's cos() for BASIC trigonometric support.
    /// @param x Angle in radians.
    /// @return cos(x).
    double rt_cos(double x);

    /// @brief Compute the tangent of an angle in radians.
    /// @details Wraps the platform's tan() for BASIC trigonometric support.
    ///          Result may overflow near odd multiples of pi/2.
    /// @param x Angle in radians.
    /// @return tan(x).
    double rt_tan(double x);

    /// @brief Compute the arctangent of a value.
    /// @details Wraps the platform's atan() for BASIC trigonometric support.
    /// @param x Input value.
    /// @return atan(x) in the range (-pi/2, pi/2).
    double rt_atan(double x);

    /// @brief Compute the exponential e^x.
    /// @details Wraps the platform's exp() for BASIC exponential support.
    ///          May overflow to +INF for very large x values.
    /// @param x Input exponent.
    /// @return e^x.
    double rt_exp(double x);

    /// @brief Compute the natural logarithm ln(x).
    /// @details Wraps the platform's log() for BASIC logarithm support. For
    ///          trapping on domain errors, use the checked variant in rt_numeric.h.
    /// @param x Input value (x > 0 for a real result).
    /// @return ln(x); returns -INF for x=0 and NaN for x<0 (unchecked variant).
    double rt_log(double x);

    /// @brief Compute the sign of an integer as -1, 0, or +1.
    /// @details Implements BASIC's SGN for integer values.
    /// @param x Input integer.
    /// @return -1 when x < 0; 0 when x == 0; +1 when x > 0.
    long long rt_sgn_i64(long long x);

    /// @brief Compute the sign of a double as -1.0, 0.0, or +1.0.
    /// @details Implements BASIC's SGN for floating-point values.
    /// @param x Input value.
    /// @return -1.0, 0.0, or +1.0 accordingly (NaN propagation is implementation-defined).
    double rt_sgn_f64(double x);

    /// @brief Compute the absolute value of an integer.
    /// @details Implements BASIC's ABS for integer values. Note that the result
    ///          is undefined for the most-negative two's-complement value.
    /// @param x Input integer.
    /// @return |x|.
    long long rt_abs_i64(long long x);

    /// @brief Compute the absolute value of a double.
    /// @details Implements BASIC's ABS for floating-point values. Clears the
    ///          sign bit or calls the platform's fabs().
    /// @param x Input value.
    /// @return |x|.
    double rt_abs_f64(double x);

    /// @brief Return the minimum of two doubles.
    /// @details Implements BASIC's MIN for floating-point values.
    /// @param a First value.
    /// @param b Second value.
    /// @return The smaller of @p a and @p b.
    double rt_min_f64(double a, double b);

    /// @brief Return the maximum of two doubles.
    /// @details Implements BASIC's MAX for floating-point values.
    /// @param a First value.
    /// @param b Second value.
    /// @return The larger of @p a and @p b.
    double rt_max_f64(double a, double b);

    /// @brief Return the minimum of two integers.
    /// @details Implements BASIC's MIN for integer values.
    /// @param a First value.
    /// @param b Second value.
    /// @return The smaller of @p a and @p b.
    long long rt_min_i64(long long a, long long b);

    /// @brief Return the maximum of two integers.
    /// @details Implements BASIC's MAX for integer values.
    /// @param a First value.
    /// @param b Second value.
    /// @return The larger of @p a and @p b.
    long long rt_max_i64(long long a, long long b);

    //=========================================================================
    // Additional Math Functions
    //=========================================================================

    /// @brief Compute the arc tangent of y/x using signs to determine the quadrant.
    /// @details Wraps the platform's atan2() for full-range angle computation.
    /// @param y Y-coordinate (numerator).
    /// @param x X-coordinate (denominator).
    /// @return Angle in radians in the range [-pi, pi].
    double rt_atan2(double y, double x);

    /// @brief Compute the arc sine of x.
    /// @details Wraps the platform's asin(). Domain: [-1, 1].
    /// @param x Input value.
    /// @return asin(x) in the range [-pi/2, pi/2]; NaN if |x| > 1.
    double rt_asin(double x);

    /// @brief Compute the arc cosine of x.
    /// @details Wraps the platform's acos(). Domain: [-1, 1].
    /// @param x Input value.
    /// @return acos(x) in the range [0, pi]; NaN if |x| > 1.
    double rt_acos(double x);

    /// @brief Compute the hyperbolic sine of x.
    /// @details Wraps the platform's sinh().
    /// @param x Input value.
    /// @return sinh(x).
    double rt_sinh(double x);

    /// @brief Compute the hyperbolic cosine of x.
    /// @details Wraps the platform's cosh().
    /// @param x Input value.
    /// @return cosh(x).
    double rt_cosh(double x);

    /// @brief Compute the hyperbolic tangent of x.
    /// @details Wraps the platform's tanh().
    /// @param x Input value.
    /// @return tanh(x) in the range (-1, 1).
    double rt_tanh(double x);

    /// @brief Round x to the nearest integer (half-away-from-zero).
    /// @details Wraps the platform's round() function.
    /// @param x Input value.
    /// @return Nearest integer as a double.
    double rt_round(double x);

    /// @brief Truncate x toward zero.
    /// @details Wraps the platform's trunc() function.
    /// @param x Input value.
    /// @return Integer part of x (rounded toward zero).
    double rt_trunc(double x);

    /// @brief Compute the base-10 logarithm of x.
    /// @details Wraps the platform's log10().
    /// @param x Input value (x > 0 for a real result).
    /// @return log10(x).
    double rt_log10(double x);

    /// @brief Compute the base-2 logarithm of x.
    /// @details Wraps the platform's log2().
    /// @param x Input value (x > 0 for a real result).
    /// @return log2(x).
    double rt_log2(double x);

    /// @brief Compute the floating-point remainder of x / y.
    /// @details Wraps the platform's fmod(). The result has the same sign as x.
    /// @param x Dividend.
    /// @param y Divisor (must not be zero).
    /// @return Remainder of x / y.
    double rt_fmod(double x, double y);

    /// @brief Compute sqrt(x*x + y*y) without intermediate overflow.
    /// @details Wraps the platform's hypot() for safe Euclidean distance computation.
    /// @param x First component.
    /// @param y Second component.
    /// @return Hypotenuse length.
    double rt_hypot(double x, double y);

    /// @brief Clamp a double value to the range [lo, hi].
    /// @details Returns lo if val < lo, hi if val > hi, otherwise val.
    /// @param val Value to clamp.
    /// @param lo  Lower bound (inclusive).
    /// @param hi  Upper bound (inclusive).
    /// @return Clamped value.
    double rt_clamp_f64(double val, double lo, double hi);

    /// @brief Clamp an integer value to the range [lo, hi].
    /// @details Returns lo if val < lo, hi if val > hi, otherwise val.
    /// @param val Value to clamp.
    /// @param lo  Lower bound (inclusive).
    /// @param hi  Upper bound (inclusive).
    /// @return Clamped value.
    long long rt_clamp_i64(long long val, long long lo, long long hi);

    /// @brief Compute linear interpolation between two values.
    /// @details Returns a + t * (b - a). When t is 0.0 the result is a;
    ///          when t is 1.0 the result is b.
    /// @param a Start value.
    /// @param b End value.
    /// @param t Interpolation parameter (typically in [0, 1]).
    /// @return Interpolated value.
    double rt_lerp(double a, double b, double t);

    /// @brief Wrap a double value to the range [lo, hi).
    /// @details Computes val modulo the range width so the result lies
    ///          within [lo, hi). Useful for cyclic quantities like angles.
    /// @param val Value to wrap.
    /// @param lo  Lower bound (inclusive).
    /// @param hi  Upper bound (exclusive).
    /// @return Wrapped value in [lo, hi).
    double rt_wrap_f64(double val, double lo, double hi);

    /// @brief Wrap an integer value to the range [lo, hi).
    /// @details Computes val modulo the range width so the result lies
    ///          within [lo, hi). Useful for cyclic integer quantities.
    /// @param val Value to wrap.
    /// @param lo  Lower bound (inclusive).
    /// @param hi  Upper bound (exclusive).
    /// @return Wrapped value in [lo, hi).
    long long rt_wrap_i64(long long val, long long lo, long long hi);

    /// @brief Return the mathematical constant Pi (3.14159...).
    /// @return Pi as a double.
    double rt_math_pi(void);

    /// @brief Return Euler's number e (2.71828...).
    /// @return e as a double.
    double rt_math_e(void);

    /// @brief Return the mathematical constant Tau (2 * Pi = 6.28318...).
    /// @return Tau as a double.
    double rt_math_tau(void);

    /// @brief Convert an angle from radians to degrees.
    /// @param radians Angle in radians.
    /// @return Equivalent angle in degrees.
    double rt_deg(double radians);

    /// @brief Convert an angle from degrees to radians.
    /// @param degrees Angle in degrees.
    /// @return Equivalent angle in radians.
    double rt_rad(double degrees);

#ifdef __cplusplus
}
#endif
