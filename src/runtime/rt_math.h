//===----------------------------------------------------------------------===//
//
// Part of the Viper project, under the GNU GPL v3.
// See LICENSE for license information.
//
//===----------------------------------------------------------------------===//
//
// This file declares the runtime library's mathematical function API, providing
// portable implementations of standard math operations for BASIC programs. These
// functions are invoked from IL code generated by the BASIC frontend when users
// call built-in math functions like SIN, COS, SQR, ABS, SGN, etc.
//
// The runtime math API serves several purposes:
//
// 1. Platform Abstraction: Provides consistent math behavior across all targets
//    (x86-64, ARM, WebAssembly) by wrapping platform-specific math libraries
//    with a uniform C ABI.
//
// 2. Error Handling: Implements BASIC's error semantics for domain errors, overflow,
//    and invalid operations. Unlike C's math library which uses errno or NaN,
//    these functions trap on error conditions, allowing BASIC's ON ERROR mechanism
//    to catch and handle exceptional cases.
//
// 3. Type Specialization: Provides both integer and floating-point variants for
//    functions like abs() and sgn(), matching BASIC's type system requirements
//    and avoiding unnecessary conversions.
//
// Mathematical Functions Provided:
//
// Transcendental Functions:
// - Trigonometric: rt_sin, rt_cos, rt_tan, rt_atan
// - Exponential: rt_exp, rt_log
// - Power/Root: rt_sqrt (in rt_numeric.h as rt_sqrt_chk_f64)
//
// Numeric Functions:
// - Sign: rt_sgn_i64 (returns -1/0/+1), rt_sgn_f64
// - Absolute value: rt_abs_i64, rt_abs_f64
// - Rounding: rt_floor, rt_ceil (explicit rounding direction)
//
// Design Philosophy:
// These functions intentionally mirror C99 math library signatures for easy
// implementation on platforms with standard math support. The rt_ prefix
// distinguishes runtime functions from system functions and provides a clear
// namespace for runtime APIs.
//
// Error Handling Contract:
// All functions that can encounter domain errors (sqrt of negative, log of zero)
// have "_chk" variants that validate inputs and trap on errors. The basic
// functions declared here assume valid inputs for performance; checked variants
// are in rt_numeric.h.
//
// Implementation Notes:
// Most functions are thin wrappers around platform math libraries (libm on Unix,
// MSVCRT on Windows). The wrappers ensure consistent behavior across platforms
// and provide the extern "C" ABI required by IL's calling convention.
//
// Precision and Accuracy:
// All floating-point operations use IEEE-754 double precision (f64 in IL).
// BASIC's SINGLE type is currently promoted to DOUBLE during lowering, so all
// runtime math operates at double precision.
//
//===----------------------------------------------------------------------===//

#pragma once

#include <stdint.h>

#ifdef __cplusplus
extern "C"
{
#endif

    /// What: Square root of @p x.
    /// Why:  Implement BASIC's SQR over double-precision values.
    /// How:  Delegates to platform libm; see checked variants for traps.
    /// @param x Input (must be non-negative for real result).
    /// @return sqrt(x) as double; may return NaN for negative inputs (unchecked variant).
    double rt_sqrt(double x);

    /// What: Floor of @p x (largest integer <= x).
    /// Why:  Provide explicit downward rounding.
    /// How:  Wraps platform floor() with C ABI.
    /// What: Floor of @p x (largest integer <= x).
    /// @param x Input.
    /// @return Floor value as double.
    double rt_floor(double x);

    /// What: Ceil of @p x (smallest integer >= x).
    /// Why:  Provide explicit upward rounding.
    /// How:  Wraps platform ceil() with C ABI.
    /// What: Ceil of @p x (smallest integer >= x).
    /// @param x Input.
    /// @return Ceil value as double.
    double rt_ceil(double x);

    /// What: Sine of @p x (radians).
    /// Why:  BASIC trigonometric support.
    /// How:  Wraps platform sin().
    /// What: Sine of @p x (radians).
    /// @param x Angle in radians.
    /// @return sin(x).
    double rt_sin(double x);

    /// What: Cosine of @p x (radians).
    /// Why:  BASIC trigonometric support.
    /// How:  Wraps platform cos().
    /// What: Cosine of @p x (radians).
    /// @param x Angle in radians.
    /// @return cos(x).
    double rt_cos(double x);

    /// What: Tangent of @p x (radians).
    /// Why:  BASIC trigonometric support.
    /// How:  Wraps platform tan().
    /// What: Tangent of @p x (radians).
    /// @param x Angle in radians.
    /// @return tan(x) which may overflow near odd multiples of pi/2.
    double rt_tan(double x);

    /// What: Arctangent of @p x (radians).
    /// Why:  BASIC trigonometric support.
    /// How:  Wraps platform atan().
    /// What: Arctangent of @p x (radians).
    /// @param x Input.
    /// @return atan(x) in range (-pi/2, pi/2).
    double rt_atan(double x);

    /// What: Exponential e^@p x.
    /// Why:  BASIC exponential support.
    /// How:  Wraps platform exp().
    /// What: Exponential e^@p x.
    /// @param x Input.
    /// @return exp(x); may overflow to +INF for large x.
    double rt_exp(double x);

    /// What: Natural logarithm ln(@p x).
    /// Why:  BASIC logarithm support.
    /// How:  Wraps platform log(); see checked variants for domain handling.
    /// What: Natural logarithm ln(@p x).
    /// @param x Input (x > 0 for real result).
    /// @return ln(x); returns -INF for x=0 and NaN for x<0 (unchecked variant).
    double rt_log(double x);

    /// What: Sign of @p x as -1, 0, or +1 (integer variant).
    /// Why:  Implement BASIC SGN for integers.
    /// How:  Compares against zero and returns sentinel values.
    /// What: Sign of @p x as -1, 0, or +1 (integer variant).
    /// @param x Input integer.
    /// @return -1 when x<0; 0 when x==0; +1 when x>0.
    long long rt_sgn_i64(long long x);

    /// What: Sign of @p x as -1.0, 0.0, or +1.0 (float variant).
    /// Why:  Implement BASIC SGN for floating-point numbers.
    /// How:  Compares against zero and returns sentinel values.
    /// What: Sign of @p x as -1.0, 0.0, or +1.0 (float variant).
    /// @param x Input.
    /// @return -1.0, 0.0, or +1.0 accordingly (NaN propagates per implementation).
    double rt_sgn_f64(double x);

    /// What: Absolute value of @p x (integer variant).
    /// Why:  Implement BASIC ABS for integers.
    /// How:  Branchless or two's-complement-safe computation.
    /// What: Absolute value of @p x (integer variant).
    /// @param x Input integer.
    /// @return |x| (beware two's-complement minimum edge case if used directly).
    long long rt_abs_i64(long long x);

    /// What: Absolute value of @p x (float variant).
    /// Why:  Implement BASIC ABS for floating-point numbers.
    /// How:  Clears the sign bit or calls platform fabs().
    /// What: Absolute value of @p x (float variant).
    /// @param x Input.
    /// @return |x|.
    double rt_abs_f64(double x);

    /// What: Minimum of two doubles.
    /// Why:  Implement BASIC MIN for floating-point numbers.
    /// @return The smaller of @p a and @p b.
    double rt_min_f64(double a, double b);

    /// What: Maximum of two doubles.
    /// Why:  Implement BASIC MAX for floating-point numbers.
    /// @return The larger of @p a and @p b.
    double rt_max_f64(double a, double b);

    /// What: Minimum of two integers.
    /// Why:  Implement BASIC MIN for integers.
    /// @return The smaller of @p a and @p b.
    long long rt_min_i64(long long a, long long b);

    /// What: Maximum of two integers.
    /// Why:  Implement BASIC MAX for integers.
    /// @return The larger of @p a and @p b.
    long long rt_max_i64(long long a, long long b);

#ifdef __cplusplus
}
#endif
