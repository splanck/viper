/**
 * @file signal.hpp
 * @brief POSIX-like signal handling for ViperOS.
 *
 * @details
 * This module provides signal delivery for user-mode tasks. Signals can be
 * generated by:
 * - Hardware exceptions (SIGSEGV, SIGBUS, SIGILL, SIGFPE)
 * - User requests via kill() syscall
 * - Kernel events (SIGCHLD, SIGPIPE, etc.)
 *
 * Currently, most signals result in task termination since user-space signal
 * handlers are not yet implemented.
 */
#pragma once

#include "../include/types.hpp"
#include "task.hpp"

namespace signal
{

/// Signal numbers (POSIX subset)
namespace sig
{
constexpr i32 SIGHUP = 1;    ///< Hangup
constexpr i32 SIGINT = 2;    ///< Interrupt (Ctrl+C)
constexpr i32 SIGQUIT = 3;   ///< Quit (Ctrl+\)
constexpr i32 SIGILL = 4;    ///< Illegal instruction
constexpr i32 SIGTRAP = 5;   ///< Trace trap
constexpr i32 SIGABRT = 6;   ///< Abort
constexpr i32 SIGBUS = 7;    ///< Bus error
constexpr i32 SIGFPE = 8;    ///< Floating point exception
constexpr i32 SIGKILL = 9;   ///< Kill (cannot be caught)
constexpr i32 SIGUSR1 = 10;  ///< User defined signal 1
constexpr i32 SIGSEGV = 11;  ///< Segmentation violation
constexpr i32 SIGUSR2 = 12;  ///< User defined signal 2
constexpr i32 SIGPIPE = 13;  ///< Broken pipe
constexpr i32 SIGALRM = 14;  ///< Alarm clock
constexpr i32 SIGTERM = 15;  ///< Termination
constexpr i32 SIGCHLD = 17;  ///< Child status changed
constexpr i32 SIGCONT = 18;  ///< Continue if stopped
constexpr i32 SIGSTOP = 19;  ///< Stop (cannot be caught)
constexpr i32 SIGTSTP = 20;  ///< Stop from terminal (Ctrl+Z)
constexpr i32 SIGTTIN = 21;  ///< Background read from tty
constexpr i32 SIGTTOU = 22;  ///< Background write to tty
constexpr i32 SIGURG = 23;   ///< Urgent I/O condition
constexpr i32 SIGXCPU = 24;  ///< CPU time limit exceeded
constexpr i32 SIGXFSZ = 25;  ///< File size limit exceeded
constexpr i32 SIGVTALRM = 26; ///< Virtual timer expired
constexpr i32 SIGPROF = 27;  ///< Profiling timer expired
constexpr i32 SIGWINCH = 28; ///< Window size change
constexpr i32 SIGIO = 29;    ///< I/O possible
constexpr i32 SIGSYS = 31;   ///< Bad system call

constexpr i32 NSIG = 32;     ///< Number of signals
} // namespace sig

/**
 * @brief Fault information passed with hardware signals.
 */
struct FaultInfo
{
    u64 fault_addr;   ///< Faulting address (FAR_EL1)
    u64 fault_pc;     ///< Instruction that caused the fault (ELR_EL1)
    u32 fault_esr;    ///< Exception syndrome register
    const char *kind; ///< Human-readable fault type
};

/**
 * @brief Get the default action for a signal.
 *
 * @param signum Signal number.
 * @return 'T' for terminate, 'I' for ignore, 'S' for stop, 'C' for continue.
 */
char default_action(i32 signum);

/**
 * @brief Get the name of a signal.
 *
 * @param signum Signal number.
 * @return Human-readable signal name (e.g., "SIGSEGV").
 */
const char *signal_name(i32 signum);

/**
 * @brief Send a signal to a task.
 *
 * @param task Target task.
 * @param signum Signal number.
 * @return 0 on success, -1 on error.
 */
i32 send_signal(task::Task *task, i32 signum);

/**
 * @brief Send a hardware fault signal to the current task.
 *
 * @details
 * Called from the exception handler when a user-mode fault occurs.
 * The fault is logged and the appropriate signal is delivered.
 *
 * @param signum Signal number (SIGSEGV, SIGBUS, SIGILL, etc.).
 * @param info Fault information.
 */
void deliver_fault_signal(i32 signum, const FaultInfo *info);

/**
 * @brief Check if a task has pending signals.
 *
 * @param task Task to check.
 * @return true if signals are pending.
 */
bool has_pending(task::Task *task);

/**
 * @brief Process pending signals for the current task.
 *
 * @details
 * Called before returning to user mode. Currently just terminates
 * the task for fatal signals since user handlers aren't implemented.
 */
void process_pending();

} // namespace signal
