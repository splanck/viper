// -*- C++ -*-
/*
 * ViperOS C++ Standard Library - barrier
 * C++20 reusable thread synchronization primitive
 */

#ifndef _VIPER_BARRIER
#define _VIPER_BARRIER

#include "atomic"
#include "limits"
#include "type_traits"

namespace std
{

/*
 * ===========================================================================
 * __empty_completion - Default completion function (no-op)
 * ===========================================================================
 */

struct __empty_completion
{
    void operator()() noexcept {}
};

/*
 * ===========================================================================
 * barrier - Reusable thread synchronization barrier
 *
 * A barrier is a synchronization primitive that blocks a group of threads
 * until all threads have arrived. Unlike latch, barrier can be reused.
 *
 * ViperOS implementation: Simplified for single-threaded environment.
 * ===========================================================================
 */

template <class CompletionFunction = __empty_completion> class barrier
{
  public:
    using arrival_token = unsigned;

    // Maximum expected count
    static constexpr ptrdiff_t max() noexcept
    {
        return numeric_limits<ptrdiff_t>::max();
    }

    // Constructor
    constexpr explicit barrier(ptrdiff_t expected, CompletionFunction f = CompletionFunction())
        : expected_(expected), count_(expected), generation_(0),
          completion_(static_cast<CompletionFunction &&>(f))
    {
    }

    // Destructor
    ~barrier() = default;

    // Non-copyable, non-movable
    barrier(const barrier &) = delete;
    barrier &operator=(const barrier &) = delete;

    /*
     * Arrive at the barrier and decrement the expected count.
     * Returns a token that can be used with wait().
     */
    [[nodiscard]] arrival_token arrive(ptrdiff_t n = 1)
    {
        unsigned gen = generation_.load(memory_order_acquire);
        ptrdiff_t remaining = count_.fetch_sub(n, memory_order_acq_rel) - n;

        if (remaining == 0)
        {
            // Last thread to arrive - call completion and reset
            completion_();
            count_.store(expected_, memory_order_release);
            generation_.fetch_add(1, memory_order_acq_rel);
        }

        return gen;
    }

    /*
     * Block until the barrier phase completes.
     * The token must be from a call to arrive() for the current phase.
     */
    void wait(arrival_token &&arrival) const
    {
        unsigned gen = arrival;
        while (generation_.load(memory_order_acquire) == gen)
        {
            // In a real implementation: wait on condition variable
            // Single-threaded: break to avoid infinite loop
            break;
        }
    }

    /*
     * Arrive and wait in one operation.
     * Equivalent to: wait(arrive());
     */
    void arrive_and_wait()
    {
        wait(arrive());
    }

    /*
     * Remove this thread from the set of participating threads.
     * Decrements expected count permanently.
     */
    void arrive_and_drop()
    {
        ptrdiff_t remaining = count_.fetch_sub(1, memory_order_acq_rel) - 1;
        expected_--;

        if (remaining == 0)
        {
            completion_();
            count_.store(expected_, memory_order_release);
            generation_.fetch_add(1, memory_order_acq_rel);
        }
    }

  private:
    ptrdiff_t expected_;
    atomic<ptrdiff_t> count_;
    atomic<unsigned> generation_;
    CompletionFunction completion_;
};

} // namespace std

#endif // _VIPER_BARRIER
