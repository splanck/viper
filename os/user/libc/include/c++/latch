// -*- C++ -*-
/*
 * ViperOS C++ Standard Library - latch
 * C++20 single-use thread synchronization primitive
 */

#ifndef _VIPER_LATCH
#define _VIPER_LATCH

#include "atomic"
#include "limits"

namespace std {

/*
 * ===========================================================================
 * latch - Single-use thread barrier
 *
 * A latch is a downward counter which can be used to synchronize threads.
 * The value of the counter is initialized on construction. Threads may
 * block on the latch until the counter reaches zero.
 *
 * ViperOS implementation: Simplified for single-threaded environment.
 * ===========================================================================
 */

class latch {
public:
    // Maximum value of the internal counter
    static constexpr ptrdiff_t max() noexcept {
        return numeric_limits<ptrdiff_t>::max();
    }

    // Constructor
    constexpr explicit latch(ptrdiff_t expected) noexcept
        : counter_(expected) {}

    // Destructor
    ~latch() = default;

    // Non-copyable, non-movable
    latch(const latch&) = delete;
    latch& operator=(const latch&) = delete;

    /*
     * Decrement the counter without blocking.
     * If the counter reaches zero, all threads blocked on wait() are released.
     */
    void count_down(ptrdiff_t n = 1) {
        ptrdiff_t old = counter_.fetch_sub(n, memory_order_acq_rel);
        // In a real implementation, if old - n <= 0, notify waiting threads
        (void)old;
    }

    /*
     * Decrement and return true if the counter reached zero.
     */
    bool try_wait() const noexcept {
        return counter_.load(memory_order_acquire) <= 0;
    }

    /*
     * Block until the counter reaches zero.
     * In this single-threaded stub, if counter > 0, it cannot become 0
     * without another thread, so this would deadlock. We just return.
     */
    void wait() const {
        while (counter_.load(memory_order_acquire) > 0) {
            // In a real implementation: wait on condition variable
            // Single-threaded: break to avoid infinite loop
            break;
        }
    }

    /*
     * Decrement the counter and block until it reaches zero.
     * Equivalent to count_down(n); wait();
     */
    void arrive_and_wait(ptrdiff_t n = 1) {
        count_down(n);
        wait();
    }

private:
    atomic<ptrdiff_t> counter_;
};

} // namespace std

#endif // _VIPER_LATCH
