#ifndef _LIBCPP_UTILITY
#define _LIBCPP_UTILITY

#include "type_traits"

namespace std {

/* declval - obtain a reference to T for use in unevaluated contexts */
template <class T>
typename add_rvalue_reference<T>::type declval() noexcept;

/* move - cast to rvalue reference */
template <class T>
constexpr typename remove_reference<T>::type&& move(T&& t) noexcept
{
    return static_cast<typename remove_reference<T>::type&&>(t);
}

/* forward - perfect forwarding */
template <class T>
constexpr T&& forward(typename remove_reference<T>::type& t) noexcept
{
    return static_cast<T&&>(t);
}

template <class T>
constexpr T&& forward(typename remove_reference<T>::type&& t) noexcept
{
    static_assert(!is_lvalue_reference<T>::value,
                  "Cannot forward an rvalue as an lvalue.");
    return static_cast<T&&>(t);
}

/* swap */
template <class T>
constexpr void swap(T& a, T& b) noexcept
{
    T tmp = move(a);
    a = move(b);
    b = move(tmp);
}

template <class T, unsigned long N>
constexpr void swap(T (&a)[N], T (&b)[N]) noexcept
{
    for (unsigned long i = 0; i < N; ++i)
    {
        swap(a[i], b[i]);
    }
}

/* exchange */
template <class T, class U = T>
constexpr T exchange(T& obj, U&& new_value)
{
    T old_value = move(obj);
    obj = forward<U>(new_value);
    return old_value;
}

/* pair */
template <class T1, class T2>
struct pair {
    using first_type = T1;
    using second_type = T2;

    T1 first;
    T2 second;

    constexpr pair() : first(), second() {}

    constexpr pair(const T1& x, const T2& y) : first(x), second(y) {}

    template <class U1, class U2>
    constexpr pair(U1&& x, U2&& y) : first(forward<U1>(x)), second(forward<U2>(y))
    {
    }

    template <class U1, class U2>
    constexpr pair(const pair<U1, U2>& p) : first(p.first), second(p.second)
    {
    }

    template <class U1, class U2>
    constexpr pair(pair<U1, U2>&& p)
        : first(forward<U1>(p.first)), second(forward<U2>(p.second))
    {
    }

    pair(const pair&) = default;
    pair(pair&&) = default;
    pair& operator=(const pair&) = default;
    pair& operator=(pair&&) = default;

    constexpr void swap(pair& other) noexcept
    {
        std::swap(first, other.first);
        std::swap(second, other.second);
    }
};

/* make_pair */
template <class T1, class T2>
constexpr pair<typename decay<T1>::type, typename decay<T2>::type> make_pair(T1&& x,
                                                                              T2&& y)
{
    return pair<typename decay<T1>::type, typename decay<T2>::type>(forward<T1>(x),
                                                                     forward<T2>(y));
}

/* pair comparison operators */
template <class T1, class T2>
constexpr bool operator==(const pair<T1, T2>& lhs, const pair<T1, T2>& rhs)
{
    return lhs.first == rhs.first && lhs.second == rhs.second;
}

template <class T1, class T2>
constexpr bool operator!=(const pair<T1, T2>& lhs, const pair<T1, T2>& rhs)
{
    return !(lhs == rhs);
}

template <class T1, class T2>
constexpr bool operator<(const pair<T1, T2>& lhs, const pair<T1, T2>& rhs)
{
    return lhs.first < rhs.first ||
           (!(rhs.first < lhs.first) && lhs.second < rhs.second);
}

template <class T1, class T2>
constexpr bool operator<=(const pair<T1, T2>& lhs, const pair<T1, T2>& rhs)
{
    return !(rhs < lhs);
}

template <class T1, class T2>
constexpr bool operator>(const pair<T1, T2>& lhs, const pair<T1, T2>& rhs)
{
    return rhs < lhs;
}

template <class T1, class T2>
constexpr bool operator>=(const pair<T1, T2>& lhs, const pair<T1, T2>& rhs)
{
    return !(lhs < rhs);
}

/* integer_sequence */
template <class T, T... Ints>
struct integer_sequence {
    using value_type = T;
    static constexpr unsigned long size() noexcept { return sizeof...(Ints); }
};

template <unsigned long... Ints>
using index_sequence = integer_sequence<unsigned long, Ints...>;

/* Helper for make_integer_sequence */
template <class T, T N, T... Ints>
struct make_integer_sequence_impl
    : make_integer_sequence_impl<T, N - 1, N - 1, Ints...> {};

template <class T, T... Ints>
struct make_integer_sequence_impl<T, 0, Ints...> {
    using type = integer_sequence<T, Ints...>;
};

template <class T, T N>
using make_integer_sequence = typename make_integer_sequence_impl<T, N>::type;

template <unsigned long N>
using make_index_sequence = make_integer_sequence<unsigned long, N>;

template <class... T>
using index_sequence_for = make_index_sequence<sizeof...(T)>;

} /* namespace std */

#endif /* _LIBCPP_UTILITY */
