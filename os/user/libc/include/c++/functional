#ifndef _LIBCPP_FUNCTIONAL
#define _LIBCPP_FUNCTIONAL

#include "utility"

namespace std {

/* Arithmetic operations */
template <class T = void>
struct plus
{
    constexpr T operator()(const T& lhs, const T& rhs) const
    {
        return lhs + rhs;
    }
};

template <>
struct plus<void>
{
    template <class T, class U>
    constexpr auto operator()(T&& lhs, U&& rhs) const
        -> decltype(forward<T>(lhs) + forward<U>(rhs))
    {
        return forward<T>(lhs) + forward<U>(rhs);
    }
};

template <class T = void>
struct minus
{
    constexpr T operator()(const T& lhs, const T& rhs) const
    {
        return lhs - rhs;
    }
};

template <>
struct minus<void>
{
    template <class T, class U>
    constexpr auto operator()(T&& lhs, U&& rhs) const
        -> decltype(forward<T>(lhs) - forward<U>(rhs))
    {
        return forward<T>(lhs) - forward<U>(rhs);
    }
};

template <class T = void>
struct multiplies
{
    constexpr T operator()(const T& lhs, const T& rhs) const
    {
        return lhs * rhs;
    }
};

template <>
struct multiplies<void>
{
    template <class T, class U>
    constexpr auto operator()(T&& lhs, U&& rhs) const
        -> decltype(forward<T>(lhs) * forward<U>(rhs))
    {
        return forward<T>(lhs) * forward<U>(rhs);
    }
};

template <class T = void>
struct divides
{
    constexpr T operator()(const T& lhs, const T& rhs) const
    {
        return lhs / rhs;
    }
};

template <>
struct divides<void>
{
    template <class T, class U>
    constexpr auto operator()(T&& lhs, U&& rhs) const
        -> decltype(forward<T>(lhs) / forward<U>(rhs))
    {
        return forward<T>(lhs) / forward<U>(rhs);
    }
};

template <class T = void>
struct modulus
{
    constexpr T operator()(const T& lhs, const T& rhs) const
    {
        return lhs % rhs;
    }
};

template <>
struct modulus<void>
{
    template <class T, class U>
    constexpr auto operator()(T&& lhs, U&& rhs) const
        -> decltype(forward<T>(lhs) % forward<U>(rhs))
    {
        return forward<T>(lhs) % forward<U>(rhs);
    }
};

template <class T = void>
struct negate
{
    constexpr T operator()(const T& arg) const
    {
        return -arg;
    }
};

template <>
struct negate<void>
{
    template <class T>
    constexpr auto operator()(T&& arg) const
        -> decltype(-forward<T>(arg))
    {
        return -forward<T>(arg);
    }
};

/* Comparison operations */
template <class T = void>
struct equal_to
{
    constexpr bool operator()(const T& lhs, const T& rhs) const
    {
        return lhs == rhs;
    }
};

template <>
struct equal_to<void>
{
    template <class T, class U>
    constexpr auto operator()(T&& lhs, U&& rhs) const
        -> decltype(forward<T>(lhs) == forward<U>(rhs))
    {
        return forward<T>(lhs) == forward<U>(rhs);
    }
};

template <class T = void>
struct not_equal_to
{
    constexpr bool operator()(const T& lhs, const T& rhs) const
    {
        return lhs != rhs;
    }
};

template <>
struct not_equal_to<void>
{
    template <class T, class U>
    constexpr auto operator()(T&& lhs, U&& rhs) const
        -> decltype(forward<T>(lhs) != forward<U>(rhs))
    {
        return forward<T>(lhs) != forward<U>(rhs);
    }
};

template <class T = void>
struct greater
{
    constexpr bool operator()(const T& lhs, const T& rhs) const
    {
        return lhs > rhs;
    }
};

template <>
struct greater<void>
{
    template <class T, class U>
    constexpr auto operator()(T&& lhs, U&& rhs) const
        -> decltype(forward<T>(lhs) > forward<U>(rhs))
    {
        return forward<T>(lhs) > forward<U>(rhs);
    }
};

template <class T = void>
struct less
{
    constexpr bool operator()(const T& lhs, const T& rhs) const
    {
        return lhs < rhs;
    }
};

template <>
struct less<void>
{
    template <class T, class U>
    constexpr auto operator()(T&& lhs, U&& rhs) const
        -> decltype(forward<T>(lhs) < forward<U>(rhs))
    {
        return forward<T>(lhs) < forward<U>(rhs);
    }
};

template <class T = void>
struct greater_equal
{
    constexpr bool operator()(const T& lhs, const T& rhs) const
    {
        return lhs >= rhs;
    }
};

template <>
struct greater_equal<void>
{
    template <class T, class U>
    constexpr auto operator()(T&& lhs, U&& rhs) const
        -> decltype(forward<T>(lhs) >= forward<U>(rhs))
    {
        return forward<T>(lhs) >= forward<U>(rhs);
    }
};

template <class T = void>
struct less_equal
{
    constexpr bool operator()(const T& lhs, const T& rhs) const
    {
        return lhs <= rhs;
    }
};

template <>
struct less_equal<void>
{
    template <class T, class U>
    constexpr auto operator()(T&& lhs, U&& rhs) const
        -> decltype(forward<T>(lhs) <= forward<U>(rhs))
    {
        return forward<T>(lhs) <= forward<U>(rhs);
    }
};

/* Logical operations */
template <class T = void>
struct logical_and
{
    constexpr bool operator()(const T& lhs, const T& rhs) const
    {
        return lhs && rhs;
    }
};

template <>
struct logical_and<void>
{
    template <class T, class U>
    constexpr auto operator()(T&& lhs, U&& rhs) const
        -> decltype(forward<T>(lhs) && forward<U>(rhs))
    {
        return forward<T>(lhs) && forward<U>(rhs);
    }
};

template <class T = void>
struct logical_or
{
    constexpr bool operator()(const T& lhs, const T& rhs) const
    {
        return lhs || rhs;
    }
};

template <>
struct logical_or<void>
{
    template <class T, class U>
    constexpr auto operator()(T&& lhs, U&& rhs) const
        -> decltype(forward<T>(lhs) || forward<U>(rhs))
    {
        return forward<T>(lhs) || forward<U>(rhs);
    }
};

template <class T = void>
struct logical_not
{
    constexpr bool operator()(const T& arg) const
    {
        return !arg;
    }
};

template <>
struct logical_not<void>
{
    template <class T>
    constexpr auto operator()(T&& arg) const
        -> decltype(!forward<T>(arg))
    {
        return !forward<T>(arg);
    }
};

/* Bitwise operations */
template <class T = void>
struct bit_and
{
    constexpr T operator()(const T& lhs, const T& rhs) const
    {
        return lhs & rhs;
    }
};

template <>
struct bit_and<void>
{
    template <class T, class U>
    constexpr auto operator()(T&& lhs, U&& rhs) const
        -> decltype(forward<T>(lhs) & forward<U>(rhs))
    {
        return forward<T>(lhs) & forward<U>(rhs);
    }
};

template <class T = void>
struct bit_or
{
    constexpr T operator()(const T& lhs, const T& rhs) const
    {
        return lhs | rhs;
    }
};

template <>
struct bit_or<void>
{
    template <class T, class U>
    constexpr auto operator()(T&& lhs, U&& rhs) const
        -> decltype(forward<T>(lhs) | forward<U>(rhs))
    {
        return forward<T>(lhs) | forward<U>(rhs);
    }
};

template <class T = void>
struct bit_xor
{
    constexpr T operator()(const T& lhs, const T& rhs) const
    {
        return lhs ^ rhs;
    }
};

template <>
struct bit_xor<void>
{
    template <class T, class U>
    constexpr auto operator()(T&& lhs, U&& rhs) const
        -> decltype(forward<T>(lhs) ^ forward<U>(rhs))
    {
        return forward<T>(lhs) ^ forward<U>(rhs);
    }
};

template <class T = void>
struct bit_not
{
    constexpr T operator()(const T& arg) const
    {
        return ~arg;
    }
};

template <>
struct bit_not<void>
{
    template <class T>
    constexpr auto operator()(T&& arg) const
        -> decltype(~forward<T>(arg))
    {
        return ~forward<T>(arg);
    }
};

/* not_fn (C++17) */
template <class F>
class not_fn_t
{
    F fn_;
public:
    explicit not_fn_t(F&& fn) : fn_(forward<F>(fn)) {}

    template <class... Args>
    auto operator()(Args&&... args) &
        -> decltype(!declval<invoke_result_t<F&, Args...>>())
    {
        return !fn_(forward<Args>(args)...);
    }

    template <class... Args>
    auto operator()(Args&&... args) const&
        -> decltype(!declval<invoke_result_t<const F&, Args...>>())
    {
        return !fn_(forward<Args>(args)...);
    }
};

template <class F>
not_fn_t<decay_t<F>> not_fn(F&& f)
{
    return not_fn_t<decay_t<F>>(forward<F>(f));
}

/* identity (C++20) */
struct identity
{
    template <class T>
    constexpr T&& operator()(T&& t) const noexcept
    {
        return forward<T>(t);
    }
};

/* reference_wrapper */
template <class T>
class reference_wrapper
{
    T* ptr_;
public:
    using type = T;

    reference_wrapper(T& ref) noexcept : ptr_(&ref) {}
    reference_wrapper(T&&) = delete;
    reference_wrapper(const reference_wrapper&) noexcept = default;

    reference_wrapper& operator=(const reference_wrapper&) noexcept = default;

    operator T&() const noexcept { return *ptr_; }
    T& get() const noexcept { return *ptr_; }

    template <class... Args>
    auto operator()(Args&&... args) const
        -> decltype((*ptr_)(forward<Args>(args)...))
    {
        return (*ptr_)(forward<Args>(args)...);
    }
};

template <class T>
reference_wrapper<T> ref(T& t) noexcept
{
    return reference_wrapper<T>(t);
}

template <class T>
reference_wrapper<const T> cref(const T& t) noexcept
{
    return reference_wrapper<const T>(t);
}

template <class T>
void ref(const T&&) = delete;

template <class T>
void cref(const T&&) = delete;

/* hash - basic implementation */
template <class T>
struct hash;

template <>
struct hash<bool>
{
    size_t operator()(bool val) const noexcept { return val; }
};

template <>
struct hash<char>
{
    size_t operator()(char val) const noexcept { return val; }
};

template <>
struct hash<signed char>
{
    size_t operator()(signed char val) const noexcept { return val; }
};

template <>
struct hash<unsigned char>
{
    size_t operator()(unsigned char val) const noexcept { return val; }
};

template <>
struct hash<short>
{
    size_t operator()(short val) const noexcept { return val; }
};

template <>
struct hash<unsigned short>
{
    size_t operator()(unsigned short val) const noexcept { return val; }
};

template <>
struct hash<int>
{
    size_t operator()(int val) const noexcept { return val; }
};

template <>
struct hash<unsigned int>
{
    size_t operator()(unsigned int val) const noexcept { return val; }
};

template <>
struct hash<long>
{
    size_t operator()(long val) const noexcept { return val; }
};

template <>
struct hash<unsigned long>
{
    size_t operator()(unsigned long val) const noexcept { return val; }
};

template <>
struct hash<long long>
{
    size_t operator()(long long val) const noexcept { return static_cast<size_t>(val); }
};

template <>
struct hash<unsigned long long>
{
    size_t operator()(unsigned long long val) const noexcept { return static_cast<size_t>(val); }
};

template <class T>
struct hash<T*>
{
    size_t operator()(T* val) const noexcept
    {
        return reinterpret_cast<size_t>(val);
    }
};

} /* namespace std */

#endif /* _LIBCPP_FUNCTIONAL */
