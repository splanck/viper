// -*- C++ -*-
/*
 * ViperOS C++ Standard Library - mutex
 * Mutual exclusion primitives
 */

#ifndef _VIPER_MUTEX
#define _VIPER_MUTEX

#include "type_traits"
#include "utility"
#include "chrono"

namespace std {

/*
 * ===========================================================================
 * Mutex types
 * ===========================================================================
 */

/*
 * mutex - Basic mutual exclusion
 *
 * ViperOS stub implementation - single-threaded environment.
 * All operations are no-ops but maintain correct semantics.
 */
class mutex {
public:
    using native_handle_type = void*;

    constexpr mutex() noexcept : locked_(false) {}
    ~mutex() = default;

    mutex(const mutex&) = delete;
    mutex& operator=(const mutex&) = delete;

    void lock() {
        // In single-threaded environment, just track state
        locked_ = true;
    }

    bool try_lock() noexcept {
        if (locked_) return false;
        locked_ = true;
        return true;
    }

    void unlock() noexcept {
        locked_ = false;
    }

    native_handle_type native_handle() { return nullptr; }

private:
    bool locked_;
};

/*
 * recursive_mutex - Mutex that can be locked multiple times by same thread
 */
class recursive_mutex {
public:
    using native_handle_type = void*;

    constexpr recursive_mutex() noexcept : count_(0) {}
    ~recursive_mutex() = default;

    recursive_mutex(const recursive_mutex&) = delete;
    recursive_mutex& operator=(const recursive_mutex&) = delete;

    void lock() {
        ++count_;
    }

    bool try_lock() noexcept {
        ++count_;
        return true;
    }

    void unlock() noexcept {
        if (count_ > 0) --count_;
    }

    native_handle_type native_handle() { return nullptr; }

private:
    unsigned int count_;
};

/*
 * timed_mutex - Mutex with timed lock operations
 */
class timed_mutex {
public:
    using native_handle_type = void*;

    constexpr timed_mutex() noexcept : locked_(false) {}
    ~timed_mutex() = default;

    timed_mutex(const timed_mutex&) = delete;
    timed_mutex& operator=(const timed_mutex&) = delete;

    void lock() {
        locked_ = true;
    }

    bool try_lock() noexcept {
        if (locked_) return false;
        locked_ = true;
        return true;
    }

    template<class Rep, class Period>
    bool try_lock_for(const chrono::duration<Rep, Period>&) {
        return try_lock();
    }

    template<class Clock, class Duration>
    bool try_lock_until(const chrono::time_point<Clock, Duration>&) {
        return try_lock();
    }

    void unlock() noexcept {
        locked_ = false;
    }

    native_handle_type native_handle() { return nullptr; }

private:
    bool locked_;
};

/*
 * recursive_timed_mutex - Recursive mutex with timed operations
 */
class recursive_timed_mutex {
public:
    using native_handle_type = void*;

    constexpr recursive_timed_mutex() noexcept : count_(0) {}
    ~recursive_timed_mutex() = default;

    recursive_timed_mutex(const recursive_timed_mutex&) = delete;
    recursive_timed_mutex& operator=(const recursive_timed_mutex&) = delete;

    void lock() {
        ++count_;
    }

    bool try_lock() noexcept {
        ++count_;
        return true;
    }

    template<class Rep, class Period>
    bool try_lock_for(const chrono::duration<Rep, Period>&) {
        return try_lock();
    }

    template<class Clock, class Duration>
    bool try_lock_until(const chrono::time_point<Clock, Duration>&) {
        return try_lock();
    }

    void unlock() noexcept {
        if (count_ > 0) --count_;
    }

    native_handle_type native_handle() { return nullptr; }

private:
    unsigned int count_;
};

/*
 * ===========================================================================
 * Lock tags
 * ===========================================================================
 */

struct defer_lock_t { explicit defer_lock_t() = default; };
struct try_to_lock_t { explicit try_to_lock_t() = default; };
struct adopt_lock_t { explicit adopt_lock_t() = default; };

inline constexpr defer_lock_t defer_lock{};
inline constexpr try_to_lock_t try_to_lock{};
inline constexpr adopt_lock_t adopt_lock{};

/*
 * ===========================================================================
 * Lock guards
 * ===========================================================================
 */

/*
 * lock_guard - RAII mutex wrapper
 */
template<class Mutex>
class lock_guard {
public:
    using mutex_type = Mutex;

    explicit lock_guard(mutex_type& m) : mutex_(m) {
        mutex_.lock();
    }

    lock_guard(mutex_type& m, adopt_lock_t) noexcept : mutex_(m) {
        // Assume already locked
    }

    ~lock_guard() {
        mutex_.unlock();
    }

    lock_guard(const lock_guard&) = delete;
    lock_guard& operator=(const lock_guard&) = delete;

private:
    mutex_type& mutex_;
};

/*
 * unique_lock - Movable mutex ownership wrapper
 */
template<class Mutex>
class unique_lock {
public:
    using mutex_type = Mutex;

    unique_lock() noexcept : mutex_(nullptr), owns_(false) {}

    explicit unique_lock(mutex_type& m) : mutex_(&m), owns_(false) {
        mutex_->lock();
        owns_ = true;
    }

    unique_lock(mutex_type& m, defer_lock_t) noexcept
        : mutex_(&m), owns_(false) {}

    unique_lock(mutex_type& m, try_to_lock_t)
        : mutex_(&m), owns_(mutex_->try_lock()) {}

    unique_lock(mutex_type& m, adopt_lock_t) noexcept
        : mutex_(&m), owns_(true) {}

    template<class Rep, class Period>
    unique_lock(mutex_type& m, const chrono::duration<Rep, Period>& timeout)
        : mutex_(&m), owns_(mutex_->try_lock_for(timeout)) {}

    template<class Clock, class Duration>
    unique_lock(mutex_type& m, const chrono::time_point<Clock, Duration>& deadline)
        : mutex_(&m), owns_(mutex_->try_lock_until(deadline)) {}

    ~unique_lock() {
        if (owns_) mutex_->unlock();
    }

    unique_lock(const unique_lock&) = delete;
    unique_lock& operator=(const unique_lock&) = delete;

    unique_lock(unique_lock&& other) noexcept
        : mutex_(other.mutex_), owns_(other.owns_) {
        other.mutex_ = nullptr;
        other.owns_ = false;
    }

    unique_lock& operator=(unique_lock&& other) noexcept {
        if (owns_) mutex_->unlock();
        mutex_ = other.mutex_;
        owns_ = other.owns_;
        other.mutex_ = nullptr;
        other.owns_ = false;
        return *this;
    }

    void lock() {
        mutex_->lock();
        owns_ = true;
    }

    bool try_lock() {
        owns_ = mutex_->try_lock();
        return owns_;
    }

    template<class Rep, class Period>
    bool try_lock_for(const chrono::duration<Rep, Period>& timeout) {
        owns_ = mutex_->try_lock_for(timeout);
        return owns_;
    }

    template<class Clock, class Duration>
    bool try_lock_until(const chrono::time_point<Clock, Duration>& deadline) {
        owns_ = mutex_->try_lock_until(deadline);
        return owns_;
    }

    void unlock() {
        mutex_->unlock();
        owns_ = false;
    }

    void swap(unique_lock& other) noexcept {
        Mutex* tmp_m = mutex_;
        bool tmp_o = owns_;
        mutex_ = other.mutex_;
        owns_ = other.owns_;
        other.mutex_ = tmp_m;
        other.owns_ = tmp_o;
    }

    mutex_type* release() noexcept {
        mutex_type* m = mutex_;
        mutex_ = nullptr;
        owns_ = false;
        return m;
    }

    mutex_type* mutex() const noexcept { return mutex_; }
    bool owns_lock() const noexcept { return owns_; }
    explicit operator bool() const noexcept { return owns_; }

private:
    mutex_type* mutex_;
    bool owns_;
};

template<class Mutex>
void swap(unique_lock<Mutex>& a, unique_lock<Mutex>& b) noexcept {
    a.swap(b);
}

/*
 * scoped_lock - RAII wrapper for multiple mutexes (C++17)
 */
template<class... MutexTypes>
class scoped_lock;

// Single mutex specialization
template<class Mutex>
class scoped_lock<Mutex> {
public:
    using mutex_type = Mutex;

    explicit scoped_lock(Mutex& m) : mutex_(m) {
        mutex_.lock();
    }

    scoped_lock(adopt_lock_t, Mutex& m) noexcept : mutex_(m) {}

    ~scoped_lock() {
        mutex_.unlock();
    }

    scoped_lock(const scoped_lock&) = delete;
    scoped_lock& operator=(const scoped_lock&) = delete;

private:
    Mutex& mutex_;
};

// Zero mutex specialization
template<>
class scoped_lock<> {
public:
    explicit scoped_lock() = default;
    explicit scoped_lock(adopt_lock_t) noexcept {}
    ~scoped_lock() = default;

    scoped_lock(const scoped_lock&) = delete;
    scoped_lock& operator=(const scoped_lock&) = delete;
};

/*
 * ===========================================================================
 * Generic locking algorithms
 * ===========================================================================
 */

// try_lock - Try to lock all lockables
template<class L1, class L2>
int try_lock(L1& l1, L2& l2) {
    if (!l1.try_lock()) return 0;
    if (!l2.try_lock()) {
        l1.unlock();
        return 1;
    }
    return -1;  // Success
}

template<class L1, class L2, class L3, class... Ln>
int try_lock(L1& l1, L2& l2, L3& l3, Ln&... ln) {
    if (!l1.try_lock()) return 0;
    int result = try_lock(l2, l3, ln...);
    if (result != -1) {
        l1.unlock();
        return result + 1;
    }
    return -1;
}

// lock - Lock all lockables (deadlock avoidance)
template<class L1, class L2>
void lock(L1& l1, L2& l2) {
    while (true) {
        l1.lock();
        if (l2.try_lock()) return;
        l1.unlock();

        l2.lock();
        if (l1.try_lock()) return;
        l2.unlock();
    }
}

template<class L1, class L2, class L3, class... Ln>
void lock(L1& l1, L2& l2, L3& l3, Ln&... ln) {
    while (true) {
        l1.lock();
        if (try_lock(l2, l3, ln...) == -1) return;
        l1.unlock();
    }
}

/*
 * ===========================================================================
 * Call once
 * ===========================================================================
 */

struct once_flag {
    constexpr once_flag() noexcept : called_(false) {}

    once_flag(const once_flag&) = delete;
    once_flag& operator=(const once_flag&) = delete;

private:
    template<class Callable, class... Args>
    friend void call_once(once_flag&, Callable&&, Args&&...);

    bool called_;
};

template<class Callable, class... Args>
void call_once(once_flag& flag, Callable&& f, Args&&... args) {
    if (!flag.called_) {
        flag.called_ = true;
        forward<Callable>(f)(forward<Args>(args)...);
    }
}

} // namespace std

#endif // _VIPER_MUTEX
