// -*- C++ -*-
/*
 * ViperOS C++ Standard Library - bit
 * C++20 bit manipulation library
 */

#ifndef _VIPER_BIT
#define _VIPER_BIT

#include "type_traits"
#include "limits"
#include "cstdint"

namespace std {

/*
 * ===========================================================================
 * endian - Byte order detection (C++20)
 * ===========================================================================
 */

enum class endian {
#if defined(__ORDER_LITTLE_ENDIAN__) && defined(__ORDER_BIG_ENDIAN__) && defined(__BYTE_ORDER__)
    little = __ORDER_LITTLE_ENDIAN__,
    big    = __ORDER_BIG_ENDIAN__,
    native = __BYTE_ORDER__
#else
    // Default to little-endian (most common)
    little = 0,
    big    = 1,
    native = 0
#endif
};

/*
 * ===========================================================================
 * bit_cast - Type-punning cast (C++20)
 * ===========================================================================
 */

template<class To, class From>
constexpr To bit_cast(const From& from) noexcept {
    static_assert(sizeof(To) == sizeof(From),
        "bit_cast requires types of equal size");
    static_assert(is_trivially_copyable_v<To>,
        "bit_cast requires trivially copyable destination");
    static_assert(is_trivially_copyable_v<From>,
        "bit_cast requires trivially copyable source");

    To to;
    __builtin_memcpy(&to, &from, sizeof(To));
    return to;
}

/*
 * ===========================================================================
 * Bit manipulation functions (C++20)
 * ===========================================================================
 */

// Helper: Check if T is unsigned integral
template<class T>
inline constexpr bool __is_unsigned_integer =
    is_unsigned_v<T> && is_integral_v<T> && !is_same_v<T, bool>;

// has_single_bit - Check if exactly one bit is set (power of 2)
template<class T>
constexpr enable_if_t<__is_unsigned_integer<T>, bool>
has_single_bit(T x) noexcept {
    return x != 0 && (x & (x - 1)) == 0;
}

// bit_ceil - Smallest power of 2 >= x
template<class T>
constexpr enable_if_t<__is_unsigned_integer<T>, T>
bit_ceil(T x) noexcept {
    if (x <= 1) return 1;
    if constexpr (sizeof(T) <= sizeof(unsigned)) {
        return T(1) << (numeric_limits<unsigned>::digits -
                        __builtin_clz(x - 1));
    } else if constexpr (sizeof(T) <= sizeof(unsigned long)) {
        return T(1) << (numeric_limits<unsigned long>::digits -
                        __builtin_clzl(x - 1));
    } else {
        return T(1) << (numeric_limits<unsigned long long>::digits -
                        __builtin_clzll(x - 1));
    }
}

// bit_floor - Largest power of 2 <= x
template<class T>
constexpr enable_if_t<__is_unsigned_integer<T>, T>
bit_floor(T x) noexcept {
    if (x == 0) return 0;
    return T(1) << (bit_width(x) - 1);
}

// bit_width - Number of bits needed to represent x
template<class T>
constexpr enable_if_t<__is_unsigned_integer<T>, int>
bit_width(T x) noexcept {
    if (x == 0) return 0;
    return numeric_limits<T>::digits - countl_zero(x);
}

// rotl - Rotate left
template<class T>
[[nodiscard]] constexpr enable_if_t<__is_unsigned_integer<T>, T>
rotl(T x, int s) noexcept {
    constexpr int N = numeric_limits<T>::digits;
    int r = s % N;
    if (r == 0) return x;
    if (r < 0) return rotr(x, -r);
    return (x << r) | (x >> (N - r));
}

// rotr - Rotate right
template<class T>
[[nodiscard]] constexpr enable_if_t<__is_unsigned_integer<T>, T>
rotr(T x, int s) noexcept {
    constexpr int N = numeric_limits<T>::digits;
    int r = s % N;
    if (r == 0) return x;
    if (r < 0) return rotl(x, -r);
    return (x >> r) | (x << (N - r));
}

// countl_zero - Count leading zeros
template<class T>
constexpr enable_if_t<__is_unsigned_integer<T>, int>
countl_zero(T x) noexcept {
    if (x == 0) return numeric_limits<T>::digits;

    if constexpr (sizeof(T) <= sizeof(unsigned)) {
        return __builtin_clz(x) -
               (numeric_limits<unsigned>::digits - numeric_limits<T>::digits);
    } else if constexpr (sizeof(T) <= sizeof(unsigned long)) {
        return __builtin_clzl(x) -
               (numeric_limits<unsigned long>::digits - numeric_limits<T>::digits);
    } else {
        return __builtin_clzll(x) -
               (numeric_limits<unsigned long long>::digits - numeric_limits<T>::digits);
    }
}

// countl_one - Count leading ones
template<class T>
constexpr enable_if_t<__is_unsigned_integer<T>, int>
countl_one(T x) noexcept {
    return countl_zero(T(~x));
}

// countr_zero - Count trailing zeros
template<class T>
constexpr enable_if_t<__is_unsigned_integer<T>, int>
countr_zero(T x) noexcept {
    if (x == 0) return numeric_limits<T>::digits;

    if constexpr (sizeof(T) <= sizeof(unsigned)) {
        return __builtin_ctz(x);
    } else if constexpr (sizeof(T) <= sizeof(unsigned long)) {
        return __builtin_ctzl(x);
    } else {
        return __builtin_ctzll(x);
    }
}

// countr_one - Count trailing ones
template<class T>
constexpr enable_if_t<__is_unsigned_integer<T>, int>
countr_one(T x) noexcept {
    return countr_zero(T(~x));
}

// popcount - Count set bits
template<class T>
constexpr enable_if_t<__is_unsigned_integer<T>, int>
popcount(T x) noexcept {
    if constexpr (sizeof(T) <= sizeof(unsigned)) {
        return __builtin_popcount(x);
    } else if constexpr (sizeof(T) <= sizeof(unsigned long)) {
        return __builtin_popcountl(x);
    } else {
        return __builtin_popcountll(x);
    }
}

/*
 * ===========================================================================
 * byteswap - Byte reversal (C++23, but useful)
 * ===========================================================================
 */

template<class T>
constexpr enable_if_t<is_integral_v<T>, T>
byteswap(T x) noexcept {
    if constexpr (sizeof(T) == 1) {
        return x;
    } else if constexpr (sizeof(T) == 2) {
        return __builtin_bswap16(x);
    } else if constexpr (sizeof(T) == 4) {
        return __builtin_bswap32(x);
    } else if constexpr (sizeof(T) == 8) {
        return __builtin_bswap64(x);
    } else {
        // Manual byte swap for other sizes
        T result = 0;
        for (size_t i = 0; i < sizeof(T); ++i) {
            result = (result << 8) | ((x >> (i * 8)) & 0xFF);
        }
        return result;
    }
}

} // namespace std

#endif // _VIPER_BIT
