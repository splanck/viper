// -*- C++ -*-
/*
 * ViperOS C++ Standard Library - thread
 * Thread support library
 */

#ifndef _VIPER_THREAD
#define _VIPER_THREAD

#include "chrono"
#include "functional"
#include "memory"
#include "type_traits"
#include "utility"

namespace std
{

/*
 * ===========================================================================
 * thread - Represents a single thread of execution
 *
 * ViperOS stub implementation - single-threaded environment.
 * Creating a thread is not supported (throws system_error equivalent).
 * ===========================================================================
 */

class thread
{
  public:
    class id
    {
      public:
        id() noexcept : id_(0) {}

        explicit id(unsigned long i) noexcept : id_(i) {}

        bool operator==(const id &other) const noexcept
        {
            return id_ == other.id_;
        }

        bool operator!=(const id &other) const noexcept
        {
            return id_ != other.id_;
        }

        bool operator<(const id &other) const noexcept
        {
            return id_ < other.id_;
        }

        bool operator<=(const id &other) const noexcept
        {
            return id_ <= other.id_;
        }

        bool operator>(const id &other) const noexcept
        {
            return id_ > other.id_;
        }

        bool operator>=(const id &other) const noexcept
        {
            return id_ >= other.id_;
        }

      private:
        unsigned long id_;

        template <class CharT, class Traits>
        friend basic_ostream<CharT, Traits> &operator<<(basic_ostream<CharT, Traits> &os,
                                                        id id_val);

        friend struct hash<id>;
    };

    using native_handle_type = void *;

    // Constructors
    thread() noexcept : id_() {}

    // Thread creation not supported - will abort
    template <class F, class... Args> explicit thread(F &&f, Args &&...args)
    {
        (void)f;
        // Suppress unused parameter warnings
        int dummy[] = {0, ((void)args, 0)...};
        (void)dummy;

        // Cannot create threads in ViperOS
        // In a real implementation, this would throw system_error
        // For now, we just don't start a thread
    }

    ~thread()
    {
        // If joinable, would normally call std::terminate()
    }

    thread(const thread &) = delete;
    thread &operator=(const thread &) = delete;

    thread(thread &&other) noexcept : id_(other.id_)
    {
        other.id_ = id();
    }

    thread &operator=(thread &&other) noexcept
    {
        if (joinable())
        {
            // Would normally call std::terminate()
        }
        id_ = other.id_;
        other.id_ = id();
        return *this;
    }

    // Observers
    bool joinable() const noexcept
    {
        return id_ != id();
    }

    id get_id() const noexcept
    {
        return id_;
    }

    native_handle_type native_handle()
    {
        return nullptr;
    }

    static unsigned int hardware_concurrency() noexcept
    {
        // Single CPU in ViperOS
        return 1;
    }

    // Operations
    void join()
    {
        // Not joinable in stub implementation
        id_ = id();
    }

    void detach()
    {
        // Not joinable in stub implementation
        id_ = id();
    }

    void swap(thread &other) noexcept
    {
        id tmp = id_;
        id_ = other.id_;
        other.id_ = tmp;
    }

  private:
    id id_;
};

inline void swap(thread &a, thread &b) noexcept
{
    a.swap(b);
}

/*
 * ===========================================================================
 * this_thread namespace
 * ===========================================================================
 */

namespace this_thread
{

inline thread::id get_id() noexcept
{
    // Main thread is always thread 1
    return thread::id(1);
}

inline void yield() noexcept
{
    // No other threads to yield to
}

template <class Rep, class Period>
void sleep_for(const chrono::duration<Rep, Period> &sleep_duration)
{
    // Convert to nanoseconds for syscall
    auto ns = chrono::duration_cast<chrono::nanoseconds>(sleep_duration);
    if (ns.count() <= 0)
        return;

    // ViperOS nanosleep syscall would go here
    // For now, busy wait (not ideal)
    (void)ns;
}

template <class Clock, class Duration>
void sleep_until(const chrono::time_point<Clock, Duration> &sleep_time)
{
    auto now = Clock::now();
    if (sleep_time > now)
    {
        sleep_for(sleep_time - now);
    }
}

} // namespace this_thread

/*
 * ===========================================================================
 * Hash specialization for thread::id
 * ===========================================================================
 */

template <> struct hash<thread::id>
{
    size_t operator()(thread::id id) const noexcept
    {
        return hash<unsigned long>()(id.id_);
    }
};

} // namespace std

#endif // _VIPER_THREAD
