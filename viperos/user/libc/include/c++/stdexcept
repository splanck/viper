// -*- C++ -*-
// ViperOS C++ Standard Library - stdexcept
// Standard exception classes

#ifndef _VIPER_STDEXCEPT
#define _VIPER_STDEXCEPT

#include "exception"
#include "string"

namespace std
{

// =============================================================================
// logic_error - Logic error exception hierarchy
// =============================================================================

class logic_error : public exception
{
  private:
    string what_msg_;

  public:
    explicit logic_error(const string &what_arg) : what_msg_(what_arg) {}

    explicit logic_error(const char *what_arg) : what_msg_(what_arg) {}

    logic_error(const logic_error &other) noexcept : what_msg_(other.what_msg_) {}

    logic_error &operator=(const logic_error &other) noexcept
    {
        what_msg_ = other.what_msg_;
        return *this;
    }

    const char *what() const noexcept override
    {
        return what_msg_.c_str();
    }
};

class domain_error : public logic_error
{
  public:
    explicit domain_error(const string &what_arg) : logic_error(what_arg) {}

    explicit domain_error(const char *what_arg) : logic_error(what_arg) {}
};

class invalid_argument : public logic_error
{
  public:
    explicit invalid_argument(const string &what_arg) : logic_error(what_arg) {}

    explicit invalid_argument(const char *what_arg) : logic_error(what_arg) {}
};

class length_error : public logic_error
{
  public:
    explicit length_error(const string &what_arg) : logic_error(what_arg) {}

    explicit length_error(const char *what_arg) : logic_error(what_arg) {}
};

class out_of_range : public logic_error
{
  public:
    explicit out_of_range(const string &what_arg) : logic_error(what_arg) {}

    explicit out_of_range(const char *what_arg) : logic_error(what_arg) {}
};

// =============================================================================
// runtime_error - Runtime error exception hierarchy
// =============================================================================

class runtime_error : public exception
{
  private:
    string what_msg_;

  public:
    explicit runtime_error(const string &what_arg) : what_msg_(what_arg) {}

    explicit runtime_error(const char *what_arg) : what_msg_(what_arg) {}

    runtime_error(const runtime_error &other) noexcept : what_msg_(other.what_msg_) {}

    runtime_error &operator=(const runtime_error &other) noexcept
    {
        what_msg_ = other.what_msg_;
        return *this;
    }

    const char *what() const noexcept override
    {
        return what_msg_.c_str();
    }
};

class range_error : public runtime_error
{
  public:
    explicit range_error(const string &what_arg) : runtime_error(what_arg) {}

    explicit range_error(const char *what_arg) : runtime_error(what_arg) {}
};

class overflow_error : public runtime_error
{
  public:
    explicit overflow_error(const string &what_arg) : runtime_error(what_arg) {}

    explicit overflow_error(const char *what_arg) : runtime_error(what_arg) {}
};

class underflow_error : public runtime_error
{
  public:
    explicit underflow_error(const string &what_arg) : runtime_error(what_arg) {}

    explicit underflow_error(const char *what_arg) : runtime_error(what_arg) {}
};

// =============================================================================
// system_error hierarchy (partial)
// =============================================================================

// error_category - base class for error categories
class error_category
{
  public:
    constexpr error_category() noexcept = default;

    virtual ~error_category() noexcept {}

    error_category(const error_category &) = delete;
    error_category &operator=(const error_category &) = delete;

    virtual const char *name() const noexcept = 0;
    virtual string message(int ev) const = 0;

    bool operator==(const error_category &rhs) const noexcept
    {
        return this == &rhs;
    }

    bool operator!=(const error_category &rhs) const noexcept
    {
        return this != &rhs;
    }

    bool operator<(const error_category &rhs) const noexcept
    {
        return this < &rhs;
    }
};

// Generic error category
class generic_category_impl : public error_category
{
  public:
    const char *name() const noexcept override
    {
        return "generic";
    }

    string message(int ev) const override
    {
        // Could map errno values to messages
        (void)ev;
        return "generic error";
    }
};

inline const error_category &generic_category() noexcept
{
    static generic_category_impl instance;
    return instance;
}

// System error category
class system_category_impl : public error_category
{
  public:
    const char *name() const noexcept override
    {
        return "system";
    }

    string message(int ev) const override
    {
        (void)ev;
        return "system error";
    }
};

inline const error_category &system_category() noexcept
{
    static system_category_impl instance;
    return instance;
}

// error_code - portable error code
class error_code
{
  private:
    int value_;
    const error_category *category_;

  public:
    error_code() noexcept : value_(0), category_(&system_category()) {}

    error_code(int val, const error_category &cat) noexcept : value_(val), category_(&cat) {}

    template <typename ErrorCodeEnum> error_code(ErrorCodeEnum e) noexcept;

    void assign(int val, const error_category &cat) noexcept
    {
        value_ = val;
        category_ = &cat;
    }

    void clear() noexcept
    {
        value_ = 0;
        category_ = &system_category();
    }

    int value() const noexcept
    {
        return value_;
    }

    const error_category &category() const noexcept
    {
        return *category_;
    }

    string message() const
    {
        return category_->message(value_);
    }

    explicit operator bool() const noexcept
    {
        return value_ != 0;
    }
};

inline bool operator==(const error_code &lhs, const error_code &rhs) noexcept
{
    return lhs.category() == rhs.category() && lhs.value() == rhs.value();
}

inline bool operator!=(const error_code &lhs, const error_code &rhs) noexcept
{
    return !(lhs == rhs);
}

inline bool operator<(const error_code &lhs, const error_code &rhs) noexcept
{
    return lhs.category() < rhs.category() ||
           (lhs.category() == rhs.category() && lhs.value() < rhs.value());
}

// error_condition - portable error condition
class error_condition
{
  private:
    int value_;
    const error_category *category_;

  public:
    error_condition() noexcept : value_(0), category_(&generic_category()) {}

    error_condition(int val, const error_category &cat) noexcept : value_(val), category_(&cat) {}

    void assign(int val, const error_category &cat) noexcept
    {
        value_ = val;
        category_ = &cat;
    }

    void clear() noexcept
    {
        value_ = 0;
        category_ = &generic_category();
    }

    int value() const noexcept
    {
        return value_;
    }

    const error_category &category() const noexcept
    {
        return *category_;
    }

    string message() const
    {
        return category_->message(value_);
    }

    explicit operator bool() const noexcept
    {
        return value_ != 0;
    }
};

inline bool operator==(const error_condition &lhs, const error_condition &rhs) noexcept
{
    return lhs.category() == rhs.category() && lhs.value() == rhs.value();
}

inline bool operator!=(const error_condition &lhs, const error_condition &rhs) noexcept
{
    return !(lhs == rhs);
}

// system_error exception
class system_error : public runtime_error
{
  private:
    error_code code_;

  public:
    system_error(error_code ec, const string &what_arg)
        : runtime_error(what_arg + ": " + ec.message()), code_(ec)
    {
    }

    system_error(error_code ec, const char *what_arg)
        : runtime_error(string(what_arg) + ": " + ec.message()), code_(ec)
    {
    }

    system_error(error_code ec) : runtime_error(ec.message()), code_(ec) {}

    system_error(int ev, const error_category &ecat, const string &what_arg)
        : runtime_error(what_arg + ": " + ecat.message(ev)), code_(ev, ecat)
    {
    }

    system_error(int ev, const error_category &ecat, const char *what_arg)
        : runtime_error(string(what_arg) + ": " + ecat.message(ev)), code_(ev, ecat)
    {
    }

    system_error(int ev, const error_category &ecat)
        : runtime_error(ecat.message(ev)), code_(ev, ecat)
    {
    }

    const error_code &code() const noexcept
    {
        return code_;
    }
};

// =============================================================================
// Additional common exceptions
// =============================================================================

// bad_alloc - allocation failure
class bad_alloc : public exception
{
  public:
    bad_alloc() noexcept {}

    const char *what() const noexcept override
    {
        return "std::bad_alloc";
    }
};

// bad_array_new_length - invalid array length
class bad_array_new_length : public bad_alloc
{
  public:
    bad_array_new_length() noexcept {}

    const char *what() const noexcept override
    {
        return "std::bad_array_new_length";
    }
};

// bad_cast - dynamic_cast failure
class bad_cast : public exception
{
  public:
    bad_cast() noexcept {}

    const char *what() const noexcept override
    {
        return "std::bad_cast";
    }
};

// bad_typeid - typeid on null pointer
class bad_typeid : public exception
{
  public:
    bad_typeid() noexcept {}

    const char *what() const noexcept override
    {
        return "std::bad_typeid";
    }
};

// bad_function_call - calling empty function<>
class bad_function_call : public exception
{
  public:
    bad_function_call() noexcept {}

    const char *what() const noexcept override
    {
        return "std::bad_function_call";
    }
};

// bad_weak_ptr - creating shared_ptr from expired weak_ptr
class bad_weak_ptr : public exception
{
  public:
    bad_weak_ptr() noexcept {}

    const char *what() const noexcept override
    {
        return "std::bad_weak_ptr";
    }
};

// bad_optional_access - accessing empty optional
class bad_optional_access : public exception
{
  public:
    bad_optional_access() noexcept {}

    const char *what() const noexcept override
    {
        return "std::bad_optional_access";
    }
};

} // namespace std

#endif // _VIPER_STDEXCEPT
