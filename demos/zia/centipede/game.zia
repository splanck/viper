// =============================================================================
// CENTIPEDE - Game Controller
// =============================================================================
// Main game loop, state management, and rendering coordination
// Uses Canvas for all rendering
// =============================================================================

module game;

bind "./config";
bind "./utils";
bind "./mushroom";
bind "./player";
bind "./centipede";
bind "./spider";
bind "./flea";
bind "./scorpion";
bind "./particle";
bind "./popup";

bind Viper.Game;
bind Viper.Graphics;
bind Viper.Random;
bind Viper.Time;
bind Viper.Fmt;

// =============================================================================
// GAME ENTITY - Main game controller
// =============================================================================

entity Game {
    hide Canvas canvas;
    hide Integer gameState;
    hide Integer score;
    hide Integer highScore;
    hide Integer lives;
    hide Integer level;
    hide Boolean running;

    // Game objects
    hide mushroom.MushroomField mushroomField;
    hide player.Player thePlayer;
    hide centipede.Centipede theCentipede;
    hide spider.Spider theSpider;
    hide flea.Flea theFlea;
    hide scorpion.Scorpion theScorpion;
    hide particle.ParticleSystem particles;
    hide popup.PopupManager popups;

    // Timers
    hide Timer spiderSpawnTimer;
    hide Timer fleaSpawnTimer;
    hide Timer scorpionSpawnTimer;
    hide Timer levelCompleteTimer;
    hide Timer gameOverTimer;

    // Animation
    hide Integer menuAnimFrame;
    hide Timer menuAnimTimer;

    // Score display
    hide SmoothValue displayScore;

    // Input debouncing
    hide Boolean enterWasHeld;
    hide Boolean escWasHeld;
    hide Boolean pauseWasHeld;

    expose func run() {
        // Create canvas
        canvas = Canvas.New("CENTIPEDE", config.SCREEN_WIDTH, config.SCREEN_HEIGHT);

        // Initialize game state
        gameState = config.STATE_MENU;
        score = 0;
        highScore = 10000;
        lives = config.INITIAL_LIVES;
        level = 1;
        running = true;

        // Initialize timers
        spiderSpawnTimer = Timer.New();
        fleaSpawnTimer = Timer.New();
        scorpionSpawnTimer = Timer.New();
        levelCompleteTimer = Timer.New();
        gameOverTimer = Timer.New();
        menuAnimTimer = Timer.New();
        menuAnimTimer.StartRepeating(10);
        menuAnimFrame = 0;

        // Initialize smooth score display (initial value, speed)
        displayScore = SmoothValue.New(0.0, 900.0);

        // Input debouncing
        enterWasHeld = false;
        escWasHeld = false;
        pauseWasHeld = false;

        // Main game loop
        while running {
            canvas.Poll();

            // Check for quit
            if utils.isEscapeHeld(canvas) {
                if !escWasHeld {
                    if gameState == config.STATE_PLAYING {
                        gameState = config.STATE_PAUSED;
                    } else if gameState == config.STATE_PAUSED {
                        gameState = config.STATE_MENU;
                    } else if gameState == config.STATE_MENU {
                        running = false;
                    }
                }
                escWasHeld = true;
            } else {
                escWasHeld = false;
            }

            // Update based on state
            if gameState == config.STATE_MENU {
                self.updateMenu();
                self.drawMenu();
            } else if gameState == config.STATE_PLAYING {
                self.updateGame();
                self.drawGame();
            } else if gameState == config.STATE_PAUSED {
                self.updatePaused();
                self.drawGame();
                self.drawPauseOverlay();
            } else if gameState == config.STATE_GAME_OVER {
                self.updateGameOver();
                self.drawGame();
                self.drawGameOverOverlay();
            } else if gameState == config.STATE_LEVEL_COMPLETE {
                self.updateLevelComplete();
                self.drawGame();
                self.drawLevelCompleteOverlay();
            }

            canvas.Flip();
            Viper.Time.SleepMs(config.FRAME_TIME);
        }

        canvas.Close();
    }

    // =========================================================================
    // MENU STATE
    // =========================================================================

    hide func updateMenu() {
        if menuAnimTimer.Update() {
            menuAnimFrame = menuAnimFrame + 1;
        }

        // Check for enter to start
        if utils.isEnterHeld(canvas) || utils.isFireHeld(canvas) {
            if !enterWasHeld {
                self.startGame();
            }
            enterWasHeld = true;
        } else {
            enterWasHeld = false;
        }
    }

    hide func drawMenu() {
        canvas.Clear(config.COLOR_BLACK);

        // Draw title
        canvas.Text(config.SCREEN_WIDTH / 2 - 72, 80, "CENTIPEDE", config.COLOR_GREEN);

        // Draw animated centipede
        var centX = 100 + (menuAnimFrame % 60) * 4;
        var centY = 200;

        // Head
        canvas.Disc(centX, centY, 10, config.COLOR_CENTIPEDE_HEAD);

        // Body segments
        for i in 0..10 {
            var segX = centX - (i + 1) * 18;
            var segY = centY + ((menuAnimFrame + i) % 2) * 4 - 2;
            canvas.Disc(segX, segY, 8, config.COLOR_CENTIPEDE_BODY);
        }

        // Draw instructions
        canvas.Text(config.SCREEN_WIDTH / 2 - 180, 350, "Press ENTER or SPACE to Start", config.COLOR_WHITE);
        canvas.Text(config.SCREEN_WIDTH / 2 - 144, 400, "Arrow Keys / WASD - Move", config.COLOR_GRAY);
        canvas.Text(config.SCREEN_WIDTH / 2 - 72, 430, "SPACE - Fire", config.COLOR_GRAY);
        canvas.Text(config.SCREEN_WIDTH / 2 - 60, 460, "ESC - Quit", config.COLOR_GRAY);

        // Draw high score
        canvas.Text(config.SCREEN_WIDTH / 2 - 84, 520, "HIGH SCORE:", config.COLOR_YELLOW);
        canvas.Text(config.SCREEN_WIDTH / 2 - 36, 550, Int(highScore), config.COLOR_WHITE);
    }

    // =========================================================================
    // GAME INITIALIZATION
    // =========================================================================

    hide func startGame() {
        score = 0;
        displayScore.SetImmediate(0.0);
        lives = config.INITIAL_LIVES;
        level = 1;

        self.initLevel();
        gameState = config.STATE_PLAYING;
    }

    hide func initLevel() {
        // Create mushroom field
        mushroomField = new mushroom.MushroomField();
        mushroomField.init();
        mushroomField.generateMushrooms(config.INITIAL_MUSHROOM_COUNT + level * 5);

        // Create player
        thePlayer = new player.Player();
        thePlayer.init();

        // Create centipede
        theCentipede = new centipede.Centipede();
        theCentipede.setup(config.INITIAL_CENTIPEDE_LENGTH + level - 1);

        // Create enemies (inactive initially)
        theSpider = new spider.Spider();
        theSpider.init();

        theFlea = new flea.Flea();
        theFlea.init();

        theScorpion = new scorpion.Scorpion();
        theScorpion.init();

        // Set spawn timers
        spiderSpawnTimer.Start(config.SPIDER_SPAWN_CHANCE);
        fleaSpawnTimer.Start(config.SPIDER_SPAWN_CHANCE * 2);
        scorpionSpawnTimer.Start(config.SCORPION_SPAWN_CHANCE);

        // Create particle system
        particles = new particle.ParticleSystem();
        particles.init();

        // Create popup manager
        popups = new popup.PopupManager();
        popups.init();
    }

    // =========================================================================
    // GAME UPDATE
    // =========================================================================

    hide func updateGame() {
        // Update smooth score display
        displayScore.Update();

        // Handle pause
        if utils.isPauseHeld(canvas) {
            if !pauseWasHeld {
                gameState = config.STATE_PAUSED;
            }
            pauseWasHeld = true;
        } else {
            pauseWasHeld = false;
        }

        // Update player
        thePlayer.update(canvas, mushroomField);

        // Update centipede
        theCentipede.update(mushroomField);

        // Check for bullet-centipede collision
        if thePlayer.isBulletActive() {
            var bulletX = thePlayer.getBulletGridX();
            var bulletY = thePlayer.getBulletGridY();

            var hitSegment = theCentipede.checkCollision(bulletX, bulletY);
            if hitSegment >= 0 {
                // Hit a centipede segment
                var isHead = theCentipede.isSegmentHead(hitSegment);
                var screenX = utils.gridToScreenX(bulletX) + config.TILE_SIZE / 2;
                var screenY = utils.gridToScreenY(bulletY) + config.TILE_SIZE / 2;
                particles.spawnCentipedeGore(screenX, screenY, isHead);
                theCentipede.killSegment(hitSegment, mushroomField);
                thePlayer.destroyBullet();

                if isHead {
                    self.addScoreWithPopup(config.SCORE_CENTIPEDE_HEAD, screenX, screenY);
                } else {
                    self.addScoreWithPopup(config.SCORE_CENTIPEDE_BODY, screenX, screenY);
                }
            }

            // Check mushroom collision
            if thePlayer.isBulletActive() {
                if mushroomField.damageMushroom(bulletX, bulletY) {
                    var screenX = utils.gridToScreenX(bulletX) + config.TILE_SIZE / 2;
                    var screenY = utils.gridToScreenY(bulletY) + config.TILE_SIZE / 2;
                    // Only spawn debris if mushroom was destroyed (health now 0)
                    if !mushroomField.hasMushroom(bulletX, bulletY) {
                        particles.spawnMushroomDebris(screenX, screenY);
                    } else {
                        particles.spawnSpark(screenX, screenY, config.COLOR_MUSHROOM_2);
                    }
                    thePlayer.destroyBullet();
                    self.addScore(config.SCORE_MUSHROOM);
                }
            }

            // Check spider collision
            if thePlayer.isBulletActive() && theSpider.isActive() {
                if theSpider.checkCollision(bulletX, bulletY) {
                    var screenX = utils.gridToScreenX(bulletX) + config.TILE_SIZE / 2;
                    var screenY = utils.gridToScreenY(bulletY) + config.TILE_SIZE / 2;
                    particles.spawnSpiderGore(screenX, screenY);
                    theSpider.kill();
                    thePlayer.destroyBullet();
                    // Score based on distance
                    var dist = utils.manhattanDistance(bulletX, bulletY, thePlayer.getGridX(), thePlayer.getGridY());
                    if dist <= 2 {
                        self.addScoreWithPopup(config.SCORE_SPIDER_CLOSE, screenX, screenY);
                    } else if dist <= 5 {
                        self.addScoreWithPopup(config.SCORE_SPIDER_MEDIUM, screenX, screenY);
                    } else {
                        self.addScoreWithPopup(config.SCORE_SPIDER_FAR, screenX, screenY);
                    }
                }
            }

            // Check flea collision
            if thePlayer.isBulletActive() && theFlea.isActive() {
                if theFlea.checkCollision(bulletX, bulletY) {
                    var screenX = utils.gridToScreenX(bulletX) + config.TILE_SIZE / 2;
                    var screenY = utils.gridToScreenY(bulletY) + config.TILE_SIZE / 2;
                    if theFlea.hit() {
                        particles.spawnFleaGore(screenX, screenY);
                        thePlayer.destroyBullet();
                        self.addScoreWithPopup(config.SCORE_FLEA, screenX, screenY);
                    } else {
                        particles.spawnSpark(screenX, screenY, config.COLOR_FLEA);
                    }
                }
            }

            // Check scorpion collision
            if thePlayer.isBulletActive() && theScorpion.isActive() {
                if theScorpion.checkCollision(bulletX, bulletY) {
                    var screenX = utils.gridToScreenX(bulletX) + config.TILE_SIZE / 2;
                    var screenY = utils.gridToScreenY(bulletY) + config.TILE_SIZE / 2;
                    particles.spawnScorpionGore(screenX, screenY);
                    theScorpion.kill();
                    thePlayer.destroyBullet();
                    self.addScoreWithPopup(config.SCORE_SCORPION, screenX, screenY);
                }
            }
        }

        // Update spider
        if theSpider.isActive() {
            theSpider.update(mushroomField);

            // Check player collision
            if theSpider.checkCollision(thePlayer.getGridX(), thePlayer.getGridY()) {
                self.playerDied();
            }
        } else {
            // Spider spawn timer
            spiderSpawnTimer.Update();
            if spiderSpawnTimer.IsExpired {
                theSpider.spawn();
                spiderSpawnTimer.Start(config.SPIDER_SPAWN_CHANCE);
            }
        }

        // Update flea
        if theFlea.isActive() {
            theFlea.update(mushroomField);
        } else {
            // Flea spawns when mushrooms in player zone are low
            var playerZoneMushrooms = mushroomField.countMushroomsInZone(config.PLAYER_ZONE_TOP, config.GRID_HEIGHT);
            if playerZoneMushrooms < config.FLEA_SPAWN_THRESHOLD {
                fleaSpawnTimer.Update();
                if fleaSpawnTimer.IsExpired {
                    theFlea.spawn();
                    fleaSpawnTimer.Start(config.SPIDER_SPAWN_CHANCE * 3);
                }
            }
        }

        // Update scorpion
        if theScorpion.isActive() {
            theScorpion.update(mushroomField);
        } else {
            scorpionSpawnTimer.Update();
            if scorpionSpawnTimer.IsExpired {
                theScorpion.spawn();
                scorpionSpawnTimer.Start(config.SCORPION_SPAWN_CHANCE);
            }
        }

        // Check centipede-player collision
        if theCentipede.checkCollision(thePlayer.getGridX(), thePlayer.getGridY()) >= 0 {
            self.playerDied();
        }

        // Check for level complete
        if theCentipede.isDefeated() {
            levelCompleteTimer.Start(120);  // 2 seconds
            gameState = config.STATE_LEVEL_COMPLETE;
        }
    }

    hide func addScore(points: Integer) {
        score = score + points;
        displayScore.Target = score * 1.0;

        // Check for extra life
        var oldLives = (score - points) / config.EXTRA_LIFE_SCORE;
        var newLives = score / config.EXTRA_LIFE_SCORE;
        if newLives > oldLives {
            lives = lives + 1;
        }

        // Update high score
        if score > highScore {
            highScore = score;
        }
    }

    hide func addScoreWithPopup(points: Integer, screenX: Integer, screenY: Integer) {
        self.addScore(points);
        popups.spawn(screenX, screenY - 10, points);
    }

    hide func playerDied() {
        // Spawn death particles
        var playerScreenX = thePlayer.getScreenX() + config.TILE_SIZE / 2;
        var playerScreenY = thePlayer.getScreenY() + config.TILE_SIZE / 2;
        particles.spawnPlayerDeath(playerScreenX, playerScreenY);

        lives = lives - 1;
        if lives <= 0 {
            gameOverTimer.Start(180);  // 3 seconds
            gameState = config.STATE_GAME_OVER;
        } else {
            // Reset player position
            thePlayer.reset();
            // Reset centipede
            theCentipede.setup(config.INITIAL_CENTIPEDE_LENGTH + level - 1);
        }
    }

    // =========================================================================
    // PAUSED STATE
    // =========================================================================

    hide func updatePaused() {
        if utils.isPauseHeld(canvas) {
            if !pauseWasHeld {
                gameState = config.STATE_PLAYING;
            }
            pauseWasHeld = true;
        } else {
            pauseWasHeld = false;
        }

        if utils.isEnterHeld(canvas) {
            if !enterWasHeld {
                gameState = config.STATE_PLAYING;
            }
            enterWasHeld = true;
        } else {
            enterWasHeld = false;
        }
    }

    hide func drawPauseOverlay() {
        // Semi-transparent overlay
        canvas.Box(config.SCREEN_WIDTH / 2 - 100, config.SCREEN_HEIGHT / 2 - 50, 200, 100, config.COLOR_DARK_GRAY);
        canvas.Text(config.SCREEN_WIDTH / 2 - 48, config.SCREEN_HEIGHT / 2 - 20, "PAUSED", config.COLOR_WHITE);
        canvas.Text(config.SCREEN_WIDTH / 2 - 96, config.SCREEN_HEIGHT / 2 + 20, "Press P or ENTER", config.COLOR_GRAY);
    }

    // =========================================================================
    // GAME OVER STATE
    // =========================================================================

    hide func updateGameOver() {
        gameOverTimer.Update();

        if gameOverTimer.IsExpired {
            if utils.isEnterHeld(canvas) || utils.isFireHeld(canvas) {
                if !enterWasHeld {
                    gameState = config.STATE_MENU;
                }
                enterWasHeld = true;
            } else {
                enterWasHeld = false;
            }

            if utils.isRestartHeld(canvas) {
                self.startGame();
            }
        }
    }

    hide func drawGameOverOverlay() {
        canvas.Box(config.SCREEN_WIDTH / 2 - 120, config.SCREEN_HEIGHT / 2 - 80, 240, 160, config.COLOR_DARK_GRAY);
        canvas.Text(config.SCREEN_WIDTH / 2 - 72, config.SCREEN_HEIGHT / 2 - 50, "GAME OVER", config.COLOR_RED);

        canvas.Text(config.SCREEN_WIDTH / 2 - 72, config.SCREEN_HEIGHT / 2 - 10, "Final Score:", config.COLOR_WHITE);
        canvas.Text(config.SCREEN_WIDTH / 2 - 36, config.SCREEN_HEIGHT / 2 + 20, Int(score), config.COLOR_YELLOW);

        if gameOverTimer.IsExpired {
            canvas.Text(config.SCREEN_WIDTH / 2 - 108, config.SCREEN_HEIGHT / 2 + 60, "Press R to Restart", config.COLOR_GRAY);
        }
    }

    // =========================================================================
    // LEVEL COMPLETE STATE
    // =========================================================================

    hide func updateLevelComplete() {
        levelCompleteTimer.Update();

        if levelCompleteTimer.IsExpired {
            level = level + 1;
            self.initLevel();
            gameState = config.STATE_PLAYING;
        }
    }

    hide func drawLevelCompleteOverlay() {
        canvas.Box(config.SCREEN_WIDTH / 2 - 120, config.SCREEN_HEIGHT / 2 - 60, 240, 120, config.COLOR_DARK_GRAY);
        canvas.Text(config.SCREEN_WIDTH / 2 - 108, config.SCREEN_HEIGHT / 2 - 30, "LEVEL COMPLETE!", config.COLOR_GREEN);

        canvas.Text(config.SCREEN_WIDTH / 2 - 48, config.SCREEN_HEIGHT / 2 + 10, "Level:", config.COLOR_WHITE);
        canvas.Text(config.SCREEN_WIDTH / 2 + 24, config.SCREEN_HEIGHT / 2 + 10, Int(level), config.COLOR_YELLOW);
    }

    // =========================================================================
    // GAME DRAWING
    // =========================================================================

    hide func drawGame() {
        canvas.Clear(config.COLOR_BACKGROUND);

        // Draw HUD
        self.drawHUD();

        // Draw mushroom field
        mushroomField.draw(canvas);

        // Draw centipede
        theCentipede.draw(canvas);

        // Draw spider
        theSpider.draw(canvas);

        // Draw flea
        theFlea.draw(canvas);

        // Draw scorpion
        theScorpion.draw(canvas);

        // Draw player and bullet
        thePlayer.draw(canvas);

        // Update and draw particles
        particles.update();
        particles.draw(canvas);

        // Update and draw score popups
        popups.update();
        popups.draw(canvas);
    }

    hide func drawHUD() {
        // Score
        canvas.Text(10, 8, "SCORE:", config.COLOR_WHITE);
        canvas.Text(80, 8, Int(displayScore.ValueI64), config.COLOR_YELLOW);

        // High score
        canvas.Text(config.SCREEN_WIDTH / 2 - 40, 8, "HI:", config.COLOR_WHITE);
        canvas.Text(config.SCREEN_WIDTH / 2, 8, Int(highScore), config.COLOR_YELLOW);

        // Lives
        canvas.Text(config.SCREEN_WIDTH - 120, 8, "LIVES:", config.COLOR_WHITE);
        for i in 0..lives {
            var lifeX = config.SCREEN_WIDTH - 50 + i * 16;
            canvas.Disc(lifeX, 12, 6, config.COLOR_PLAYER);
        }

        // Level
        canvas.Text(10, config.SCREEN_HEIGHT - 20, "LVL:", config.COLOR_WHITE);
        canvas.Text(50, config.SCREEN_HEIGHT - 20, Int(level), config.COLOR_CYAN);

        // Draw player zone boundary line
        var zoneY = config.PLAYER_ZONE_TOP * config.TILE_SIZE;
        canvas.Line(0, zoneY, config.SCREEN_WIDTH, zoneY, config.COLOR_DARK_GRAY);
    }
}

