// =============================================================================
// CENTIPEDE - Centipede Entity
// =============================================================================
// The main enemy: a segmented creature that moves across and down the screen
// When hit, it splits into two centipedes
// Uses Viper.Game.Timer for movement timing
// =============================================================================

module centipede;

bind "./config";
bind "./utils";
bind "./mushroom";

// =============================================================================
// SEGMENT ENTITY - Individual segment of the centipede
// =============================================================================

entity Segment {
    hide Integer gridX;
    hide Integer gridY;
    hide Integer screenX;
    hide Integer screenY;
    hide Integer direction;  // DIR_LEFT or DIR_RIGHT
    hide Boolean isHead;
    hide Boolean active;
    hide Integer chainId;    // Which chain this segment belongs to

    expose func init() {
        gridX = 0;
        gridY = 0;
        screenX = 0;
        screenY = 0;
        direction = config.DIR_LEFT;
        isHead = false;
        active = false;
        chainId = 0;
    }

    expose func setup(x: Integer, y: Integer, dir: Integer, head: Boolean, chain: Integer) {
        gridX = x;
        gridY = y;
        screenX = utils.gridToScreenX(x);
        screenY = utils.gridToScreenY(y);
        direction = dir;
        isHead = head;
        active = true;
        chainId = chain;
    }

    expose func isActive() -> Boolean {
        return active;
    }

    expose func kill() {
        active = false;
    }

    expose func getGridX() -> Integer {
        return gridX;
    }

    expose func getGridY() -> Integer {
        return gridY;
    }

    expose func getScreenX() -> Integer {
        return screenX;
    }

    expose func getScreenY() -> Integer {
        return screenY;
    }

    expose func getDirection() -> Integer {
        return direction;
    }

    expose func isHeadSegment() -> Boolean {
        return isHead;
    }

    expose func setHead(head: Boolean) {
        isHead = head;
    }

    expose func getChainId() -> Integer {
        return chainId;
    }

    expose func setChainId(chain: Integer) {
        chainId = chain;
    }

    expose func move(field: mushroom.MushroomField, checkPoisoned: Boolean) -> Boolean {
        if !active {
            return false;
        }

        var nextX = gridX + utils.getDirX(direction);
        var nextY = gridY;
        var needsToDescend = false;
        var hitPoisoned = false;

        // Check if we hit a wall or mushroom
        if nextX < 0 || nextX >= config.GRID_WIDTH || field.hasMushroom(nextX, nextY) {
            needsToDescend = true;
        }

        // Check if current mushroom is poisoned (only heads check this)
        if checkPoisoned && isHead && field.isPoisoned(gridX, gridY) {
            hitPoisoned = true;
        }

        if needsToDescend {
            // Move down and reverse direction
            nextX = gridX;
            nextY = gridY + 1;
            if direction == config.DIR_LEFT {
                direction = config.DIR_RIGHT;
            } else {
                direction = config.DIR_LEFT;
            }
        }

        // Update grid position
        gridX = nextX;
        gridY = nextY;

        // Animate towards new position
        screenX = utils.gridToScreenX(gridX);
        screenY = utils.gridToScreenY(gridY);

        return hitPoisoned;
    }

    expose func draw(canvas: Viper.Graphics.Canvas) {
        if !active {
            return;
        }

        var centerX = screenX + config.TILE_SIZE / 2;
        var centerY = screenY + config.TILE_SIZE / 2;
        var radius = config.TILE_SIZE / 2 - 1;

        if isHead {
            // Draw head (larger, different color)
            canvas.Disc(centerX, centerY, radius, config.COLOR_CENTIPEDE_HEAD);

            // Draw eyes
            var eyeOffset = 3;
            var eyeY = centerY - 2;
            if direction == config.DIR_LEFT {
                canvas.Disc(centerX - eyeOffset, eyeY, 2, config.COLOR_WHITE);
            } else {
                canvas.Disc(centerX + eyeOffset, eyeY, 2, config.COLOR_WHITE);
            }
        } else {
            // Draw body segment
            canvas.Disc(centerX, centerY, radius - 1, config.COLOR_CENTIPEDE_BODY);
        }
    }
}

// =============================================================================
// CENTIPEDE ENTITY - Collection of segments
// =============================================================================

entity Centipede {
    hide List[Segment] segments;
    hide Viper.Game.Timer moveTimer;
    hide Integer moveDelay;
    hide Integer nextChainId;

    expose func init() {
        segments = [];
        moveTimer = Viper.Game.Timer.New();
        moveDelay = config.CENTIPEDE_MOVE_DELAY;
        nextChainId = 1;
    }

    expose func setup(length: Integer) {
        segments = [];
        moveTimer.StartRepeating(config.CENTIPEDE_MOVE_DELAY);
        nextChainId = 1;

        // Create segments starting from top right, moving left
        var startX = config.GRID_WIDTH - 2;
        var startY = 0;

        for i in 0..length {
            var seg = new Segment();
            seg.setup(startX + i, startY, config.DIR_LEFT, i == 0, 0);
            segments.add(seg);
        }
    }

    expose func update(field: mushroom.MushroomField) {
        if moveTimer.Update() {
            self.moveAll(field);
        }
    }

    hide func moveAll(field: mushroom.MushroomField) {
        // Process segments in order, heads first
        for seg in segments {
            if seg.isActive() && seg.isHeadSegment() {
                var hitPoisoned = seg.move(field, true);

                // If hit poisoned mushroom, dive to bottom
                if hitPoisoned {
                    self.diveTobottom(seg);
                }
            }
        }

        // Then move body segments (they follow their chain's head)
        for seg in segments {
            if seg.isActive() && !seg.isHeadSegment() {
                seg.move(field, false);
            }
        }
    }

    hide func diveTobottom(headSeg: Segment) {
        // Make the centipede dive straight down when hitting poisoned mushroom
        // This is simplified - just move down quickly
        var chainId = headSeg.getChainId();
        for seg in segments {
            if seg.isActive() && seg.getChainId() == chainId {
                // Force downward movement until bottom
                var y = seg.getGridY();
                if y < config.GRID_HEIGHT - 2 {
                    // Move down by one for now (will continue on next updates)
                }
            }
        }
    }

    expose func checkCollision(gridX: Integer, gridY: Integer) -> Integer {
        var idx = 0;
        for seg in segments {
            if seg.isActive() {
                if seg.getGridX() == gridX && seg.getGridY() == gridY {
                    return idx;
                }
            }
            idx = idx + 1;
        }
        return -1;
    }

    expose func isSegmentHead(index: Integer) -> Boolean {
        if index >= 0 && index < segments.size() {
            var seg = segments.get(index);
            return seg.isHeadSegment();
        }
        return false;
    }

    expose func killSegment(index: Integer, field: mushroom.MushroomField) {
        if index < 0 || index >= segments.size() {
            return;
        }

        var seg = segments.get(index);
        if !seg.isActive() {
            return;
        }

        // Create mushroom where segment died
        field.createMushroom(seg.getGridX(), seg.getGridY());

        // Kill the segment
        seg.kill();

        // If this was a head, the next segment in the chain becomes a head
        if seg.isHeadSegment() {
            var chainId = seg.getChainId();
            // Find the next segment in the same chain
            var found = false;
            for otherSeg in segments {
                if found && otherSeg.isActive() && otherSeg.getChainId() == chainId {
                    otherSeg.setHead(true);
                    break;
                }
                if otherSeg == seg {
                    found = true;
                }
            }
        } else {
            // If this was a body segment, the segment behind it becomes a new head
            // (splitting the centipede)
            var found = false;
            var oldChainId = seg.getChainId();
            for otherSeg in segments {
                if found && otherSeg.isActive() && otherSeg.getChainId() == oldChainId {
                    // Make this segment a new head with new chain
                    otherSeg.setHead(true);
                    otherSeg.setChainId(nextChainId);

                    // Update all following segments in the old chain
                    var updateChain = false;
                    for updateSeg in segments {
                        if updateSeg == otherSeg {
                            updateChain = true;
                        } else if updateChain && updateSeg.isActive() && updateSeg.getChainId() == oldChainId {
                            updateSeg.setChainId(nextChainId);
                        }
                    }

                    nextChainId = nextChainId + 1;
                    break;
                }
                if otherSeg == seg {
                    found = true;
                }
            }
        }
    }

    expose func isDefeated() -> Boolean {
        for seg in segments {
            if seg.isActive() {
                return false;
            }
        }
        return true;
    }

    expose func getActiveCount() -> Integer {
        var count = 0;
        for seg in segments {
            if seg.isActive() {
                count = count + 1;
            }
        }
        return count;
    }

    expose func draw(canvas: Viper.Graphics.Canvas) {
        // Draw body segments first, then heads (so heads appear on top)
        for seg in segments {
            if seg.isActive() && !seg.isHeadSegment() {
                seg.draw(canvas);
            }
        }
        for seg in segments {
            if seg.isActive() && seg.isHeadSegment() {
                seg.draw(canvas);
            }
        }
    }
}

