// Viper Web Server - A multithreaded HTTP server written in Zia
module main;

bind "./config";
bind "./logger";
bind "./threadpool";
bind "./router";

bind Viper.Terminal;
bind Viper.String;
bind Viper.Network;
bind Viper.IO;
bind Viper.Time;
bind Viper.Fmt;

// ============================================================================
// CONFIGURATION
// ============================================================================

final MAX_REQUEST_SIZE = 8192;
final VERSION = "0.7.1";

// Web root directory (relative to server location)
var webRoot: String;

// ============================================================================
// DYNAMIC ROUTE HANDLERS
// ============================================================================

// Handler for /api/status - returns server status as JSON
func handleApiStatus(path: String, query: String) -> String {
    var body = "{";
    body = body + "\"server\": \"Viper Web Server\",";
    body = body + "\"version\": \"" + VERSION + "\",";
    body = body + "\"status\": \"running\",";
    body = body + "\"workers\": " + Fmt.Int(cfg_workers);
    body = body + "}";

    return buildResponse(200, "OK", "application/json", body);
}

// Handler for /api/echo - echoes query parameters
func handleApiEcho(path: String, query: String) -> String {
    var message = router_getQueryParam(query, "message");
    if message == "" {
        message = "Hello from Viper!";
    }

    var body = "{\"echo\": \"" + message + "\"}";
    return buildResponse(200, "OK", "application/json", body);
}

// Handler for /api/time - returns current server time
func handleApiTime(path: String, query: String) -> String {
    var now = Time.DateTime.Now();
    var year = Time.DateTime.Year(now);
    var month = Time.DateTime.Month(now);
    var day = Time.DateTime.Day(now);
    var hour = Time.DateTime.Hour(now);
    var minute = Time.DateTime.Minute(now);
    var second = Time.DateTime.Second(now);

    var body = "{";
    body = body + "\"year\": " + Fmt.Int(year) + ",";
    body = body + "\"month\": " + Fmt.Int(month) + ",";
    body = body + "\"day\": " + Fmt.Int(day) + ",";
    body = body + "\"hour\": " + Fmt.Int(hour) + ",";
    body = body + "\"minute\": " + Fmt.Int(minute) + ",";
    body = body + "\"second\": " + Fmt.Int(second);
    body = body + "}";

    return buildResponse(200, "OK", "application/json", body);
}

// Dispatch to appropriate handler based on route ID
func dispatchRoute(routeId: Integer, path: String, query: String) -> String {
    if routeId == ROUTE_ID_STATUS {
        return handleApiStatus(path, query);
    }
    if routeId == ROUTE_ID_ECHO {
        return handleApiEcho(path, query);
    }
    if routeId == ROUTE_ID_TIME {
        return handleApiTime(path, query);
    }
    // Unknown route - return 404
    return response404();
}

// Register all API routes
func registerRoutes() {
    router_init();
    // Routes are defined directly in router.zia router_findRoute()
}

// ============================================================================
// HTTP REQUEST PARSING
// ============================================================================

// Parse HTTP request line to extract method, path, and version
// Returns true if parsing succeeded
func parseRequestLine(line: String, method: String, path: String, version: String) -> Boolean {
    // Find first space (after method)
    var len = String.Length(line);
    var i = 0;
    var firstSpace = -1;
    var secondSpace = -1;

    while i < len {
        var ch = String.Substring(line, i, 1);
        if ch == " " {
            if firstSpace == -1 {
                firstSpace = i;
            } else {
                secondSpace = i;
                break;
            }
        }
        i = i + 1;
    }

    if firstSpace == -1 || secondSpace == -1 {
        return false;
    }

    // Extract parts
    method = String.Substring(line, 0, firstSpace);
    var pathLen = secondSpace - firstSpace - 1;
    path = String.Substring(line, firstSpace + 1, pathLen);
    var versionLen = len - secondSpace - 1;
    version = String.Substring(line, secondSpace + 1, versionLen);

    return true;
}

// ============================================================================
// THREAD-SAFE REQUEST PARSING
// ============================================================================
// These functions are pure - they return values instead of modifying shared
// state, making them safe for concurrent use by multiple worker threads.

// Find the end of the first line (request line)
func findLineEnd(rawRequest: String) -> Integer {
    var len = String.Length(rawRequest);
    var i = 0;
    while i < len {
        var ch = String.Substring(rawRequest, i, 1);
        if ch == "\r" || ch == "\n" {
            return i;
        }
        i = i + 1;
    }
    return len;
}

// Extract HTTP method from raw request (GET, POST, HEAD, etc.)
// Returns empty string if parsing fails
func extractMethod(rawRequest: String) -> String {
    var lineEnd = findLineEnd(rawRequest);
    if lineEnd == 0 {
        return "";
    }

    // Find first space
    var i = 0;
    while i < lineEnd {
        var ch = String.Substring(rawRequest, i, 1);
        if ch == " " {
            if i > 0 {
                return String.Substring(rawRequest, 0, i);
            }
            return "";
        }
        i = i + 1;
    }

    return "";
}

// Extract request path from raw request
// Returns empty string if parsing fails
func extractRequestPath(rawRequest: String) -> String {
    var lineEnd = findLineEnd(rawRequest);
    if lineEnd == 0 {
        return "";
    }

    // Find first space (after method)
    var firstSpace = -1;
    var i = 0;
    while i < lineEnd {
        var ch = String.Substring(rawRequest, i, 1);
        if ch == " " {
            firstSpace = i;
            break;
        }
        i = i + 1;
    }

    if firstSpace == -1 {
        return "";
    }

    // Find second space (before HTTP version) or end of line
    var secondSpace = lineEnd;
    i = firstSpace + 1;
    while i < lineEnd {
        var ch = String.Substring(rawRequest, i, 1);
        if ch == " " {
            secondSpace = i;
            break;
        }
        i = i + 1;
    }

    var pathLen = secondSpace - firstSpace - 1;
    if pathLen <= 0 {
        return "";
    }

    return String.Substring(rawRequest, firstSpace + 1, pathLen);
}

// Validate that a raw request is parseable
func isValidRequest(rawRequest: String) -> Boolean {
    var method = extractMethod(rawRequest);
    var path = extractRequestPath(rawRequest);
    return method != "" && path != "";
}

// ============================================================================
// HTTP RESPONSE BUILDING
// ============================================================================

// Build response with optional Last-Modified header and optional body inclusion
func buildResponseFull(statusCode: Integer, statusText: String, contentType: String,
                       body: String, lastModified: Integer, includeBody: Boolean) -> String {
    var bodyLen = String.Length(body);

    var response = "HTTP/1.1 ";
    response = response + Fmt.Int(statusCode);
    response = response + " ";
    response = response + statusText;
    response = response + "\r\n";
    response = response + "Content-Type: ";
    response = response + contentType;
    response = response + "\r\n";
    response = response + "Content-Length: ";
    response = response + Fmt.Int(bodyLen);
    response = response + "\r\n";

    // Add Last-Modified header if provided
    if lastModified > 0 {
        response = response + "Last-Modified: ";
        response = response + formatHttpDate(lastModified);
        response = response + "\r\n";
    }

    response = response + "Connection: close\r\n";
    response = response + "Server: Viper/";
    response = response + VERSION;
    response = response + "\r\n";
    response = response + "\r\n";

    // Only include body for non-HEAD requests
    if includeBody {
        response = response + body;
    }

    return response;
}

func buildResponse(statusCode: Integer, statusText: String, contentType: String, body: String) -> String {
    return buildResponseFull(statusCode, statusText, contentType, body, 0, true);
}

// Format HTTP date from Unix timestamp (simplified - just timestamp for now)
// Full HTTP date format: "Sun, 06 Nov 1994 08:49:37 GMT"
func formatHttpDate(timestamp: Integer) -> String {
    // For now, return Unix timestamp as string
    // Full date formatting would require day-of-week calculation
    return Fmt.Int(timestamp);
}

func response200(contentType: String, body: String) -> String {
    return buildResponse(200, "OK", contentType, body);
}

func response200WithMod(contentType: String, body: String, lastMod: Integer, isHead: Boolean) -> String {
    return buildResponseFull(200, "OK", contentType, body, lastMod, isHead == false);
}

func response304() -> String {
    return buildResponseFull(304, "Not Modified", "text/plain", "", 0, false);
}

func response404() -> String {
    var body = "<!DOCTYPE html><html><head><title>404 Not Found</title></head>";
    body = body + "<body><h1>404 Not Found</h1><p>The requested resource was not found.</p></body></html>";
    return buildResponse(404, "Not Found", "text/html; charset=utf-8", body);
}

func response500(message: String) -> String {
    var body = "<!DOCTYPE html><html><head><title>500 Internal Server Error</title></head>";
    body = body + "<body><h1>500 Internal Server Error</h1><p>";
    body = body + message;
    body = body + "</p></body></html>";
    return buildResponse(500, "Internal Server Error", "text/html; charset=utf-8", body);
}

func response400() -> String {
    var body = "<!DOCTYPE html><html><head><title>400 Bad Request</title></head>";
    body = body + "<body><h1>400 Bad Request</h1><p>Invalid HTTP request.</p></body></html>";
    return buildResponse(400, "Bad Request", "text/html; charset=utf-8", body);
}

// ============================================================================
// MIME TYPE DETECTION
// ============================================================================

func getMimeType(path: String) -> String {
    var len = String.Length(path);

    // Find last dot
    var dotPos = -1;
    var i = len - 1;
    while i >= 0 {
        var ch = String.Substring(path, i, 1);
        if ch == "." {
            dotPos = i;
            break;
        }
        i = i - 1;
    }

    if dotPos == -1 {
        return "application/octet-stream";
    }

    var extLen = len - dotPos;
    var ext = String.Substring(path, dotPos, extLen);

    // Check extensions
    if ext == ".html" || ext == ".htm" {
        return "text/html; charset=utf-8";
    }
    if ext == ".css" {
        return "text/css; charset=utf-8";
    }
    if ext == ".js" {
        return "application/javascript";
    }
    if ext == ".json" {
        return "application/json";
    }
    if ext == ".png" {
        return "image/png";
    }
    if ext == ".jpg" || ext == ".jpeg" {
        return "image/jpeg";
    }
    if ext == ".gif" {
        return "image/gif";
    }
    if ext == ".ico" {
        return "image/x-icon";
    }
    if ext == ".svg" {
        return "image/svg+xml";
    }
    if ext == ".txt" {
        return "text/plain; charset=utf-8";
    }
    if ext == ".xml" {
        return "application/xml";
    }

    return "application/octet-stream";
}

// ============================================================================
// PATH SECURITY
// ============================================================================

// Check if path is safe (no directory traversal)
func isPathSafe(path: String) -> Boolean {
    // Check for ".." sequences
    var len = String.Length(path);
    var i = 0;

    while i < len - 1 {
        var ch1 = String.Substring(path, i, 1);
        var ch2 = String.Substring(path, i + 1, 1);
        if ch1 == "." && ch2 == "." {
            return false;
        }
        i = i + 1;
    }

    // Check for null bytes
    i = 0;
    while i < len {
        var ch = String.Substring(path, i, 1);
        if ch == "\0" {
            return false;
        }
        i = i + 1;
    }

    return true;
}

// Normalize path (handle /)
func normalizePath(path: String) -> String {
    // If path is just "/", serve index.html
    if path == "/" {
        return "/index.html";
    }

    // Remove query string if present
    var len = String.Length(path);
    var i = 0;
    while i < len {
        var ch = String.Substring(path, i, 1);
        if ch == "?" {
            return String.Substring(path, 0, i);
        }
        i = i + 1;
    }

    return path;
}

// ============================================================================
// STATIC FILE SERVING
// ============================================================================

// Workaround for BUG-004: VM string store/load corruption
// These helper functions take the fullPath as a parameter to avoid storing
// the runtime-created string to a local variable.

func fileExists(fullPath: String) -> Boolean {
    return IO.File.Exists(fullPath);
}

func readFileContent(fullPath: String) -> String {
    return IO.File.ReadAllText(fullPath);
}

func getFileMimeType(fullPath: String) -> String {
    return getMimeType(fullPath);
}

func buildFullPath(relativePath: String) -> String {
    return IO.Path.Join(webRoot, relativePath);
}

func getFileModTime(fullPath: String) -> Integer {
    return IO.File.Modified(fullPath);
}

// Serve static file with support for HEAD requests
func serveStaticFile(path: String, isHead: Boolean) -> String {
    // Normalize and validate path
    var normalizedPath = normalizePath(path);

    if isPathSafe(normalizedPath) == false {
        return response404();
    }

    // Build relative path (remove leading /)
    var relativePath = normalizedPath;
    var pathLen = String.Length(normalizedPath);
    if pathLen > 0 {
        var firstChar = String.Substring(normalizedPath, 0, 1);
        if firstChar == "/" {
            relativePath = String.Substring(normalizedPath, 1, pathLen - 1);
        }
    }

    // Workaround for BUG-004: pass path through functions to avoid local storage
    if fileExists(buildFullPath(relativePath)) == false {
        return response404();
    }

    // Get file modification time
    var modTime = getFileModTime(buildFullPath(relativePath));

    // Read file content
    var content = readFileContent(buildFullPath(relativePath));
    var mimeType = getFileMimeType(buildFullPath(relativePath));

    return response200WithMod(mimeType, content, modTime, isHead);
}

// ============================================================================
// CLIENT HANDLING
// ============================================================================

// Extract HTTP status code from response string
// Response starts with "HTTP/1.1 XXX StatusText\r\n..."
func extractStatusCode(response: String) -> Integer {
    // Find the first space (after HTTP/1.1)
    var len = String.Length(response);
    if len < 12 {
        return 0;
    }

    // Status code starts at position 9 (after "HTTP/1.1 ")
    var codeStr = String.Substring(response, 9, 3);

    // Parse the 3-digit code manually
    var c1 = String.Substring(codeStr, 0, 1);
    var c2 = String.Substring(codeStr, 1, 1);
    var c3 = String.Substring(codeStr, 2, 1);

    var d1 = charToDigit(c1);
    var d2 = charToDigit(c2);
    var d3 = charToDigit(c3);

    if d1 < 0 || d2 < 0 || d3 < 0 {
        return 0;
    }

    return d1 * 100 + d2 * 10 + d3;
}

func handleClient(client: Ptr) {
    var startTime = log_startTimer();
    var clientHost = Network.Tcp.get_Host(client);
    var statusCode = 200;
    var responseSize = 0;

    // Set a timeout for receiving
    Network.Tcp.SetRecvTimeout(client, 5000);

    // Read request (up to MAX_REQUEST_SIZE bytes)
    var rawRequest = Network.Tcp.RecvStr(client, MAX_REQUEST_SIZE);

    var requestLen = String.Length(rawRequest);
    if requestLen == 0 {
        Network.Tcp.Close(client);
        return;
    }

    // Parse request using thread-safe pure functions (local variables only)
    var reqMethod = extractMethod(rawRequest);
    var reqPath = extractRequestPath(rawRequest);

    if reqMethod == "" || reqPath == "" {
        statusCode = 400;
        var response = response400();
        responseSize = String.Length(response);
        Network.Tcp.SendStr(client, response);
        Network.Tcp.Close(client);
        log_request(clientHost, "???", "???", statusCode, responseSize, log_elapsed(startTime));
        return;
    }

    // Only handle GET and HEAD requests
    if reqMethod != "GET" && reqMethod != "HEAD" {
        statusCode = 405;
        var response = buildResponse(405, "Method Not Allowed", "text/plain", "Method not allowed");
        responseSize = String.Length(response);
        Network.Tcp.SendStr(client, response);
        Network.Tcp.Close(client);
        log_request(clientHost, reqMethod, reqPath, statusCode, responseSize, log_elapsed(startTime));
        return;
    }

    // Determine if this is a HEAD request (headers only, no body)
    var isHead = reqMethod == "HEAD";

    var response: String;

    // Check for dynamic route first
    var routeId = router_findRoute(reqPath);
    if routeId != ROUTE_ID_NONE {
        var path = router_extractPath(reqPath);
        var query = router_extractQuery(reqPath);
        response = dispatchRoute(routeId, path, query);
    } else {
        // Fall back to static file serving
        response = serveStaticFile(reqPath, isHead);
    }
    responseSize = String.Length(response);

    // Extract status code from response (first line: "HTTP/1.1 XXX ...")
    statusCode = extractStatusCode(response);

    Network.Tcp.SendStr(client, response);
    Network.Tcp.Close(client);

    log_request(clientHost, reqMethod, reqPath, statusCode, responseSize, log_elapsed(startTime));
}

// ============================================================================
// MAIN SERVER
// ============================================================================

func main() {
    // Load configuration from file (or use defaults)
    var configPath = IO.Path.Join(IO.Dir.Current(), CFG_FILENAME);
    var configLoaded = config_load(configPath);

    // Initialize logger with configured level
    log_init(cfg_log_level);

    // Set web root (resolve relative paths)
    if String.Substring(cfg_webroot, 0, 1) == "/" {
        webRoot = cfg_webroot;
    } else {
        webRoot = IO.Path.Join(IO.Dir.Current(), cfg_webroot);
    }

    // Startup banner (always shown)
    Terminal.Say("========================================");
    Terminal.Say("  Viper Web Server v" + VERSION);
    Terminal.Say("========================================");

    if configLoaded {
        log_info("Configuration loaded from " + configPath);
    } else {
        log_info("Using default configuration (no " + CFG_FILENAME + " found)");
    }

    log_info("Port: " + Fmt.Int(cfg_port));
    log_info("Web root: " + webRoot);
    log_info("Workers: " + Fmt.Int(cfg_workers));

    // Initialize router and register API routes
    registerRoutes();
    log_info("Routes registered: " + Fmt.Int(router_getCount()) + " API endpoints");

    // Initialize thread pool with configured worker count
    pool_init(&handleClient, cfg_workers);
    log_info("Thread pool initialized");

    // Create server on configured port
    var server = Network.TcpServer.Listen(cfg_port);

    log_info("Server listening on http://localhost:" + Fmt.Int(cfg_port) + "/");
    Terminal.Say("Press Ctrl+C to stop.");
    Terminal.Say("");

    // Accept connections and dispatch to thread pool
    var running = 1;
    while running == 1 {
        // Accept a client connection
        var client = Network.TcpServer.Accept(server);

        // Submit to thread pool for handling
        pool_submit(client);
    }

    // Shutdown thread pool
    log_info("Shutting down...");
    pool_shutdown();

    Network.TcpServer.Close(server);
    log_info("Server stopped");
}
