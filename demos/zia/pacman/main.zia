// =============================================================================
// PAC-MAN CLONE - A comprehensive Zia game demonstrating OOP and graphics
// =============================================================================
//
// This is a feature-complete Pac-Man clone built incrementally with testing.
// Uses Viper.Graphics.* for all rendering and input handling.
//
// Controls:
//   Arrow Keys - Move Pac-Man
//   ESC - Quit game
//   P - Pause
//   R - Restart (after game over)
//
// =============================================================================

module PacMan;

// =============================================================================
// CONSTANTS
// =============================================================================

// Screen dimensions
final SCREEN_WIDTH = 672;    // 28 tiles * 24 pixels
final SCREEN_HEIGHT = 744;   // 31 tiles * 24 pixels

// Tile size (classic Pac-Man uses 8x8, we'll use 24x24 for visibility)
final TILE_SIZE = 24;

// Grid dimensions
final GRID_WIDTH = 28;
final GRID_HEIGHT = 31;

// Colors (0x00RRGGBB format)
final COLOR_BLACK = 0x00000000;
final COLOR_YELLOW = 0x00FFFF00;
final COLOR_WHITE = 0x00FFFFFF;
final COLOR_BLUE = 0x000000FF;
final COLOR_RED = 0x00FF0000;
final COLOR_PINK = 0x00FFB8FF;
final COLOR_CYAN = 0x0000FFFF;
final COLOR_ORANGE = 0x00FFB852;
final COLOR_WALL = 0x002121DE;
final COLOR_DOT = 0x00FFB897;
final COLOR_PELLET = 0x00FFB897;

// Key codes (from vgfx.h)
final KEY_UP = 260;
final KEY_DOWN = 261;
final KEY_LEFT = 258;
final KEY_RIGHT = 259;
final KEY_ESCAPE = 256;
final KEY_P = 80;
final KEY_R = 82;

// Game states
final STATE_PLAYING = 0;
final STATE_PAUSED = 1;
final STATE_GAME_OVER = 2;
final STATE_WIN = 3;
final STATE_READY = 4;

// Direction constants
final DIR_NONE = 0;
final DIR_UP = 1;
final DIR_DOWN = 2;
final DIR_LEFT = 3;
final DIR_RIGHT = 4;

// Ghost modes
final MODE_SCATTER = 0;
final MODE_CHASE = 1;
final MODE_FRIGHTENED = 2;
final MODE_EATEN = 3;

// Timing (in milliseconds)
final FRAME_TIME = 16;  // ~60 FPS

// Tile types
final TILE_EMPTY = 0;
final TILE_WALL = 1;
final TILE_DOT = 2;
final TILE_PELLET = 3;
final TILE_GATE = 4;

// Fruit types and their point values
final FRUIT_NONE = 0;
final FRUIT_CHERRY = 1;      // 100 points - Level 1
final FRUIT_STRAWBERRY = 2;  // 300 points - Level 2
final FRUIT_ORANGE = 3;      // 500 points - Level 3-4
final FRUIT_APPLE = 4;       // 700 points - Level 5-6
final FRUIT_MELON = 5;       // 1000 points - Level 7-8
final FRUIT_GALAXIAN = 6;    // 2000 points - Level 9-10
final FRUIT_BELL = 7;        // 3000 points - Level 11-12
final FRUIT_KEY = 8;         // 5000 points - Level 13+

// Fruit colors
final COLOR_CHERRY = 0x00FF0000;
final COLOR_STRAWBERRY = 0x00FF3366;
final COLOR_ORANGE_FRUIT = 0x00FF8800;
final COLOR_APPLE = 0x0000FF00;
final COLOR_MELON = 0x0088FF88;
final COLOR_GALAXIAN = 0x00FFFF00;
final COLOR_BELL = 0x00FFDD00;
final COLOR_KEY = 0x0000CCFF;

// Menu states
final MENU_MAIN = 0;
final MENU_PLAYING = 1;
final MENU_HIGHSCORES = 2;
final MENU_PAUSED = 3;

// =============================================================================
// UTILITY FUNCTIONS
// =============================================================================

// Convert grid position to screen position
func gridToScreenX(gridX: Integer) -> Integer {
    return gridX * TILE_SIZE;
}

func gridToScreenY(gridY: Integer) -> Integer {
    return gridY * TILE_SIZE;
}

// Convert screen position to grid position
func screenToGridX(screenX: Integer) -> Integer {
    return screenX / TILE_SIZE;
}

func screenToGridY(screenY: Integer) -> Integer {
    return screenY / TILE_SIZE;
}

// =============================================================================
// VECTOR2 - 2D Position/Velocity helper
// =============================================================================

entity Vec2 {
    expose Integer x;
    expose Integer y;

    expose func init(xVal: Integer, yVal: Integer) {
        x = xVal;
        y = yVal;
    }
}

func makeVec2(xVal: Integer, yVal: Integer) -> Vec2 {
    var v = new Vec2(xVal, yVal);
    return v;
}

func vec2Add(a: Vec2, b: Vec2) -> Vec2 {
    return makeVec2(a.x + b.x, a.y + b.y);
}

func vec2Equals(a: Vec2, b: Vec2) -> Boolean {
    return a.x == b.x and a.y == b.y;
}

// =============================================================================
// DIRECTION HELPERS
// =============================================================================

func getDirectionVector(dir: Integer) -> Vec2 {
    if dir == 1 {  // DIR_UP
        return makeVec2(0, -1);
    } else if dir == 2 {  // DIR_DOWN
        return makeVec2(0, 1);
    } else if dir == 3 {  // DIR_LEFT
        return makeVec2(-1, 0);
    } else if dir == 4 {  // DIR_RIGHT
        return makeVec2(1, 0);
    }
    return makeVec2(0, 0);
}

func getOppositeDirection(dir: Integer) -> Integer {
    if dir == 1 { return 2; }  // UP -> DOWN
    if dir == 2 { return 1; }  // DOWN -> UP
    if dir == 3 { return 4; }  // LEFT -> RIGHT
    if dir == 4 { return 3; }  // RIGHT -> LEFT
    return 0;  // DIR_NONE
}

// =============================================================================
// FRUIT HELPERS
// =============================================================================

func getFruitForLevel(level: Integer) -> Integer {
    if level == 1 { return FRUIT_CHERRY; }
    if level == 2 { return FRUIT_STRAWBERRY; }
    if level == 3 or level == 4 { return FRUIT_ORANGE; }
    if level == 5 or level == 6 { return FRUIT_APPLE; }
    if level == 7 or level == 8 { return FRUIT_MELON; }
    if level == 9 or level == 10 { return FRUIT_GALAXIAN; }
    if level == 11 or level == 12 { return FRUIT_BELL; }
    return FRUIT_KEY;
}

func getFruitPoints(fruitType: Integer) -> Integer {
    if fruitType == FRUIT_CHERRY { return 100; }
    if fruitType == FRUIT_STRAWBERRY { return 300; }
    if fruitType == FRUIT_ORANGE { return 500; }
    if fruitType == FRUIT_APPLE { return 700; }
    if fruitType == FRUIT_MELON { return 1000; }
    if fruitType == FRUIT_GALAXIAN { return 2000; }
    if fruitType == FRUIT_BELL { return 3000; }
    if fruitType == FRUIT_KEY { return 5000; }
    return 0;
}

func getFruitColor(fruitType: Integer) -> Integer {
    if fruitType == FRUIT_CHERRY { return COLOR_CHERRY; }
    if fruitType == FRUIT_STRAWBERRY { return COLOR_STRAWBERRY; }
    if fruitType == FRUIT_ORANGE { return COLOR_ORANGE_FRUIT; }
    if fruitType == FRUIT_APPLE { return COLOR_APPLE; }
    if fruitType == FRUIT_MELON { return COLOR_MELON; }
    if fruitType == FRUIT_GALAXIAN { return COLOR_GALAXIAN; }
    if fruitType == FRUIT_BELL { return COLOR_BELL; }
    if fruitType == FRUIT_KEY { return COLOR_KEY; }
    return COLOR_WHITE;
}

// =============================================================================
// FRUIT - Bonus item that appears in the maze
// =============================================================================

entity Fruit {
    hide Integer fruitType;
    hide Integer gridX;
    hide Integer gridY;
    hide Integer screenX;
    hide Integer screenY;
    hide Boolean active;
    hide Integer timer;
    hide Integer displayTimer;  // For showing points when collected

    expose func init() {
        fruitType = FRUIT_NONE;
        gridX = 14;  // Center of maze
        gridY = 17;  // Below ghost house
        screenX = gridToScreenX(gridX);
        screenY = gridToScreenY(gridY);
        active = false;
        timer = 0;
        displayTimer = 0;
    }

    expose func spawn(level: Integer) {
        fruitType = getFruitForLevel(level);
        active = true;
        timer = 600;  // 10 seconds at 60 fps
        displayTimer = 0;
    }

    expose func update() {
        if active {
            timer = timer - 1;
            if timer <= 0 {
                active = false;
                fruitType = FRUIT_NONE;
            }
        }
        if displayTimer > 0 {
            displayTimer = displayTimer - 1;
        }
    }

    expose func isActive() -> Boolean {
        return active;
    }

    expose func collect() -> Integer {
        if active {
            active = false;
            displayTimer = 120;  // Show points for 2 seconds
            var points = getFruitPoints(fruitType);
            return points;
        }
        return 0;
    }

    expose func collidesWithPacman(pacmanX: Integer, pacmanY: Integer) -> Boolean {
        if !active { return false; }
        return gridX == pacmanX and gridY == pacmanY;
    }

    expose func draw(canvas: Viper.Graphics.Canvas) {
        if active {
            var color = getFruitColor(fruitType);
            var centerX = screenX + TILE_SIZE / 2;
            var centerY = screenY + TILE_SIZE / 2;

            // Draw fruit as a colored circle with a small stem
            canvas.Disc(centerX, centerY, 8, color);

            // Draw stem (small green rectangle on top)
            canvas.Box(centerX - 1, centerY - 10, 3, 4, 0x00008800);
        }

        // Show points briefly after collection
        if displayTimer > 0 {
            var pointsText = Viper.Fmt.Int(getFruitPoints(fruitType));
            canvas.Text(screenX, screenY, pointsText, COLOR_WHITE);
        }
    }
}

// =============================================================================
// HIGH SCORE ENTRY
// =============================================================================

entity HighScoreEntry {
    expose Integer score;
    expose Integer level;

    expose func init(s: Integer, l: Integer) {
        score = s;
        level = l;
    }
}

// =============================================================================
// MAZE - The game board
// =============================================================================

entity Maze {
    hide List[Integer] tiles;
    hide Integer width;
    hide Integer height;
    hide Integer totalDots;
    hide Integer dotsRemaining;

    expose func init() {
        width = GRID_WIDTH;
        height = GRID_HEIGHT;
        tiles = [];
        totalDots = 0;
        dotsRemaining = 0;
        self.initializeMaze();
    }

    // Initialize the classic Pac-Man maze layout
    hide func initializeMaze() {
        // Create empty grid
        var size = width * height;
        var i = 0;
        while i < size {
            tiles.add(TILE_EMPTY);
            i = i + 1;
        }

        // Define the classic Pac-Man maze layout
        // 1 = wall, 2 = dot, 3 = power pellet, 4 = ghost gate
        // Layout is 28x31

        // Row 0 - top wall
        self.setRow(0, "1111111111111111111111111111");

        // Row 1 - dots and walls
        self.setRow(1, "1222222222222112222222222221");

        // Row 2 - dots and walls with power pellets
        self.setRow(2, "1211112111112112111112111121");

        // Row 3 - power pellet row
        self.setRow(3, "1311112111112112111112111131");

        // Row 4
        self.setRow(4, "1211112111112112111112111121");

        // Row 5 - all dots
        self.setRow(5, "1222222222222222222222222221");

        // Row 6
        self.setRow(6, "1211112112111111112112111121");

        // Row 7
        self.setRow(7, "1211112112111111112112111121");

        // Row 8
        self.setRow(8, "1222222112222112222112222221");

        // Row 9
        self.setRow(9, "1111112111110110111112111111");

        // Row 10
        self.setRow(10, "0000012111110110111112100000");

        // Row 11
        self.setRow(11, "0000012110000000000112100000");

        // Row 12
        self.setRow(12, "0000012110111441110112100000");

        // Row 13 - ghost house
        self.setRow(13, "1111112110100000010112111111");

        // Row 14 - tunnel row (empty sides for wrap-around)
        self.setRow(14, "0000002000100000010002000000");

        // Row 15
        self.setRow(15, "1111112110100000010112111111");

        // Row 16
        self.setRow(16, "0000012110111111110112100000");

        // Row 17
        self.setRow(17, "0000012110000000000112100000");

        // Row 18
        self.setRow(18, "0000012110111111110112100000");

        // Row 19
        self.setRow(19, "1111112110111111110112111111");

        // Row 20
        self.setRow(20, "1222222222222112222222222221");

        // Row 21
        self.setRow(21, "1211112111112112111112111121");

        // Row 22
        self.setRow(22, "1211112111112112111112111121");

        // Row 23 - power pellet row
        self.setRow(23, "1322112222222002222222112231");

        // Row 24
        self.setRow(24, "1112112112111111112112112111");

        // Row 25
        self.setRow(25, "1112112112111111112112112111");

        // Row 26
        self.setRow(26, "1222222112222112222112222221");

        // Row 27
        self.setRow(27, "1211111111112112111111111121");

        // Row 28
        self.setRow(28, "1211111111112112111111111121");

        // Row 29
        self.setRow(29, "1222222222222222222222222221");

        // Row 30 - bottom wall
        self.setRow(30, "1111111111111111111111111111");

        // Count dots
        self.countDots();
    }

    // Set a row of tiles from a string
    hide func setRow(row: Integer, pattern: String) {
        var col = 0;
        while col < Viper.String.Length(pattern) and col < width {
            var ch = Viper.String.Substring(pattern, col, 1);
            var tile = TILE_EMPTY;
            if ch == "1" {
                tile = TILE_WALL;
            } else if ch == "2" {
                tile = TILE_DOT;
            } else if ch == "3" {
                tile = TILE_PELLET;
            } else if ch == "4" {
                tile = TILE_GATE;
            }
            self.setTile(col, row, tile);
            col = col + 1;
        }
    }

    // Count total dots in maze
    hide func countDots() {
        totalDots = 0;
        var i = 0;
        while i < tiles.length() {
            var tile = tiles.get(i);
            if tile == TILE_DOT or tile == TILE_PELLET {
                totalDots = totalDots + 1;
            }
            i = i + 1;
        }
        dotsRemaining = totalDots;
    }

    // Get tile at position
    expose func getTile(x: Integer, y: Integer) -> Integer {
        if x < 0 or x >= width or y < 0 or y >= height {
            return TILE_WALL;
        }
        var index = y * width + x;
        return tiles.get(index);
    }

    // Set tile at position
    expose func setTile(x: Integer, y: Integer, value: Integer) {
        if x >= 0 and x < width and y >= 0 and y < height {
            var index = y * width + x;
            tiles.set(index, value);
        }
    }

    // Check if position is a wall
    expose func isWall(x: Integer, y: Integer) -> Boolean {
        var tile = self.getTile(x, y);
        return tile == TILE_WALL or tile == TILE_GATE;
    }

    // Check if position is walkable (not a wall)
    expose func isWalkable(x: Integer, y: Integer) -> Boolean {
        return !self.isWall(x, y);
    }

    // Eat dot at position, returns points earned
    expose func eatDot(x: Integer, y: Integer) -> Integer {
        var tile = self.getTile(x, y);
        if tile == TILE_DOT {
            self.setTile(x, y, TILE_EMPTY);
            dotsRemaining = dotsRemaining - 1;
            return 10;
        } else if tile == TILE_PELLET {
            self.setTile(x, y, TILE_EMPTY);
            dotsRemaining = dotsRemaining - 1;
            return 50;
        }
        return 0;
    }

    // Check if a position has a power pellet
    expose func hasPowerPellet(x: Integer, y: Integer) -> Boolean {
        return self.getTile(x, y) == TILE_PELLET;
    }

    // Get remaining dots
    expose func getDotsRemaining() -> Integer {
        return dotsRemaining;
    }

    // Check if all dots eaten
    expose func allDotsEaten() -> Boolean {
        return dotsRemaining <= 0;
    }

    // Reset maze to initial state
    expose func reset() {
        self.initializeMaze();
    }

    // Draw the maze
    expose func draw(canvas: Viper.Graphics.Canvas) {
        var y = 0;
        while y < height {
            var x = 0;
            while x < width {
                var tile = self.getTile(x, y);
                var screenX = gridToScreenX(x);
                var screenY = gridToScreenY(y);

                if tile == TILE_WALL {
                    // Draw wall as blue rectangle
                    canvas.Box(screenX, screenY, TILE_SIZE, TILE_SIZE, COLOR_WALL);
                } else if tile == TILE_DOT {
                    // Draw small dot in center of tile
                    var centerX = screenX + TILE_SIZE / 2;
                    var centerY = screenY + TILE_SIZE / 2;
                    canvas.Disc(centerX, centerY, 3, COLOR_DOT);
                } else if tile == TILE_PELLET {
                    // Draw larger power pellet
                    var centerX = screenX + TILE_SIZE / 2;
                    var centerY = screenY + TILE_SIZE / 2;
                    canvas.Disc(centerX, centerY, 8, COLOR_PELLET);
                } else if tile == TILE_GATE {
                    // Draw ghost gate as pink rectangle
                    canvas.Box(screenX, screenY + TILE_SIZE / 3, TILE_SIZE, TILE_SIZE / 3, COLOR_PINK);
                }

                x = x + 1;
            }
            y = y + 1;
        }
    }
}

// =============================================================================
// PACMAN - The player character
// =============================================================================

entity PacMan {
    hide Integer gridX;
    hide Integer gridY;
    hide Integer screenX;
    hide Integer screenY;
    hide Integer direction;
    hide Integer nextDirection;
    hide Integer speed;
    hide Integer animFrame;
    hide Integer animTimer;
    hide Boolean mouthOpen;

    expose func init(startX: Integer, startY: Integer) {
        gridX = startX;
        gridY = startY;
        screenX = gridToScreenX(startX);
        screenY = gridToScreenY(startY);
        direction = DIR_NONE;
        nextDirection = DIR_NONE;
        speed = 4;  // pixels per frame
        animFrame = 0;
        animTimer = 0;
        mouthOpen = true;
    }

    // Set the queued direction
    expose func setNextDirection(dir: Integer) {
        nextDirection = dir;
    }

    // Update Pac-Man position and state
    expose func update(maze: Maze) {
        // Update animation
        animTimer = animTimer + 1;
        if animTimer >= 5 {
            animTimer = 0;
            mouthOpen = !mouthOpen;
        }

        // Check if we can change to queued direction (only when aligned to grid)
        var atGridX = gridToScreenX(gridX);
        var atGridY = gridToScreenY(gridY);

        if nextDirection != DIR_NONE and screenX == atGridX and screenY == atGridY {
            var nextVec = getDirectionVector(nextDirection);
            var nextGridX = gridX + nextVec.x;
            var nextGridY = gridY + nextVec.y;

            // Handle tunnel wrap-around
            if nextGridX < 0 {
                nextGridX = GRID_WIDTH - 1;
            } else if nextGridX >= GRID_WIDTH {
                nextGridX = 0;
            }

            if maze.isWalkable(nextGridX, nextGridY) {
                direction = nextDirection;
                nextDirection = DIR_NONE;
            }
        }

        // Move in current direction
        if direction != DIR_NONE {
            var dirVec = getDirectionVector(direction);
            var targetGridX = gridX + dirVec.x;
            var targetGridY = gridY + dirVec.y;

            // Handle tunnel wrap-around (teleport to other side)
            if targetGridX < 0 {
                // Teleport to right side
                gridX = GRID_WIDTH - 1;
                screenX = gridToScreenX(gridX);
                return;
            } else if targetGridX >= GRID_WIDTH {
                // Teleport to left side
                gridX = 0;
                screenX = gridToScreenX(gridX);
                return;
            }

            if maze.isWalkable(targetGridX, targetGridY) {
                // Move towards target
                var targetScreenX = gridToScreenX(targetGridX);
                var targetScreenY = gridToScreenY(targetGridY);

                if screenX < targetScreenX {
                    screenX = screenX + speed;
                    if screenX >= targetScreenX {
                        screenX = targetScreenX;
                        gridX = targetGridX;
                    }
                } else if screenX > targetScreenX {
                    screenX = screenX - speed;
                    if screenX <= targetScreenX {
                        screenX = targetScreenX;
                        gridX = targetGridX;
                    }
                }

                if screenY < targetScreenY {
                    screenY = screenY + speed;
                    if screenY >= targetScreenY {
                        screenY = targetScreenY;
                        gridY = targetGridY;
                    }
                } else if screenY > targetScreenY {
                    screenY = screenY - speed;
                    if screenY <= targetScreenY {
                        screenY = targetScreenY;
                        gridY = targetGridY;
                    }
                }
            } else {
                // Hit a wall, stop
                direction = DIR_NONE;
                screenX = gridToScreenX(gridX);
                screenY = gridToScreenY(gridY);
            }
        }
    }

    // Get grid position X
    expose func getGridX() -> Integer {
        return gridX;
    }

    // Get grid position Y
    expose func getGridY() -> Integer {
        return gridY;
    }

    // Reset to starting position
    expose func reset(startX: Integer, startY: Integer) {
        gridX = startX;
        gridY = startY;
        screenX = gridToScreenX(startX);
        screenY = gridToScreenY(startY);
        direction = DIR_NONE;
        nextDirection = DIR_NONE;
    }

    // Draw Pac-Man
    expose func draw(canvas: Viper.Graphics.Canvas) {
        var centerX = screenX + TILE_SIZE / 2;
        var centerY = screenY + TILE_SIZE / 2;
        var radius = TILE_SIZE / 2 - 2;

        // Draw body as yellow disc
        canvas.Disc(centerX, centerY, radius, COLOR_YELLOW);

        // Draw mouth (as black triangle when open)
        if mouthOpen {
            var mouthX1 = centerX;
            var mouthY1 = centerY;
            var mouthX2 = centerX;
            var mouthY2 = centerY;
            var mouthX3 = centerX;
            var mouthY3 = centerY;

            // Calculate mouth vertices based on direction
            if direction == DIR_RIGHT or direction == DIR_NONE {
                mouthX2 = centerX + radius;
                mouthY2 = centerY - radius / 2;
                mouthX3 = centerX + radius;
                mouthY3 = centerY + radius / 2;
            } else if direction == DIR_LEFT {
                mouthX2 = centerX - radius;
                mouthY2 = centerY - radius / 2;
                mouthX3 = centerX - radius;
                mouthY3 = centerY + radius / 2;
            } else if direction == DIR_UP {
                mouthX2 = centerX - radius / 2;
                mouthY2 = centerY - radius;
                mouthX3 = centerX + radius / 2;
                mouthY3 = centerY - radius;
            } else if direction == DIR_DOWN {
                mouthX2 = centerX - radius / 2;
                mouthY2 = centerY + radius;
                mouthX3 = centerX + radius / 2;
                mouthY3 = centerY + radius;
            }

            canvas.Triangle(mouthX1, mouthY1, mouthX2, mouthY2, mouthX3, mouthY3, COLOR_BLACK);
        }
    }
}

// =============================================================================
// GHOST - Enemy characters
// =============================================================================

entity Ghost {
    hide Integer gridX;
    hide Integer gridY;
    hide Integer screenX;
    hide Integer screenY;
    hide Integer direction;
    hide Integer speed;
    hide Integer color;
    hide Integer mode;
    hide Integer ghostType;  // 0=Blinky, 1=Pinky, 2=Inky, 3=Clyde
    hide Integer frightenedTimer;
    hide Integer homeX;
    hide Integer homeY;
    hide Integer scatterX;
    hide Integer scatterY;

    expose func init(gType: Integer, startX: Integer, startY: Integer, ghostColor: Integer) {
        ghostType = gType;
        gridX = startX;
        gridY = startY;
        screenX = gridToScreenX(startX);
        screenY = gridToScreenY(startY);
        direction = DIR_UP;
        speed = 3;
        color = ghostColor;
        mode = MODE_SCATTER;
        frightenedTimer = 0;
        homeX = startX;
        homeY = startY;

        // Set scatter corner based on ghost type
        if ghostType == 0 {  // Blinky - top right
            scatterX = GRID_WIDTH - 3;
            scatterY = 0;
        } else if ghostType == 1 {  // Pinky - top left
            scatterX = 2;
            scatterY = 0;
        } else if ghostType == 2 {  // Inky - bottom right
            scatterX = GRID_WIDTH - 1;
            scatterY = GRID_HEIGHT - 1;
        } else {  // Clyde - bottom left
            scatterX = 0;
            scatterY = GRID_HEIGHT - 1;
        }
    }

    // Set mode (scatter, chase, frightened)
    expose func setMode(newMode: Integer) {
        if newMode == MODE_FRIGHTENED {
            frightenedTimer = 600;  // 10 seconds at 60 fps
        }
        mode = newMode;
    }

    // Get mode
    expose func getMode() -> Integer {
        return mode;
    }

    // Update ghost AI and movement
    expose func update(maze: Maze, pacmanX: Integer, pacmanY: Integer, blinkyX: Integer, blinkyY: Integer) {
        // Update frightened timer
        if mode == MODE_FRIGHTENED {
            frightenedTimer = frightenedTimer - 1;
            if frightenedTimer <= 0 {
                mode = MODE_CHASE;
            }
        }

        // Determine target based on mode and ghost type
        var targetX = scatterX;
        var targetY = scatterY;

        if mode == MODE_CHASE {
            if ghostType == 0 {
                // Blinky - directly targets Pac-Man
                targetX = pacmanX;
                targetY = pacmanY;
            } else if ghostType == 1 {
                // Pinky - targets 4 tiles ahead of Pac-Man
                targetX = pacmanX;
                targetY = pacmanY - 4;
            } else if ghostType == 2 {
                // Inky - complex targeting using Blinky's position
                var aheadX = pacmanX;
                var aheadY = pacmanY - 2;
                targetX = aheadX + (aheadX - blinkyX);
                targetY = aheadY + (aheadY - blinkyY);
            } else {
                // Clyde - targets Pac-Man when far, scatter when close
                var dist = self.manhattanDistance(gridX, gridY, pacmanX, pacmanY);
                if dist > 8 {
                    targetX = pacmanX;
                    targetY = pacmanY;
                }
            }
        } else if mode == MODE_FRIGHTENED {
            // Random movement when frightened - pick random target
            targetX = Viper.Random.NextInt(GRID_WIDTH);
            targetY = Viper.Random.NextInt(GRID_HEIGHT);
        }

        // Move towards target using simple pathfinding
        self.moveTowards(targetX, targetY, maze);
    }

    // Manhattan distance calculation
    hide func manhattanDistance(x1: Integer, y1: Integer, x2: Integer, y2: Integer) -> Integer {
        var dx = x1 - x2;
        var dy = y1 - y2;
        if dx < 0 { dx = 0 - dx; }
        if dy < 0 { dy = 0 - dy; }
        return dx + dy;
    }

    // Move towards target position
    hide func moveTowards(targetX: Integer, targetY: Integer, maze: Maze) {
        // Find best direction to move
        var bestDir = direction;
        var bestDist = 999999;
        var oppositeDir = getOppositeDirection(direction);

        // Check each direction
        var dirs = [DIR_UP, DIR_DOWN, DIR_LEFT, DIR_RIGHT];
        var i = 0;
        while i < 4 {
            var testDir = dirs.get(i);

            // Don't reverse direction (unless no other option)
            if testDir != oppositeDir {
                var dirVec = getDirectionVector(testDir);
                var nextX = gridX + dirVec.x;
                var nextY = gridY + dirVec.y;

                // Handle tunnel wrap
                if nextX < 0 { nextX = GRID_WIDTH - 1; }
                if nextX >= GRID_WIDTH { nextX = 0; }

                if maze.isWalkable(nextX, nextY) {
                    var dist = self.manhattanDistance(nextX, nextY, targetX, targetY);
                    if dist < bestDist {
                        bestDist = dist;
                        bestDir = testDir;
                    }
                }
            }
            i = i + 1;
        }

        direction = bestDir;

        // Move in chosen direction
        var moveVec = getDirectionVector(direction);
        var nextGridX = gridX + moveVec.x;
        var nextGridY = gridY + moveVec.y;

        // Handle tunnel wrap
        if nextGridX < 0 {
            nextGridX = GRID_WIDTH - 1;
            screenX = gridToScreenX(GRID_WIDTH);
        } else if nextGridX >= GRID_WIDTH {
            nextGridX = 0;
            screenX = 0 - TILE_SIZE;
        }

        if maze.isWalkable(nextGridX, nextGridY) {
            var targetScreenX = gridToScreenX(nextGridX);
            var targetScreenY = gridToScreenY(nextGridY);

            if screenX < targetScreenX {
                screenX = screenX + speed;
                if screenX >= targetScreenX {
                    screenX = targetScreenX;
                    gridX = nextGridX;
                }
            } else if screenX > targetScreenX {
                screenX = screenX - speed;
                if screenX <= targetScreenX {
                    screenX = targetScreenX;
                    gridX = nextGridX;
                }
            }

            if screenY < targetScreenY {
                screenY = screenY + speed;
                if screenY >= targetScreenY {
                    screenY = targetScreenY;
                    gridY = nextGridY;
                }
            } else if screenY > targetScreenY {
                screenY = screenY - speed;
                if screenY <= targetScreenY {
                    screenY = targetScreenY;
                    gridY = nextGridY;
                }
            }
        }
    }

    // Get grid position
    expose func getGridX() -> Integer {
        return gridX;
    }

    expose func getGridY() -> Integer {
        return gridY;
    }

    // Check collision with Pac-Man
    expose func collidesWithPacman(pacmanX: Integer, pacmanY: Integer) -> Boolean {
        return gridX == pacmanX and gridY == pacmanY;
    }

    // Reset ghost to home position
    expose func reset() {
        gridX = homeX;
        gridY = homeY;
        screenX = gridToScreenX(homeX);
        screenY = gridToScreenY(homeY);
        direction = DIR_UP;
        mode = MODE_SCATTER;
        frightenedTimer = 0;
    }

    // Draw ghost
    expose func draw(canvas: Viper.Graphics.Canvas) {
        var centerX = screenX + TILE_SIZE / 2;
        var centerY = screenY + TILE_SIZE / 2;
        var radius = TILE_SIZE / 2 - 2;

        // Choose color based on mode
        var drawColor = color;
        if mode == MODE_FRIGHTENED {
            drawColor = COLOR_BLUE;
        }

        // Draw ghost body (top half circle)
        canvas.Disc(centerX, centerY - 2, radius, drawColor);

        // Draw bottom half (rectangle with wavy bottom simulated)
        canvas.Box(screenX + 2, centerY - 2, TILE_SIZE - 4, radius, drawColor);

        // Draw eyes (white with blue pupils)
        var eyeOffset = 4;
        canvas.Disc(centerX - eyeOffset, centerY - 4, 4, COLOR_WHITE);
        canvas.Disc(centerX + eyeOffset, centerY - 4, 4, COLOR_WHITE);

        // Draw pupils (looking in movement direction)
        var pupilOffsetX = 0;
        var pupilOffsetY = 0;
        if direction == DIR_LEFT { pupilOffsetX = -2; }
        else if direction == DIR_RIGHT { pupilOffsetX = 2; }
        else if direction == DIR_UP { pupilOffsetY = -2; }
        else if direction == DIR_DOWN { pupilOffsetY = 2; }

        canvas.Disc(centerX - eyeOffset + pupilOffsetX, centerY - 4 + pupilOffsetY, 2, COLOR_BLUE);
        canvas.Disc(centerX + eyeOffset + pupilOffsetX, centerY - 4 + pupilOffsetY, 2, COLOR_BLUE);
    }
}

// =============================================================================
// GAME - Main game controller
// =============================================================================

entity Game {
    hide Viper.Graphics.Canvas canvas;
    hide Maze maze;
    hide PacMan pacman;
    hide List[Ghost] ghosts;
    hide Fruit fruit;
    hide Integer score;
    hide Integer lives;
    hide Integer level;
    hide Integer state;
    hide Integer readyTimer;
    hide Integer modeTimer;
    hide Boolean globalMode;  // true = chase, false = scatter
    hide Integer ghostsEaten;  // For scoring combo during frightened mode
    hide Integer dotsEaten;    // Counter for fruit spawning
    hide Integer menuState;
    hide Integer menuSelection;
    hide Integer highScore;
    hide List[Integer] highScores;  // Top 5 high scores
    hide Integer extraLifeAwarded;  // Track if extra life at 10000 was given

    expose func init() {
        // Create canvas
        canvas = Viper.Graphics.Canvas.New("PAC-MAN", SCREEN_WIDTH, SCREEN_HEIGHT);

        // Initialize game objects
        maze = new Maze();
        maze.init();

        pacman = new PacMan(14, 23);  // Starting position

        // Create ghosts
        ghosts = [];

        var blinky = new Ghost(0, 14, 11, COLOR_RED);
        ghosts.add(blinky);

        var pinky = new Ghost(1, 13, 14, COLOR_PINK);
        ghosts.add(pinky);

        var inky = new Ghost(2, 14, 14, COLOR_CYAN);
        ghosts.add(inky);

        var clyde = new Ghost(3, 15, 14, COLOR_ORANGE);
        ghosts.add(clyde);

        // Initialize fruit
        fruit = new Fruit();
        fruit.init();

        // Initialize high scores
        highScores = [];
        highScores.add(10000);
        highScores.add(8000);
        highScores.add(6000);
        highScores.add(4000);
        highScores.add(2000);
        highScore = 10000;

        // Game state
        score = 0;
        lives = 3;
        level = 1;
        state = STATE_READY;
        readyTimer = 180;  // 3 seconds
        modeTimer = 0;
        globalMode = false;  // Start in scatter mode
        ghostsEaten = 0;
        dotsEaten = 0;
        menuState = MENU_MAIN;
        menuSelection = 0;
        extraLifeAwarded = 0;
    }

    // Main game loop
    expose func run() {
        var running = true;

        while running {
            // Poll for input (MUST be called first)
            canvas.Poll();

            // Check for quit
            if canvas.KeyHeld(KEY_ESCAPE) != 0 {
                if menuState == MENU_PLAYING {
                    menuState = MENU_MAIN;
                    Viper.Time.SleepMs(200);
                } else {
                    running = false;
                }
            }

            // Handle based on menu state
            if menuState == MENU_MAIN {
                self.handleMenuInput();
                self.renderMenu();
            } else if menuState == MENU_HIGHSCORES {
                self.handleHighScoreInput();
                self.renderHighScores();
            } else if menuState == MENU_PLAYING {
                // Handle input based on game state
                if state == STATE_PLAYING {
                    self.handlePlayingInput();
                    self.updateGame();
                } else if state == STATE_READY {
                    readyTimer = readyTimer - 1;
                    if readyTimer <= 0 {
                        state = STATE_PLAYING;
                    }
                } else if state == STATE_PAUSED {
                    if canvas.KeyHeld(KEY_P) != 0 {
                        state = STATE_PLAYING;
                        Viper.Time.SleepMs(200);  // Debounce
                    }
                } else if state == STATE_GAME_OVER {
                    self.updateHighScores();
                    if canvas.KeyHeld(KEY_R) != 0 {
                        self.resetGame();
                    }
                } else if state == STATE_WIN {
                    if canvas.KeyHeld(KEY_R) != 0 {
                        self.nextLevel();
                    }
                }

                // Render game
                self.render();
            }

            // Frame timing
            Viper.Time.SleepMs(FRAME_TIME);
        }
        // Window closes automatically when program ends
    }

    // Handle menu input
    hide func handleMenuInput() {
        if canvas.KeyHeld(KEY_UP) != 0 {
            menuSelection = menuSelection - 1;
            if menuSelection < 0 {
                menuSelection = 2;
            }
            Viper.Time.SleepMs(150);
        } else if canvas.KeyHeld(KEY_DOWN) != 0 {
            menuSelection = menuSelection + 1;
            if menuSelection > 2 {
                menuSelection = 0;
            }
            Viper.Time.SleepMs(150);
        }

        // Enter key or Space to select
        if canvas.KeyHeld(257) != 0 or canvas.KeyHeld(32) != 0 {  // ENTER or SPACE
            if menuSelection == 0 {
                // Start Game
                self.resetGame();
                menuState = MENU_PLAYING;
            } else if menuSelection == 1 {
                // High Scores
                menuState = MENU_HIGHSCORES;
            } else if menuSelection == 2 {
                // Quit - handled by ESC
            }
            Viper.Time.SleepMs(200);
        }
    }

    // Handle high score screen input
    hide func handleHighScoreInput() {
        if canvas.KeyHeld(257) != 0 or canvas.KeyHeld(32) != 0 or canvas.KeyHeld(KEY_ESCAPE) != 0 {
            menuState = MENU_MAIN;
            Viper.Time.SleepMs(200);
        }
    }

    // Update high scores
    hide func updateHighScores() {
        // Insert score into high scores list if it qualifies
        var i = 0;
        while i < highScores.length() {
            if score > highScores.get(i) {
                // Shift scores down
                var j = highScores.length() - 1;
                while j > i {
                    var prevScore = highScores.get(j - 1);
                    highScores.set(j, prevScore);
                    j = j - 1;
                }
                highScores.set(i, score);
                if i == 0 {
                    highScore = score;
                }
                return;
            }
            i = i + 1;
        }
    }

    // Render main menu
    hide func renderMenu() {
        canvas.Clear(COLOR_BLACK);

        // Title
        canvas.Text(SCREEN_WIDTH / 2 - 80, 100, "PAC-MAN", COLOR_YELLOW);

        // Menu options
        var startColor = COLOR_WHITE;
        var scoresColor = COLOR_WHITE;
        var quitColor = COLOR_WHITE;

        if menuSelection == 0 { startColor = COLOR_YELLOW; }
        if menuSelection == 1 { scoresColor = COLOR_YELLOW; }
        if menuSelection == 2 { quitColor = COLOR_YELLOW; }

        canvas.Text(SCREEN_WIDTH / 2 - 60, 250, "START GAME", startColor);
        canvas.Text(SCREEN_WIDTH / 2 - 60, 300, "HIGH SCORES", scoresColor);
        canvas.Text(SCREEN_WIDTH / 2 - 60, 350, "QUIT (ESC)", quitColor);

        // High score display
        canvas.Text(SCREEN_WIDTH / 2 - 80, 450, "HIGH SCORE: " + Viper.Fmt.Int(highScore), COLOR_CYAN);

        // Instructions
        canvas.Text(SCREEN_WIDTH / 2 - 100, 550, "Use Arrow Keys to Select", COLOR_WHITE);
        canvas.Text(SCREEN_WIDTH / 2 - 100, 580, "Press ENTER to Confirm", COLOR_WHITE);

        // Draw Pac-Man and ghosts as decoration
        canvas.Disc(100, 200, 20, COLOR_YELLOW);
        canvas.Disc(SCREEN_WIDTH - 100, 200, 20, COLOR_RED);
        canvas.Disc(SCREEN_WIDTH - 150, 200, 20, COLOR_PINK);
        canvas.Disc(SCREEN_WIDTH - 200, 200, 20, COLOR_CYAN);
        canvas.Disc(SCREEN_WIDTH - 250, 200, 20, COLOR_ORANGE);

        canvas.Flip();
    }

    // Render high scores screen
    hide func renderHighScores() {
        canvas.Clear(COLOR_BLACK);

        // Title
        canvas.Text(SCREEN_WIDTH / 2 - 80, 100, "HIGH SCORES", COLOR_YELLOW);

        // Display scores
        var y = 200;
        var rank = 1;
        var i = 0;
        while i < highScores.length() {
            var scoreVal = highScores.get(i);
            var rankText = Viper.Fmt.Int(rank) + ". " + Viper.Fmt.Int(scoreVal);
            var color = COLOR_WHITE;
            if rank == 1 { color = COLOR_YELLOW; }
            if rank == 2 { color = COLOR_CYAN; }
            if rank == 3 { color = COLOR_PINK; }
            canvas.Text(SCREEN_WIDTH / 2 - 60, y, rankText, color);
            y = y + 50;
            rank = rank + 1;
            i = i + 1;
        }

        // Instructions
        canvas.Text(SCREEN_WIDTH / 2 - 100, 500, "Press ENTER to Return", COLOR_WHITE);

        canvas.Flip();
    }

    // Handle input during gameplay
    hide func handlePlayingInput() {
        // Direction input
        if canvas.KeyHeld(KEY_UP) != 0 {
            pacman.setNextDirection(DIR_UP);
        } else if canvas.KeyHeld(KEY_DOWN) != 0 {
            pacman.setNextDirection(DIR_DOWN);
        } else if canvas.KeyHeld(KEY_LEFT) != 0 {
            pacman.setNextDirection(DIR_LEFT);
        } else if canvas.KeyHeld(KEY_RIGHT) != 0 {
            pacman.setNextDirection(DIR_RIGHT);
        }

        // Pause
        if canvas.KeyHeld(KEY_P) != 0 {
            state = STATE_PAUSED;
            Viper.Time.SleepMs(200);  // Debounce
        }
    }

    // Update game logic
    hide func updateGame() {
        // Update mode timer
        modeTimer = modeTimer + 1;
        if modeTimer >= 420 {  // 7 seconds
            modeTimer = 0;
            globalMode = !globalMode;

            // Update ghost modes (except frightened ghosts)
            var i = 0;
            while i < ghosts.length() {
                var ghost = ghosts.get(i);
                if ghost.getMode() != MODE_FRIGHTENED {
                    if globalMode {
                        ghost.setMode(MODE_CHASE);
                    } else {
                        ghost.setMode(MODE_SCATTER);
                    }
                }
                i = i + 1;
            }
        }

        // Update Pac-Man
        pacman.update(maze);

        // Update fruit
        fruit.update();

        // Check for dot eating
        var points = maze.eatDot(pacman.getGridX(), pacman.getGridY());
        if points > 0 {
            score = score + points;
            dotsEaten = dotsEaten + 1;

            // Spawn fruit at 70 and 170 dots eaten
            if dotsEaten == 70 or dotsEaten == 170 {
                fruit.spawn(level);
            }

            // Check for power pellet
            if points == 50 {
                // Frighten all ghosts
                ghostsEaten = 0;
                var i = 0;
                while i < ghosts.length() {
                    var ghost = ghosts.get(i);
                    ghost.setMode(MODE_FRIGHTENED);
                    i = i + 1;
                }
            }
        }

        // Check for fruit collection
        if fruit.collidesWithPacman(pacman.getGridX(), pacman.getGridY()) {
            var fruitPoints = fruit.collect();
            score = score + fruitPoints;
        }

        // Award extra life at 10000 points
        if score >= 10000 and extraLifeAwarded == 0 {
            lives = lives + 1;
            extraLifeAwarded = 1;
        }

        // Update ghosts
        var blinkyX = 0;
        var blinkyY = 0;
        if ghosts.length() > 0 {
            var blinky = ghosts.get(0);
            blinkyX = blinky.getGridX();
            blinkyY = blinky.getGridY();
        }

        var i = 0;
        while i < ghosts.length() {
            var ghost = ghosts.get(i);
            ghost.update(maze, pacman.getGridX(), pacman.getGridY(), blinkyX, blinkyY);
            i = i + 1;
        }

        // Check for ghost collisions
        i = 0;
        while i < ghosts.length() {
            var ghost = ghosts.get(i);
            if ghost.collidesWithPacman(pacman.getGridX(), pacman.getGridY()) {
                if ghost.getMode() == MODE_FRIGHTENED {
                    // Eat ghost
                    ghostsEaten = ghostsEaten + 1;
                    var ghostPoints = 200;
                    var mult = 1;
                    var j = 1;
                    while j < ghostsEaten {
                        mult = mult * 2;
                        j = j + 1;
                    }
                    score = score + ghostPoints * mult;
                    ghost.reset();
                } else {
                    // Pac-Man dies
                    self.pacmanDeath();
                    return;
                }
            }
            i = i + 1;
        }

        // Check win condition
        if maze.allDotsEaten() {
            state = STATE_WIN;
        }
    }

    // Handle Pac-Man death
    hide func pacmanDeath() {
        lives = lives - 1;
        if lives <= 0 {
            state = STATE_GAME_OVER;
        } else {
            // Reset positions
            pacman.reset(14, 23);
            var i = 0;
            while i < ghosts.length() {
                var ghost = ghosts.get(i);
                ghost.reset();
                i = i + 1;
            }
            state = STATE_READY;
            readyTimer = 120;
        }
    }

    // Reset entire game
    hide func resetGame() {
        score = 0;
        lives = 3;
        level = 1;
        maze.reset();
        pacman.reset(14, 23);
        var i = 0;
        while i < ghosts.length() {
            var ghost = ghosts.get(i);
            ghost.reset();
            i = i + 1;
        }
        state = STATE_READY;
        readyTimer = 180;
        modeTimer = 0;
        globalMode = false;
    }

    // Advance to next level
    hide func nextLevel() {
        level = level + 1;
        maze.reset();
        pacman.reset(14, 23);
        var i = 0;
        while i < ghosts.length() {
            var ghost = ghosts.get(i);
            ghost.reset();
            i = i + 1;
        }
        fruit.init();  // Reset fruit
        dotsEaten = 0;
        state = STATE_READY;
        readyTimer = 180;
        modeTimer = 0;
        globalMode = false;
    }

    // Render the game
    hide func render() {
        // Clear screen
        canvas.Clear(COLOR_BLACK);

        // Draw maze
        maze.draw(canvas);

        // Draw fruit
        fruit.draw(canvas);

        // Draw Pac-Man
        pacman.draw(canvas);

        // Draw ghosts
        var i = 0;
        while i < ghosts.length() {
            var ghost = ghosts.get(i);
            ghost.draw(canvas);
            i = i + 1;
        }

        // Draw UI
        self.drawUI();

        // Draw state-specific overlays
        if state == STATE_READY {
            self.drawReadyText();
        } else if state == STATE_PAUSED {
            self.drawPausedText();
        } else if state == STATE_GAME_OVER {
            self.drawGameOverText();
        } else if state == STATE_WIN {
            self.drawWinText();
        }

        // Present frame
        canvas.Flip();
    }

    // Draw UI (score, lives, level)
    hide func drawUI() {
        // Score at top
        var scoreText = "SCORE: " + Viper.Fmt.Int(score);
        canvas.Text(10, 5, scoreText, COLOR_WHITE);

        // Level
        var levelText = "LEVEL: " + Viper.Fmt.Int(level);
        canvas.Text(SCREEN_WIDTH / 2 - 40, 5, levelText, COLOR_WHITE);

        // Lives at top right
        var livesText = "LIVES: " + Viper.Fmt.Int(lives);
        canvas.Text(SCREEN_WIDTH - 100, 5, livesText, COLOR_WHITE);
    }

    // Draw READY text
    hide func drawReadyText() {
        var text = "READY!";
        var x = SCREEN_WIDTH / 2 - 40;
        var y = SCREEN_HEIGHT / 2;
        canvas.Text(x, y, text, COLOR_YELLOW);
    }

    // Draw PAUSED text
    hide func drawPausedText() {
        var text = "PAUSED";
        var x = SCREEN_WIDTH / 2 - 40;
        var y = SCREEN_HEIGHT / 2;
        canvas.Text(x, y, text, COLOR_YELLOW);

        var text2 = "Press P to continue";
        canvas.Text(x - 30, y + 30, text2, COLOR_WHITE);
    }

    // Draw GAME OVER text
    hide func drawGameOverText() {
        var text = "GAME OVER";
        var x = SCREEN_WIDTH / 2 - 60;
        var y = SCREEN_HEIGHT / 2;
        canvas.Text(x, y, text, COLOR_RED);

        var text2 = "Press R to restart";
        canvas.Text(x - 10, y + 30, text2, COLOR_WHITE);
    }

    // Draw WIN text
    hide func drawWinText() {
        var text = "LEVEL COMPLETE!";
        var x = SCREEN_WIDTH / 2 - 80;
        var y = SCREEN_HEIGHT / 2;
        canvas.Text(x, y, text, COLOR_YELLOW);

        var text2 = "Press R for next level";
        canvas.Text(x - 20, y + 30, text2, COLOR_WHITE);
    }
}

// =============================================================================
// LEVEL CONFIGURATION - Difficulty settings per level
// =============================================================================

entity LevelConfig {
    expose Integer pacmanSpeed;
    expose Integer ghostSpeed;
    expose Integer frightenedDuration;
    expose Integer scatterDuration;
    expose Integer chaseDuration;
    expose Integer elroyDotsLeft;
    expose Integer elroySpeed;

    expose func init(level: Integer) {
        // Base speeds
        pacmanSpeed = 4;
        ghostSpeed = 3;
        frightenedDuration = 600;  // 10 seconds
        scatterDuration = 420;     // 7 seconds
        chaseDuration = 1200;      // 20 seconds
        elroyDotsLeft = 20;        // Blinky speeds up when this many dots left
        elroySpeed = 4;

        // Adjust based on level
        if level >= 2 {
            pacmanSpeed = 4;
            ghostSpeed = 3;
            frightenedDuration = 540;
        }

        if level >= 3 {
            ghostSpeed = 4;
            frightenedDuration = 480;
            elroyDotsLeft = 30;
        }

        if level >= 5 {
            pacmanSpeed = 5;
            ghostSpeed = 4;
            frightenedDuration = 360;
            chaseDuration = 1500;
            elroySpeed = 5;
        }

        if level >= 7 {
            ghostSpeed = 5;
            frightenedDuration = 240;
            elroyDotsLeft = 40;
        }

        if level >= 10 {
            pacmanSpeed = 6;
            ghostSpeed = 5;
            frightenedDuration = 120;
            scatterDuration = 300;
            chaseDuration = 1800;
        }

        if level >= 15 {
            ghostSpeed = 6;
            frightenedDuration = 60;
            elroyDotsLeft = 60;
            elroySpeed = 6;
        }

        if level >= 20 {
            frightenedDuration = 0;  // No frightened mode at very high levels
        }
    }

    expose func getPacmanSpeed() -> Integer {
        return pacmanSpeed;
    }

    expose func getGhostSpeed() -> Integer {
        return ghostSpeed;
    }

    expose func getFrightenedDuration() -> Integer {
        return frightenedDuration;
    }

    expose func getScatterDuration() -> Integer {
        return scatterDuration;
    }

    expose func getChaseDuration() -> Integer {
        return chaseDuration;
    }
}

// =============================================================================
// SCORE POPUP - Floating score text that appears when eating ghosts/fruit
// =============================================================================

entity ScorePopup {
    hide Integer x;
    hide Integer y;
    hide Integer points;
    hide Integer timer;
    hide Boolean active;

    expose func init() {
        x = 0;
        y = 0;
        points = 0;
        timer = 0;
        active = false;
    }

    expose func spawn(px: Integer, py: Integer, pts: Integer) {
        x = px;
        y = py;
        points = pts;
        timer = 90;  // 1.5 seconds
        active = true;
    }

    expose func update() {
        if active {
            timer = timer - 1;
            y = y - 1;  // Float upward
            if timer <= 0 {
                active = false;
            }
        }
    }

    expose func isActive() -> Boolean {
        return active;
    }

    expose func draw(canvas: Viper.Graphics.Canvas) {
        if active {
            var text = Viper.Fmt.Int(points);
            // Fade effect based on timer
            var color = COLOR_WHITE;
            if timer < 30 {
                color = COLOR_CYAN;
            }
            canvas.Text(x, y, text, color);
        }
    }
}

// =============================================================================
// INTERMISSION SCREEN - Cutscenes between levels
// =============================================================================

entity Intermission {
    hide Integer sceneType;
    hide Integer frameCount;
    hide Integer duration;
    hide Boolean active;
    hide Integer pacmanX;
    hide Integer ghostX;
    hide Integer phase;

    expose func init() {
        sceneType = 0;
        frameCount = 0;
        duration = 0;
        active = false;
        pacmanX = 0;
        ghostX = 0;
        phase = 0;
    }

    expose func start(level: Integer) {
        // Show intermission after levels 2, 5, 9, 13, 17
        if level == 2 or level == 5 or level == 9 or level == 13 or level == 17 {
            active = true;
            sceneType = (level / 4) % 3;
            frameCount = 0;
            duration = 360;  // 6 seconds
            pacmanX = SCREEN_WIDTH + 50;
            ghostX = SCREEN_WIDTH + 150;
            phase = 0;
        }
    }

    expose func isActive() -> Boolean {
        return active;
    }

    expose func update() {
        if !active { return; }

        frameCount = frameCount + 1;

        // Animation phases
        if frameCount < 120 {
            // Phase 1: Chase - ghosts chase Pac-Man from right to left
            phase = 0;
            pacmanX = pacmanX - 4;
            ghostX = ghostX - 4;
        } else if frameCount < 180 {
            // Phase 2: Power pellet eaten
            phase = 1;
        } else if frameCount < 300 {
            // Phase 3: Pac-Man chases ghosts back
            phase = 2;
            pacmanX = pacmanX + 5;
            ghostX = ghostX + 6;
        } else {
            // End intermission
            active = false;
        }
    }

    expose func draw(canvas: Viper.Graphics.Canvas) {
        if !active { return; }

        canvas.Clear(COLOR_BLACK);

        var centerY = SCREEN_HEIGHT / 2;

        // Draw scene based on type and phase
        if phase == 0 {
            // Ghosts chasing Pac-Man
            self.drawPacman(canvas, pacmanX, centerY, DIR_LEFT, true);
            self.drawGhostChasing(canvas, ghostX, centerY, COLOR_RED);
            self.drawGhostChasing(canvas, ghostX + 30, centerY, COLOR_PINK);
            self.drawGhostChasing(canvas, ghostX + 60, centerY, COLOR_CYAN);
            self.drawGhostChasing(canvas, ghostX + 90, centerY, COLOR_ORANGE);
        } else if phase == 1 {
            // Power pellet moment
            canvas.Text(SCREEN_WIDTH / 2 - 60, centerY - 50, "POWER!", COLOR_YELLOW);
            self.drawPacman(canvas, pacmanX, centerY, DIR_RIGHT, true);
            // Draw frightened ghosts
            self.drawGhostFrightened(canvas, ghostX, centerY);
            self.drawGhostFrightened(canvas, ghostX + 30, centerY);
            self.drawGhostFrightened(canvas, ghostX + 60, centerY);
            self.drawGhostFrightened(canvas, ghostX + 90, centerY);
        } else {
            // Pac-Man chasing ghosts
            self.drawPacman(canvas, pacmanX, centerY, DIR_RIGHT, true);
            self.drawGhostFrightened(canvas, ghostX, centerY);
            self.drawGhostFrightened(canvas, ghostX + 30, centerY);
            self.drawGhostFrightened(canvas, ghostX + 60, centerY);
            self.drawGhostFrightened(canvas, ghostX + 90, centerY);
        }

        // Draw intermission text based on scene type
        var text = "";
        if sceneType == 0 {
            text = "THE CHASE";
        } else if sceneType == 1 {
            text = "THEY MEET AGAIN";
        } else {
            text = "JUNIOR";
        }
        canvas.Text(SCREEN_WIDTH / 2 - 60, 100, text, COLOR_CYAN);

        canvas.Flip();
    }

    hide func drawPacman(canvas: Viper.Graphics.Canvas, px: Integer, py: Integer, dir: Integer, mouthOpen: Boolean) {
        var radius = 20;
        canvas.Disc(px, py, radius, COLOR_YELLOW);
        if mouthOpen {
            // Draw mouth
            if dir == DIR_LEFT {
                canvas.Triangle(px, py, px - radius, py - radius / 2, px - radius, py + radius / 2, COLOR_BLACK);
            } else {
                canvas.Triangle(px, py, px + radius, py - radius / 2, px + radius, py + radius / 2, COLOR_BLACK);
            }
        }
    }

    hide func drawGhostChasing(canvas: Viper.Graphics.Canvas, gx: Integer, gy: Integer, color: Integer) {
        canvas.Disc(gx, gy - 5, 15, color);
        canvas.Box(gx - 15, gy - 5, 30, 20, color);
        // Eyes
        canvas.Disc(gx - 5, gy - 5, 4, COLOR_WHITE);
        canvas.Disc(gx + 5, gy - 5, 4, COLOR_WHITE);
        canvas.Disc(gx - 7, gy - 5, 2, COLOR_BLUE);
        canvas.Disc(gx + 3, gy - 5, 2, COLOR_BLUE);
    }

    hide func drawGhostFrightened(canvas: Viper.Graphics.Canvas, gx: Integer, gy: Integer) {
        canvas.Disc(gx, gy - 5, 15, COLOR_BLUE);
        canvas.Box(gx - 15, gy - 5, 30, 20, COLOR_BLUE);
        // Scared face
        canvas.Disc(gx - 5, gy - 5, 3, COLOR_WHITE);
        canvas.Disc(gx + 5, gy - 5, 3, COLOR_WHITE);
        // Wavy mouth
        canvas.Line(gx - 8, gy + 5, gx - 4, gy + 8, COLOR_WHITE);
        canvas.Line(gx - 4, gy + 8, gx, gy + 5, COLOR_WHITE);
        canvas.Line(gx, gy + 5, gx + 4, gy + 8, COLOR_WHITE);
        canvas.Line(gx + 4, gy + 8, gx + 8, gy + 5, COLOR_WHITE);
    }
}

// =============================================================================
// STATS TRACKER - Track game statistics
// =============================================================================

entity StatsTracker {
    expose Integer totalDotsEaten;
    expose Integer totalGhostsEaten;
    expose Integer totalFruitCollected;
    expose Integer totalDeaths;
    expose Integer gamesPlayed;
    expose Integer highestLevel;
    expose Integer longestStreak;  // Consecutive ghosts eaten in one power pellet
    expose Integer currentStreak;

    expose func init() {
        totalDotsEaten = 0;
        totalGhostsEaten = 0;
        totalFruitCollected = 0;
        totalDeaths = 0;
        gamesPlayed = 0;
        highestLevel = 1;
        longestStreak = 0;
        currentStreak = 0;
    }

    expose func onDotEaten() {
        totalDotsEaten = totalDotsEaten + 1;
    }

    expose func onGhostEaten() {
        totalGhostsEaten = totalGhostsEaten + 1;
        currentStreak = currentStreak + 1;
        if currentStreak > longestStreak {
            longestStreak = currentStreak;
        }
    }

    expose func onPowerPelletEnded() {
        currentStreak = 0;
    }

    expose func onFruitCollected() {
        totalFruitCollected = totalFruitCollected + 1;
    }

    expose func onDeath() {
        totalDeaths = totalDeaths + 1;
    }

    expose func onGameStart() {
        gamesPlayed = gamesPlayed + 1;
        currentStreak = 0;
    }

    expose func onLevelComplete(level: Integer) {
        if level > highestLevel {
            highestLevel = level;
        }
    }

    expose func getTotalScore() -> Integer {
        // Calculate total score from all components
        return totalDotsEaten * 10 + totalGhostsEaten * 200 + totalFruitCollected * 500;
    }
}

// =============================================================================
// ANIMATION HELPER - For smooth animations
// =============================================================================

entity AnimationTimer {
    hide Integer currentFrame;
    hide Integer maxFrames;
    hide Integer speed;
    hide Boolean looping;
    hide Boolean finished;

    expose func init(frames: Integer, animSpeed: Integer, loop: Boolean) {
        currentFrame = 0;
        maxFrames = frames;
        speed = animSpeed;
        looping = loop;
        finished = false;
    }

    expose func update() {
        if finished and !looping {
            return;
        }

        currentFrame = currentFrame + 1;
        if currentFrame >= maxFrames * speed {
            if looping {
                currentFrame = 0;
            } else {
                finished = true;
            }
        }
    }

    expose func getFrame() -> Integer {
        return currentFrame / speed;
    }

    expose func isFinished() -> Boolean {
        return finished;
    }

    expose func reset() {
        currentFrame = 0;
        finished = false;
    }
}

// =============================================================================
// PARTICLE EFFECT - Simple particle system for visual effects
// =============================================================================

entity Particle {
    hide Integer x;
    hide Integer y;
    hide Integer vx;
    hide Integer vy;
    hide Integer life;
    hide Integer color;
    hide Integer size;

    expose func init(px: Integer, py: Integer, pvx: Integer, pvy: Integer, pcolor: Integer) {
        x = px;
        y = py;
        vx = pvx;
        vy = pvy;
        life = 30;
        color = pcolor;
        size = 3;
    }

    expose func update() {
        x = x + vx;
        y = y + vy;
        life = life - 1;
        if life < 10 {
            size = 2;
        }
        if life < 5 {
            size = 1;
        }
    }

    expose func isAlive() -> Boolean {
        return life > 0;
    }

    expose func draw(canvas: Viper.Graphics.Canvas) {
        if life > 0 {
            canvas.Disc(x, y, size, color);
        }
    }
}

// =============================================================================
// PARTICLE SYSTEM - Manages multiple particles
// =============================================================================

entity ParticleSystem {
    hide List[Particle] particles;

    expose func init() {
        particles = [];
    }

    expose func spawnBurst(x: Integer, y: Integer, count: Integer, color: Integer) {
        var i = 0;
        while i < count {
            var vx = Viper.Random.NextInt(11) - 5;
            var vy = Viper.Random.NextInt(11) - 5;
            if vx == 0 and vy == 0 {
                vx = 1;
            }
            var p = new Particle(x, y, vx, vy, color);
            particles.add(p);
            i = i + 1;
        }
    }

    expose func update() {
        var i = particles.length() - 1;
        while i >= 0 {
            var p = particles.get(i);
            p.update();
            // Remove dead particles by swapping with last and removing
            // For now, just let them accumulate (Zia doesn't have list remove)
            i = i - 1;
        }
    }

    expose func draw(canvas: Viper.Graphics.Canvas) {
        var i = 0;
        while i < particles.length() {
            var p = particles.get(i);
            if p.isAlive() {
                p.draw(canvas);
            }
            i = i + 1;
        }
    }

    expose func clear() {
        particles = [];
    }
}

// =============================================================================
// CREDITS SCREEN - Display game credits
// =============================================================================

func drawCredits(canvas: Viper.Graphics.Canvas) {
    canvas.Clear(COLOR_BLACK);

    var y = 80;
    canvas.Text(SCREEN_WIDTH / 2 - 60, y, "CREDITS", COLOR_YELLOW);

    y = y + 60;
    canvas.Text(SCREEN_WIDTH / 2 - 100, y, "PAC-MAN Clone", COLOR_WHITE);

    y = y + 40;
    canvas.Text(SCREEN_WIDTH / 2 - 120, y, "Written in Zia Language", COLOR_CYAN);

    y = y + 40;
    canvas.Text(SCREEN_WIDTH / 2 - 100, y, "Built with Viper VM", COLOR_CYAN);

    y = y + 60;
    canvas.Text(SCREEN_WIDTH / 2 - 140, y, "Original PAC-MAN by NAMCO 1980", COLOR_PINK);

    y = y + 60;
    canvas.Text(SCREEN_WIDTH / 2 - 80, y, "CONTROLS:", COLOR_YELLOW);

    y = y + 30;
    canvas.Text(SCREEN_WIDTH / 2 - 120, y, "Arrow Keys - Move", COLOR_WHITE);

    y = y + 25;
    canvas.Text(SCREEN_WIDTH / 2 - 120, y, "P - Pause", COLOR_WHITE);

    y = y + 25;
    canvas.Text(SCREEN_WIDTH / 2 - 120, y, "R - Restart", COLOR_WHITE);

    y = y + 25;
    canvas.Text(SCREEN_WIDTH / 2 - 120, y, "ESC - Menu/Quit", COLOR_WHITE);

    y = y + 60;
    canvas.Text(SCREEN_WIDTH / 2 - 80, y, "SCORING:", COLOR_YELLOW);

    y = y + 30;
    canvas.Text(100, y, "Dot: 10 pts", COLOR_WHITE);
    canvas.Text(350, y, "Power Pellet: 50 pts", COLOR_WHITE);

    y = y + 25;
    canvas.Text(100, y, "Ghost 1: 200 pts", COLOR_WHITE);
    canvas.Text(350, y, "Ghost 2: 400 pts", COLOR_WHITE);

    y = y + 25;
    canvas.Text(100, y, "Ghost 3: 800 pts", COLOR_WHITE);
    canvas.Text(350, y, "Ghost 4: 1600 pts", COLOR_WHITE);

    y = y + 40;
    canvas.Text(SCREEN_WIDTH / 2 - 140, y, "Press ENTER to return", COLOR_WHITE);
}

// =============================================================================
// HELPER FUNCTIONS
// =============================================================================

// Draw a life indicator (small Pac-Man icon)
func drawLifeIcon(canvas: Viper.Graphics.Canvas, x: Integer, y: Integer) {
    canvas.Disc(x, y, 8, COLOR_YELLOW);
    canvas.Triangle(x, y, x + 8, y - 4, x + 8, y + 4, COLOR_BLACK);
}

// Draw fruit icon for level indicator
func drawFruitIcon(canvas: Viper.Graphics.Canvas, x: Integer, y: Integer, level: Integer) {
    var fruitType = getFruitForLevel(level);
    var color = getFruitColor(fruitType);

    if fruitType == FRUIT_CHERRY {
        canvas.Disc(x - 2, y, 4, color);
        canvas.Disc(x + 2, y, 4, color);
        canvas.Line(x - 2, y - 4, x, y - 8, 0x00008800);
        canvas.Line(x + 2, y - 4, x, y - 8, 0x00008800);
    } else if fruitType == FRUIT_STRAWBERRY {
        canvas.Disc(x, y, 5, color);
        canvas.Box(x - 2, y - 5, 4, 2, 0x0000AA00);
    } else {
        canvas.Disc(x, y, 5, color);
    }
}

// Calculate ghost point value based on combo
func getGhostPoints(comboCount: Integer) -> Integer {
    if comboCount == 1 { return 200; }
    if comboCount == 2 { return 400; }
    if comboCount == 3 { return 800; }
    return 1600;
}

// =============================================================================
// ENTRY POINT
// =============================================================================

func start() {
    Viper.Terminal.Say("PAC-MAN - A Zia/Viper Game");
    Viper.Terminal.Say("Loading...");

    var game = new Game();
    game.init();

    Viper.Terminal.Say("Starting game!");
    game.run();

    Viper.Terminal.Say("Thanks for playing!");
}
