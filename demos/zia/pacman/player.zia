// =============================================================================
// PAC-MAN - Player Entity
// =============================================================================
// Uses new Viper runtime features:
// - Timer for mouth animation timing
// - Simplified movement with cleaner logic
// =============================================================================

module player;

bind Viper.Game;
bind Viper.Graphics;

bind "./config";
bind "./utils";
bind "./maze";

// =============================================================================
// PACMAN ENTITY - The player character
// =============================================================================

entity PacMan {
    hide Integer gridX;
    hide Integer gridY;
    hide Integer screenX;
    hide Integer screenY;
    hide Integer direction;
    hide Integer nextDirection;

    // Use Timer for mouth animation
    hide Timer mouthTimer;
    hide Boolean mouthOpen;

    expose func init(startX: Integer, startY: Integer) {
        gridX = startX;
        gridY = startY;
        screenX = utils.gridToScreenX(startX);
        screenY = utils.gridToScreenY(startY);
        direction = config.DIR_NONE;
        nextDirection = config.DIR_NONE;

        // Setup mouth animation timer (toggles every 5 frames)
        mouthTimer = Timer.New();
        mouthTimer.StartRepeating(5);
        mouthOpen = true;
    }

    expose func setNextDirection(dir: Integer) {
        nextDirection = dir;
    }

    expose func update(theMaze: maze.Maze) {
        // Update mouth animation
        if mouthTimer.Update() {
            mouthOpen = !mouthOpen;
        }

        var atGridX = utils.gridToScreenX(gridX);
        var atGridY = utils.gridToScreenY(gridY);

        // Check if we can change direction (only at tile center)
        if nextDirection != config.DIR_NONE && screenX == atGridX && screenY == atGridY {
            var nextDirX = utils.getDirX(nextDirection);
            var nextDirY = utils.getDirY(nextDirection);
            var nextGridX = self.wrapX(gridX + nextDirX);
            var nextGridY = gridY + nextDirY;

            if theMaze.isWalkable(nextGridX, nextGridY) {
                direction = nextDirection;
                nextDirection = config.DIR_NONE;
            }
        }

        // Move in current direction
        if direction != config.DIR_NONE {
            var dirX = utils.getDirX(direction);
            var dirY = utils.getDirY(direction);
            var targetGridX = self.wrapX(gridX + dirX);
            var targetGridY = gridY + dirY;

            // Handle tunnel wrap (instant teleport)
            if dirX != 0 && ((gridX == 0 && dirX < 0) || (gridX == config.GRID_WIDTH - 1 && dirX > 0)) {
                gridX = targetGridX;
                screenX = utils.gridToScreenX(gridX);
                return;
            }

            if theMaze.isWalkable(targetGridX, targetGridY) {
                var targetScreenX = utils.gridToScreenX(targetGridX);
                var targetScreenY = utils.gridToScreenY(targetGridY);

                // Move toward target
                if screenX < targetScreenX {
                    screenX = screenX + config.PACMAN_SPEED;
                    if screenX >= targetScreenX {
                        screenX = targetScreenX;
                        gridX = targetGridX;
                    }
                } else if screenX > targetScreenX {
                    screenX = screenX - config.PACMAN_SPEED;
                    if screenX <= targetScreenX {
                        screenX = targetScreenX;
                        gridX = targetGridX;
                    }
                }

                if screenY < targetScreenY {
                    screenY = screenY + config.PACMAN_SPEED;
                    if screenY >= targetScreenY {
                        screenY = targetScreenY;
                        gridY = targetGridY;
                    }
                } else if screenY > targetScreenY {
                    screenY = screenY - config.PACMAN_SPEED;
                    if screenY <= targetScreenY {
                        screenY = targetScreenY;
                        gridY = targetGridY;
                    }
                }
            } else {
                // Hit wall, stop and snap to grid
                direction = config.DIR_NONE;
                screenX = utils.gridToScreenX(gridX);
                screenY = utils.gridToScreenY(gridY);
            }
        }
    }

    hide func wrapX(x: Integer) -> Integer {
        if x < 0 {
            return config.GRID_WIDTH - 1;
        } else if x >= config.GRID_WIDTH {
            return 0;
        }
        return x;
    }

    expose func getGridX() -> Integer {
        return gridX;
    }

    expose func getGridY() -> Integer {
        return gridY;
    }

    expose func getScreenX() -> Integer {
        return screenX;
    }

    expose func getScreenY() -> Integer {
        return screenY;
    }

    expose func reset(startX: Integer, startY: Integer) {
        gridX = startX;
        gridY = startY;
        screenX = utils.gridToScreenX(startX);
        screenY = utils.gridToScreenY(startY);
        direction = config.DIR_NONE;
        nextDirection = config.DIR_NONE;
        mouthOpen = true;
        mouthTimer.Reset();
    }

    expose func draw(canvas: Canvas) {
        var centerX = screenX + config.TILE_SIZE / 2;
        var centerY = screenY + config.TILE_SIZE / 2;
        var radius = config.TILE_SIZE / 2 - 2;

        // Draw body
        canvas.Disc(centerX, centerY, radius, config.COLOR_YELLOW);

        // Draw mouth when open
        if mouthOpen {
            var mouthX1 = centerX;
            var mouthY1 = centerY;
            var mouthX2 = centerX;
            var mouthY2 = centerY;
            var mouthX3 = centerX;
            var mouthY3 = centerY;

            if direction == config.DIR_RIGHT || direction == config.DIR_NONE {
                mouthX2 = centerX + radius;
                mouthY2 = centerY - radius / 2;
                mouthX3 = centerX + radius;
                mouthY3 = centerY + radius / 2;
            } else if direction == config.DIR_LEFT {
                mouthX2 = centerX - radius;
                mouthY2 = centerY - radius / 2;
                mouthX3 = centerX - radius;
                mouthY3 = centerY + radius / 2;
            } else if direction == config.DIR_UP {
                mouthX2 = centerX - radius / 2;
                mouthY2 = centerY - radius;
                mouthX3 = centerX + radius / 2;
                mouthY3 = centerY - radius;
            } else if direction == config.DIR_DOWN {
                mouthX2 = centerX - radius / 2;
                mouthY2 = centerY + radius;
                mouthX3 = centerX + radius / 2;
                mouthY3 = centerY + radius;
            }

            canvas.Triangle(mouthX1, mouthY1, mouthX2, mouthY2, mouthX3, mouthY3, config.COLOR_BLACK);
        }
    }
}

