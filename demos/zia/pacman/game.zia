// =============================================================================
// PAC-MAN - Game Controller Entity
// =============================================================================
// Uses new Viper runtime features:
// - Manager for edge detection and debounced menu input
// - Timer for game timing (ready state, death, mode switching)
// - Tween for animations (ready text bounce)
// - SmoothValue for score counter animation
// - for-in range syntax for cleaner iteration
// =============================================================================

module game;

bind Viper.Graphics;
bind Viper.Input;
bind Viper.Game;
bind Viper.Time;
bind Viper.Fmt;

bind "./config";
bind "./utils";
bind "./maze";
bind "./player";
bind "./ghost";
bind "./fruit";

// =============================================================================
// GAME ENTITY - Main game controller
// =============================================================================

entity Game {
    hide Canvas canvas;
    hide Manager input;
    hide maze.Maze theMaze;
    hide player.PacMan pacman;
    hide List[ghost.Ghost] ghosts;
    hide fruit.Fruit theFruit;

    // Game state
    hide Integer score;
    hide Integer lives;
    hide Integer level;
    hide Integer highScore;
    hide Integer dotsEaten;
    hide Integer ghostsEaten;
    hide Boolean extraLifeAwarded;
    hide Integer gameState;
    hide Integer menuSelection;

    // Use Timers instead of manual counters
    hide Timer readyTimer;
    hide Timer deathTimer;
    hide Timer modeTimer;
    hide Boolean chaseMode;

    // Animations
    hide Tween readyTween;
    hide SmoothValue displayScore;

    // High scores list
    hide List[Integer] highScores;

    expose func init() {
        canvas = Canvas.New("PAC-MAN", config.SCREEN_WIDTH, config.SCREEN_HEIGHT);
        input = Manager.New();

        // Initialize game objects
        theMaze = new maze.Maze();
        theMaze.init();

        pacman = new player.PacMan(14, 23);

        ghosts = [];
        ghosts.add(new ghost.Ghost(0, 14, 11, config.COLOR_RED));    // Blinky
        ghosts.add(new ghost.Ghost(1, 13, 14, config.COLOR_PINK));   // Pinky
        ghosts.add(new ghost.Ghost(2, 14, 14, config.COLOR_CYAN));   // Inky
        ghosts.add(new ghost.Ghost(3, 15, 14, config.COLOR_ORANGE)); // Clyde

        theFruit = new fruit.Fruit();
        theFruit.init();

        // Initialize timers
        readyTimer = Timer.New();
        deathTimer = Timer.New();
        modeTimer = Timer.New();

        // Initialize animations
        readyTween = Tween.New();
        displayScore = SmoothValue.New(0.0, 900.0);

        // Initialize high scores
        highScores = [];
        highScores.add(10000);
        highScores.add(8000);
        highScores.add(6000);
        highScores.add(4000);
        highScores.add(2000);
        highScore = 10000;

        // Initialize state
        score = 0;
        lives = 3;
        level = 1;
        dotsEaten = 0;
        ghostsEaten = 0;
        extraLifeAwarded = false;
        gameState = config.STATE_MENU;
        menuSelection = 0;
        chaseMode = false;
    }

    // Helper functions for input (using canvas.KeyHeld directly)
    hide func isKeyHeld(key: Integer) -> Boolean {
        return canvas.KeyHeld(key) != 0;
    }

    hide func isKeyPressed(key: Integer) -> Boolean {
        // For "pressed" we use the InputManager's edge detection
        return input.KeyPressed(key);
    }

    hide func isUpHeld() -> Boolean {
        return self.isKeyHeld(config.KEY_UP) || self.isKeyHeld(config.KEY_W);
    }

    hide func isDownHeld() -> Boolean {
        return self.isKeyHeld(config.KEY_DOWN) || self.isKeyHeld(config.KEY_S);
    }

    hide func isLeftHeld() -> Boolean {
        return self.isKeyHeld(config.KEY_LEFT) || self.isKeyHeld(config.KEY_A);
    }

    hide func isRightHeld() -> Boolean {
        return self.isKeyHeld(config.KEY_RIGHT) || self.isKeyHeld(config.KEY_D);
    }

    hide func isConfirmPressed() -> Boolean {
        return self.isKeyPressed(config.KEY_ENTER) || self.isKeyPressed(config.KEY_SPACE);
    }

    hide func isCancelPressed() -> Boolean {
        return self.isKeyPressed(config.KEY_ESCAPE);
    }

    hide func isPausePressed() -> Boolean {
        return self.isKeyPressed(config.KEY_P);
    }

    hide func isRestartPressed() -> Boolean {
        return self.isKeyPressed(config.KEY_R);
    }

    expose func run() {
        var running = true;

        while running {
            canvas.Poll();
            input.Update();

            // Update smooth score display
            displayScore.Target = score * 1.0;
            displayScore.Update();

            // State-specific logic
            if gameState == config.STATE_MENU {
                running = self.updateMenu();
                self.renderMenu();
            } else if gameState == config.STATE_HIGHSCORES {
                self.updateHighScores();
                self.renderHighScores();
            } else if gameState == config.STATE_READY {
                self.updateReady();
                self.render();
            } else if gameState == config.STATE_PLAYING {
                self.updatePlaying();
                self.render();
            } else if gameState == config.STATE_PAUSED {
                self.updatePaused();
                self.render();
            } else if gameState == config.STATE_DYING {
                self.updateDying();
                self.render();
            } else if gameState == config.STATE_GAME_OVER {
                self.updateGameOver();
                self.render();
            } else if gameState == config.STATE_WIN {
                self.updateWin();
                self.render();
            }

            Viper.Time.SleepMs(config.FRAME_TIME);
        }
    }

    // =========================================================================
    // MENU STATE
    // =========================================================================

    hide func updateMenu() -> Boolean {
        // Menu navigation with debounced input
        if input.KeyPressedDebounced(config.KEY_UP) || input.KeyPressedDebounced(config.KEY_W) {
            menuSelection = menuSelection - 1;
            if menuSelection < 0 { menuSelection = 2; }
        }
        if input.KeyPressedDebounced(config.KEY_DOWN) || input.KeyPressedDebounced(config.KEY_S) {
            menuSelection = menuSelection + 1;
            if menuSelection > 2 { menuSelection = 0; }
        }

        // Selection
        if self.isConfirmPressed() {
            if menuSelection == 0 {
                // Start Game
                self.resetGame();
                self.startReady();
            } else if menuSelection == 1 {
                // High Scores
                gameState = config.STATE_HIGHSCORES;
            } else {
                // Quit
                return false;
            }
        }

        // Quick quit
        if self.isCancelPressed() {
            return false;
        }

        return true;
    }

    hide func renderMenu() {
        canvas.Clear(config.COLOR_BLACK);

        // Title
        canvas.Text(config.SCREEN_WIDTH / 2 - 80, 100, "PAC-MAN", config.COLOR_YELLOW);

        // Menu options with highlighting
        var startColor = config.COLOR_WHITE;
        var scoresColor = config.COLOR_WHITE;
        var quitColor = config.COLOR_WHITE;

        if menuSelection == 0 { startColor = config.COLOR_YELLOW; }
        if menuSelection == 1 { scoresColor = config.COLOR_YELLOW; }
        if menuSelection == 2 { quitColor = config.COLOR_YELLOW; }

        canvas.Text(config.SCREEN_WIDTH / 2 - 60, 250, "START GAME", startColor);
        canvas.Text(config.SCREEN_WIDTH / 2 - 60, 300, "HIGH SCORES", scoresColor);
        canvas.Text(config.SCREEN_WIDTH / 2 - 60, 350, "QUIT", quitColor);

        // High score display
        canvas.Text(config.SCREEN_WIDTH / 2 - 80, 450, "HIGH SCORE: " + Int(highScore), config.COLOR_CYAN);

        // Instructions
        canvas.Text(config.SCREEN_WIDTH / 2 - 120, 550, "Arrow Keys / WASD / D-Pad", config.COLOR_WHITE);
        canvas.Text(config.SCREEN_WIDTH / 2 - 100, 580, "ENTER / SPACE / A Button", config.COLOR_WHITE);

        // Decorative characters
        canvas.Disc(100, 200, 20, config.COLOR_YELLOW);
        canvas.Disc(config.SCREEN_WIDTH - 100, 200, 20, config.COLOR_RED);
        canvas.Disc(config.SCREEN_WIDTH - 150, 200, 20, config.COLOR_PINK);
        canvas.Disc(config.SCREEN_WIDTH - 200, 200, 20, config.COLOR_CYAN);
        canvas.Disc(config.SCREEN_WIDTH - 250, 200, 20, config.COLOR_ORANGE);

        canvas.Flip();
    }

    // =========================================================================
    // HIGH SCORES STATE
    // =========================================================================

    hide func updateHighScores() {
        if self.isConfirmPressed() || self.isCancelPressed() {
            gameState = config.STATE_MENU;
        }
    }

    hide func renderHighScores() {
        canvas.Clear(config.COLOR_BLACK);

        canvas.Text(config.SCREEN_WIDTH / 2 - 80, 100, "HIGH SCORES", config.COLOR_YELLOW);

        var y = 200;
        var rank = 1;
        for i in 0..highScores.length() {
            var scoreVal = highScores.get(i);
            var rankText = Int(rank) + ". " + Int(scoreVal);
            var color = config.COLOR_WHITE;
            if rank == 1 { color = config.COLOR_YELLOW; }
            if rank == 2 { color = config.COLOR_CYAN; }
            if rank == 3 { color = config.COLOR_PINK; }
            canvas.Text(config.SCREEN_WIDTH / 2 - 60, y, rankText, color);
            y = y + 40;
            rank = rank + 1;
        }

        canvas.Text(config.SCREEN_WIDTH / 2 - 100, 500, "Press any key to return", config.COLOR_WHITE);
        canvas.Flip();
    }

    hide func updateHighScoresList() {
        for i in 0..highScores.length() {
            if score > highScores.get(i) {
                // Shift scores down
                var j = highScores.length() - 1;
                while j > i {
                    highScores.set(j, highScores.get(j - 1));
                    j = j - 1;
                }
                highScores.set(i, score);
                if i == 0 {
                    highScore = score;
                }
                return;
            }
        }
    }

    // =========================================================================
    // READY STATE
    // =========================================================================

    hide func startReady() {
        readyTimer.Start(config.READY_DURATION);
        readyTween.StartI64(0, 100, 30, config.EASE_OUT_BOUNCE);
        gameState = config.STATE_READY;
    }

    hide func updateReady() {
        readyTimer.Update();
        readyTween.Update();

        if readyTimer.IsExpired {
            modeTimer.Start(config.MODE_SWITCH_TIME);
            chaseMode = false;
            gameState = config.STATE_PLAYING;
        }
    }

    // =========================================================================
    // PLAYING STATE
    // =========================================================================

    hide func updatePlaying() {
        // Handle pause
        if self.isPausePressed() {
            gameState = config.STATE_PAUSED;
            return;
        }

        // Handle movement input
        if self.isUpHeld() {
            pacman.setNextDirection(config.DIR_UP);
        } else if self.isDownHeld() {
            pacman.setNextDirection(config.DIR_DOWN);
        } else if self.isLeftHeld() {
            pacman.setNextDirection(config.DIR_LEFT);
        } else if self.isRightHeld() {
            pacman.setNextDirection(config.DIR_RIGHT);
        }

        // Update ghost mode timer
        if modeTimer.Update() {
            chaseMode = !chaseMode;
            modeTimer.Start(config.MODE_SWITCH_TIME);

            // Update ghost modes
            for i in 0..ghosts.length() {
                var g = ghosts.get(i);
                if g.getMode() != config.MODE_FRIGHTENED {
                    if chaseMode {
                        g.setMode(config.MODE_CHASE);
                    } else {
                        g.setMode(config.MODE_SCATTER);
                    }
                }
            }
        }

        // Update game objects
        pacman.update(theMaze);
        theFruit.update();

        // Check for dot eating
        var points = theMaze.eatDot(pacman.getGridX(), pacman.getGridY());
        if points > 0 {
            score = score + points;
            dotsEaten = dotsEaten + 1;

            // Spawn fruit at 70 and 170 dots
            if dotsEaten == 70 || dotsEaten == 170 {
                theFruit.spawn(level);
            }

            // Power pellet - frighten ghosts
            if points == config.PELLET_POINTS {
                ghostsEaten = 0;
                for i in 0..ghosts.length() {
                    var g = ghosts.get(i);
                    g.setMode(config.MODE_FRIGHTENED);
                }
            }
        }

        // Check fruit collection
        if theFruit.collidesWithPacman(pacman.getGridX(), pacman.getGridY()) {
            score = score + theFruit.collect();
        }

        // Extra life at 10000 points
        if score >= config.EXTRA_LIFE_SCORE && !extraLifeAwarded {
            lives = lives + 1;
            extraLifeAwarded = true;
        }

        // Update high score
        if score > highScore {
            highScore = score;
        }

        // Update ghosts
        var blinkyX = 0;
        var blinkyY = 0;
        if ghosts.length() > 0 {
            var blinky = ghosts.get(0);
            blinkyX = blinky.getGridX();
            blinkyY = blinky.getGridY();
        }

        for i in 0..ghosts.length() {
            var g = ghosts.get(i);
            g.update(theMaze, pacman.getGridX(), pacman.getGridY(), blinkyX, blinkyY);
        }

        // Check ghost collisions
        for i in 0..ghosts.length() {
            var g = ghosts.get(i);
            if g.collidesWithPacman(pacman.getGridX(), pacman.getGridY()) {
                if g.getMode() == config.MODE_FRIGHTENED {
                    // Eat ghost
                    ghostsEaten = ghostsEaten + 1;
                    var ghostPoints = config.GHOST_BASE_POINTS;
                    var mult = 1;
                    for j in 1..ghostsEaten {
                        mult = mult * 2;
                    }
                    score = score + ghostPoints * mult;
                    g.reset();
                } else {
                    // Pac-Man dies
                    self.pacmanDeath();
                    return;
                }
            }
        }

        // Check win condition
        if theMaze.allDotsEaten() {
            gameState = config.STATE_WIN;
        }
    }

    hide func pacmanDeath() {
        lives = lives - 1;

        if lives <= 0 {
            self.updateHighScoresList();
            gameState = config.STATE_GAME_OVER;
        } else {
            deathTimer.Start(config.DEATH_DURATION);
            gameState = config.STATE_DYING;
        }
    }

    // =========================================================================
    // DYING STATE
    // =========================================================================

    hide func updateDying() {
        deathTimer.Update();
        if deathTimer.IsExpired {
            pacman.reset(14, 23);
            for i in 0..ghosts.length() {
                var g = ghosts.get(i);
                g.reset();
            }
            self.startReady();
        }
    }

    // =========================================================================
    // PAUSED STATE
    // =========================================================================

    hide func updatePaused() {
        if self.isPausePressed() || self.isConfirmPressed() {
            gameState = config.STATE_PLAYING;
        }
        if self.isCancelPressed() {
            gameState = config.STATE_MENU;
        }
    }

    // =========================================================================
    // GAME OVER STATE
    // =========================================================================

    hide func updateGameOver() {
        if self.isRestartPressed() {
            self.resetGame();
            self.startReady();
        }
        if self.isCancelPressed() {
            gameState = config.STATE_MENU;
        }
    }

    // =========================================================================
    // WIN STATE
    // =========================================================================

    hide func updateWin() {
        if self.isRestartPressed() || self.isConfirmPressed() {
            self.nextLevel();
        }
        if self.isCancelPressed() {
            gameState = config.STATE_MENU;
        }
    }

    // =========================================================================
    // GAME RESET
    // =========================================================================

    hide func resetGame() {
        score = 0;
        lives = 3;
        level = 1;
        dotsEaten = 0;
        extraLifeAwarded = false;
        chaseMode = false;

        theMaze.reset();
        pacman.reset(14, 23);
        for i in 0..ghosts.length() {
            var g = ghosts.get(i);
            g.reset();
        }
        theFruit.reset();

        displayScore.SetImmediate(0.0);
    }

    hide func nextLevel() {
        level = level + 1;
        dotsEaten = 0;
        chaseMode = false;

        theMaze.reset();
        pacman.reset(14, 23);
        for i in 0..ghosts.length() {
            var g = ghosts.get(i);
            g.reset();
        }
        theFruit.reset();

        self.startReady();
    }

    // =========================================================================
    // RENDERING
    // =========================================================================

    hide func render() {
        canvas.Clear(config.COLOR_BLACK);

        // Draw game objects
        theMaze.draw(canvas);
        theFruit.draw(canvas);
        pacman.draw(canvas);

        for i in 0..ghosts.length() {
            var g = ghosts.get(i);
            g.draw(canvas);
        }

        // Draw UI
        self.drawUI();

        // Draw state overlays
        if gameState == config.STATE_READY {
            var tweenProgress = readyTween.Progress;
            var textY = config.SCREEN_HEIGHT / 2 - 10 + (100 - tweenProgress);
            canvas.Text(config.SCREEN_WIDTH / 2 - 40, textY, "READY!", config.COLOR_YELLOW);
        } else if gameState == config.STATE_PAUSED {
            canvas.Text(config.SCREEN_WIDTH / 2 - 40, config.SCREEN_HEIGHT / 2, "PAUSED", config.COLOR_YELLOW);
            canvas.Text(config.SCREEN_WIDTH / 2 - 70, config.SCREEN_HEIGHT / 2 + 30, "P to continue", config.COLOR_WHITE);
            canvas.Text(config.SCREEN_WIDTH / 2 - 70, config.SCREEN_HEIGHT / 2 + 60, "ESC for menu", config.COLOR_WHITE);
        } else if gameState == config.STATE_GAME_OVER {
            canvas.Text(config.SCREEN_WIDTH / 2 - 60, config.SCREEN_HEIGHT / 2, "GAME OVER", config.COLOR_RED);
            canvas.Text(config.SCREEN_WIDTH / 2 - 70, config.SCREEN_HEIGHT / 2 + 30, "R to restart", config.COLOR_WHITE);
            canvas.Text(config.SCREEN_WIDTH / 2 - 70, config.SCREEN_HEIGHT / 2 + 60, "ESC for menu", config.COLOR_WHITE);
        } else if gameState == config.STATE_WIN {
            canvas.Text(config.SCREEN_WIDTH / 2 - 80, config.SCREEN_HEIGHT / 2, "LEVEL COMPLETE!", config.COLOR_YELLOW);
            canvas.Text(config.SCREEN_WIDTH / 2 - 90, config.SCREEN_HEIGHT / 2 + 30, "R for next level", config.COLOR_WHITE);
        } else if gameState == config.STATE_DYING {
            canvas.Text(config.SCREEN_WIDTH / 2 - 40, config.SCREEN_HEIGHT / 2, "OUCH!", config.COLOR_RED);
        }

        canvas.Flip();
    }

    hide func drawUI() {
        // Use smooth score for display
        var displayScoreInt = displayScore.ValueI64;
        var scoreText = "SCORE: " + Int(displayScoreInt);
        canvas.Text(10, 5, scoreText, config.COLOR_WHITE);

        var levelText = "LEVEL: " + Int(level);
        canvas.Text(config.SCREEN_WIDTH / 2 - 40, 5, levelText, config.COLOR_WHITE);

        var livesText = "LIVES: " + Int(lives);
        canvas.Text(config.SCREEN_WIDTH - 100, 5, livesText, config.COLOR_WHITE);
    }
}

