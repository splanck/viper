// =============================================================================
// PAC-MAN - Maze Entity
// =============================================================================
// Uses new Viper runtime features:
// - Grid2D for 2D tile storage with bounds checking
// - Timer for pellet blink animation
// - for-in range syntax for cleaner iteration
// =============================================================================

module maze;

bind Viper.Game;
bind Viper.Graphics;
bind Viper.String;

bind "./config";
bind "./utils";

// =============================================================================
// MAZE ENTITY - The game board with walls, dots, and power pellets
// =============================================================================

entity Maze {
    hide Grid2D tiles;
    hide Integer totalDots;
    hide Integer dotsRemaining;

    // Use Timer for pellet blinking instead of manual counter
    hide Timer pelletBlinkTimer;
    hide Boolean pelletVisible;

    expose func init() {
        // Create Grid2D with dimensions and default value
        tiles = Grid2D.New(config.GRID_WIDTH, config.GRID_HEIGHT, config.TILE_EMPTY);
        totalDots = 0;
        dotsRemaining = 0;

        // Setup pellet blink timer (toggles every 10 frames)
        pelletBlinkTimer = Timer.New();
        pelletBlinkTimer.StartRepeating(10);
        pelletVisible = true;

        self.initializeMaze();
    }

    hide func initializeMaze() {
        // Classic Pac-Man maze layout (28x31)
        // 0=empty, 1=wall, 2=dot, 3=pellet, 4=gate
        self.setRow(0,  "1111111111111111111111111111");
        self.setRow(1,  "1222222222222112222222222221");
        self.setRow(2,  "1211112111112112111112111121");
        self.setRow(3,  "1311112111112112111112111131");
        self.setRow(4,  "1211112111112112111112111121");
        self.setRow(5,  "1222222222222222222222222221");
        self.setRow(6,  "1211112112111111112112111121");
        self.setRow(7,  "1211112112111111112112111121");
        self.setRow(8,  "1222222112222112222112222221");
        self.setRow(9,  "1111112111110110111112111111");
        self.setRow(10, "0000012111110110111112100000");
        self.setRow(11, "0000012110000000000112100000");
        self.setRow(12, "0000012110111441110112100000");
        self.setRow(13, "1111112110100000010112111111");
        self.setRow(14, "0000002000100000010002000000");
        self.setRow(15, "1111112110100000010112111111");
        self.setRow(16, "0000012110111111110112100000");
        self.setRow(17, "0000012110000000000112100000");
        self.setRow(18, "0000012110111111110112100000");
        self.setRow(19, "1111112110111111110112111111");
        self.setRow(20, "1222222222222112222222222221");
        self.setRow(21, "1211112111112112111112111121");
        self.setRow(22, "1211112111112112111112111121");
        self.setRow(23, "1322112222222002222222112231");
        self.setRow(24, "1112112112111111112112112111");
        self.setRow(25, "1112112112111111112112112111");
        self.setRow(26, "1222222112222112222112222221");
        self.setRow(27, "1211111111112112111111111121");
        self.setRow(28, "1211111111112112111111111121");
        self.setRow(29, "1222222222222222222222222221");
        self.setRow(30, "1111111111111111111111111111");

        self.countDots();
    }

    hide func setRow(row: Integer, pattern: String) {
        var patternLen = Length(pattern);
        for col in 0..config.GRID_WIDTH {
            if col >= patternLen {
                break;
            }
            var ch = Substring(pattern, col, 1);
            var tile = config.TILE_EMPTY;
            if ch == "1" {
                tile = config.TILE_WALL;
            } else if ch == "2" {
                tile = config.TILE_DOT;
            } else if ch == "3" {
                tile = config.TILE_PELLET;
            } else if ch == "4" {
                tile = config.TILE_GATE;
            }
            tiles.Set(col, row, tile);
        }
    }

    hide func countDots() {
        // Use Grid2D's Count method for efficiency
        totalDots = tiles.Count(config.TILE_DOT) + tiles.Count(config.TILE_PELLET);
        dotsRemaining = totalDots;
    }

    expose func getTile(x: Integer, y: Integer) -> Integer {
        if !tiles.InBounds(x, y) {
            return config.TILE_WALL;
        }
        return tiles.Get(x, y);
    }

    expose func setTile(x: Integer, y: Integer, value: Integer) {
        tiles.Set(x, y, value);
    }

    expose func isWall(x: Integer, y: Integer) -> Boolean {
        var tile = self.getTile(x, y);
        return tile == config.TILE_WALL || tile == config.TILE_GATE;
    }

    expose func isWalkable(x: Integer, y: Integer) -> Boolean {
        return !self.isWall(x, y);
    }

    // Ghosts can walk through gates to exit the ghost house
    expose func isWalkableForGhost(x: Integer, y: Integer) -> Boolean {
        var tile = self.getTile(x, y);
        return tile != config.TILE_WALL;
    }

    expose func eatDot(x: Integer, y: Integer) -> Integer {
        var tile = self.getTile(x, y);
        if tile == config.TILE_DOT {
            self.setTile(x, y, config.TILE_EMPTY);
            dotsRemaining = dotsRemaining - 1;
            return config.DOT_POINTS;
        } else if tile == config.TILE_PELLET {
            self.setTile(x, y, config.TILE_EMPTY);
            dotsRemaining = dotsRemaining - 1;
            return config.PELLET_POINTS;
        }
        return 0;
    }

    expose func getDotsRemaining() -> Integer {
        return dotsRemaining;
    }

    expose func allDotsEaten() -> Boolean {
        return dotsRemaining <= 0;
    }

    expose func reset() {
        tiles.Fill(config.TILE_EMPTY);
        self.initializeMaze();
    }

    expose func draw(canvas: Canvas) {
        // Update pellet blink timer
        if pelletBlinkTimer.Update() {
            pelletVisible = !pelletVisible;
        }

        for y in 0..config.GRID_HEIGHT {
            for x in 0..config.GRID_WIDTH {
                var tile = tiles.Get(x, y);
                var screenX = utils.gridToScreenX(x);
                var screenY = utils.gridToScreenY(y);

                if tile == config.TILE_WALL {
                    canvas.Box(screenX, screenY, config.TILE_SIZE, config.TILE_SIZE, config.COLOR_WALL);
                } else if tile == config.TILE_DOT {
                    var centerX = screenX + config.TILE_SIZE / 2;
                    var centerY = screenY + config.TILE_SIZE / 2;
                    canvas.Disc(centerX, centerY, 3, config.COLOR_DOT);
                } else if tile == config.TILE_PELLET {
                    // Power pellets blink using Timer
                    if pelletVisible {
                        var centerX = screenX + config.TILE_SIZE / 2;
                        var centerY = screenY + config.TILE_SIZE / 2;
                        canvas.Disc(centerX, centerY, 8, config.COLOR_PELLET);
                    }
                } else if tile == config.TILE_GATE {
                    canvas.Box(screenX, screenY + config.TILE_SIZE / 3, config.TILE_SIZE, config.TILE_SIZE / 3, config.COLOR_PINK);
                }
            }
        }
    }
}

