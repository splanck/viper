// =============================================================================
// PAC-MAN - Ghost Entity
// =============================================================================
// Uses new Viper runtime features:
// - Viper.Game.Timer for frightened mode countdown and flash animation
// - Cleaner AI targeting logic
// =============================================================================

module ghost;

bind "./config";
bind "./utils";
bind "./maze";

// Ghost type constants
final GHOST_BLINKY = 0;  // Red - targets Pac-Man directly
final GHOST_PINKY = 1;   // Pink - targets 4 tiles ahead of Pac-Man
final GHOST_INKY = 2;    // Cyan - complex targeting using Blinky position
final GHOST_CLYDE = 3;   // Orange - targets Pac-Man when far, scatter when close

// =============================================================================
// GHOST ENTITY - Enemy characters with AI
// =============================================================================

entity Ghost {
    hide Integer gridX;
    hide Integer gridY;
    hide Integer screenX;
    hide Integer screenY;
    hide Integer direction;
    hide Integer color;
    hide Integer mode;
    hide Integer ghostType;
    hide Integer homeX;
    hide Integer homeY;
    hide Integer scatterX;
    hide Integer scatterY;
    hide Boolean atTileCenter;
    hide Boolean inHouse;  // True if ghost is still in the ghost house

    // Use Timers for frightened mode
    hide Viper.Game.Timer frightenedTimer;
    hide Viper.Game.Timer flashTimer;
    hide Viper.Game.Timer exitTimer;  // Delay before exiting house
    hide Boolean flashWhite;

    expose func init(gType: Integer, startX: Integer, startY: Integer, ghostColor: Integer) {
        ghostType = gType;
        gridX = startX;
        gridY = startY;
        screenX = utils.gridToScreenX(startX);
        screenY = utils.gridToScreenY(startY);
        direction = config.DIR_UP;
        color = ghostColor;
        mode = config.MODE_SCATTER;
        homeX = startX;
        homeY = startY;
        atTileCenter = true;

        // Blinky starts outside, others start in the ghost house
        inHouse = (ghostType != GHOST_BLINKY);

        // Set scatter corner based on ghost type
        if ghostType == GHOST_BLINKY {
            scatterX = config.GRID_WIDTH - 3;
            scatterY = 0;
        } else if ghostType == GHOST_PINKY {
            scatterX = 2;
            scatterY = 0;
        } else if ghostType == GHOST_INKY {
            scatterX = config.GRID_WIDTH - 1;
            scatterY = config.GRID_HEIGHT - 1;
        } else {
            scatterX = 0;
            scatterY = config.GRID_HEIGHT - 1;
        }

        // Setup frightened timer
        frightenedTimer = Viper.Game.Timer.New();

        // Setup flash timer (toggles every 10 frames when about to end)
        flashTimer = Viper.Game.Timer.New();
        flashTimer.StartRepeating(10);
        flashWhite = false;

        // Setup exit timer - stagger ghost exits
        exitTimer = Viper.Game.Timer.New();
        if ghostType == GHOST_PINKY {
            exitTimer.Start(60);   // Pinky exits after 1 second
        } else if ghostType == GHOST_INKY {
            exitTimer.Start(180);  // Inky exits after 3 seconds
        } else if ghostType == GHOST_CLYDE {
            exitTimer.Start(300);  // Clyde exits after 5 seconds
        }
    }

    expose func setMode(newMode: Integer) {
        if newMode == config.MODE_FRIGHTENED {
            frightenedTimer.Start(config.FRIGHTENED_DURATION);
            direction = utils.getOppositeDirection(direction);
            flashWhite = false;
        } else {
            frightenedTimer.Stop();
        }
        mode = newMode;
    }

    expose func getMode() -> Integer {
        return mode;
    }

    expose func update(theMaze: maze.Maze, pacmanX: Integer, pacmanY: Integer, blinkyX: Integer, blinkyY: Integer) {
        // Update exit timer for ghosts in house
        if inHouse {
            exitTimer.Update();
        }

        // Update frightened mode
        if mode == config.MODE_FRIGHTENED {
            frightenedTimer.Update();

            // Flash when about to end (last 2 seconds = 120 frames)
            if frightenedTimer.Remaining < 120 {
                if flashTimer.Update() {
                    flashWhite = !flashWhite;
                }
            }

            if frightenedTimer.IsExpired {
                mode = config.MODE_CHASE;
            }
        }

        // Check if at tile center
        var tileScreenX = utils.gridToScreenX(gridX);
        var tileScreenY = utils.gridToScreenY(gridY);
        atTileCenter = (screenX == tileScreenX) && (screenY == tileScreenY);

        // Check if ghost has exited the house (reached row 11 or above)
        if inHouse && gridY <= 11 {
            inHouse = false;
        }

        // Choose direction at tile centers
        if atTileCenter {
            var targetX = scatterX;
            var targetY = scatterY;

            // If in house and timer expired, target the exit
            if inHouse {
                if exitTimer.IsExpired {
                    // Target exit point (above the gate)
                    targetX = 14;
                    targetY = 11;
                } else {
                    // Stay in place or bob up and down
                    targetX = gridX;
                    targetY = gridY;
                }
            } else if mode == config.MODE_CHASE {
                if ghostType == GHOST_BLINKY {
                    // Blinky targets Pac-Man directly
                    targetX = pacmanX;
                    targetY = pacmanY;
                } else if ghostType == GHOST_PINKY {
                    // Pinky targets 4 tiles ahead of Pac-Man
                    targetX = pacmanX;
                    targetY = pacmanY - 4;
                    if targetY < 0 { targetY = 0; }
                } else if ghostType == GHOST_INKY {
                    // Inky uses vector from Blinky through 2 tiles ahead of Pac-Man
                    var aheadX = pacmanX;
                    var aheadY = pacmanY - 2;
                    targetX = aheadX + (aheadX - blinkyX);
                    targetY = aheadY + (aheadY - blinkyY);
                } else {
                    // Clyde targets Pac-Man when far, scatter corner when close
                    var dist = utils.manhattanDistance(gridX, gridY, pacmanX, pacmanY);
                    if dist > 8 {
                        targetX = pacmanX;
                        targetY = pacmanY;
                    }
                    // Otherwise uses scatterX/scatterY
                }
            } else if mode == config.MODE_FRIGHTENED {
                // Random target when frightened
                targetX = Viper.Random.NextInt(config.GRID_WIDTH);
                targetY = Viper.Random.NextInt(config.GRID_HEIGHT);
            }

            self.chooseDirection(targetX, targetY, theMaze);
        }

        self.move(theMaze);
    }

    hide func chooseDirection(targetX: Integer, targetY: Integer, theMaze: maze.Maze) {
        var bestDir = direction;
        var bestDist = 999999;
        var oppositeDir = utils.getOppositeDirection(direction);

        // Check all four directions in order: UP, LEFT, DOWN, RIGHT (tie-breaker order)
        var dirs = [config.DIR_UP, config.DIR_LEFT, config.DIR_DOWN, config.DIR_RIGHT];
        for i in 0..4 {
            var testDir = dirs.get(i);

            // Can't reverse direction (unless in house)
            if testDir == oppositeDir && !inHouse {
                continue;
            }

            var dirX = utils.getDirX(testDir);
            var dirY = utils.getDirY(testDir);
            var nextX = self.wrapX(gridX + dirX);
            var nextY = gridY + dirY;

            // Ghosts can walk through gates
            if theMaze.isWalkableForGhost(nextX, nextY) {
                var dist = utils.manhattanDistance(nextX, nextY, targetX, targetY);
                if dist < bestDist {
                    bestDist = dist;
                    bestDir = testDir;
                }
            }
        }

        // If no valid direction found (stuck), allow reverse
        if bestDist == 999999 {
            var dirX = utils.getDirX(oppositeDir);
            var dirY = utils.getDirY(oppositeDir);
            var nextX = self.wrapX(gridX + dirX);
            var nextY = gridY + dirY;
            if theMaze.isWalkableForGhost(nextX, nextY) {
                bestDir = oppositeDir;
            }
        }

        direction = bestDir;
    }

    hide func move(theMaze: maze.Maze) {
        var moveX = utils.getDirX(direction);
        var moveY = utils.getDirY(direction);
        var nextGridX = self.wrapX(gridX + moveX);
        var nextGridY = gridY + moveY;

        // Handle tunnel wrap
        if moveX != 0 && ((gridX == 0 && moveX < 0) || (gridX == config.GRID_WIDTH - 1 && moveX > 0)) {
            gridX = nextGridX;
            screenX = utils.gridToScreenX(nextGridX);
            return;
        }

        // Ghosts can walk through gates
        if theMaze.isWalkableForGhost(nextGridX, nextGridY) {
            var targetScreenX = utils.gridToScreenX(nextGridX);
            var targetScreenY = utils.gridToScreenY(nextGridY);

            if screenX < targetScreenX {
                screenX = screenX + config.GHOST_SPEED;
                if screenX >= targetScreenX {
                    screenX = targetScreenX;
                    gridX = nextGridX;
                }
            } else if screenX > targetScreenX {
                screenX = screenX - config.GHOST_SPEED;
                if screenX <= targetScreenX {
                    screenX = targetScreenX;
                    gridX = nextGridX;
                }
            }

            if screenY < targetScreenY {
                screenY = screenY + config.GHOST_SPEED;
                if screenY >= targetScreenY {
                    screenY = targetScreenY;
                    gridY = nextGridY;
                }
            } else if screenY > targetScreenY {
                screenY = screenY - config.GHOST_SPEED;
                if screenY <= targetScreenY {
                    screenY = targetScreenY;
                    gridY = nextGridY;
                }
            }
        }
    }

    hide func wrapX(x: Integer) -> Integer {
        if x < 0 {
            return config.GRID_WIDTH - 1;
        } else if x >= config.GRID_WIDTH {
            return 0;
        }
        return x;
    }

    expose func getGridX() -> Integer {
        return gridX;
    }

    expose func getGridY() -> Integer {
        return gridY;
    }

    expose func getScreenX() -> Integer {
        return screenX;
    }

    expose func getScreenY() -> Integer {
        return screenY;
    }

    expose func collidesWithPacman(pacmanX: Integer, pacmanY: Integer) -> Boolean {
        return gridX == pacmanX && gridY == pacmanY;
    }

    expose func reset() {
        gridX = homeX;
        gridY = homeY;
        screenX = utils.gridToScreenX(homeX);
        screenY = utils.gridToScreenY(homeY);
        direction = config.DIR_UP;
        mode = config.MODE_SCATTER;
        atTileCenter = true;
        frightenedTimer.Stop();
        flashWhite = false;

        // Reset house state
        inHouse = (ghostType != GHOST_BLINKY);
        if ghostType == GHOST_PINKY {
            exitTimer.Start(60);
        } else if ghostType == GHOST_INKY {
            exitTimer.Start(180);
        } else if ghostType == GHOST_CLYDE {
            exitTimer.Start(300);
        }
    }

    expose func draw(canvas: Viper.Graphics.Canvas) {
        var centerX = screenX + config.TILE_SIZE / 2;
        var centerY = screenY + config.TILE_SIZE / 2;
        var radius = config.TILE_SIZE / 2 - 2;

        // Determine draw color
        var drawColor = color;
        if mode == config.MODE_FRIGHTENED {
            if frightenedTimer.Remaining < 120 && flashWhite {
                drawColor = config.COLOR_WHITE;
            } else {
                drawColor = config.COLOR_BLUE;
            }
        }

        // Ghost body (semicircle + rectangle)
        canvas.Disc(centerX, centerY - 2, radius, drawColor);
        canvas.Box(screenX + 2, centerY - 2, config.TILE_SIZE - 4, radius, drawColor);

        // Eyes (not shown when frightened)
        if mode != config.MODE_FRIGHTENED {
            var eyeOffset = 4;
            canvas.Disc(centerX - eyeOffset, centerY - 4, 4, config.COLOR_WHITE);
            canvas.Disc(centerX + eyeOffset, centerY - 4, 4, config.COLOR_WHITE);

            // Pupils look in movement direction
            var pupilOffsetX = 0;
            var pupilOffsetY = 0;
            if direction == config.DIR_LEFT { pupilOffsetX = -2; }
            else if direction == config.DIR_RIGHT { pupilOffsetX = 2; }
            else if direction == config.DIR_UP { pupilOffsetY = -2; }
            else if direction == config.DIR_DOWN { pupilOffsetY = 2; }

            canvas.Disc(centerX - eyeOffset + pupilOffsetX, centerY - 4 + pupilOffsetY, 2, config.COLOR_BLUE);
            canvas.Disc(centerX + eyeOffset + pupilOffsetX, centerY - 4 + pupilOffsetY, 2, config.COLOR_BLUE);
        } else {
            // Frightened face - simple dots for eyes
            canvas.Disc(centerX - 4, centerY - 3, 2, config.COLOR_WHITE);
            canvas.Disc(centerX + 4, centerY - 3, 2, config.COLOR_WHITE);
        }
    }
}

