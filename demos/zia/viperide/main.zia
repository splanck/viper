module viperide;

bind "app_shell";
bind "core/document";
bind "core/document_manager";
bind "core/project";
bind "core/project_manager";
bind "core/settings";
bind "editor/editor_engine";
bind "editor/editor_tabs";
bind "editor/completion";
bind "services/file_utils";
bind "build/build_system";

bind Viper.GUI;
bind IO = Viper.IO;
bind Path = Viper.IO.Path;
bind Dir = Viper.IO.Dir;
bind Input = Viper.Input;
bind Exec = Viper.Exec;
bind Convert = Viper.Core.Convert;
bind Str = Viper.String;

// ============================================================================
// ViperIDE — main entry point
// ============================================================================
// Creates the UI shell, sets up components, and runs the event loop.
// Professional IDE layout with MenuBar, Toolbar, SplitPane, StatusBar.
// ============================================================================

// Window dimensions
var WIN_WIDTH = 1280;
var WIN_HEIGHT = 800;

func main() {
    // ========================================================================
    // Initialize components
    // ========================================================================
    var shell = new app_shell.AppShell();
    var docMgr = new document_manager.DocumentManager();
    var engine = new editor_engine.EditorEngine();
    var tabs = new editor_tabs.EditorTabs();
    var projMgr = new project_manager.ProjectManager();
    var buildSys = new build_system.BuildSystem();

    // Build the UI shell
    shell.Build("ViperIDE", WIN_WIDTH, WIN_HEIGHT);

    // Resize window to 80% of the monitor and center it
    shell.CenterAndSize(80);

    // Setup editor inside editorRow (the HBox for editor + minimap side by side)
    engine.Setup(shell.editorRow);

    // Setup IntelliSense completion controller
    var completer = new completion.CompletionController();
    completer.Setup(engine.editor, shell.app);

    // Create minimap in the right side of editorRow and bind it to the editor
    shell.minimap = GUI.Minimap.New(shell.editorRow);
    shell.minimap.SetWidth(100);
    shell.minimap.BindEditor(engine.editor);

    // Setup tab bar
    tabs.Setup(shell.tabBar);

    // Setup project manager with the sidebar tree
    projMgr.Setup(shell.sidebarTree);

    // ========================================================================
    // Register keyboard shortcuts
    // ========================================================================
    Shortcuts.Register("new",       "Ctrl+N",       "New File");
    Shortcuts.Register("open",      "Ctrl+O",       "Open File");
    Shortcuts.Register("save",      "Ctrl+S",       "Save File");
    Shortcuts.Register("saveall",   "Ctrl+Shift+S", "Save All Files");
    Shortcuts.Register("close",     "Ctrl+W",       "Close File");
    Shortcuts.Register("reload",    "Ctrl+Shift+R", "Reload File");
    Shortcuts.Register("togglesidebar", "Ctrl+B",   "Toggle Sidebar");
    Shortcuts.Register("build",     "Ctrl+Shift+B", "Build");
    Shortcuts.Register("buildrun",  "F5",           "Build and Run");
    Shortcuts.Register("run",       "Ctrl+F5",      "Run without Build");
    Shortcuts.Register("find",      "Ctrl+F",       "Find / Replace");
    Shortcuts.Register("goto",      "Ctrl+G",       "Go To Line");
    Shortcuts.Register("palette",   "Ctrl+Shift+P", "Command Palette");
    Shortcuts.Register("zoomin",      "Ctrl+=",       "Zoom In");
    Shortcuts.Register("zoomout",     "Ctrl+-",       "Zoom Out");
    Shortcuts.Register("zoomreset",   "Ctrl+0",       "Reset Zoom");
    Shortcuts.Register("toggletheme", "Ctrl+Shift+T", "Toggle Theme");
    Shortcuts.Register("fullscreen",  "F11",          "Toggle Fullscreen");
    Shortcuts.Register("minimap",     "Ctrl+Shift+M", "Toggle Minimap");
    Shortcuts.Register("settings",    "Ctrl+,",       "Settings");
    Shortcuts.Register("completion_trigger",  "Ctrl+Space", "Trigger Completion");
    Shortcuts.Register("completion_accept",   "Tab",        "Accept Completion");
    Shortcuts.Register("completion_dismiss",  "Escape",     "Dismiss Completion");
    Shortcuts.Register("completion_down",     "Down",       "Next Completion Item");
    Shortcuts.Register("completion_up",       "Up",         "Prev Completion Item");

    // ========================================================================
    // Register command palette commands
    // ========================================================================
    shell.commandPalette.AddCommandWithShortcut("new",       "New File",          "Create a new untitled file",      "Ctrl+N");
    shell.commandPalette.AddCommandWithShortcut("open",      "Open File...",      "Open a file from disk",           "Ctrl+O");
    shell.commandPalette.AddCommandWithShortcut("save",      "Save",              "Save the current file",           "Ctrl+S");
    shell.commandPalette.AddCommandWithShortcut("saveall",   "Save All",          "Save all open files",             "Ctrl+Shift+S");
    shell.commandPalette.AddCommandWithShortcut("close",     "Close File",        "Close the current tab",           "Ctrl+W");
    shell.commandPalette.AddCommandWithShortcut("reload",    "Reload File",       "Reload file from disk",           "Ctrl+Shift+R");
    shell.commandPalette.AddCommandWithShortcut("find",      "Find / Replace",    "Open the find bar",               "Ctrl+F");
    shell.commandPalette.AddCommandWithShortcut("goto",      "Go To Line",        "Jump to a specific line number",  "Ctrl+G");
    shell.commandPalette.AddCommandWithShortcut("build",     "Build",             "Compile the current file",        "Ctrl+Shift+B");
    shell.commandPalette.AddCommandWithShortcut("buildrun",  "Build and Run",     "Build and run the current file",  "F5");
    shell.commandPalette.AddCommandWithShortcut("run",       "Run without Build", "Run without compiling first",     "Ctrl+F5");
    shell.commandPalette.AddCommandWithShortcut("sidebar",   "Toggle Sidebar",    "Show or hide the file tree",      "Ctrl+B");
    shell.commandPalette.AddCommandWithShortcut("statusbar", "Toggle Status Bar", "Show or hide the status bar",     "");
    shell.commandPalette.AddCommandWithShortcut("zoomin",      "Zoom In",           "Increase editor font size",           "Ctrl+=");
    shell.commandPalette.AddCommandWithShortcut("zoomout",     "Zoom Out",          "Decrease editor font size",           "Ctrl+-");
    shell.commandPalette.AddCommandWithShortcut("zoomreset",   "Reset Zoom",        "Reset editor font size to default",   "Ctrl+0");
    shell.commandPalette.AddCommandWithShortcut("toggletheme", "Toggle Theme",      "Switch between dark and light theme", "Ctrl+Shift+T");
    shell.commandPalette.AddCommandWithShortcut("fullscreen",  "Toggle Fullscreen", "Enter or exit fullscreen mode",       "F11");
    shell.commandPalette.AddCommandWithShortcut("minimap",     "Toggle Minimap",    "Show or hide the minimap panel",      "Ctrl+Shift+M");
    shell.commandPalette.AddCommandWithShortcut("settings",    "Settings",          "View and adjust IDE settings",        "Ctrl+,");

    // ========================================================================
    // Create welcome document
    // ========================================================================
    var welcomeText = "// Welcome to ViperIDE!\n";
    welcomeText = welcomeText + "// A full-featured IDE for Zia and Viper Basic\n";
    welcomeText = welcomeText + "\n";
    welcomeText = welcomeText + "func main() {\n";
    welcomeText = welcomeText + "    Viper.Terminal.Say(\"Hello from ViperIDE!\");\n";
    welcomeText = welcomeText + "}\n";

    var welcomeDoc = docMgr.NewDocument();
    welcomeDoc.content = welcomeText;
    tabs.AddTab(welcomeDoc.fileName, 1);
    tabs.SetActive(0);
    engine.LoadDocument(welcomeDoc);

    shell.SetStatusLeft("Ready");
    shell.SetStatusCenter("Ln 1, Col 1  |  Lines: " + engine.GetLineCount());
    shell.SetStatusRight(DocStatusLabel(welcomeDoc));

    // Wire the find bar to the editor (enables Find/Replace to search in editor)
    shell.findBar.BindEditor(engine.editor);

    // ========================================================================
    // Load persistent settings and apply them
    // ========================================================================
    var appSettings = new settings.SettingsManager();
    appSettings.Load();
    shell.app.SetFontSize(appSettings.fontSize);
    engine.editor.SetFontSize(appSettings.fontSize);
    appSettings.ApplyTheme();
    if appSettings.minimapVisible == false {
        shell.minimap.SetVisible(0);
    }

    // File watcher — tracks whether the active file was modified externally.
    // hasWatcher is false until the first non-new document is active.
    var watchedPath = "";
    var hasWatcher = false;
    var fileWatcher = IO.Watcher.New(".");

    // True when an external modification to the active file is pending reload.
    var pendingReload = false;

    // ========================================================================
    // Main event loop
    // ========================================================================
    var loopCount = 0;
    var cpSelected = "";   // command palette selection for this frame
    var ctxDir = "";       // directory targeted by the last tree right-click
    var minimapVisible = appSettings.minimapVisible;   // tracks minimap panel visibility

    // Cursor tracking for dot-trigger and completion auto-dismiss
    var prevCursorLine = 1;
    var prevCursorCol  = 1;

    while shell != null and shell.ShouldClose() == false {
        loopCount = loopCount + 1;
        shell.Poll();

        // ====================================================================
        // Code Completion — IntelliSense popup
        // ====================================================================
        completer.Update();

        // Keyboard shortcuts for completion navigation
        if completer.isVisible {
            if Shortcuts.WasTriggered("completion_accept") != 0 {
                completer.AcceptSelected();
            } else if Shortcuts.WasTriggered("completion_dismiss") != 0 {
                completer.Hide();
            } else if Shortcuts.WasTriggered("completion_down") != 0 {
                completer.NavigateDown();
            } else if Shortcuts.WasTriggered("completion_up") != 0 {
                completer.NavigateUp();
            }
        }

        // Ctrl+Space always triggers (even when popup is open, to refresh)
        if Shortcuts.WasTriggered("completion_trigger") != 0 {
            completer.TriggerCompletion();
        }

        // Dot trigger: detect when '.' is typed (cursor advances 1 col, same line)
        var curCursorLine = engine.GetCursorLine();
        var curCursorCol  = engine.GetCursorCol();
        if curCursorLine == prevCursorLine and curCursorCol == prevCursorCol + 1 {
            if curCursorCol >= 2 {
                var dotLineText = engine.editor.GetLine(curCursorLine - 1);
                // Str.MidLen uses 1-based start; char just typed is at col curCursorCol-1
                if Str.MidLen(dotLineText, curCursorCol - 1, 1) == "." {
                    completer.TriggerCompletion();
                }
            }
        }
        prevCursorLine = curCursorLine;
        prevCursorCol  = curCursorCol;

        // ====================================================================
        // Command Palette — check selection and show on Ctrl+Shift+P
        // ====================================================================
        cpSelected = "";
        if shell.commandPalette.WasSelected() != 0 {
            cpSelected = shell.commandPalette.GetSelected();
        }
        if Shortcuts.WasTriggered("palette") != 0 {
            shell.commandPalette.Show();
        }

        // ====================================================================
        // Context menu — right-click on the file tree
        // ====================================================================
        if Input.Mouse.WasClicked(1) {
            if shell.sidebarTree.IsHovered() != 0 {
                // Determine which directory to use for New File / New Folder.
                // Default to root; override from the currently selected tree node.
                ctxDir = projMgr.project.rootPath;
                var ctxNode = shell.sidebarTree.GetSelected();
                if ctxNode != null {
                    var nodePath = GUI.TreeView.Node.GetData(ctxNode);
                    var nodeLabel = GUI.TreeView.Node.GetText(ctxNode);
                    if Str.IndexOf(nodeLabel, "[D] ") == 1 {
                        ctxDir = nodePath;   // directory node — use it directly
                    } else {
                        ctxDir = Path.Dir(nodePath);  // file node — use its parent
                    }
                }
                shell.treeContextMenu.Show(Input.Mouse.X, Input.Mouse.Y);
            }
        }
        if shell.ctxOpen.WasClicked() != 0 {
            // Same action as a tree left-click — handled below via projMgr
        }
        if shell.ctxReveal.WasClicked() != 0 {
            var revealDoc = docMgr.GetActive();
            if revealDoc != null and revealDoc.isNew == false {
                Exec.Shell("open -R \"" + revealDoc.filePath + "\"");
            }
        }
        if shell.ctxNewFile.WasClicked() != 0 {
            if ctxDir != "" {
                var newName = GUI.MessageBox.Prompt("New File", "Enter file name:");
                if newName != "" {
                    var newFilePath = Path.Join(ctxDir, newName);
                    IO.File.Touch(newFilePath);
                    projMgr.RefreshTree();
                    GUI.Toast.Success("Created: " + newName);
                }
            }
        }
        if shell.ctxNewFolder.WasClicked() != 0 {
            if ctxDir != "" {
                var folderName = GUI.MessageBox.Prompt("New Folder", "Enter folder name:");
                if folderName != "" {
                    var newFolderPath = Path.Join(ctxDir, folderName);
                    Dir.Make(newFolderPath);
                    projMgr.RefreshTree();
                    GUI.Toast.Success("Created folder: " + folderName);
                }
            }
        }

        // ====================================================================
        // Handle New File (menu, toolbar, Ctrl+N, or CommandPalette)
        // ====================================================================
        var doNew = shell.miNew.WasClicked() != 0;
        if doNew == false {
            doNew = shell.tbNew.WasClicked() != 0;
        }
        if doNew == false {
            doNew = Shortcuts.WasTriggered("new") != 0;
        }
        if doNew == false {
            doNew = cpSelected == "new";
        }
        if doNew {
            SaveEditorState(docMgr, engine);

            var newDoc = docMgr.NewDocument();
            tabs.AddTab(newDoc.fileName, 1);
            tabs.SetActive(docMgr.activeIndex);
            engine.LoadDocument(newDoc);

            shell.breadcrumb.SetPath("", "/");
            shell.SetStatusLeft("New file created");
            shell.SetStatusRight(DocStatusLabel(newDoc));
            pendingReload = false;
        }

        // ====================================================================
        // Handle Open File (menu, toolbar, Ctrl+O, or CommandPalette)
        // ====================================================================
        var doOpen = shell.miOpen.WasClicked() != 0;
        if doOpen == false {
            doOpen = shell.tbOpen.WasClicked() != 0;
        }
        if doOpen == false {
            doOpen = Shortcuts.WasTriggered("open") != 0;
        }
        if doOpen == false {
            doOpen = cpSelected == "open";
        }
        if doOpen {
            var path = FileDialog.Open("Open File", "*.zia;*.bas;*.txt", "");
            if path != "" {
                SaveEditorState(docMgr, engine);

                var prevCount = docMgr.GetCount();
                var openDoc = docMgr.OpenFile(path);

                if docMgr.GetCount() > prevCount {
                    tabs.AddTab(openDoc.fileName, 1);
                }
                tabs.SetActive(docMgr.activeIndex);
                engine.LoadDocument(openDoc);

                shell.breadcrumb.SetPath(openDoc.filePath, "/");
                shell.SetStatusLeft("Opened: " + openDoc.fileName);
                shell.SetStatusRight(DocStatusLabel(openDoc));
                pendingReload = false;
            }
        }

        // ====================================================================
        // Handle Open Folder (menu item)
        // ====================================================================
        if shell.miOpenFolder.WasClicked() != 0 {
            var folderPath = FileDialog.SelectFolder("Open Folder", "");
            if folderPath != "" {
                projMgr.OpenFolder(folderPath);
                shell.SetStatusLeft("Opened project: " + projMgr.project.name);
            }
        }

        // ====================================================================
        // Handle file tree clicks — open selected file
        // ====================================================================
        var treeSelectedPath = projMgr.HandleTreeClicks();
        if treeSelectedPath != "" {
            SaveEditorState(docMgr, engine);

            var prevCount = docMgr.GetCount();
            var treeOpenDoc = docMgr.OpenFile(treeSelectedPath);

            if docMgr.GetCount() > prevCount {
                tabs.AddTab(treeOpenDoc.fileName, 1);
            }
            tabs.SetActive(docMgr.activeIndex);
            engine.LoadDocument(treeOpenDoc);

            shell.breadcrumb.SetPath(treeOpenDoc.filePath, "/");
            shell.SetStatusLeft("Opened: " + treeOpenDoc.fileName);
            shell.SetStatusRight(DocStatusLabel(treeOpenDoc));
            pendingReload = false;
        }

        // ====================================================================
        // Handle Save (menu, toolbar, Ctrl+S, or CommandPalette)
        // ====================================================================
        var doSave = shell.miSave.WasClicked() != 0;
        if doSave == false {
            doSave = shell.tbSave.WasClicked() != 0;
        }
        if doSave == false {
            doSave = Shortcuts.WasTriggered("save") != 0;
        }
        if doSave == false {
            doSave = cpSelected == "save";
        }
        if doSave {
            SaveEditorState(docMgr, engine);
            var saveDoc = docMgr.GetActive();
            if saveDoc != null {
                if saveDoc.isNew {
                    var savePath = FileDialog.Save(
                        "Save File", "*.zia", saveDoc.fileName, "");
                    if savePath != "" {
                        docMgr.SaveAs(savePath);
                        tabs.SetTitle(docMgr.activeIndex, saveDoc.fileName);
                        tabs.SetModified(docMgr.activeIndex, false);
                        engine.ClearModified();
                        shell.breadcrumb.SetPath(saveDoc.filePath, "/");
                        shell.SetStatusLeft("Saved: " + saveDoc.fileName);
                        shell.SetStatusRight(DocStatusLabel(saveDoc));
                        GUI.Toast.Success("Saved: " + saveDoc.fileName);
                    }
                } else {
                    docMgr.SaveActive();
                    tabs.SetModified(docMgr.activeIndex, false);
                    engine.ClearModified();
                    pendingReload = false;
                    shell.SetStatusLeft("Saved: " + saveDoc.fileName);
                    GUI.Toast.Success("Saved: " + saveDoc.fileName);
                }
            }
        }

        // ====================================================================
        // Handle Save As (menu item)
        // ====================================================================
        if shell.miSaveAs.WasClicked() != 0 {
            SaveEditorState(docMgr, engine);
            var saveAsDoc = docMgr.GetActive();
            if saveAsDoc != null {
                var saveAsPath = FileDialog.Save(
                    "Save As", "*.zia", saveAsDoc.fileName, "");
                if saveAsPath != "" {
                    docMgr.SaveAs(saveAsPath);
                    tabs.SetTitle(docMgr.activeIndex, saveAsDoc.fileName);
                    tabs.SetModified(docMgr.activeIndex, false);
                    engine.ClearModified();
                    shell.breadcrumb.SetPath(saveAsDoc.filePath, "/");
                    shell.SetStatusLeft("Saved as: " + saveAsDoc.fileName);
                    shell.SetStatusRight(DocStatusLabel(saveAsDoc));
                }
            }
        }

        // ====================================================================
        // Handle Save All (menu, toolbar, Ctrl+Shift+S, or CommandPalette)
        // ====================================================================
        var doSaveAll = shell.miSaveAll.WasClicked() != 0;
        if doSaveAll == false {
            doSaveAll = shell.tbSaveAll.WasClicked() != 0;
        }
        if doSaveAll == false {
            doSaveAll = Shortcuts.WasTriggered("saveall") != 0;
        }
        if doSaveAll == false {
            doSaveAll = cpSelected == "saveall";
        }
        if doSaveAll {
            SaveEditorState(docMgr, engine);
            var savedCount = docMgr.SaveAll();

            var i = 0;
            while i < docMgr.GetCount() {
                var doc = docMgr.documents.get(i);
                if doc != null and doc.isModified == false {
                    tabs.SetModified(i, false);
                }
                i = i + 1;
            }
            shell.SetStatusLeft("Saved " + savedCount + " files");
        }

        // ====================================================================
        // Handle Reload File (menu, Ctrl+Shift+R, or CommandPalette)
        // ====================================================================
        var doReload = shell.miReload.WasClicked() != 0;
        if doReload == false {
            doReload = Shortcuts.WasTriggered("reload") != 0;
        }
        if doReload == false {
            doReload = cpSelected == "reload";
        }
        if doReload {
            var reloadDoc = docMgr.GetActive();
            if reloadDoc != null and reloadDoc.isNew == false {
                reloadDoc.content = IO.File.ReadAllText(reloadDoc.filePath);
                engine.LoadDocument(reloadDoc);
                engine.ClearModified();
                tabs.SetModified(docMgr.activeIndex, false);
                pendingReload = false;
                shell.SetStatusLeft("Reloaded: " + reloadDoc.fileName);
                GUI.Toast.Success("File reloaded from disk");
            }
        }

        // ====================================================================
        // Handle Close File (menu, Ctrl+W, or tab close button)
        // ====================================================================
        var doClose = shell.miClose.WasClicked() != 0;
        if doClose == false {
            doClose = Shortcuts.WasTriggered("close") != 0;
        }
        if doClose == false {
            doClose = cpSelected == "close";
        }
        var closeIdx = -1;
        if doClose {
            closeIdx = docMgr.activeIndex;
        }
        if doClose == false {
            if shell.tabBar.WasCloseClicked() != 0 {
                closeIdx = shell.tabBar.GetCloseClickedIndex();
                doClose = closeIdx >= 0;
            }
        }
        if doClose and closeIdx >= 0 and closeIdx < docMgr.GetCount() {
            // Save editor state before closing
            SaveEditorState(docMgr, engine);

            // Ask for confirmation if the document has unsaved changes
            var closingDoc = docMgr.documents.get(closeIdx);
            if closingDoc != null and closingDoc.isModified {
                var confirmed = GUI.MessageBox.Confirm(
                    "Unsaved Changes",
                    closingDoc.fileName + " has unsaved changes.\nClose without saving?");
                if confirmed == 0 {
                    doClose = false;
                }
            }

            if doClose {
                // Close document and remove tab
                docMgr.CloseDocument(closeIdx);
                tabs.RemoveTab(closeIdx);

                // Update editor with next document or clear
                var nextDoc = docMgr.GetActive();
                if nextDoc != null {
                    tabs.SetActive(docMgr.activeIndex);
                    engine.LoadDocument(nextDoc);
                    shell.breadcrumb.SetPath(nextDoc.filePath, "/");
                    shell.SetStatusRight(DocStatusLabel(nextDoc));
                } else {
                    engine.SetText("");
                    engine.ClearModified();
                    shell.breadcrumb.SetPath("", "/");
                    shell.SetStatusRight("No file");
                }
                pendingReload = false;
                shell.SetStatusLeft("File closed");
            }
        }

        // ====================================================================
        // Handle Exit (menu item)
        // ====================================================================
        if shell.miExit.WasClicked() != 0 {
            // Break out of the event loop
            shell.Destroy();
            return;
        }

        // ====================================================================
        // Handle Edit menu: Undo
        // ====================================================================
        if shell.miUndo.WasClicked() != 0 {
            if engine != null and engine.editor != null {
                engine.editor.Undo();
            }
        }

        // ====================================================================
        // Handle Edit menu: Redo
        // ====================================================================
        if shell.miRedo.WasClicked() != 0 {
            if engine != null and engine.editor != null {
                engine.editor.Redo();
            }
        }

        // ====================================================================
        // Handle Edit menu: Cut
        // ====================================================================
        if shell.miCut.WasClicked() != 0 {
            if engine != null and engine.editor != null {
                engine.editor.Cut();
            }
        }

        // ====================================================================
        // Handle Edit menu: Copy
        // ====================================================================
        if shell.miCopy.WasClicked() != 0 {
            if engine != null and engine.editor != null {
                engine.editor.Copy();
            }
        }

        // ====================================================================
        // Handle Edit menu: Paste
        // ====================================================================
        if shell.miPaste.WasClicked() != 0 {
            if engine != null and engine.editor != null {
                engine.editor.Paste();
            }
        }

        // ====================================================================
        // Handle Edit menu: Select All
        // ====================================================================
        if shell.miSelectAll.WasClicked() != 0 {
            if engine != null and engine.editor != null {
                engine.editor.SelectAll();
            }
        }

        // ====================================================================
        // Handle Find / Replace (menu item or Ctrl+F)
        // ====================================================================
        var doFind = shell.miFind.WasClicked() != 0;
        if doFind == false {
            doFind = Shortcuts.WasTriggered("find") != 0;
        }
        if doFind == false {
            doFind = cpSelected == "find";
        }
        if doFind {
            if shell.findBar.IsVisible() != 0 {
                // Already visible — hide it
                shell.findBar.SetVisible(0);
            } else {
                shell.findBar.SetVisible(1);
                shell.findBar.Focus();
            }
        }

        // ====================================================================
        // Handle Go To Line (Ctrl+G or CommandPalette)
        // ====================================================================
        var doGoto = Shortcuts.WasTriggered("goto") != 0;
        if doGoto == false {
            doGoto = cpSelected == "goto";
        }
        if doGoto {
            var lineStr = GUI.MessageBox.Prompt("Go To Line", "Enter line number:");
            if lineStr != "" {
                var lineNum = Convert.ToInt(lineStr);
                if lineNum > 0 {
                    engine.GoToLine(lineNum);
                    shell.SetStatusLeft("Jumped to line " + lineNum);
                }
            }
        }

        // FindBar per-frame: trigger navigation actions and show match count.
        if shell.findBar.IsVisible() != 0 {
            shell.findBar.FindNext();
            shell.findBar.FindPrev();
            shell.findBar.Replace();
            shell.findBar.ReplaceAll();
            var matchCount = shell.findBar.GetMatchCount();
            if matchCount > 0 {
                var currMatch = shell.findBar.GetCurrentMatch();
                shell.SetStatusLeft("" + currMatch + " of " + matchCount + " matches");
            }
        }

        // ====================================================================
        // Handle Toggle Sidebar (menu, Ctrl+B, or CommandPalette)
        // ====================================================================
        var doToggleSidebar = shell.miToggleSidebar.WasClicked() != 0;
        if doToggleSidebar == false {
            doToggleSidebar = Shortcuts.WasTriggered("togglesidebar") != 0;
        }
        if doToggleSidebar == false {
            doToggleSidebar = cpSelected == "sidebar";
        }
        if doToggleSidebar {
            shell.ToggleSidebar();
        }

        // ====================================================================
        // Handle Toggle Status Bar (View menu or CommandPalette)
        // ====================================================================
        var doToggleStatusBar = shell.miToggleStatusBar.WasClicked() != 0;
        if doToggleStatusBar == false {
            doToggleStatusBar = cpSelected == "statusbar";
        }
        if doToggleStatusBar {
            if shell.statusBar.IsVisible() != 0 {
                shell.statusBar.SetVisible(0);
            } else {
                shell.statusBar.SetVisible(1);
            }
        }

        // ====================================================================
        // Handle Zoom In (View menu, Ctrl+=, or CommandPalette)
        // ====================================================================
        var doZoomIn = shell.miZoomIn.WasClicked() != 0;
        if doZoomIn == false {
            doZoomIn = Shortcuts.WasTriggered("zoomin") != 0;
        }
        if doZoomIn == false {
            doZoomIn = cpSelected == "zoomin";
        }
        if doZoomIn {
            appSettings.fontSize = appSettings.fontSize + 1;
            shell.app.SetFontSize(appSettings.fontSize);
            engine.editor.SetFontSize(appSettings.fontSize);
            appSettings.Save();
            shell.SetStatusLeft("Font size: " + appSettings.fontSize);
        }

        // ====================================================================
        // Handle Zoom Out (View menu, Ctrl+-, or CommandPalette)
        // ====================================================================
        var doZoomOut = shell.miZoomOut.WasClicked() != 0;
        if doZoomOut == false {
            doZoomOut = Shortcuts.WasTriggered("zoomout") != 0;
        }
        if doZoomOut == false {
            doZoomOut = cpSelected == "zoomout";
        }
        if doZoomOut {
            appSettings.fontSize = appSettings.fontSize - 1;
            shell.app.SetFontSize(appSettings.fontSize);
            engine.editor.SetFontSize(appSettings.fontSize);
            appSettings.Save();
            shell.SetStatusLeft("Font size: " + appSettings.fontSize);
        }

        // ====================================================================
        // Handle Reset Zoom (View menu, Ctrl+0, or CommandPalette)
        // ====================================================================
        var doZoomReset = shell.miZoomReset.WasClicked() != 0;
        if doZoomReset == false {
            doZoomReset = Shortcuts.WasTriggered("zoomreset") != 0;
        }
        if doZoomReset == false {
            doZoomReset = cpSelected == "zoomreset";
        }
        if doZoomReset {
            appSettings.fontSize = 14;
            shell.app.SetFontSize(14.0);
            engine.editor.SetFontSize(14.0);
            appSettings.Save();
            shell.SetStatusLeft("Font size reset to 14");
        }

        // ====================================================================
        // Handle Toggle Theme (View menu, Ctrl+Shift+T, or CommandPalette)
        // ====================================================================
        var doToggleTheme = shell.miToggleTheme.WasClicked() != 0;
        if doToggleTheme == false {
            doToggleTheme = Shortcuts.WasTriggered("toggletheme") != 0;
        }
        if doToggleTheme == false {
            doToggleTheme = cpSelected == "toggletheme";
        }
        if doToggleTheme {
            if appSettings.theme == "dark" {
                GUI.Theme.SetLight();
                appSettings.theme = "light";
                GUI.Toast.Info("Switched to light theme");
            } else {
                GUI.Theme.SetDark();
                appSettings.theme = "dark";
                GUI.Toast.Info("Switched to dark theme");
            }
            appSettings.Save();
        }

        // ====================================================================
        // Handle Toggle Fullscreen (View menu, F11, or CommandPalette)
        // ====================================================================
        var doFullscreen = shell.miFullscreen.WasClicked() != 0;
        if doFullscreen == false {
            doFullscreen = Shortcuts.WasTriggered("fullscreen") != 0;
        }
        if doFullscreen == false {
            doFullscreen = cpSelected == "fullscreen";
        }
        if doFullscreen {
            if shell.app.IsFullscreen() {
                shell.app.SetFullscreen(false);
            } else {
                shell.app.SetFullscreen(true);
            }
        }

        // ====================================================================
        // Handle Toggle Minimap (View menu, Ctrl+Shift+M, or CommandPalette)
        // ====================================================================
        var doMinimap = shell.miToggleMinimap.WasClicked() != 0;
        if doMinimap == false {
            doMinimap = Shortcuts.WasTriggered("minimap") != 0;
        }
        if doMinimap == false {
            doMinimap = cpSelected == "minimap";
        }
        if doMinimap {
            if minimapVisible {
                minimapVisible = false;
                shell.minimap.SetVisible(0);
                appSettings.minimapVisible = false;
            } else {
                minimapVisible = true;
                shell.minimap.SetVisible(1);
                appSettings.minimapVisible = true;
            }
            appSettings.Save();
        }

        // ====================================================================
        // Handle Settings / Preferences (Edit menu, Ctrl+,, or CommandPalette)
        // ====================================================================
        var doSettings = shell.miPreferences.WasClicked() != 0;
        if doSettings == false {
            doSettings = Shortcuts.WasTriggered("settings") != 0;
        }
        if doSettings == false {
            doSettings = cpSelected == "settings";
        }
        if doSettings {
            var settingsInfo = "Current Settings\n\n";
            settingsInfo = settingsInfo + "Font Size:  " + appSettings.fontSize + "pt\n";
            settingsInfo = settingsInfo + "Theme:      " + appSettings.theme + "\n";
            settingsInfo = settingsInfo + "\nKeyboard shortcuts:\n";
            settingsInfo = settingsInfo + "  Ctrl+=  /  Ctrl+-   Zoom In / Out\n";
            settingsInfo = settingsInfo + "  Ctrl+0              Reset Font Size\n";
            settingsInfo = settingsInfo + "  Ctrl+Shift+T        Toggle Theme\n";
            settingsInfo = settingsInfo + "  F11                 Toggle Fullscreen\n";
            settingsInfo = settingsInfo + "  Ctrl+Shift+M        Toggle Minimap";
            GUI.MessageBox.Info("Settings", settingsInfo);
        }

        // ====================================================================
        // Handle About (Help menu)
        // ====================================================================
        if shell.miAbout.WasClicked() != 0 {
            GUI.MessageBox.Info("About ViperIDE",
                "ViperIDE — IDE for Zia and Viper Basic\nPowered by the Viper Runtime.");
        }

        // ====================================================================
        // Handle Build (menu, Ctrl+Shift+B, or CommandPalette)
        // ====================================================================
        var doBuild = shell.miBuild.WasClicked() != 0;
        if doBuild == false {
            doBuild = Shortcuts.WasTriggered("build") != 0;
        }
        if doBuild == false {
            doBuild = cpSelected == "build";
        }
        if doBuild {
            SaveEditorState(docMgr, engine);
            var buildDoc = docMgr.GetActive();
            if buildDoc != null {
                if buildDoc.isNew == false {
                    docMgr.SaveActive();
                    shell.SetStatusLeft("Building...");
                    var success = buildSys.Build(buildDoc.filePath);
                    if success {
                        shell.SetStatusLeft("Build succeeded in " + buildSys.GetBuildTime());
                        GUI.Toast.Success("Build succeeded in " + buildSys.GetBuildTime());
                    } else {
                        var errCount = buildSys.GetErrorCount();
                        shell.SetStatusLeft("Build failed: " + errCount + " errors");
                        GUI.Toast.Error("Build failed: " + errCount + " errors");
                    }
                    // Refresh diagnostics panel and minimap markers
                    UpdateDiagnostics(shell, buildSys, engine);
                } else {
                    shell.SetStatusLeft("Save file before building");
                }
            }
        }

        // ====================================================================
        // Handle Build and Run (menu, F5, or CommandPalette)
        // ====================================================================
        var doBuildRun = shell.miBuildAndRun.WasClicked() != 0;
        if doBuildRun == false {
            doBuildRun = Shortcuts.WasTriggered("buildrun") != 0;
        }
        if doBuildRun == false {
            doBuildRun = cpSelected == "buildrun";
        }
        if doBuildRun {
            SaveEditorState(docMgr, engine);
            var runDoc = docMgr.GetActive();
            if runDoc != null {
                if runDoc.isNew == false {
                    docMgr.SaveActive();
                    shell.SetStatusLeft("Building and running...");
                    var success = buildSys.BuildAndRun(runDoc.filePath);
                    if success {
                        shell.SetStatusLeft("Run completed in " + buildSys.GetBuildTime());
                        GUI.Toast.Info("Run completed in " + buildSys.GetBuildTime());
                    } else {
                        var errCount = buildSys.GetErrorCount();
                        shell.SetStatusLeft("Build failed: " + errCount + " errors");
                        GUI.Toast.Error("Build failed: " + errCount + " errors");
                    }
                    UpdateDiagnostics(shell, buildSys, engine);
                } else {
                    shell.SetStatusLeft("Save file before running");
                }
            }
        }

        // ====================================================================
        // Handle Run without Build (menu, Ctrl+F5, or CommandPalette)
        // ====================================================================
        var doRunOnly = shell.miRun.WasClicked() != 0;
        if doRunOnly == false {
            doRunOnly = Shortcuts.WasTriggered("run") != 0;
        }
        if doRunOnly == false {
            doRunOnly = cpSelected == "run";
        }
        if doRunOnly {
            SaveEditorState(docMgr, engine);
            var runOnlyDoc = docMgr.GetActive();
            if runOnlyDoc != null {
                if runOnlyDoc.isNew == false {
                    shell.SetStatusLeft("Running...");
                    var runSuccess = buildSys.BuildAndRun(runOnlyDoc.filePath);
                    if runSuccess {
                        shell.SetStatusLeft("Run completed in " + buildSys.GetBuildTime());
                        GUI.Toast.Info("Run completed in " + buildSys.GetBuildTime());
                    } else {
                        var runErrCount = buildSys.GetErrorCount();
                        shell.SetStatusLeft("Run failed: " + runErrCount + " errors");
                        GUI.Toast.Error("Run failed: " + runErrCount + " errors");
                    }
                    UpdateDiagnostics(shell, buildSys, engine);
                } else {
                    shell.SetStatusLeft("Save file before running");
                }
            }
        }

        // ====================================================================
        // Handle Diagnostics panel: click to navigate to error line
        // ====================================================================
        if shell.diagListBox.WasSelectionChanged() != 0 {
            var selItem = shell.diagListBox.Selected;
            if selItem != null {
                var lineStr = GUI.ListBox.ItemGetData(selItem);
                var lineNum = Convert.ToInt(lineStr);
                if lineNum > 0 {
                    engine.GoToLine(lineNum);
                }
            }
        }

        // ====================================================================
        // Handle tab switching (user clicked a different tab)
        // ====================================================================
        if shell.tabBar.WasChanged() != 0 {
            var newIdx = shell.tabBar.GetActiveIndex();
            // Guard against invalid indices and skip if already on this tab
            if newIdx >= 0 and newIdx < docMgr.GetCount() and newIdx != docMgr.activeIndex {
                SaveEditorState(docMgr, engine);
                docMgr.SetActive(newIdx);
                var switchDoc = docMgr.GetActive();
                if switchDoc != null {
                    engine.LoadDocument(switchDoc);
                    if switchDoc.isNew {
                        shell.breadcrumb.SetPath("", "/");
                    } else {
                        shell.breadcrumb.SetPath(switchDoc.filePath, "/");
                    }
                    shell.SetStatusRight(DocStatusLabel(switchDoc));
                    shell.SetStatusLeft("Switched to: " + switchDoc.fileName);
                    pendingReload = false;
                }
            }
        }

        // ====================================================================
        // Track modified state
        // ====================================================================
        if engine != null and docMgr != null and docMgr.GetCount() > 0 {
            if engine.IsModified() {
                var curDoc = docMgr.GetActive();
                if curDoc != null {
                    if curDoc.isModified == false {
                        curDoc.isModified = true;
                        tabs.SetModified(docMgr.activeIndex, true);
                    }
                }
            }
        }

        // ====================================================================
        // File change detection (IO.Watcher for active document)
        // ====================================================================
        var activeDoc = docMgr.GetActive();
        if activeDoc != null and activeDoc.isNew == false {
            if activeDoc.filePath != watchedPath {
                // Active document changed — stop old watcher and start a new one
                if hasWatcher {
                    fileWatcher.Stop();
                }
                watchedPath = activeDoc.filePath;
                fileWatcher = IO.Watcher.New(watchedPath);
                fileWatcher.Start();
                hasWatcher = true;
                pendingReload = false;
            }
            if hasWatcher {
                var watchEvent = fileWatcher.Poll();
                if watchEvent == fileWatcher.EVENT_MODIFIED {
                    if pendingReload == false {
                        pendingReload = true;
                        GUI.Toast.Warning("File changed on disk. Use File > Reload File to update.");
                        shell.SetStatusLeft("Warning: external change — " + activeDoc.fileName);
                    }
                }
            }
        } else {
            if hasWatcher {
                fileWatcher.Stop();
                hasWatcher = false;
                pendingReload = false;
            }
            watchedPath = "";
        }

        // ====================================================================
        // Update status bar cursor position
        // ====================================================================
        if engine != null {
            shell.SetStatusCenter("Ln " + engine.GetCursorLine() + ", Col " + engine.GetCursorCol() + "  |  Lines: " + engine.GetLineCount());
        }

        shell.Render();
    }

    // ========================================================================
    // Cleanup
    // ========================================================================
    if shell != null {
        shell.Destroy();
    }
}

// Save the editor's current content back to the active document.
func SaveEditorState(docMgr: document_manager.DocumentManager,
                     engine: editor_engine.EditorEngine) {
    if docMgr == null or engine == null {
        return;
    }
    var doc = docMgr.GetActive();
    if doc != null {
        engine.SaveToDocument(doc);
    }
}

// Refresh the diagnostics panel, minimap markers, and build output after a build.
// Error lines are marked red (16711680) and warnings yellow (16776960).
func UpdateDiagnostics(shell: app_shell.AppShell,
                       buildSys: build_system.BuildSystem,
                       engine: editor_engine.EditorEngine) {
    shell.diagListBox.Clear();
    shell.minimap.ClearMarkers();

    var diagCount = buildSys.diagnostics.count();
    if diagCount > 0 {
        shell.diagListBox.SetVisible(1);
        var i = 0;
        while i < diagCount {
            var diag = buildSys.diagnostics.get(i);
            var sevLabel = "error";
            var markerColor = 16711680;   // red
            if diag.severity == 1 {
                sevLabel = "warning";
                markerColor = 16776960;   // yellow
            }
            var diagText = diag.filePath + ":" + diag.line + "  " + sevLabel + "[" + diag.code + "]: " + diag.message;
            var item = shell.diagListBox.AddItem(diagText);
            GUI.ListBox.ItemSetData(item, "" + diag.line);
            shell.minimap.AddMarker(diag.line, 1, markerColor);
            i = i + 1;
        }
    } else {
        shell.diagListBox.SetVisible(0);
    }

    // Show raw build output so the user can always see compiler stdout/stderr.
    shell.SetBuildOutput(buildSys.GetOutput());
}

// Build the status bar right-zone label for a document.
// Returns e.g. "Zia  |  LF" or "Basic  |  CRLF".
// Shown in the status bar right zone; the breadcrumb already shows the file path.
func DocStatusLabel(doc: document.Document) -> String {
    var lang = "Text";
    if doc.language == "zia"   { lang = "Zia"; }
    if doc.language == "basic" { lang = "Basic"; }

    var eol = "LF";
    if Str.IndexOf(doc.content, "\r\n") != 0 { eol = "CRLF"; }

    return lang + "  |  " + eol;
}