module build_system;

bind Str = Viper.String;
bind Exec = Viper.Exec;
bind Convert = Viper.Core.Convert;
bind CP = Viper.Text.CompiledPattern;
bind Seq = Viper.Collections.Seq;
bind Obj = Viper.Core.Object;
bind Sw = Viper.Time.Stopwatch;

// ============================================================================
// BuildSystem — compile and run Zia/BASIC programs from the IDE
// ============================================================================
// Handles compilation, error parsing, and running programs.
// Uses Exec.ShellFull to run the zia compiler and capture the exit code.
//
// Diagnostic format: "file.zia:line:col: error[code]: message"
// ============================================================================

entity BuildSystem {
    // Build state
    expose Boolean isBuilding;
    expose Boolean isRunning;
    expose Boolean lastBuildSuccess;

    // Build output
    expose String buildOutput;
    expose String compilerPath;

    // Build timing ("1.2s" after last build)
    expose String lastBuildTime;

    // Parsed diagnostics
    expose List[Diagnostic] diagnostics;

    expose func init() {
        isBuilding = false;
        isRunning = false;
        lastBuildSuccess = false;
        buildOutput = "";
        compilerPath = "zia";
        lastBuildTime = "";
        diagnostics = [];
    }

    // Build a Zia file. Returns true if compilation succeeded.
    expose func Build(filePath: String) -> Boolean {
        isBuilding = true;
        diagnostics = [];

        var sw = Sw.New();
        sw.Start();

        // Run compiler with stderr merged so error messages are captured
        var cmd = compilerPath + " " + filePath + " --emit-il 2>&1";
        buildOutput = Exec.ShellFull(cmd);

        // Use exit code as the authoritative success indicator
        lastBuildSuccess = Exec.LastExitCode() == 0;

        // Record elapsed time
        lastBuildTime = "" + sw.ElapsedMs + "ms";

        // Parse output to populate the diagnostics list for gutter markers
        ParseBuildOutput();

        isBuilding = false;
        return lastBuildSuccess;
    }

    // Build and run a Zia file.
    expose func BuildAndRun(filePath: String) -> Boolean {
        isBuilding = true;
        diagnostics = [];

        var sw = Sw.New();
        sw.Start();

        // Run file directly (zia compiles and runs); merge stderr for error capture
        var cmd = compilerPath + " " + filePath + " 2>&1";
        buildOutput = Exec.ShellFull(cmd);

        lastBuildSuccess = Exec.LastExitCode() == 0;

        lastBuildTime = "" + sw.ElapsedMs + "ms";

        ParseBuildOutput();

        isBuilding = false;
        return lastBuildSuccess;
    }

    // Parse build output for diagnostics (error/warning lines).
    // Populates `diagnostics` list. Success is determined by exit code in callers.
    func ParseBuildOutput() {
        // Regex for compiler diagnostic lines.
        // Format: "file.zia:line:col: error[code]: message"
        // Group 1=file  2=line  3=col  4=severity  5=code  6=message
        var diagPat = CP.New("([^:]+):([0-9]+):([0-9]+): (error|warning)\\[([^\\]]*)\\]: (.+)");

        // Split output into lines and scan for diagnostic entries
        var lines = Str.Split(buildOutput, "\n");
        var i = 0;
        while i < Seq.get_Len(lines) {
            var line = Seq.Get(lines, i);

            var caps = diagPat.Captures(line);
            if Seq.get_Len(caps) >= 7 {
                var diag = new Diagnostic();
                diag.filePath = Obj.ToString(Seq.Get(caps, 1));
                diag.line     = Convert.ToInt(Seq.Get(caps, 2));
                diag.column   = Convert.ToInt(Seq.Get(caps, 3));
                var sev       = Obj.ToString(Seq.Get(caps, 4));
                diag.severity = 0;
                if sev == "warning" {
                    diag.severity = 1;
                }
                diag.code    = Obj.ToString(Seq.Get(caps, 5));
                diag.message = Obj.ToString(Seq.Get(caps, 6));
                diagnostics.add(diag);
            }

            i = i + 1;
        }
    }

    // Get the number of errors.
    expose func GetErrorCount() -> Integer {
        var count = 0;
        var i = 0;
        while i < diagnostics.count() {
            var diag = diagnostics.get(i);
            if diag.severity == 0 {
                count = count + 1;
            }
            i = i + 1;
        }
        return count;
    }

    // Get the number of warnings.
    expose func GetWarningCount() -> Integer {
        var count = 0;
        var i = 0;
        while i < diagnostics.count() {
            var diag = diagnostics.get(i);
            if diag.severity == 1 {
                count = count + 1;
            }
            i = i + 1;
        }
        return count;
    }

    // Get the build output text.
    expose func GetOutput() -> String {
        return buildOutput;
    }

    // Get the elapsed time of the last build ("1.2s").
    expose func GetBuildTime() -> String {
        return lastBuildTime;
    }

    // Clear diagnostics.
    expose func ClearDiagnostics() {
        diagnostics = [];
    }
}

// Diagnostic — represents a compiler error or warning
entity Diagnostic {
    expose String filePath;
    expose Integer line;
    expose Integer column;
    expose Integer severity;   // 0=error, 1=warning, 2=info
    expose String message;
    expose String code;

    expose func init() {
        filePath = "";
        line = 0;
        column = 0;
        severity = 0;
        message = "";
        code = "";
    }
}
