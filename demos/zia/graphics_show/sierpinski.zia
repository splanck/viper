module sierpinski;

// ============================================================================
// SIERPINSKI.VIPER - Fractal Demonstration
// ============================================================================
// Shows various fractal patterns including Sierpinski triangle,
// Mandelbrot set visualization, and recursive tree.
// ============================================================================

bind "./colors";

bind Viper.Random;
bind Viper.Graphics;
bind Viper.Graphics.Color;
bind Viper.Math;
bind Viper.Time;

var PI: Number;

func initConstants() {
    PI = 3.14159265358979;
}

// Sierpinski triangle using chaos game
entity SierpinskiTriangle {
    expose List[Integer] points;  // Packed x,y positions
    expose Integer maxPoints;
    expose List[Integer] vertices;  // 3 vertices as packed x,y
    expose Number currentX;
    expose Number currentY;
    expose Integer phase;

    expose func init(width: Integer, height: Integer) {
        maxPoints = 50000;
        points = [];
        vertices = [];
        phase = 0;

        // Triangle vertices
        var v1x = width / 2;
        var v1y = 50;
        var v2x = 50;
        var v2y = height - 50;
        var v3x = width - 50;
        var v3y = height - 50;

        vertices.add(v1x * 10000 + v1y);
        vertices.add(v2x * 10000 + v2y);
        vertices.add(v3x * 10000 + v3y);

        // Start at random position
        currentX = width / 2;
        currentY = height / 2;
    }

    expose func update(pointsPerFrame: Integer) {
        var i = 0;
        while i < pointsPerFrame {
            if points.count() >= maxPoints {
                return;
            }

            // Pick random vertex
            var idx = NextInt(3);
            var vertex = vertices.get(idx);
            var vx = vertex / 10000;
            var vy = vertex - (vx * 10000);

            // Move halfway toward vertex
            currentX = (currentX + vx) / 2.0;
            currentY = (currentY + vy) / 2.0;

            // Store point
            var px = Floor(currentX);
            var py = Floor(currentY);
            points.add(px * 10000 + py);

            i = i + 1;
        }
        phase = phase + 1;
    }

    expose func draw(canvas: Canvas) {
        var i = 0;
        while i < points.count() {
            var point = points.get(i);
            var px = point / 10000;
            var py = point - (px * 10000);

            // Color based on position
            var colorPhase = (px + py + phase) / 3;
            var color = colors.rainbowPhase(colorPhase);

            canvas.Plot(px, py, color);
            i = i + 1;
        }

        // Draw vertices
        var j = 0;
        while j < 3 {
            var vertex = vertices.get(j);
            var vx = vertex / 10000;
            var vy = vertex - (vx * 10000);
            canvas.Disc(vx, vy, 5, colors.WHITE);
            j = j + 1;
        }
    }

    expose func reset(width: Integer, height: Integer) {
        points.clear();
        currentX = width / 2;
        currentY = height / 2;
        phase = 0;
    }
}

// Simple Mandelbrot set renderer
entity MandelbrotRenderer {
    expose Pixels buffer;
    expose Integer width;
    expose Integer height;
    expose Number centerX;
    expose Number centerY;
    expose Number zoom;
    expose Integer maxIter;
    expose Integer currentRow;
    expose Boolean complete;

    expose func init(w: Integer, h: Integer) {
        width = w;
        height = h;
        buffer = new Pixels(width, height);
        centerX = -0.5;
        centerY = 0.0;
        zoom = 200.0;
        maxIter = 100;
        currentRow = 0;
        complete = false;
    }

    expose func renderRows(rowsPerFrame: Integer) {
        if complete {
            return;
        }

        var endRow = currentRow + rowsPerFrame;
        if endRow > height {
            endRow = height;
        }

        var row = currentRow;
        while row < endRow {
            var col = 0;
            while col < width {
                // Map pixel to complex plane
                var x0 = (col - width / 2) / zoom + centerX;
                var y0 = (row - height / 2) / zoom + centerY;

                var x = 0.0;
                var y = 0.0;
                var iter = 0;

                while iter < maxIter {
                    var x2 = x * x;
                    var y2 = y * y;

                    if x2 + y2 > 4.0 {
                        break;
                    }

                    y = 2.0 * x * y + y0;
                    x = x2 - y2 + x0;
                    iter = iter + 1;
                }

                // Color based on iteration count
                var color: Integer;
                if iter == maxIter {
                    color = colors.BLACK;
                } else {
                    var hue = (iter * 10) - ((iter * 10) / 360) * 360;
                    color = colors.rainbowPhase(hue);
                }

                buffer.Set(col, row, color);
                col = col + 1;
            }
            row = row + 1;
        }

        currentRow = endRow;
        if currentRow >= height {
            complete = true;
        }
    }

    expose func draw(canvas: Canvas) {
        canvas.Blit(0, 0, buffer);

        if not complete {
            // Draw progress line
            canvas.Line(0, currentRow, width, currentRow, colors.WHITE);
        }
    }

    expose func zoomIn(factor: Number) {
        zoom = zoom * factor;
        reset();
    }

    expose func zoomOut(factor: Number) {
        zoom = zoom / factor;
        reset();
    }

    expose func pan(dx: Number, dy: Number) {
        centerX = centerX + dx / zoom;
        centerY = centerY + dy / zoom;
        reset();
    }

    expose func reset() {
        currentRow = 0;
        complete = false;
        buffer.Clear();
    }

    expose func isComplete() -> Boolean {
        return complete;
    }
}

// Recursive fractal tree
entity FractalTree {
    expose List[Integer] branches;  // Packed as x1,y1,x2,y2,depth
    expose Integer maxDepth;
    expose Number angle;
    expose Number lengthRatio;
    expose Integer colorPhase;

    expose func init(width: Integer, height: Integer) {
        branches = [];
        maxDepth = 10;
        angle = 0.4;  // About 23 degrees
        lengthRatio = 0.7;
        colorPhase = 0;

        // Generate tree
        var startX = width / 2;
        var startY = height - 50;
        var trunkLength = 120;

        generateBranch(startX, startY, -PI / 2.0, trunkLength, 0);
    }

    expose func generateBranch(x: Number, y: Number, dir: Number, len: Number, depth: Integer) {
        if depth > maxDepth {
            return;
        }
        if len < 2.0 {
            return;
        }

        // Calculate end point
        var endX = x + Cos(dir) * len;
        var endY = y + Sin(dir) * len;

        // Store as list of line segments
        var startPacked = Floor(x) * 10000 + Floor(y);
        var endPacked = Floor(endX) * 10000 + Floor(endY);
        branches.add(startPacked);
        branches.add(endPacked);
        branches.add(depth);

        // Generate child branches
        var newLen = len * lengthRatio;
        generateBranch(endX, endY, dir - angle, newLen, depth + 1);
        generateBranch(endX, endY, dir + angle, newLen, depth + 1);
    }

    expose func setAngle(a: Number) {
        angle = a;
    }

    expose func draw(canvas: Canvas, width: Integer, height: Integer) {
        var i = 0;
        while i < branches.count() {
            var startPacked = branches.get(i);
            var endPacked = branches.get(i + 1);
            var depth = branches.get(i + 2);

            var x1 = startPacked / 10000;
            var y1 = startPacked - (x1 * 10000);
            var x2 = endPacked / 10000;
            var y2 = endPacked - (x2 * 10000);

            // Color based on depth
            var hue = (depth * 30 + colorPhase) - ((depth * 30 + colorPhase) / 360) * 360;
            var color: Integer;
            if depth < 3 {
                color = RGB(101, 67, 33);  // Brown trunk
            } else {
                color = colors.rainbowPhase(hue);
            }

            // Thickness based on depth
            var thickness = maxDepth - depth + 1;
            if thickness > 5 {
                thickness = 5;
            }

            if thickness > 1 {
                canvas.ThickLine(x1, y1, x2, y2, thickness, color);
            } else {
                canvas.Line(x1, y1, x2, y2, color);
            }

            i = i + 3;
        }
    }

    expose func regenerate(width: Integer, height: Integer) {
        branches.clear();
        var startX = width / 2;
        var startY = height - 50;
        var trunkLength = 120;
        generateBranch(startX, startY, -PI / 2.0, trunkLength, 0);
    }

    expose func update() {
        colorPhase = colorPhase + 1;
    }
}

// Fractal demo manager
entity FractalDemo {
    expose Integer mode;  // 0=sierpinski, 1=mandelbrot, 2=tree
    expose SierpinskiTriangle sierpinski;
    expose MandelbrotRenderer mandelbrot;
    expose FractalTree tree;

    expose func init(width: Integer, height: Integer) {
        mode = 0;

        sierpinski = new SierpinskiTriangle();
        sierpinski.init(width, height);

        mandelbrot = new MandelbrotRenderer();
        mandelbrot.init(width / 2, height / 2);  // Lower res for speed

        tree = new FractalTree();
        tree.init(width, height);
    }

    expose func update() {
        if mode == 0 {
            sierpinski.update(500);
        } else if mode == 1 {
            mandelbrot.renderRows(5);
        } else {
            tree.update();
        }
    }

    expose func draw(canvas: Canvas, width: Integer, height: Integer) {
        if mode == 0 {
            sierpinski.draw(canvas);
        } else if mode == 1 {
            // Scale up mandelbrot
            canvas.Blit(0, 0, mandelbrot.buffer);
            // Simple 2x scale by blitting multiple times
            canvas.Blit(width / 2, 0, mandelbrot.buffer);
            canvas.Blit(0, height / 2, mandelbrot.buffer);
            canvas.Blit(width / 2, height / 2, mandelbrot.buffer);
        } else {
            tree.draw(canvas, width, height);
        }
    }

    expose func nextMode(width: Integer, height: Integer) {
        mode = mode + 1;
        if mode > 2 {
            mode = 0;
        }

        // Reset current mode
        if mode == 0 {
            sierpinski.reset(width, height);
        } else if mode == 1 {
            mandelbrot.reset();
        } else {
            tree.regenerate(width, height);
        }
    }

    expose func getModeName() -> String {
        if mode == 0 {
            return "Sierpinski Triangle";
        } else if mode == 1 {
            return "Mandelbrot Set";
        } else {
            return "Fractal Tree";
        }
    }
}

// Run the fractal demo
func run(canvas: Canvas) {
    var width = canvas.Width;
    var height = canvas.Height;

    colors.initColors();
    initConstants();

    var demo = new FractalDemo();
    demo.init(width, height);

    var running = true;
    var modeTimer = 0;

    while running {
        canvas.Poll();

        if canvas.ShouldClose != 0 {
            running = false;
        }

        // ESC or Q to exit
        if canvas.KeyHeld(27) != 0 {
            running = false;
        }
        if canvas.KeyHeld(81) != 0 {
            running = false;
        }

        // Space changes mode
        if canvas.KeyHeld(32) != 0 {
            if modeTimer == 0 {
                demo.nextMode(width, height);
                modeTimer = 20;
            }
        }

        // R resets current mode
        if canvas.KeyHeld(82) != 0 {
            if modeTimer == 0 {
                if demo.mode == 0 {
                    demo.sierpinski.reset(width, height);
                } else if demo.mode == 1 {
                    demo.mandelbrot.reset();
                } else {
                    demo.tree.regenerate(width, height);
                }
                modeTimer = 20;
            }
        }

        // Arrow keys for mandelbrot navigation
        if demo.mode == 1 {
            if canvas.KeyHeld(265) != 0 {  // Up - zoom in
                demo.mandelbrot.zoomIn(1.1);
            }
            if canvas.KeyHeld(264) != 0 {  // Down - zoom out
                demo.mandelbrot.zoomOut(1.1);
            }
            if canvas.KeyHeld(263) != 0 {  // Left
                demo.mandelbrot.pan(-20.0, 0.0);
            }
            if canvas.KeyHeld(262) != 0 {  // Right
                demo.mandelbrot.pan(20.0, 0.0);
            }
        }

        // Arrow keys for tree angle
        if demo.mode == 2 {
            if canvas.KeyHeld(263) != 0 {  // Left
                demo.tree.angle = demo.tree.angle - 0.02;
                demo.tree.regenerate(width, height);
            }
            if canvas.KeyHeld(262) != 0 {  // Right
                demo.tree.angle = demo.tree.angle + 0.02;
                demo.tree.regenerate(width, height);
            }
        }

        if modeTimer > 0 {
            modeTimer = modeTimer - 1;
        }

        // Update
        demo.update();

        // Draw
        canvas.Clear(colors.BLACK);
        demo.draw(canvas, width, height);

        // Draw UI
        var modeName = demo.getModeName();
        canvas.TextBg(10, 10, modeName, colors.WHITE, colors.BLACK);

        var hint = "";
        if demo.mode == 0 {
            hint = "SPACE: Next | R: Reset | ESC: Exit";
        } else if demo.mode == 1 {
            hint = "SPACE: Next | R: Reset | Arrows: Navigate | ESC: Exit";
        } else {
            hint = "SPACE: Next | R: Reset | Left/Right: Angle | ESC: Exit";
        }
        canvas.TextBg(10, height - 25, hint, colors.DARK_GRAY, colors.BLACK);

        canvas.Flip();
        Viper.Time.SleepMs(16);
    }
}
