module simple_starfield;

// ============================================================================
// SIMPLE_STARFIELD.VIPER - Standalone Starfield Demo (Integer-Only Version)
// ============================================================================
// Uses integer math only to work around Viperlang type coercion bugs.
// ============================================================================

bind Viper.Random;
bind Viper.Graphics;
bind Viper.Graphics.Canvas;
bind Viper.Graphics.Color;
bind Viper.Time;

// Color constants
var BLACK: Integer;
var WHITE: Integer;
var CYAN: Integer;
var GRAY: Integer;

func initColors() {
    BLACK = RGB(0, 0, 0);
    WHITE = RGB(255, 255, 255);
    CYAN = RGB(0, 255, 255);
    GRAY = RGB(128, 128, 128);
}

// Fade a color by a percentage (0 = black, 100 = original)
func fadeColorInt(color: Integer, percent: Integer) -> Integer {
    // Extract components (color = 0x00RRGGBB)
    var r = (color / 65536) - ((color / 16777216) * 256);
    var g = (color / 256) - ((color / 65536) * 256);
    var b = color - ((color / 256) * 256);

    // Scale by percentage using integer math
    var ri = (r * percent) / 100;
    var gi = (g * percent) / 100;
    var bi = (b * percent) / 100;

    // Clamp
    if ri < 0 { ri = 0; }
    if gi < 0 { gi = 0; }
    if bi < 0 { bi = 0; }
    if ri > 255 { ri = 255; }
    if gi > 255 { gi = 255; }
    if bi > 255 { bi = 255; }

    return RGB(ri, gi, bi);
}

// Star entity using scaled integers (multiply coords by 1000 for precision)
entity Star {
    expose Integer x;      // x * 1000
    expose Integer y;      // y * 1000
    expose Integer z;      // z (actual depth)
    expose Integer speed;  // speed * 100
    expose Integer color;
    expose Integer maxZ;

    expose func init(maxDepth: Integer) {
        maxZ = maxDepth;
        reset();
    }

    expose func reset() {
        // Random position: -1000 to +1000 (scaled by 1000 = -1.0 to +1.0)
        x = NextInt(2000000) - 1000000;
        y = NextInt(2000000) - 1000000;
        z = 1 + NextInt(maxZ);
        speed = 50 + NextInt(150);
        var brightness = 180 + NextInt(76);
        color = RGB(brightness, brightness, brightness);
    }

    expose func update(deltaZ: Integer) {
        z = z - (deltaZ * speed) / 100;
        if z <= 1 {
            reset();
            z = maxZ;
        }
    }

    expose func draw(canvas: Canvas, centerX: Integer, centerY: Integer, fov: Integer, width: Integer, height: Integer) {
        if z <= 0 {
            return;
        }

        // Project to screen coordinates (x and y are scaled by 1000)
        // projX = (x / 1000) * fov / z = (x * fov) / (z * 1000)
        var sx = centerX + (x * fov) / (z * 1000);
        var sy = centerY + (y * fov) / (z * 1000);

        // Check bounds
        if sx < 0 or sx >= width or sy < 0 or sy >= height {
            return;
        }

        // Calculate size based on depth (closer = bigger)
        // size = 4 * (1 - z/maxZ) = 4 * (maxZ - z) / maxZ
        var size = (4 * (maxZ - z)) / maxZ;
        if size < 1 {
            size = 1;
        }
        if size > 4 {
            size = 4;
        }

        // Calculate brightness percentage: 100 - (z * 70 / maxZ)
        var brightPercent = 100 - (z * 70) / maxZ;
        if brightPercent < 30 {
            brightPercent = 30;
        }

        var drawColor = fadeColorInt(color, brightPercent);

        // Draw the star
        if size <= 1 {
            canvas.Plot(sx, sy, drawColor);
        } else {
            canvas.Disc(sx, sy, size, drawColor);
        }
    }
}

// Starfield manager
entity Starfield {
    expose List[Star] stars;
    expose Integer numStars;
    expose Integer maxDepth;
    expose Integer speed;
    expose Integer fov;
    expose Boolean warpMode;

    expose func init(count: Integer) {
        numStars = count;
        maxDepth = 1000;
        speed = 8;
        fov = 256;
        warpMode = false;

        stars = [];
        var i = 0;
        while i < numStars {
            var star = new Star();
            star.init(maxDepth);
            // Distribute stars evenly in depth
            star.z = 1 + (i * maxDepth) / numStars;
            stars.add(star);
            i = i + 1;
        }
    }

    expose func update() {
        var effectiveSpeed = speed;
        if warpMode {
            effectiveSpeed = speed * 3;
        }

        var i = 0;
        while i < stars.count() {
            var star = stars.get(i);
            star.update(effectiveSpeed);
            i = i + 1;
        }
    }

    expose func draw(canvas: Canvas, width: Integer, height: Integer) {
        var centerX = width / 2;
        var centerY = height / 2;

        var i = 0;
        while i < stars.count() {
            var star = stars.get(i);
            star.draw(canvas, centerX, centerY, fov, width, height);
            i = i + 1;
        }
    }

    expose func toggleWarp() {
        warpMode = not warpMode;
    }
}

// Run the starfield demo
func run(canvas: Canvas, width: Integer, height: Integer) {
    initColors();

    var field = new Starfield();
    field.init(400);

    var running = true;
    var warpDebounce = 0;

    while running {
        canvas.Poll();

        if canvas.ShouldClose != 0 {
            running = false;
        }

        // ESC to exit
        if canvas.KeyHeld(27) != 0 {
            running = false;
        }
        // Q to exit
        if canvas.KeyHeld(81) != 0 {
            running = false;
        }

        // SPACE toggles warp
        if canvas.KeyHeld(32) != 0 and warpDebounce == 0 {
            field.toggleWarp();
            warpDebounce = 15;
        }
        if warpDebounce > 0 {
            warpDebounce = warpDebounce - 1;
        }

        // UP increases speed
        if canvas.KeyHeld(265) != 0 {
            field.speed = field.speed + 1;
            if field.speed > 30 {
                field.speed = 30;
            }
        }
        // DOWN decreases speed
        if canvas.KeyHeld(264) != 0 {
            field.speed = field.speed - 1;
            if field.speed < 1 {
                field.speed = 1;
            }
        }

        // Clear screen
        canvas.Clear(BLACK);

        // Update and draw starfield
        field.update();
        field.draw(canvas, width, height);

        // Draw UI
        canvas.Text(10, 10, "STARFIELD DEMO", WHITE);
        canvas.Text(10, 25, "UP/DOWN: Speed | SPACE: Warp | ESC: Exit", GRAY);

        if field.warpMode {
            canvas.Text(10, 45, "** WARP ENGAGED **", CYAN);
        }

        canvas.Flip();
        Viper.Time.SleepMs(16);
    }
}

// Main entry point
func main() {
    var canvas = Canvas.New("Viper Starfield Demo", 800, 600);
    run(canvas, 800, 600);
}
