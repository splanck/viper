module snake;

// ============================================================================
// SNAKE.VIPER - Classic Snake Game
// ============================================================================
// Classic arcade snake game.
// ============================================================================

bind "./colors";

bind Viper.Random;
bind Viper.Graphics;
bind Viper.Graphics.Color;
bind Viper.Fmt;
bind Viper.Time;

var DIR_UP: Integer;
var DIR_DOWN: Integer;
var DIR_LEFT: Integer;
var DIR_RIGHT: Integer;

func initDirections() {
    DIR_UP = 0;
    DIR_DOWN = 1;
    DIR_LEFT = 2;
    DIR_RIGHT = 3;
}

// Snake segment
entity Segment {
    expose Integer x;
    expose Integer y;

    expose func init(px: Integer, py: Integer) {
        x = px;
        y = py;
    }
}

// Food
entity Food {
    expose Integer x;
    expose Integer y;
    expose Integer color;

    expose func init(gridWidth: Integer, gridHeight: Integer) {
        spawn(gridWidth, gridHeight);
    }

    expose func spawn(gridWidth: Integer, gridHeight: Integer) {
        x = NextInt(gridWidth);
        y = NextInt(gridHeight);
        color = colors.rainbowPhase(NextInt(360));
    }

    expose func draw(canvas: Canvas, cellSize: Integer, offsetX: Integer, offsetY: Integer) {
        var px = offsetX + x * cellSize + cellSize / 2;
        var py = offsetY + y * cellSize + cellSize / 2;
        var radius = cellSize / 2 - 2;
        if radius < 3 {
            radius = 3;
        }

        canvas.Disc(px, py, radius, color);
        canvas.Ring(px, py, radius, colors.WHITE);
    }
}

// Snake
entity Snake {
    expose List[Segment] segments;
    expose Integer direction;
    expose Integer nextDirection;
    expose Integer growing;
    expose Boolean alive;
    expose Integer headColor;
    expose Integer bodyColor;

    expose func init(startX: Integer, startY: Integer) {
        segments = [];
        direction = DIR_RIGHT;
        nextDirection = DIR_RIGHT;
        growing = 0;
        alive = true;
        headColor = RGB(100, 255, 100);
        bodyColor = RGB(50, 200, 50);

        var i = 0;
        while i < 3 {
            var seg = new Segment();
            seg.init(startX - i, startY);
            segments.add(seg);
            i = i + 1;
        }
    }

    expose func setDirection(dir: Integer) {
        if dir == DIR_UP and direction != DIR_DOWN {
            nextDirection = dir;
        } else if dir == DIR_DOWN and direction != DIR_UP {
            nextDirection = dir;
        } else if dir == DIR_LEFT and direction != DIR_RIGHT {
            nextDirection = dir;
        } else if dir == DIR_RIGHT and direction != DIR_LEFT {
            nextDirection = dir;
        }
    }

    expose func update(gridWidth: Integer, gridHeight: Integer) {
        if not alive {
            return;
        }

        direction = nextDirection;

        var head = segments.get(0);
        var newX = head.x;
        var newY = head.y;

        if direction == DIR_UP {
            newY = newY - 1;
        } else if direction == DIR_DOWN {
            newY = newY + 1;
        } else if direction == DIR_LEFT {
            newX = newX - 1;
        } else if direction == DIR_RIGHT {
            newX = newX + 1;
        }

        if newX < 0 or newX >= gridWidth or newY < 0 or newY >= gridHeight {
            alive = false;
            return;
        }

        var i = 0;
        while i < segments.count() {
            var seg = segments.get(i);
            if seg.x == newX and seg.y == newY {
                alive = false;
                return;
            }
            i = i + 1;
        }

        var newHead = new Segment();
        newHead.init(newX, newY);
        segments.insert(0, newHead);

        if growing > 0 {
            growing = growing - 1;
        } else {
            segments.removeAt(segments.count() - 1);
        }
    }

    expose func grow(amount: Integer) {
        growing = growing + amount;
    }

    expose func getHeadX() -> Integer {
        var head = segments.get(0);
        return head.x;
    }

    expose func getHeadY() -> Integer {
        var head = segments.get(0);
        return head.y;
    }

    expose func getLength() -> Integer {
        return segments.count();
    }

    expose func draw(canvas: Canvas, cellSize: Integer, offsetX: Integer, offsetY: Integer) {
        var i = segments.count() - 1;
        while i >= 0 {
            var seg = segments.get(i);
            var px = offsetX + seg.x * cellSize;
            var py = offsetY + seg.y * cellSize;

            var segColor: Integer;
            if i == 0 {
                segColor = headColor;
            } else {
                var fade = 1.0 - (i * 0.4) / segments.count();
                if fade < 0.4 {
                    fade = 0.4;
                }
                segColor = colors.fadeColor(bodyColor, fade);
            }

            canvas.RoundBox(px + 1, py + 1, cellSize - 2, cellSize - 2, 3, segColor);

            i = i - 1;
        }
    }
}

// Game state
entity SnakeGame {
    expose Snake snake;
    expose Food food;
    expose Integer gridWidth;
    expose Integer gridHeight;
    expose Integer cellSize;
    expose Integer offsetX;
    expose Integer offsetY;
    expose Integer score;
    expose Integer highScore;
    expose Boolean gameOver;
    expose Integer moveTimer;
    expose Integer moveDelay;

    expose func init(screenWidth: Integer, screenHeight: Integer) {
        cellSize = 20;
        gridWidth = (screenWidth - 40) / cellSize;
        gridHeight = (screenHeight - 80) / cellSize;
        offsetX = (screenWidth - gridWidth * cellSize) / 2;
        offsetY = 50;

        score = 0;
        highScore = 0;
        gameOver = false;
        moveTimer = 0;
        moveDelay = 8;

        snake = new Snake();
        snake.init(gridWidth / 2, gridHeight / 2);

        food = new Food();
        food.init(gridWidth, gridHeight);
    }

    expose func restart() {
        if score > highScore {
            highScore = score;
        }

        score = 0;
        gameOver = false;
        moveDelay = 8;

        snake = new Snake();
        snake.init(gridWidth / 2, gridHeight / 2);
        food.spawn(gridWidth, gridHeight);
    }

    expose func update() {
        if gameOver {
            return;
        }

        moveTimer = moveTimer + 1;
        if moveTimer < moveDelay {
            return;
        }
        moveTimer = 0;

        snake.update(gridWidth, gridHeight);

        if not snake.alive {
            gameOver = true;
            return;
        }

        if snake.getHeadX() == food.x and snake.getHeadY() == food.y {
            snake.grow(3);
            score = score + 10;

            if moveDelay > 3 and (score / 50) * 50 == score {
                moveDelay = moveDelay - 1;
            }

            food.spawn(gridWidth, gridHeight);
        }
    }

    expose func draw(canvas: Canvas, screenWidth: Integer, screenHeight: Integer) {
        var gridColor = RGB(30, 40, 30);
        canvas.Box(offsetX, offsetY, gridWidth * cellSize, gridHeight * cellSize, gridColor);

        canvas.Frame(offsetX - 2, offsetY - 2, gridWidth * cellSize + 4, gridHeight * cellSize + 4, colors.WHITE);

        food.draw(canvas, cellSize, offsetX, offsetY);
        snake.draw(canvas, cellSize, offsetX, offsetY);

        var scoreStr = "Score: " + Int(score);
        canvas.TextBg(10, 10, scoreStr, colors.WHITE, colors.BLACK);

        var hiStr = "High: " + Int(highScore);
        canvas.TextBg(screenWidth - 100, 10, hiStr, colors.YELLOW, colors.BLACK);

        if gameOver {
            canvas.Box(screenWidth / 2 - 100, screenHeight / 2 - 40, 200, 80, colors.BLACK);
            canvas.Frame(screenWidth / 2 - 100, screenHeight / 2 - 40, 200, 80, colors.RED);
            canvas.Text(screenWidth / 2 - 50, screenHeight / 2 - 20, "GAME OVER", colors.RED);
            canvas.Text(screenWidth / 2 - 70, screenHeight / 2 + 10, "Press R to restart", colors.WHITE);
        }

        canvas.TextBg(10, screenHeight - 25, "Arrow Keys: Move | R: Restart | ESC: Exit", colors.DARK_GRAY, colors.BLACK);
    }
}

// Run the snake game
func run(canvas: Canvas) {
    var width = canvas.Width;
    var height = canvas.Height;

    colors.initColors();
    initDirections();

    var game = new SnakeGame();
    game.init(width, height);

    var running = true;

    while running {
        canvas.Poll();

        if canvas.ShouldClose != 0 {
            running = false;
        }

        if canvas.KeyHeld(27) != 0 {
            running = false;
        }

        if canvas.KeyHeld(265) != 0 {
            game.snake.setDirection(DIR_UP);
        }
        if canvas.KeyHeld(264) != 0 {
            game.snake.setDirection(DIR_DOWN);
        }
        if canvas.KeyHeld(263) != 0 {
            game.snake.setDirection(DIR_LEFT);
        }
        if canvas.KeyHeld(262) != 0 {
            game.snake.setDirection(DIR_RIGHT);
        }

        if canvas.KeyHeld(87) != 0 {
            game.snake.setDirection(DIR_UP);
        }
        if canvas.KeyHeld(83) != 0 {
            game.snake.setDirection(DIR_DOWN);
        }
        if canvas.KeyHeld(65) != 0 {
            game.snake.setDirection(DIR_LEFT);
        }
        if canvas.KeyHeld(68) != 0 {
            game.snake.setDirection(DIR_RIGHT);
        }

        if canvas.KeyHeld(82) != 0 {
            game.restart();
            Viper.Time.SleepMs(200);
        }

        game.update();

        canvas.Clear(RGB(20, 25, 20));
        game.draw(canvas, width, height);

        canvas.Flip();
        Viper.Time.SleepMs(16);
    }
}
