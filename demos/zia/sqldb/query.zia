// query.zia — SELECT/Query Processing Engine
// Part of ViperSQL
//
// Handles SELECT statement execution, including:
//   - Single-table queries with WHERE, ORDER BY, GROUP BY, HAVING
//   - View materialization and derived table (subquery in FROM)
//   - Aggregate queries (COUNT, SUM, AVG, MIN, MAX)
//   - DISTINCT, LIMIT/OFFSET
//   - CTE (Common Table Expressions) with WITH clause
//   - Result set sorting (quicksort) for ORDER BY
//
// The QueryHandler holds a back-reference to the Executor for access
// to shared state (database, indexes, expression evaluation, etc.).

module query;

bind String = Viper.String;
bind Fmt = Viper.Fmt;
bind Viper.Math;

bind "./types";
bind "./schema";
bind "./table";
bind "./expr";
bind "./stmt";
bind "./result";
bind "./database";
bind "./index";
bind "./executor";
bind "./parser";
bind "./server";
bind "./optimizer/optimizer";
bind "./sql_window";
bind "./system_views";

//=============================================================================
// QUERY HANDLER ENTITY
//=============================================================================

entity QueryHandler {
    expose Executor exec;

    expose func init(executor: Executor) {
        exec = executor;
    }

    //=========================================================================
    // AGGREGATE EVALUATION
    //=========================================================================

    // Evaluate an aggregate function over a list of row indices
    expose func evalAggregate(expr: Expr, matchingRows: List[Integer], table: Table) -> SqlValue {
        // Apply FILTER clause if present — restrict rows before aggregation
        var filteredRows = matchingRows;
        if expr.filterExpr != null {
            filteredRows = [];
            var fi = 0;
            while fi < matchingRows.count() {
                var fRowIdx = matchingRows.get(fi);
                var fMaybeRow = table.getRow(fRowIdx);
                if fMaybeRow != null {
                    var fRow = fMaybeRow;
                    if exec.evalCondition(expr.filterExpr, fRow, table) {
                        filteredRows.add(fRowIdx);
                    }
                }
                fi = fi + 1;
            }
            matchingRows = filteredRows;
        }

        var funcName = String.ToUpper(expr.funcName);
        var hasArg = expr.args.count() > 0;

        // COUNT(DISTINCT column) - count distinct non-NULL values
        if funcName == "COUNT_DISTINCT" && hasArg {
            var seen = new List[String]();
            var i = 0;
            while i < matchingRows.count() {
                var rowIdx = matchingRows.get(i);
                var maybeRow = table.getRow(rowIdx);
                if maybeRow != null {
                    var row = maybeRow;
                    var argExpr = expr.args.get(0);
                    var val = exec.evalExpr(argExpr, row, table);
                    if val.kind != SQL_NULL {
                        var valStr = val.toString();
                        var found = false;
                        var k = 0;
                        while k < seen.count() {
                            if seen.get(k) == valStr {
                                found = true;
                                k = seen.count();
                            }
                            k = k + 1;
                        }
                        if found == false {
                            seen.add(valStr);
                        }
                    }
                }
                i = i + 1;
            }
            return sqlInteger(seen.count());
        }

        // COUNT(*)
        if funcName == "COUNT" && hasArg {
            var arg0 = expr.args.get(0);
            if arg0.kind == EXPR_STAR {
                return sqlInteger(matchingRows.count());
            }
        }

        // COUNT(column) - count non-NULL values
        if funcName == "COUNT" {
            var count = 0;
            var i = 0;
            while i < matchingRows.count() {
                var rowIdx = matchingRows.get(i);
                var maybeRow = table.getRow(rowIdx);
                if maybeRow != null {
                    var row = maybeRow;
                    if hasArg {
                        var argExpr = expr.args.get(0);
                        var val = exec.evalExpr(argExpr, row, table);
                        if val.kind != SQL_NULL {
                            count = count + 1;
                        }
                    }
                }
                i = i + 1;
            }
            return sqlInteger(count);
        }

        // SUM(column)
        if funcName == "SUM" {
            var sumInt = 0;
            var sumReal = 0.0;
            var hasValue = false;
            var hasReal = false;
            var i = 0;
            while i < matchingRows.count() {
                var rowIdx = matchingRows.get(i);
                var maybeRow = table.getRow(rowIdx);
                if maybeRow != null {
                    var row = maybeRow;
                    if hasArg {
                        var argExpr = expr.args.get(0);
                        var val = exec.evalExpr(argExpr, row, table);
                        if val.kind == SQL_INTEGER {
                            sumInt = sumInt + val.intValue;
                            hasValue = true;
                        } else if val.kind == SQL_REAL {
                            sumReal = sumReal + val.realValue;
                            hasValue = true;
                            hasReal = true;
                        }
                    }
                }
                i = i + 1;
            }
            if hasValue == false {
                return sqlNull();
            }
            if hasReal {
                var total = sumReal + sumInt * 1.0;
                return sqlReal(total, Fmt.Num(total));
            }
            return sqlInteger(sumInt);
        }

        // AVG(column)
        if funcName == "AVG" {
            var sumInt = 0;
            var sumReal = 0.0;
            var count = 0;
            var hasReal = false;
            var i = 0;
            while i < matchingRows.count() {
                var rowIdx = matchingRows.get(i);
                var maybeRow = table.getRow(rowIdx);
                if maybeRow != null {
                    var row = maybeRow;
                    if hasArg {
                        var argExpr = expr.args.get(0);
                        var val = exec.evalExpr(argExpr, row, table);
                        if val.kind == SQL_INTEGER {
                            sumInt = sumInt + val.intValue;
                            count = count + 1;
                        } else if val.kind == SQL_REAL {
                            sumReal = sumReal + val.realValue;
                            count = count + 1;
                            hasReal = true;
                        }
                    }
                }
                i = i + 1;
            }
            if count == 0 {
                return sqlNull();
            }
            var total = sumReal + sumInt * 1.0;
            var avg = total / count;
            return sqlReal(avg, Fmt.Num(avg));
        }

        // MIN(column) - handles INTEGER and REAL
        if funcName == "MIN" {
            var hasMin = false;
            var minResult = sqlNull();
            var i = 0;
            while i < matchingRows.count() {
                var rowIdx = matchingRows.get(i);
                var maybeRow = table.getRow(rowIdx);
                if maybeRow != null {
                    var row = maybeRow;
                    if hasArg {
                        var argExpr = expr.args.get(0);
                        var val = exec.evalExpr(argExpr, row, table);
                        if val.kind != SQL_NULL {
                            if hasMin == false {
                                minResult = val;
                                hasMin = true;
                            } else {
                                var cmp = val.compare(minResult);
                                if cmp < 0 {
                                    minResult = val;
                                }
                            }
                        }
                    }
                }
                i = i + 1;
            }
            if hasMin == false {
                return sqlNull();
            }
            return minResult;
        }

        // MAX(column) - handles INTEGER and REAL
        if funcName == "MAX" {
            var hasMax = false;
            var maxResult = sqlNull();
            var i = 0;
            while i < matchingRows.count() {
                var rowIdx = matchingRows.get(i);
                var maybeRow = table.getRow(rowIdx);
                if maybeRow != null {
                    var row = maybeRow;
                    if hasArg {
                        var argExpr = expr.args.get(0);
                        var val = exec.evalExpr(argExpr, row, table);
                        if val.kind != SQL_NULL {
                            if hasMax == false {
                                maxResult = val;
                                hasMax = true;
                            } else {
                                var cmp = val.compare(maxResult);
                                if cmp > 0 {
                                    maxResult = val;
                                }
                            }
                        }
                    }
                }
                i = i + 1;
            }
            if hasMax == false {
                return sqlNull();
            }
            return maxResult;
        }

        // STRING_AGG(column, separator) - concatenate values with separator
        if (funcName == "STRING_AGG" || funcName == "GROUP_CONCAT") && hasArg {
            var separator = ",";
            if expr.args.count() >= 2 {
                // Evaluate separator from second arg
                if matchingRows.count() > 0 {
                    var firstRowIdx = matchingRows.get(0);
                    var firstRowMaybe = table.getRow(firstRowIdx);
                    if firstRowMaybe != null {
                        var firstRow = firstRowMaybe;
                        separator = exec.evalExpr(expr.args.get(1), firstRow, table).toString();
                    }
                }
            }
            var result = "";
            var first = true;
            var i = 0;
            while i < matchingRows.count() {
                var rowIdx = matchingRows.get(i);
                var maybeRow = table.getRow(rowIdx);
                if maybeRow != null {
                    var row = maybeRow;
                    var argExpr = expr.args.get(0);
                    var val = exec.evalExpr(argExpr, row, table);
                    if val.kind != SQL_NULL {
                        if first == false {
                            result = result + separator;
                        }
                        result = result + val.toString();
                        first = false;
                    }
                }
                i = i + 1;
            }
            if first { return sqlNull(); }
            return sqlText(result);
        }

        // ARRAY_AGG(column) - collect values into an array
        if funcName == "ARRAY_AGG" && hasArg {
            var elements: List[String] = [];
            var i = 0;
            while i < matchingRows.count() {
                var rowIdx = matchingRows.get(i);
                var maybeRow = table.getRow(rowIdx);
                if maybeRow != null {
                    var row = maybeRow;
                    var argExpr = expr.args.get(0);
                    var val = exec.evalExpr(argExpr, row, table);
                    if val.kind == SQL_NULL {
                        elements.add("NULL");
                    } else {
                        elements.add(val.toString());
                    }
                }
                i = i + 1;
            }
            return sqlArray(buildArrayString(elements));
        }

        // BOOL_AND(column) - logical AND of all non-NULL boolean values
        if funcName == "BOOL_AND" && hasArg {
            var result = true;
            var hasValue = false;
            var i = 0;
            while i < matchingRows.count() {
                var rowIdx = matchingRows.get(i);
                var maybeRow = table.getRow(rowIdx);
                if maybeRow != null {
                    var row = maybeRow;
                    var argExpr = expr.args.get(0);
                    var val = exec.evalExpr(argExpr, row, table);
                    if val.kind != SQL_NULL {
                        hasValue = true;
                        if val.intValue == 0 { result = false; }
                    }
                }
                i = i + 1;
            }
            if hasValue == false { return sqlNull(); }
            if result { return sqlBoolean(true); }
            return sqlBoolean(false);
        }

        // BOOL_OR(column) - logical OR of all non-NULL boolean values
        if funcName == "BOOL_OR" && hasArg {
            var result = false;
            var hasValue = false;
            var i = 0;
            while i < matchingRows.count() {
                var rowIdx = matchingRows.get(i);
                var maybeRow = table.getRow(rowIdx);
                if maybeRow != null {
                    var row = maybeRow;
                    var argExpr = expr.args.get(0);
                    var val = exec.evalExpr(argExpr, row, table);
                    if val.kind != SQL_NULL {
                        hasValue = true;
                        if val.intValue != 0 { result = true; }
                    }
                }
                i = i + 1;
            }
            if hasValue == false { return sqlNull(); }
            if result { return sqlBoolean(true); }
            return sqlBoolean(false);
        }

        return sqlNull();
    }

    //=========================================================================
    // SELECT EXECUTION
    //=========================================================================

    // Execute SELECT against a view by materializing the view as a temp table
    hide func executeViewSelect(stmt: SelectStmt, viewSql: String) -> QueryResult {
        // Execute the view definition to get the data
        var viewResult = exec.executeSql(viewSql);
        if viewResult.success == false {
            return viewResult;
        }

        // Create a temporary table from the view results
        var tempTable = new Table();
        tempTable.initWithName("_view_" + stmt.tableName);

        // Add columns from view result
        var ci = 0;
        while ci < viewResult.columnNames.count() {
            var col = new Column();
            col.initWithName(viewResult.columnNames.get(ci), SQL_TEXT);
            tempTable.addColumn(col);
            ci = ci + 1;
        }

        // Add rows from view result
        var ri = 0;
        while ri < viewResult.rowCount() {
            var srcRow = viewResult.getRow(ri);
            if srcRow != null {
                var sr = srcRow;
                tempTable.addRow(sr);
            }
            ri = ri + 1;
        }

        // Temporarily add the temp table to the database
        exec.db.addTable(tempTable);

        // Re-execute the SELECT against the temp table
        var modifiedStmt = new SelectStmt();
        modifiedStmt.init();
        modifiedStmt.selectAll = stmt.selectAll;
        modifiedStmt.isDistinct = stmt.isDistinct;
        modifiedStmt.distinctOnExprs = stmt.distinctOnExprs;
        modifiedStmt.limitValue = stmt.limitValue;
        modifiedStmt.offsetValue = stmt.offsetValue;
        modifiedStmt.tableName = tempTable.name;
        modifiedStmt.tableAlias = stmt.tableAlias;
        modifiedStmt.whereClause = stmt.whereClause;
        modifiedStmt.havingClause = stmt.havingClause;

        // Copy columns
        ci = 0;
        while ci < stmt.columns.count() {
            if ci < stmt.columnAliases.count() {
                modifiedStmt.addColumnWithAlias(stmt.columns.get(ci), stmt.columnAliases.get(ci));
            } else {
                modifiedStmt.addColumn(stmt.columns.get(ci));
            }
            ci = ci + 1;
        }

        // Copy GROUP BY
        ci = 0;
        while ci < stmt.groupByExprs.count() {
            modifiedStmt.addGroupBy(stmt.groupByExprs.get(ci));
            ci = ci + 1;
        }

        // Copy ORDER BY
        ci = 0;
        while ci < stmt.orderByExprs.count() {
            modifiedStmt.addOrderBy(stmt.orderByExprs.get(ci), stmt.orderByDir.get(ci));
            ci = ci + 1;
        }

        // Copy table names for single table
        modifiedStmt.addTable(tempTable.name, stmt.tableAlias);

        // Copy join info if any (shouldn't be for views but just in case)
        ci = 0;
        while ci < stmt.joinTypes.count() {
            modifiedStmt.joinTypes.add(stmt.joinTypes.get(ci));
            ci = ci + 1;
        }
        ci = 0;
        while ci < stmt.joinConditions.count() {
            modifiedStmt.joinConditions.add(stmt.joinConditions.get(ci));
            ci = ci + 1;
        }

        var result = executeSelect(modifiedStmt);

        // Remove temp table
        exec.db.dropTable(tempTable.name);

        return result;
    }

    // Handle SELECT with derived table (subquery in FROM)
    hide func executeDerivedTableSelect(stmt: SelectStmt) -> QueryResult {
        // Execute the subquery
        var subResult = exec.executeSql(stmt.derivedTableSQL);
        if subResult.success == false {
            return subResult;
        }

        // Create a temporary table from the subquery results
        var tempName = "_derived_" + stmt.derivedTableAlias;
        var tempTable = new Table();
        tempTable.initWithName(tempName);

        var ci = 0;
        while ci < subResult.columnNames.count() {
            var col = new Column();
            col.initWithName(subResult.columnNames.get(ci), SQL_TEXT);
            tempTable.addColumn(col);
            ci = ci + 1;
        }

        var ri = 0;
        while ri < subResult.rowCount() {
            var srcRow = subResult.getRow(ri);
            if srcRow != null {
                var sr = srcRow;
                tempTable.addRow(sr);
            }
            ri = ri + 1;
        }

        // Add temp table to database
        exec.db.addTable(tempTable);

        // Build modified SELECT against the temp table
        var modStmt = new SelectStmt();
        modStmt.init();
        modStmt.selectAll = stmt.selectAll;
        modStmt.isDistinct = stmt.isDistinct;
        modStmt.distinctOnExprs = stmt.distinctOnExprs;
        modStmt.limitValue = stmt.limitValue;
        modStmt.offsetValue = stmt.offsetValue;
        modStmt.tableName = tempName;
        modStmt.tableAlias = stmt.derivedTableAlias;
        modStmt.whereClause = stmt.whereClause;
        modStmt.havingClause = stmt.havingClause;

        ci = 0;
        while ci < stmt.columns.count() {
            if ci < stmt.columnAliases.count() {
                modStmt.addColumnWithAlias(stmt.columns.get(ci), stmt.columnAliases.get(ci));
            } else {
                modStmt.addColumn(stmt.columns.get(ci));
            }
            ci = ci + 1;
        }

        ci = 0;
        while ci < stmt.groupByExprs.count() {
            modStmt.addGroupBy(stmt.groupByExprs.get(ci));
            ci = ci + 1;
        }

        ci = 0;
        while ci < stmt.orderByExprs.count() {
            modStmt.addOrderBy(stmt.orderByExprs.get(ci), stmt.orderByDir.get(ci));
            ci = ci + 1;
        }

        modStmt.addTable(tempName, stmt.derivedTableAlias);

        var result = executeSelect(modStmt);

        // Cleanup temp table
        exec.db.dropTable(tempName);

        return result;
    }

    // Handle SELECT without FROM clause (e.g., SELECT 1+1, SELECT EXISTS(...))
    hide func executeExpressionSelect(stmt: SelectStmt) -> QueryResult {
        var result = new QueryResult();
        result.init();

        // Create a dummy row and table for expression evaluation
        var dummyRow = new Row();
        dummyRow.initWithCount(0);
        var dummyTable = new Table();
        dummyTable.init();

        // Build column names
        var c = 0;
        while c < stmt.columns.count() {
            var alias = "";
            if c < stmt.columnAliases.count() {
                alias = stmt.columnAliases.get(c);
            }
            if alias != "" {
                result.addColumnName(alias);
            } else {
                var colExpr = stmt.columns.get(c);
                if colExpr.kind == EXPR_FUNCTION {
                    result.addColumnName(colExpr.funcName);
                } else {
                    result.addColumnName("col" + Fmt.Int(c));
                }
            }
            c = c + 1;
        }

        // Evaluate each column expression
        var row = new Row();
        row.initWithCount(stmt.columns.count());
        c = 0;
        while c < stmt.columns.count() {
            var val = exec.evalExpr(stmt.columns.get(c), dummyRow, dummyTable);
            row.setValue(c, val);
            c = c + 1;
        }
        result.addRow(row);

        return result;
    }

    expose func executeSelect(stmt: SelectStmt) -> QueryResult {
        // Acquire shared locks on all FROM/JOIN tables
        if stmt.tableNames.count() > 0 {
            var li = 0;
            while li < stmt.tableNames.count() {
                if exec.acquireSharedLock(stmt.tableNames.get(li)) == false {
                    return exec.lockTimeoutError(stmt.tableNames.get(li));
                }
                li = li + 1;
            }
        } else if stmt.tableName != "" {
            if exec.acquireSharedLock(stmt.tableName) == false {
                return exec.lockTimeoutError(stmt.tableName);
            }
        }

        // Privilege check: SELECT requires PRIV_SELECT on all tables
        if stmt.tableNames.count() > 0 {
            var pi = 0;
            while pi < stmt.tableNames.count() {
                var privErr = exec.checkPrivilege(stmt.tableNames.get(pi), PRIV_SELECT);
                if privErr != null {
                    return privErr;
                }
                pi = pi + 1;
            }
        } else if stmt.tableName != "" {
            var privErr = exec.checkPrivilege(stmt.tableName, PRIV_SELECT);
            if privErr != null {
                return privErr;
            }
        }

        // Handle SELECT without FROM (e.g., SELECT 1+1, SELECT EXISTS(...))
        if stmt.tableName == "" && stmt.tableNames.count() == 0 {
            return executeExpressionSelect(stmt);
        }

        // Handle system views (information_schema.*, sys.*)
        if isSystemView(stmt.tableName) {
            var sysViewUpper = String.ToUpper(stmt.tableName);
            // Views needing executor-level data (not just server data)
            if sysViewUpper == "SYS.VACUUM_STATS" {
                return buildVacuumStatsView();
            }
            if sysViewUpper == "PG_STAT_ACTIVITY" || sysViewUpper == "PG_CATALOG.PG_STAT_ACTIVITY" {
                return buildPgStatActivity();
            }
            if sysViewUpper == "PG_STAT_USER_TABLES" || sysViewUpper == "PG_CATALOG.PG_STAT_USER_TABLES" {
                return buildPgStatUserTables();
            }
            if sysViewUpper == "PG_STAT_USER_INDEXES" || sysViewUpper == "PG_CATALOG.PG_STAT_USER_INDEXES" {
                return buildPgStatUserIndexes();
            }
            return executeSystemView(stmt.tableName, exec.server, exec.currentDbName);
        }

        // Handle derived table (subquery in FROM)
        if stmt.hasDerivedTable {
            return executeDerivedTableSelect(stmt);
        }

        // Check for multi-table (JOIN) query
        if stmt.tableNames.count() > 1 {
            return exec.joinEngine.executeCrossJoin(stmt);
        }

        // Handle table functions (GENERATE_SERIES, etc.)
        if stmt.hasTableFunction && String.ToUpper(stmt.tableName) == "GENERATE_SERIES" {
            return executeGenerateSeries(stmt);
        }

        var result = new QueryResult();
        result.init();

        var table = exec.findTable(stmt.tableName);
        if table == null {
            // Check if it's a view
            var viewSql = exec.db.findView(stmt.tableName);
            if viewSql != "" {
                return executeViewSelect(stmt, viewSql);
            }
            result.setError("Table '" + stmt.tableName + "' not found");
            return result;
        }

        var t = table;

        // Partition-aware SELECT: if parent table, query all children
        if t.isPartitioned && t.partitionChildren.count() > 0 {
            return executePartitionedSelect(stmt, t);
        }

        // Inheritance-aware SELECT: if parent with children and ONLY not specified
        if t.hasChildren && t.inheritChildren.count() > 0 && stmt.onlyFlag == false {
            return executeInheritanceSelect(stmt, t);
        }

        exec.currentTableAlias = stmt.tableAlias;

        // Build column names for result
        if stmt.selectAll {
            var c = 0;
            while c < t.columnCount() {
                var col = t.getColumn(c);
                if col != null {
                    var column = col;
                    result.addColumnName(column.name);
                }
                c = c + 1;
            }
        } else {
            var c = 0;
            while c < stmt.columns.count() {
                // Check for column alias first
                var alias = "";
                if c < stmt.columnAliases.count() {
                    alias = stmt.columnAliases.get(c);
                }
                if alias != "" {
                    result.addColumnName(alias);
                } else {
                    var colExpr = stmt.columns.get(c);
                    if colExpr.kind == EXPR_COLUMN {
                        result.addColumnName(colExpr.columnName);
                    } else if colExpr.kind == EXPR_FUNCTION {
                        var displayName = colExpr.funcName;
                        if displayName == "COUNT_DISTINCT" {
                            displayName = "COUNT";
                        }
                        result.addColumnName(displayName);
                    } else {
                        result.addColumnName("col" + Fmt.Int(c));
                    }
                }
                c = c + 1;
            }
        }

        // First pass: collect matching row indices
        // Use optimizer to choose access path (index seek vs table scan)
        var matchingRows = new List[Integer]();
        var usedIndex = false;
        var accessPathUsed = "TABLE_SCAN";

        if stmt.whereClause != null && exec.canUseIndex(stmt.whereClause, stmt.tableName) {
            // Compare optimizer costs: index seek vs table scan
            var scanPath = exec.optimizer.createTableScan(stmt.tableName);
            var selectivityPct = exec.optimizer.estimateSelectivityPct(true);
            var wc = stmt.whereClause;
            var idxColName = "";
            if wc.getLeft().kind == EXPR_COLUMN {
                idxColName = wc.getLeft().columnName;
            } else if wc.getRight().kind == EXPR_COLUMN {
                idxColName = wc.getRight().columnName;
            }
            var idxName = "";
            var maybeIdx = exec.indexMgr.findIndexForColumn(stmt.tableName, idxColName);
            if maybeIdx != null {
                var foundIdx = maybeIdx;
                idxName = foundIdx.name;
            }
            var seekPath = exec.optimizer.createIndexSeek(stmt.tableName, idxName, selectivityPct);

            // Use index if it has lower cost
            if seekPath.estimatedCost < scanPath.estimatedCost {
                matchingRows = exec.indexLookup(wc, stmt.tableName, t);
                usedIndex = true;
                accessPathUsed = "INDEX_SEEK";
                exec.recordIdxScan(stmt.tableName, matchingRows.count());
                if idxName != "" {
                    exec.recordIndexScan(idxName, stmt.tableName, matchingRows.count(), matchingRows.count());
                }
                // Filter out deleted rows from index results
                var filtered = new List[Integer]();
                var fi = 0;
                while fi < matchingRows.count() {
                    var rowIdx = matchingRows.get(fi);
                    var maybeRow = t.getRow(rowIdx);
                    if maybeRow != null {
                        var row = maybeRow;
                        if row.isVisible(exec.mvccSnapshotId, exec.mvccTxnId) {
                            filtered.add(rowIdx);
                        }
                    }
                    fi = fi + 1;
                }
                matchingRows = filtered;
            }
        }

        // Try range index if equality index was not used
        if usedIndex == false && stmt.whereClause != null && exec.canUseIndexRange(stmt.whereClause, stmt.tableName) {
            var wc = stmt.whereClause;
            var scanPath = exec.optimizer.createTableScan(stmt.tableName);
            var rangeSel = RANGE_SELECTIVITY;
            var rangeColName = "";
            if wc.getLeft().kind == EXPR_COLUMN {
                rangeColName = wc.getLeft().columnName;
            } else if wc.op == OP_AND && wc.getLeft().getLeft().kind == EXPR_COLUMN {
                rangeColName = wc.getLeft().getLeft().columnName;
            }
            var rangeIdxName = "";
            var maybeRangeIdx = exec.indexMgr.findIndexForColumn(stmt.tableName, rangeColName);
            if maybeRangeIdx != null {
                var rIdx = maybeRangeIdx;
                rangeIdxName = rIdx.name;
            }
            var rangePath = exec.optimizer.createIndexSeek(stmt.tableName, rangeIdxName, rangeSel);

            // Use range index scan if cost-effective
            if rangePath.estimatedCost < scanPath.estimatedCost {
                matchingRows = exec.indexRangeLookup(wc, stmt.tableName, t);
                usedIndex = true;
                accessPathUsed = "INDEX_RANGE_SCAN";
                exec.recordIdxScan(stmt.tableName, matchingRows.count());
                if rangeIdxName != "" {
                    exec.recordIndexScan(rangeIdxName, stmt.tableName, matchingRows.count(), matchingRows.count());
                }
            }
        }

        // Fall back to linear scan if no index was used
        if usedIndex == false {
            exec.recordSeqScan(stmt.tableName, t.rowCount());
            var r = 0;
            while r < t.rowCount() {
                var row = t.getRow(r);
                if row != null {
                    var rowData = row;
                    if rowData.isVisible(exec.mvccSnapshotId, exec.mvccTxnId) {
                        if exec.evalCondition(stmt.whereClause, rowData, t) {
                            matchingRows.add(r);
                        }
                    }
                }
                r = r + 1;
            }
        }

        // Phase 70: TABLESAMPLE — randomly sample a percentage of rows
        if stmt.tablesamplePercent >= 0 && stmt.tablesamplePercent < 100 {
            var sampledRows = new List[Integer]();
            var si = 0;
            var threshold = stmt.tablesamplePercent * 21474836;  // ~pct of 2147483647
            while si < matchingRows.count() {
                exec.randomSeed = (exec.randomSeed * 1103515245 + 12345) % 2147483647;
                if exec.randomSeed < threshold || (exec.randomSeed < 0 && stmt.tablesamplePercent > 0) {
                    sampledRows.add(matchingRows.get(si));
                }
                si = si + 1;
            }
            matchingRows = sampledRows;
        }

        // Apply row-level locks if FOR UPDATE / FOR SHARE specified
        if stmt.lockMode > 0 {
            var lockedRows = new List[Integer]();
            var ri = 0;
            while ri < matchingRows.count() {
                var rowIdx = matchingRows.get(ri);
                var lockResult = exec.acquireRowLockForSelect(
                    stmt.tableName, rowIdx, stmt.lockMode, stmt.lockNowait);
                if lockResult == 0 {
                    // Lock acquired
                    lockedRows.add(rowIdx);
                } else if lockResult == 1 && stmt.lockSkipLocked {
                    // Conflict — skip this row (SKIP LOCKED)
                } else if lockResult == 1 {
                    // Conflict — block (non-NOWAIT, non-SKIP LOCKED)
                    // Try blocking acquire
                    if exec.rowLockMgr != null {
                        var rlm = exec.rowLockMgr;
                        if rlm.acquireRowLock(exec.sessionId, stmt.tableName, rowIdx, stmt.lockMode) {
                            lockedRows.add(rowIdx);
                        } else {
                            return exec.rowLockError(stmt.tableName, rowIdx);
                        }
                    } else {
                        lockedRows.add(rowIdx);
                    }
                } else {
                    // NOWAIT conflict — return error
                    return exec.rowLockError(stmt.tableName, rowIdx);
                }
                ri = ri + 1;
            }
            matchingRows = lockedRows;
        }

        // Check if this is an aggregate query
        var isAggregate = exec.hasAggregates(stmt);

        if isAggregate && stmt.groupByExprs.count() == 0 {
            // Aggregate query without GROUP BY: return single row
            var resultRow = new Row();
            resultRow.init();

            var c = 0;
            while c < stmt.columns.count() {
                var colExpr = stmt.columns.get(c);
                if exec.isAggregateExpr(colExpr) {
                    var val = evalAggregate(colExpr, matchingRows, t);
                    resultRow.addValue(val);
                } else if colExpr.kind == EXPR_COLUMN {
                    // For non-aggregate columns, use first matching row value
                    if matchingRows.count() > 0 {
                        var firstRow = t.getRow(matchingRows.get(0));
                        if firstRow != null {
                            var fr = firstRow;
                            var val = exec.evalExpr(colExpr, fr, t);
                            resultRow.addValue(val);
                        } else {
                            resultRow.addValue(sqlNull());
                        }
                    } else {
                        resultRow.addValue(sqlNull());
                    }
                } else {
                    resultRow.addValue(sqlNull());
                }
                c = c + 1;
            }
            result.addRow(resultRow);

        } else if stmt.groupByExprs.count() > 0 {
            // GROUP BY query
            executeGroupBy(stmt, matchingRows, t, result);

        } else {
            // Regular (non-aggregate) query
            // Sort matchingRows BEFORE projection so ORDER BY evaluates
            // against full table rows (not projected result rows)
            if stmt.orderByExprs.count() > 0 {
                // Phase 70: Resolve column aliases in ORDER BY to actual expressions
                var resolvedOrderExprs = stmt.orderByExprs;
                if stmt.columnAliases.count() > 0 {
                    resolvedOrderExprs = [];
                    var oe = 0;
                    while oe < stmt.orderByExprs.count() {
                        var oExpr = stmt.orderByExprs.get(oe);
                        var resolved = false;
                        if oExpr.kind == EXPR_COLUMN {
                            var ai = 0;
                            while ai < stmt.columnAliases.count() {
                                if stmt.columnAliases.get(ai) == oExpr.columnName {
                                    // Replace alias with actual select expression
                                    resolvedOrderExprs.add(stmt.columns.get(ai));
                                    resolved = true;
                                    ai = stmt.columnAliases.count();
                                }
                                ai = ai + 1;
                            }
                        }
                        if resolved == false {
                            resolvedOrderExprs.add(oExpr);
                        }
                        oe = oe + 1;
                    }
                }
                sortMatchingRows(matchingRows, resolvedOrderExprs, stmt.orderByDir, stmt.orderByNulls, t);
            }

            var i = 0;
            while i < matchingRows.count() {
                var rowIdx = matchingRows.get(i);
                var row = t.getRow(rowIdx);
                if row != null {
                    var rowData = row;
                    var resultRow = new Row();
                    resultRow.init();

                    if stmt.selectAll {
                        var c = 0;
                        while c < rowData.columnCount() {
                            resultRow.addValue(exec.cloneValue(rowData.getValue(c)));
                            c = c + 1;
                        }
                    } else {
                        var c = 0;
                        while c < stmt.columns.count() {
                            var colExpr = stmt.columns.get(c);
                            var val = exec.evalExpr(colExpr, rowData, t);
                            resultRow.addValue(exec.cloneValue(val));
                            c = c + 1;
                        }
                    }

                    result.addRow(resultRow);
                }
                i = i + 1;
            }
        }

        // Apply window functions (before DISTINCT/ORDER BY)
        applyWindowFunctions(stmt, result, t);

        // Apply DISTINCT
        if stmt.isDistinct {
            applyDistinct(result);
        }

        // Apply ORDER BY for aggregate/GROUP BY paths (regular path sorted above)
        if stmt.orderByExprs.count() > 0 && (exec.hasAggregates(stmt) || stmt.groupByExprs.count() > 0) {
            sortResults(result, stmt.orderByExprs, stmt.orderByDir, stmt.orderByNulls, t, stmt.columns, stmt.columnAliases);
        }

        // Apply DISTINCT ON (after ORDER BY, before LIMIT/OFFSET)
        if stmt.distinctOnExprs.count() > 0 {
            applyDistinctOn(stmt, result);
        }

        // Apply LIMIT/OFFSET
        if stmt.limitValue >= 0 || stmt.offsetValue > 0 {
            var actualLimit = stmt.limitValue;
            // Phase 69: LIMIT n PERCENT
            if stmt.isLimitPercent && actualLimit >= 0 {
                var totalRows = result.rowCount();
                actualLimit = (totalRows * actualLimit) / 100;
                if actualLimit < 1 && totalRows > 0 { actualLimit = 1; }
            }
            applyLimitOffset(result, actualLimit, stmt.offsetValue);
        }

        exec.currentTableAlias = "";
        return result;
    }

    //=========================================================================
    // GROUP BY
    //=========================================================================

    // Execute GROUP BY query using hash-based grouping (O(n) amortized).
    //
    // Algorithm:
    //   1. Build a hash table with 128 buckets, keyed by the concatenated
    //      string representation of GROUP BY column values (pipe-separated).
    //   2. For each matching row, compute the group key, hash it, and look up
    //      the bucket. If the key already exists in the bucket (via linear
    //      scan for collision resolution), add the row to that group.
    //      Otherwise, create a new group.
    //   3. After grouping, evaluate SELECT expressions for each group,
    //      computing aggregates (COUNT, SUM, AVG, MIN, MAX) over each
    //      group's row list.
    //   4. Optionally filter groups with HAVING clause.
    //
    // The 128-bucket count is a balance between memory usage and collision
    // frequency. For typical SQL workloads with <100 distinct groups, most
    // buckets have 0-1 entries, giving O(1) amortized lookups.
    expose func executeGroupBy(stmt: SelectStmt, matchingRows: List[Integer], table: Table, result: QueryResult) {
        // Phase 59: If groupingSets is non-empty, dispatch to multi-set grouping
        if stmt.groupingSets.count() > 0 {
            executeGroupingSets(stmt, matchingRows, table, result);
            return;
        }

        // Build groups based on GROUP BY columns using hash buckets
        var groupKeys = new List[String]();
        var groupRowLists = new List[List[Integer]]();

        // Hash bucket table: each bucket stores indices into groupKeys
        var numBuckets = 128;
        var buckets = new List[List[Integer]]();
        var b = 0;
        while b < numBuckets {
            buckets.add(new List[Integer]());
            b = b + 1;
        }

        var i = 0;
        while i < matchingRows.count() {
            var rowIdx = matchingRows.get(i);
            var row = table.getRow(rowIdx);
            if row != null {
                var rowData = row;
                // Build group key from GROUP BY expressions
                var key = "";
                var g = 0;
                while g < stmt.groupByExprs.count() {
                    var groupExpr = stmt.groupByExprs.get(g);
                    var val = exec.evalExpr(groupExpr, rowData, table);
                    if g > 0 {
                        key = key + "|";
                    }
                    key = key + val.toString();
                    g = g + 1;
                }

                // Hash-based group lookup
                var keyHash = exec.computeKeyHash(key);
                var bucketIdx = keyHash % numBuckets;
                var bucket = buckets.get(bucketIdx);

                var groupIdx = -1;
                var k = 0;
                while k < bucket.count() {
                    var gIdx = bucket.get(k);
                    if groupKeys.get(gIdx) == key {
                        groupIdx = gIdx;
                        k = bucket.count();  // break
                    }
                    k = k + 1;
                }

                if groupIdx < 0 {
                    // New group: add to keys, row lists, and bucket
                    var newGIdx = groupKeys.count();
                    groupKeys.add(key);
                    var newList = new List[Integer]();
                    newList.add(rowIdx);
                    groupRowLists.add(newList);
                    bucket.add(newGIdx);
                } else {
                    var existingList = groupRowLists.get(groupIdx);
                    existingList.add(rowIdx);
                }
            }
            i = i + 1;
        }

        // Build result rows from groups
        var g = 0;
        while g < groupKeys.count() {
            var groupRows = groupRowLists.get(g);
            var resultRow = new Row();
            resultRow.init();

            // Get first row in group for non-aggregate columns
            var firstRowIdx = groupRows.get(0);
            var firstRow = table.getRow(firstRowIdx);

            var c = 0;
            while c < stmt.columns.count() {
                var colExpr = stmt.columns.get(c);
                if exec.isAggregateExpr(colExpr) {
                    var val = evalAggregate(colExpr, groupRows, table);
                    resultRow.addValue(val);
                } else if firstRow != null {
                    var fr = firstRow;
                    var val = exec.evalExpr(colExpr, fr, table);
                    resultRow.addValue(val);
                } else {
                    resultRow.addValue(sqlNull());
                }
                c = c + 1;
            }

            // Check HAVING condition before adding row
            if stmt.havingClause != null {
                var hc = stmt.havingClause;
                if evalHavingExpr(hc, groupRows, table) == false {
                    g = g + 1;
                    continue;
                }
            }

            result.addRow(resultRow);
            g = g + 1;
        }
    }

    // Phase 59: Execute GROUPING SETS / ROLLUP / CUBE
    // Runs one grouping pass per set, NULLing out columns not in the active set.
    expose func executeGroupingSets(stmt: SelectStmt, matchingRows: List[Integer], table: Table, result: QueryResult) {
        // Parse which groupByExprs indices are active for each set
        var si = 0;
        while si < stmt.groupingSets.count() {
            var setStr = stmt.groupingSets.get(si);

            // Parse the active column indices for this set
            var activeIndices = new List[Integer]();
            if setStr != "" {
                var pos = 0;
                var sLen = String.Length(setStr);
                while pos < sLen {
                    var commaPos = sLen;
                    var scan = pos;
                    while scan < sLen {
                        if String.Substring(setStr, scan, 1) == "," {
                            commaPos = scan;
                            scan = sLen;
                        }
                        scan = scan + 1;
                    }
                    var numStr = String.Substring(setStr, pos, commaPos - pos);
                    activeIndices.add(stringToInt(numStr));
                    pos = commaPos + 1;
                }
            }

            // Group rows using only the active GROUP BY columns
            var groupKeys = new List[String]();
            var groupRowLists = new List[List[Integer]]();
            var numBuckets = 128;
            var buckets = new List[List[Integer]]();
            var b = 0;
            while b < numBuckets {
                buckets.add(new List[Integer]());
                b = b + 1;
            }

            var i = 0;
            while i < matchingRows.count() {
                var rowIdx = matchingRows.get(i);
                var row = table.getRow(rowIdx);
                if row != null {
                    var rowData = row;
                    var key = "";
                    var ai = 0;
                    while ai < activeIndices.count() {
                        var colIdx = activeIndices.get(ai);
                        if colIdx < stmt.groupByExprs.count() {
                            var groupExpr = stmt.groupByExprs.get(colIdx);
                            var val = exec.evalExpr(groupExpr, rowData, table);
                            if ai > 0 { key = key + "|"; }
                            key = key + val.toString();
                        }
                        ai = ai + 1;
                    }

                    var keyHash = exec.computeKeyHash(key);
                    var bucketIdx = keyHash % numBuckets;
                    var bucket = buckets.get(bucketIdx);

                    var groupIdx = -1;
                    var k = 0;
                    while k < bucket.count() {
                        var gIdx = bucket.get(k);
                        if groupKeys.get(gIdx) == key {
                            groupIdx = gIdx;
                            k = bucket.count();
                        }
                        k = k + 1;
                    }

                    if groupIdx < 0 {
                        var newGIdx = groupKeys.count();
                        groupKeys.add(key);
                        var newList = new List[Integer]();
                        newList.add(rowIdx);
                        groupRowLists.add(newList);
                        bucket.add(newGIdx);
                    } else {
                        var existingList = groupRowLists.get(groupIdx);
                        existingList.add(rowIdx);
                    }
                }
                i = i + 1;
            }

            // Build result rows for this grouping set
            var g = 0;
            while g < groupKeys.count() {
                var groupRows = groupRowLists.get(g);
                var resultRow = new Row();
                resultRow.init();

                var firstRowIdx = groupRows.get(0);
                var firstRow = table.getRow(firstRowIdx);

                var c = 0;
                while c < stmt.columns.count() {
                    var colExpr = stmt.columns.get(c);
                    if exec.isAggregateExpr(colExpr) {
                        var val = evalAggregate(colExpr, groupRows, table);
                        resultRow.addValue(val);
                    } else if firstRow != null {
                        var fr = firstRow;
                        // Check if this SELECT column corresponds to a GROUP BY column
                        // that is NOT active in this set — if so, output NULL
                        var isNulled = false;
                        var gi = 0;
                        while gi < stmt.groupByExprs.count() {
                            var gExpr = stmt.groupByExprs.get(gi);
                            if gExpr.kind == colExpr.kind && gExpr.columnName == colExpr.columnName {
                                // Found matching group-by column; check if active
                                var isActive = false;
                                var ai = 0;
                                while ai < activeIndices.count() {
                                    if activeIndices.get(ai) == gi {
                                        isActive = true;
                                        ai = activeIndices.count();
                                    }
                                    ai = ai + 1;
                                }
                                if isActive == false {
                                    isNulled = true;
                                    gi = stmt.groupByExprs.count();
                                }
                            }
                            gi = gi + 1;
                        }
                        if isNulled {
                            resultRow.addValue(sqlNull());
                        } else {
                            var val = exec.evalExpr(colExpr, fr, table);
                            resultRow.addValue(val);
                        }
                    } else {
                        resultRow.addValue(sqlNull());
                    }
                    c = c + 1;
                }

                // Check HAVING condition
                if stmt.havingClause != null {
                    var hc = stmt.havingClause;
                    if evalHavingExpr(hc, groupRows, table) == false {
                        g = g + 1;
                        continue;
                    }
                }

                result.addRow(resultRow);
                g = g + 1;
            }

            si = si + 1;
        }
    }

    // Evaluate HAVING expression for a group
    expose func evalHavingExpr(expr: Expr, groupRows: List[Integer], table: Table) -> Boolean {
        // Handle binary expressions (comparisons and logical operators)
        if expr.kind == EXPR_BINARY {
            var left = expr.getLeft();
            var right = expr.getRight();
            var op = expr.op;

            // Handle logical operators
            if op == OP_AND {
                return evalHavingExpr(left, groupRows, table) && evalHavingExpr(right, groupRows, table);
            }
            if op == OP_OR {
                return evalHavingExpr(left, groupRows, table) || evalHavingExpr(right, groupRows, table);
            }

            // Evaluate left and right sides for comparison
            var leftVal = evalHavingValue(left, groupRows, table);
            var rightVal = evalHavingValue(right, groupRows, table);

            // Comparison operators (handle NULL: compare returns 2)
            var cmp = leftVal.compare(rightVal);
            if cmp == 2 { return false; }
            if op == OP_EQ { return cmp == 0; }
            if op == OP_NE { return cmp != 0; }
            if op == OP_LT { return cmp < 0; }
            if op == OP_LE { return cmp <= 0; }
            if op == OP_GT { return cmp > 0; }
            if op == OP_GE { return cmp >= 0; }
        }

        return false;
    }

    // Evaluate a value in HAVING context (handles aggregates)
    expose func evalHavingValue(expr: Expr, groupRows: List[Integer], table: Table) -> SqlValue {
        // If it's an aggregate function, evaluate it on the group
        if expr.kind == EXPR_FUNCTION {
            if exec.isAggregateExpr(expr) {
                return evalAggregate(expr, groupRows, table);
            }
        }

        // If it's a literal, return its value
        if expr.kind == EXPR_LITERAL {
            return expr.literalValue;
        }

        // If it's a column ref, evaluate using first row in group
        if expr.kind == EXPR_COLUMN {
            if groupRows.count() > 0 {
                var firstRowIdx = groupRows.get(0);
                var maybeRow = table.getRow(firstRowIdx);
                if maybeRow != null {
                    var row = maybeRow;
                    return exec.evalExpr(expr, row, table);
                }
            }
        }

        return sqlNull();
    }

    //=========================================================================
    // DISTINCT
    //=========================================================================

    // Apply DISTINCT - remove duplicate rows (hash-based for O(n) amortized)
    expose func applyDistinct(result: QueryResult) {
        var seenKeys = new List[String]();
        var uniqueRows = new List[Row]();

        // Hash bucket table: each bucket stores indices into seenKeys
        var numBuckets = 128;
        var buckets = new List[List[Integer]]();
        var b = 0;
        while b < numBuckets {
            buckets.add(new List[Integer]());
            b = b + 1;
        }

        var i = 0;
        while i < result.rowCount() {
            var row = result.getRow(i);
            if row != null {
                var r = row;
                // Build key from all column values
                var key = "";
                var c = 0;
                while c < r.columnCount() {
                    if c > 0 {
                        key = key + "|";
                    }
                    key = key + r.getValue(c).toString();
                    c = c + 1;
                }

                // Hash-based duplicate check
                var keyHash = exec.computeKeyHash(key);
                var bucketIdx = keyHash % numBuckets;
                var bucket = buckets.get(bucketIdx);

                var found = false;
                var k = 0;
                while k < bucket.count() {
                    var sIdx = bucket.get(k);
                    if seenKeys.get(sIdx) == key {
                        found = true;
                        k = bucket.count();  // break
                    }
                    k = k + 1;
                }

                if found == false {
                    var newIdx = seenKeys.count();
                    seenKeys.add(key);
                    uniqueRows.add(r);
                    bucket.add(newIdx);
                }
            }
            i = i + 1;
        }

        // Replace result rows with unique rows
        result.rows = uniqueRows;
    }

    //=========================================================================
    // DISTINCT ON
    //=========================================================================

    // Apply DISTINCT ON: keep only the first row for each unique combination
    // of the DISTINCT ON expression values. Must be called after ORDER BY.
    expose func applyDistinctOn(stmt: SelectStmt, result: QueryResult) {
        // Map each DISTINCT ON expression to a result column index
        var colIndices = new List[Integer]();
        var di = 0;
        while di < stmt.distinctOnExprs.count() {
            var dExpr = stmt.distinctOnExprs.get(di);
            var foundIdx = -1;
            // Match by column name against SELECT list
            if dExpr.kind == EXPR_COLUMN {
                var c = 0;
                while c < stmt.columns.count() {
                    var selExpr = stmt.columns.get(c);
                    // Match by column name
                    if selExpr.kind == EXPR_COLUMN && selExpr.columnName == dExpr.columnName {
                        foundIdx = c;
                        c = stmt.columns.count();
                    }
                    c = c + 1;
                }
                // Also check aliases
                if foundIdx < 0 {
                    c = 0;
                    while c < stmt.columnAliases.count() {
                        if stmt.columnAliases.get(c) == dExpr.columnName {
                            foundIdx = c;
                            c = stmt.columnAliases.count();
                        }
                        c = c + 1;
                    }
                }
                // If selectAll, find by column name position in first row
                if foundIdx < 0 && stmt.selectAll && result.columnNames.count() > 0 {
                    c = 0;
                    while c < result.columnNames.count() {
                        if result.columnNames.get(c) == dExpr.columnName {
                            foundIdx = c;
                            c = result.columnNames.count();
                        }
                        c = c + 1;
                    }
                }
            }
            if foundIdx < 0 {
                // Fallback: use position index
                foundIdx = di;
            }
            colIndices.add(foundIdx);
            di = di + 1;
        }

        // Deduplicate using hash-based key matching
        var seenKeys = new List[String]();
        var uniqueRows = new List[Row]();
        var numBuckets = 128;
        var buckets = new List[List[Integer]]();
        var b = 0;
        while b < numBuckets {
            buckets.add(new List[Integer]());
            b = b + 1;
        }

        var i = 0;
        while i < result.rowCount() {
            var row = result.getRow(i);
            if row != null {
                var r = row;
                // Build key from DISTINCT ON columns only
                var key = "";
                var ci = 0;
                while ci < colIndices.count() {
                    if ci > 0 { key = key + "|"; }
                    var colIdx = colIndices.get(ci);
                    if colIdx >= 0 && colIdx < r.columnCount() {
                        key = key + r.getValue(colIdx).toString();
                    }
                    ci = ci + 1;
                }

                var keyHash = exec.computeKeyHash(key);
                var bucketIdx = keyHash % numBuckets;
                var bucket = buckets.get(bucketIdx);

                var found = false;
                var k = 0;
                while k < bucket.count() {
                    var sIdx = bucket.get(k);
                    if seenKeys.get(sIdx) == key {
                        found = true;
                        k = bucket.count();
                    }
                    k = k + 1;
                }

                if found == false {
                    var newIdx = seenKeys.count();
                    seenKeys.add(key);
                    uniqueRows.add(r);
                    bucket.add(newIdx);
                }
            }
            i = i + 1;
        }

        result.rows = uniqueRows;
    }

    //=========================================================================
    // SORTING (ORDER BY)
    //=========================================================================

    // Compare two table rows by row index for sorting. Returns -1, 0, or 1.
    hide func compareTableRows(idx1: Integer, idx2: Integer, orderExprs: List[Expr], orderDir: List[Integer], orderNulls: List[Integer], table: Table) -> Integer {
        var row1 = table.getRow(idx1);
        var row2 = table.getRow(idx2);
        if row1 == null || row2 == null { return 0; }
        var r1 = row1;
        var r2 = row2;
        var e = 0;
        while e < orderExprs.count() {
            var isDesc = orderDir.get(e);
            var nullsMode = 0;
            if e < orderNulls.count() { nullsMode = orderNulls.get(e); }
            var val1 = exec.evalExpr(orderExprs.get(e), r1, table);
            var val2 = exec.evalExpr(orderExprs.get(e), r2, table);
            var cmp = val1.compare(val2);
            if cmp == 2 {
                if val1.kind == SQL_NULL && val2.kind != SQL_NULL {
                    if nullsMode == 1 { return -1; }
                    if nullsMode == 2 { return 1; }
                    if isDesc == 1 { return -1; } return 1;
                } else if val1.kind != SQL_NULL && val2.kind == SQL_NULL {
                    if nullsMode == 1 { return 1; }
                    if nullsMode == 2 { return -1; }
                    if isDesc == 1 { return 1; } return -1;
                }
                // Both NULL — equal for this column, continue to next
            } else if cmp != 0 {
                if isDesc == 1 { if cmp < 0 { return 1; } return -1; }
                else { if cmp > 0 { return 1; } return -1; }
            }
            e = e + 1;
        }
        return 0;
    }

    // Sort row indices by evaluating ORDER BY expressions against actual table rows (quicksort).
    hide func sortMatchingRows(rows: List[Integer], orderExprs: List[Expr], orderDir: List[Integer], orderNulls: List[Integer], table: Table) {
        var n = rows.count();
        if n <= 1 { return; }

        var stackLo: List[Integer] = [];
        var stackHi: List[Integer] = [];
        stackLo.add(0);
        stackHi.add(n - 1);

        while stackLo.count() > 0 {
            var si = stackLo.count() - 1;
            var lo = stackLo.get(si);
            var hi = stackHi.get(si);
            stackLo.removeAt(si);
            stackHi.removeAt(si);

            if lo >= hi { continue; }

            // Pivot: median of three
            var mid = lo + (hi - lo) / 2;
            if compareTableRows(rows.get(lo), rows.get(mid), orderExprs, orderDir, orderNulls, table) > 0 {
                var tmp = rows.get(lo); rows.set(lo, rows.get(mid)); rows.set(mid, tmp);
            }
            if compareTableRows(rows.get(lo), rows.get(hi), orderExprs, orderDir, orderNulls, table) > 0 {
                var tmp = rows.get(lo); rows.set(lo, rows.get(hi)); rows.set(hi, tmp);
            }
            if compareTableRows(rows.get(mid), rows.get(hi), orderExprs, orderDir, orderNulls, table) > 0 {
                var tmp = rows.get(mid); rows.set(mid, rows.get(hi)); rows.set(hi, tmp);
            }

            // Move pivot to hi
            var tmp2 = rows.get(mid); rows.set(mid, rows.get(hi)); rows.set(hi, tmp2);
            var pivotIdx = rows.get(hi);

            var i = lo;
            var j = hi - 1;
            var partitioning = true;
            while partitioning {
                while i <= j && compareTableRows(rows.get(i), pivotIdx, orderExprs, orderDir, orderNulls, table) < 0 {
                    i = i + 1;
                }
                while j >= i && compareTableRows(rows.get(j), pivotIdx, orderExprs, orderDir, orderNulls, table) > 0 {
                    j = j - 1;
                }
                if i >= j {
                    partitioning = false;
                } else {
                    var tmp3 = rows.get(i); rows.set(i, rows.get(j)); rows.set(j, tmp3);
                    i = i + 1;
                    j = j - 1;
                }
            }

            // Move pivot to final position
            var tmp4 = rows.get(i); rows.set(i, rows.get(hi)); rows.set(hi, tmp4);

            if i > lo + 1 { stackLo.add(lo); stackHi.add(i - 1); }
            if i + 1 < hi { stackLo.add(i + 1); stackHi.add(hi); }
        }
    }

    // Map an ORDER BY expression to a result column index by matching
    // against the SELECT column expressions. Returns -1 if no match.
    hide func findOrderByResultIndex(orderExpr: Expr, selectCols: List[Expr], columnAliases: List[String]) -> Integer {
        var c = 0;
        while c < selectCols.count() {
            var colExpr = selectCols.get(c);

            // Match aggregate functions (SUM, COUNT, AVG, MIN, MAX)
            if orderExpr.kind == EXPR_FUNCTION && colExpr.kind == EXPR_FUNCTION {
                if String.ToUpper(orderExpr.funcName) == String.ToUpper(colExpr.funcName) {
                    if orderExpr.args.count() == colExpr.args.count() {
                        var argsMatch = true;
                        if orderExpr.args.count() > 0 {
                            var oarg = orderExpr.args.get(0);
                            var carg = colExpr.args.get(0);
                            if oarg.kind == EXPR_COLUMN && carg.kind == EXPR_COLUMN {
                                if oarg.columnName != carg.columnName {
                                    argsMatch = false;
                                }
                            }
                        }
                        if argsMatch {
                            return c;
                        }
                    }
                }
            }

            // Match column references
            if orderExpr.kind == EXPR_COLUMN && colExpr.kind == EXPR_COLUMN {
                if orderExpr.columnName == colExpr.columnName {
                    return c;
                }
            }

            c = c + 1;
        }

        // Phase 70: Check column aliases for ORDER BY resolution
        if orderExpr.kind == EXPR_COLUMN {
            var a = 0;
            while a < columnAliases.count() {
                if columnAliases.get(a) == orderExpr.columnName {
                    return a;
                }
                a = a + 1;
            }
        }

        return -1;
    }

    // Compare two result rows for sorting. Returns -1 (a<b), 0 (a==b), or 1 (a>b).
    hide func compareResultRows(r1: Row, r2: Row, orderExprs: List[Expr], orderDir: List[Integer], orderNulls: List[Integer], colMappings: List[Integer], table: Table) -> Integer {
        var e = 0;
        while e < orderExprs.count() {
            var orderExpr = orderExprs.get(e);
            var isDesc = orderDir.get(e);
            var nullsMode = 0;
            if e < orderNulls.count() { nullsMode = orderNulls.get(e); }
            var colIdx = colMappings.get(e);

            var val1 = sqlNull();
            var val2 = sqlNull();
            if colIdx >= 0 {
                val1 = r1.getValue(colIdx);
                val2 = r2.getValue(colIdx);
            } else {
                val1 = exec.evalExpr(orderExpr, r1, table);
                val2 = exec.evalExpr(orderExpr, r2, table);
            }
            var cmp = val1.compare(val2);

            // Handle NULL (cmp==2)
            if cmp == 2 {
                if val1.kind == SQL_NULL && val2.kind != SQL_NULL {
                    if nullsMode == 1 { return -1; }
                    if nullsMode == 2 { return 1; }
                    if isDesc == 1 { return -1; }
                    return 1;
                } else if val1.kind != SQL_NULL && val2.kind == SQL_NULL {
                    if nullsMode == 1 { return 1; }
                    if nullsMode == 2 { return -1; }
                    if isDesc == 1 { return 1; }
                    return -1;
                }
                // Both NULL — equal for this column, continue to next
            } else if cmp != 0 {
                if isDesc == 1 {
                    if cmp < 0 { return 1; }
                    return -1;
                } else {
                    if cmp > 0 { return 1; }
                    return -1;
                }
            }
            e = e + 1;
        }
        return 0;
    }

    hide func sortResults(result: QueryResult, orderExprs: List[Expr], orderDir: List[Integer], orderNulls: List[Integer], table: Table, selectCols: List[Expr], columnAliases: List[String]) {
        // Pre-compute column index mappings for ORDER BY expressions
        var colMappings = new List[Integer]();
        var e = 0;
        while e < orderExprs.count() {
            colMappings.add(findOrderByResultIndex(orderExprs.get(e), selectCols, columnAliases));
            e = e + 1;
        }

        var n = result.rowCount();
        if n <= 1 { return; }

        // Iterative quicksort using explicit stack
        var stackLo: List[Integer] = [];
        var stackHi: List[Integer] = [];
        stackLo.add(0);
        stackHi.add(n - 1);

        while stackLo.count() > 0 {
            var si = stackLo.count() - 1;
            var lo = stackLo.get(si);
            var hi = stackHi.get(si);
            stackLo.removeAt(si);
            stackHi.removeAt(si);

            if lo >= hi { continue; }

            // Median-of-three pivot selection
            var mid = lo + (hi - lo) / 2;
            // Sort lo, mid, hi and use mid as pivot
            var rowLo = result.getRow(lo);
            var rowMid = result.getRow(mid);
            var rowHi = result.getRow(hi);
            if rowLo != null && rowMid != null && rowHi != null {
                var rl = rowLo;
                var rm = rowMid;
                var rh = rowHi;
                if compareResultRows(rl, rm, orderExprs, orderDir, orderNulls, colMappings, table) > 0 {
                    result.swapRows(lo, mid);
                }
                if compareResultRows(rl, rh, orderExprs, orderDir, orderNulls, colMappings, table) > 0 {
                    result.swapRows(lo, hi);
                }
                if compareResultRows(rm, rh, orderExprs, orderDir, orderNulls, colMappings, table) > 0 {
                    result.swapRows(mid, hi);
                }
            }

            // Use middle element as pivot, move to hi-1
            result.swapRows(mid, hi);
            var pivotRow = result.getRow(hi);
            if pivotRow == null { continue; }
            var pivot = pivotRow;

            var i = lo;
            var j = hi - 1;
            var partitioning = true;
            while partitioning {
                // Move i right while row[i] < pivot
                while i <= j {
                    var ri = result.getRow(i);
                    if ri == null { break; }
                    var rir = ri;
                    if compareResultRows(rir, pivot, orderExprs, orderDir, orderNulls, colMappings, table) >= 0 { break; }
                    i = i + 1;
                }
                // Move j left while row[j] > pivot
                while j >= i {
                    var rj = result.getRow(j);
                    if rj == null { break; }
                    var rjr = rj;
                    if compareResultRows(rjr, pivot, orderExprs, orderDir, orderNulls, colMappings, table) <= 0 { break; }
                    j = j - 1;
                }
                if i >= j {
                    partitioning = false;
                } else {
                    result.swapRows(i, j);
                    i = i + 1;
                    j = j - 1;
                }
            }

            // Move pivot to final position
            result.swapRows(i, hi);

            // Push sub-partitions
            if i > lo + 1 {
                stackLo.add(lo);
                stackHi.add(i - 1);
            }
            if i + 1 < hi {
                stackLo.add(i + 1);
                stackHi.add(hi);
            }
        }
    }

    //=========================================================================
    // LIMIT/OFFSET
    //=========================================================================

    expose func applyLimitOffset(result: QueryResult, limitVal: Integer, offsetVal: Integer) {
        var newRows: List[Row] = [];
        var i = offsetVal;
        var count = 0;
        while i < result.rowCount() {
            if limitVal >= 0 && count >= limitVal {
                break;
            }
            var row = result.getRow(i);
            if row != null {
                // Deep-clone row to avoid string retain issues when old list is freed
                var clonedRow = new Row();
                clonedRow.init();
                var vc = 0;
                while vc < row.columnCount() {
                    clonedRow.addValue(exec.cloneValue(row.getValue(vc)));
                    vc = vc + 1;
                }
                newRows.add(clonedRow);
                count = count + 1;
            }
            i = i + 1;
        }
        result.rows = newRows;
    }

    //=========================================================================
    // SUBQUERY EXECUTION
    //=========================================================================

    // Dedicated path for subquery execution that parses and runs a SELECT
    // without going through the full executeSql dispatch. This avoids
    // string lifetime corruption in native codegen during recursive calls.
    expose func executeSubquerySelect(sql: String) -> QueryResult {
        var parser = new Parser(sql);
        if parser.currentKind() == TK_SELECT {
            parser.advance();
            var stmt = parser.parseSelectStmt();
            if parser.hasError {
                var result = new QueryResult();
                result.init();
                result.setError(parser.error);
                return result;
            }
            return executeSelect(stmt);
        }
        var result = new QueryResult();
        result.init();
        result.setError("Subquery must be a SELECT statement");
        return result;
    }

    //=========================================================================
    // CTE (Common Table Expressions) — WITH clause
    //=========================================================================

    // Create a temporary Table from a QueryResult
    hide func createTempTableFromResult(name: String, qr: QueryResult) -> Table {
        var tempTable = new Table();
        tempTable.initWithName(name);
        // Create columns from result column names
        var c = 0;
        while c < qr.columnNames.count() {
            var col = new Column();
            col.initWithName(qr.columnNames.get(c), SQL_TEXT);  // Default type
            tempTable.addColumn(col);
            c = c + 1;
        }
        // Copy rows
        var r = 0;
        while r < qr.rows.count() {
            var srcRow = qr.rows.get(r);
            var newRow = new Row();
            newRow.initWithCount(srcRow.columnCount());
            var v = 0;
            while v < srcRow.columnCount() {
                newRow.setValue(v, srcRow.getValue(v));
                v = v + 1;
            }
            tempTable.addRow(newRow);
            r = r + 1;
        }
        return tempTable;
    }

    // Execute a WITH ... SELECT/INSERT/UPDATE/DELETE statement
    // Split a CTE SQL string on top-level UNION [ALL].
    // Returns: anchor SQL (before UNION) and recursive SQL (after UNION ALL/UNION).
    // If no top-level UNION found, returns the full SQL as anchor and "" as recursive.
    // isAllFlag: list to receive 1 (UNION ALL) or 0 (UNION)
    hide func splitOnUnion(cteSql: String, isAllFlag: List[Integer]) -> List[String] {
        var parts: List[String] = [];
        // Tokenize to find top-level UNION
        var tempLexer = new Lexer(cteSql);
        var tokens: List[Integer] = [];
        var texts: List[String] = [];
        var pos = 0;
        var tok = tempLexer.nextToken();
        while tok.kind != TK_EOF {
            tokens.add(tok.kind);
            if tok.kind == TK_STRING {
                texts.add("'" + tok.text + "'");
            } else {
                texts.add(tok.text);
            }
            pos = pos + 1;
            tok = tempLexer.nextToken();
        }

        // Find the last top-level UNION (depth 0)
        var unionPos = -1;
        var unionIsAll = 0;
        var depth = 0;
        var i = 0;
        while i < tokens.count() {
            if tokens.get(i) == TK_LPAREN {
                depth = depth + 1;
            } else if tokens.get(i) == TK_RPAREN {
                depth = depth - 1;
            } else if tokens.get(i) == TK_UNION && depth == 0 {
                unionPos = i;
                // Check for ALL
                if i + 1 < tokens.count() && tokens.get(i + 1) == TK_ALL {
                    unionIsAll = 1;
                } else {
                    unionIsAll = 0;
                }
            }
            i = i + 1;
        }

        isAllFlag.add(unionIsAll);

        if unionPos < 0 {
            parts.add(cteSql);
            parts.add("");
            return parts;
        }

        // Build anchor SQL (tokens before UNION)
        var anchor = "";
        i = 0;
        while i < unionPos {
            if anchor != "" {
                anchor = anchor + " ";
            }
            anchor = anchor + texts.get(i);
            i = i + 1;
        }

        // Build recursive SQL (tokens after UNION [ALL])
        var recStart = unionPos + 1;
        if unionIsAll == 1 {
            recStart = recStart + 1;
        }
        var recSql = "";
        i = recStart;
        while i < tokens.count() {
            if recSql != "" {
                recSql = recSql + " ";
            }
            recSql = recSql + texts.get(i);
            i = i + 1;
        }

        parts.add(anchor);
        parts.add(recSql);
        return parts;
    }

    // Execute a recursive CTE: anchor UNION [ALL] recursive
    hide func executeRecursiveCTE(cteName: String, cteSql: String, cteNames: List[String], cteColNames: List[String]) -> QueryResult {
        final MAX_RECURSION = 1000;

        var isAllFlag: List[Integer] = [];
        var parts = splitOnUnion(cteSql, isAllFlag);
        var anchorSql = parts.get(0);
        var recursiveSql = parts.get(1);
        var unionAll = isAllFlag.get(0) == 1;

        if recursiveSql == "" {
            // No UNION found — execute as non-recursive
            return exec.executeSql(cteSql);
        }

        // Step 1: Execute anchor member
        var anchorResult = exec.executeSql(anchorSql);
        if anchorResult.success == false {
            return anchorResult;
        }

        // If no explicit column list, infer from anchor result column names
        if cteColNames.count() == 0 {
            var ci = 0;
            while ci < anchorResult.columnNames.count() {
                cteColNames.add(anchorResult.columnNames.get(ci));
                ci = ci + 1;
            }
        }

        // Create accumulator result with all rows
        var allResult = new QueryResult();
        allResult.init();
        allResult.success = true;
        allResult.message = "";
        // Copy column names
        var c = 0;
        while c < anchorResult.columnNames.count() {
            allResult.addColumnName(anchorResult.columnNames.get(c));
            c = c + 1;
        }

        // For UNION (not ALL), track seen row keys for dedup
        var seenKeys: List[String] = [];

        // Copy anchor rows (with dedup for UNION)
        var r = 0;
        while r < anchorResult.rows.count() {
            var row = anchorResult.rows.get(r);
            if unionAll {
                allResult.addRow(row);
            } else {
                // Build key for dedup using toString() (textValue is "" for integers)
                var key = "";
                var v = 0;
                while v < row.columnCount() {
                    if v > 0 { key = key + "|"; }
                    var rv = row.getValue(v);
                    key = key + rv.toString();
                    v = v + 1;
                }
                seenKeys.add(key);
                allResult.addRow(row);
            }
            r = r + 1;
        }

        // Create working table from anchor results
        var workingTable = createTempTableFromResult(cteName, anchorResult);
        // Rename columns if CTE column list was provided
        if cteColNames.count() > 0 {
            var ri = 0;
            while ri < cteColNames.count() && ri < workingTable.columnCount() {
                workingTable.getColumn(ri).name = cteColNames.get(ri);
                ri = ri + 1;
            }
        }
        exec.db.addTable(workingTable);
        cteNames.add(cteName);

        // Step 2: Iterate recursive member
        var iteration = 0;
        var hasNewRows = true;
        while hasNewRows && iteration < MAX_RECURSION {
            var recResult = exec.executeSql(recursiveSql);
            if recResult.success == false || recResult.rows.count() == 0 {
                hasNewRows = false;
            } else {
                // Add new rows to accumulator (with dedup for UNION)
                var addedNewRows = false;
                r = 0;
                while r < recResult.rows.count() {
                    var row = recResult.rows.get(r);
                    if unionAll {
                        allResult.addRow(row);
                        addedNewRows = true;
                    } else {
                        // Check if row already seen
                        var key = "";
                        var v = 0;
                        while v < row.columnCount() {
                            if v > 0 { key = key + "|"; }
                            key = key + row.getValue(v).toString();
                            v = v + 1;
                        }
                        var isDup = false;
                        var si = 0;
                        while si < seenKeys.count() {
                            if seenKeys.get(si) == key {
                                isDup = true;
                            }
                            si = si + 1;
                        }
                        if isDup == false {
                            seenKeys.add(key);
                            allResult.addRow(row);
                            addedNewRows = true;
                        }
                    }
                    r = r + 1;
                }

                if addedNewRows == false {
                    hasNewRows = false;
                } else {
                    // Replace working table with this iteration's full output
                    exec.db.dropTable(cteName);
                    var newWorking = createTempTableFromResult(cteName, recResult);
                    if cteColNames.count() > 0 {
                        var ri = 0;
                        while ri < cteColNames.count() && ri < newWorking.columnCount() {
                            newWorking.getColumn(ri).name = cteColNames.get(ri);
                            ri = ri + 1;
                        }
                    }
                    exec.db.addTable(newWorking);
                    iteration = iteration + 1;
                }
            }
        }

        // Replace working table with full accumulated result
        exec.db.dropTable(cteName);
        var finalTable = createTempTableFromResult(cteName, allResult);
        if cteColNames.count() > 0 {
            var ri = 0;
            while ri < cteColNames.count() && ri < finalTable.columnCount() {
                finalTable.getColumn(ri).name = cteColNames.get(ri);
                ri = ri + 1;
            }
        }
        exec.db.addTable(finalTable);

        return allResult;
    }

    expose func executeWithCTE(sql: String, parser: Parser) -> QueryResult {
        var cteNames: List[String] = [];

        // Skip WITH token
        parser.advance();

        var isRecursive = false;
        if parser.currentKind() == TK_RECURSIVE {
            isRecursive = true;
            parser.advance();
        }

        // Parse CTE definitions: name AS (SELECT ...) [, name2 AS (...)]
        var parseCTEs = true;
        while parseCTEs {
            if parser.currentKind() != TK_IDENTIFIER {
                var result = new QueryResult();
                result.init();
                result.setError("Expected CTE name after WITH");
                return result;
            }
            var cteName = parser.currentText();
            parser.advance();

            // Optional column list: name(col1, col2, ...)
            var cteColNames: List[String] = [];
            if parser.currentKind() == TK_LPAREN {
                parser.advance();
                while parser.currentKind() != TK_RPAREN && parser.currentKind() != TK_EOF {
                    if parser.currentKind() == TK_IDENTIFIER {
                        cteColNames.add(parser.currentText());
                    }
                    parser.advance();
                    if parser.currentKind() == TK_COMMA {
                        parser.advance();
                    }
                }
                if parser.currentKind() == TK_RPAREN {
                    parser.advance();
                }
            }

            // Expect AS
            if parser.currentKind() != TK_AS {
                var result = new QueryResult();
                result.init();
                result.setError("Expected AS after CTE name '" + cteName + "'");
                return result;
            }
            parser.advance();

            // Expect (
            if parser.currentKind() != TK_LPAREN {
                var result = new QueryResult();
                result.init();
                result.setError("Expected '(' after AS in CTE '" + cteName + "'");
                return result;
            }
            parser.advance();

            // Capture the CTE SQL by tracking parentheses
            var cteSql = "";
            var parenDepth = 1;
            while parenDepth > 0 && parser.currentKind() != TK_EOF {
                if parser.currentKind() == TK_LPAREN {
                    parenDepth = parenDepth + 1;
                    cteSql = cteSql + "(";
                    parser.advance();
                } else if parser.currentKind() == TK_RPAREN {
                    parenDepth = parenDepth - 1;
                    if parenDepth > 0 {
                        cteSql = cteSql + ")";
                    }
                    parser.advance();
                } else {
                    if cteSql != "" {
                        cteSql = cteSql + " ";
                    }
                    // Preserve string literals with quotes
                    if parser.currentKind() == TK_STRING {
                        cteSql = cteSql + "'" + parser.currentText() + "'";
                    } else {
                        cteSql = cteSql + parser.currentText();
                    }
                    parser.advance();
                }
            }

            if isRecursive {
                // Execute as recursive CTE with iterative fixpoint
                var cteResult = executeRecursiveCTE(cteName, cteSql, cteNames, cteColNames);
                if cteResult.success == false {
                    // Clean up any previously created CTE tables
                    var ci = 0;
                    while ci < cteNames.count() {
                        exec.db.dropTable(cteNames.get(ci));
                        ci = ci + 1;
                    }
                    var result = new QueryResult();
                    result.init();
                    result.setError("CTE '" + cteName + "' failed: " + cteResult.message);
                    return result;
                }
                // Table already added by executeRecursiveCTE (with column renaming)
            } else {
                // Execute the CTE query and create temp table (non-recursive)
                var cteResult = exec.executeSql(cteSql);
                if cteResult.success == false {
                    // Clean up any previously created CTE tables
                    var ci = 0;
                    while ci < cteNames.count() {
                        exec.db.dropTable(cteNames.get(ci));
                        ci = ci + 1;
                    }
                    var result = new QueryResult();
                    result.init();
                    result.setError("CTE '" + cteName + "' failed: " + cteResult.message);
                    return result;
                }

                var tempTable = createTempTableFromResult(cteName, cteResult);
                // Rename columns if CTE column list was provided
                if cteColNames.count() > 0 {
                    var ri = 0;
                    while ri < cteColNames.count() && ri < tempTable.columnCount() {
                        tempTable.getColumn(ri).name = cteColNames.get(ri);
                        ri = ri + 1;
                    }
                }
                exec.db.addTable(tempTable);
                cteNames.add(cteName);
            }

            // Check for comma (more CTEs) or continue to main query
            if parser.currentKind() == TK_COMMA {
                parser.advance();
            } else {
                parseCTEs = false;
            }
        }

        // Now capture remaining SQL and execute as the main statement
        var mainSql = "";
        while parser.currentKind() != TK_EOF {
            if mainSql != "" {
                mainSql = mainSql + " ";
            }
            if parser.currentKind() == TK_STRING {
                mainSql = mainSql + "'" + parser.currentText() + "'";
            } else {
                mainSql = mainSql + parser.currentText();
            }
            parser.advance();
        }

        var mainResult = exec.executeSql(mainSql);

        // Clean up CTE temp tables
        var ci = 0;
        while ci < cteNames.count() {
            exec.db.dropTable(cteNames.get(ci));
            ci = ci + 1;
        }

        return mainResult;
    }

    //=========================================================================
    // sys.vacuum_stats VIEW (Phase 26)
    //=========================================================================

    hide func buildVacuumStatsView() -> QueryResult {
        var result = new QueryResult();
        result.init();

        result.addColumnName("table_name");
        result.addColumnName("vacuum_count");
        result.addColumnName("dead_rows_removed");
        result.addColumnName("last_vacuum");
        result.addColumnName("analyze_count");
        result.addColumnName("live_rows");
        result.addColumnName("dead_rows");
        result.addColumnName("last_analyze");

        var i = 0;
        while i < exec.vacuumStatNames.count() {
            var row = new Row();
            row.init();
            row.addValue(sqlText(exec.vacuumStatNames.get(i)));
            row.addValue(sqlInteger(exec.vacuumStatVacuumCount.get(i)));
            row.addValue(sqlInteger(exec.vacuumStatDeadRemoved.get(i)));
            var lastVac = exec.vacuumStatLastVacuumTime.get(i);
            if lastVac > 0 {
                row.addValue(sqlInteger(lastVac));
            } else {
                var nullVal = new SqlValue();
                nullVal.initNull();
                row.addValue(nullVal);
            }
            row.addValue(sqlInteger(exec.analyzeStatAnalyzeCount.get(i)));
            row.addValue(sqlInteger(exec.analyzeStatLiveRows.get(i)));
            row.addValue(sqlInteger(exec.analyzeStatDeadRows.get(i)));
            var lastAna = exec.analyzeStatLastAnalyzeTime.get(i);
            if lastAna > 0 {
                row.addValue(sqlInteger(lastAna));
            } else {
                var nullVal2 = new SqlValue();
                nullVal2.initNull();
                row.addValue(nullVal2);
            }
            result.addRow(row);
            i = i + 1;
        }

        return result;
    }

    //=========================================================================
    // PARTITION-AWARE SELECT (Phase 28)
    //=========================================================================

    //=========================================================================
    // TABLE FUNCTIONS (Phase 29)
    //=========================================================================

    // Evaluate a literal expression (no row context needed)
    hide func evalLiteralExpr(expr: Expr) -> SqlValue {
        if expr.kind == EXPR_LITERAL {
            return expr.literalValue;
        }
        if expr.kind == EXPR_UNARY && expr.op == OP_NEG {
            var inner = evalLiteralExpr(expr.getLeft());
            if inner.kind == SQL_INTEGER {
                return sqlInteger(0 - inner.intValue);
            }
        }
        if expr.kind == EXPR_BINARY {
            var left = evalLiteralExpr(expr.getLeft());
            var right = evalLiteralExpr(expr.getRight());
            if left.kind == SQL_INTEGER && right.kind == SQL_INTEGER {
                if expr.op == OP_ADD { return sqlInteger(left.intValue + right.intValue); }
                if expr.op == OP_SUB { return sqlInteger(left.intValue - right.intValue); }
                if expr.op == OP_MUL { return sqlInteger(left.intValue * right.intValue); }
            }
        }
        return sqlNull();
    }

    // GENERATE_SERIES(start, stop [, step])
    hide func executeGenerateSeries(stmt: SelectStmt) -> QueryResult {
        var result = new QueryResult();
        result.init();
        result.addColumnName("generate_series");

        if stmt.tableFunctionArgs.count() < 2 {
            result.setError("generate_series requires at least 2 arguments (start, stop)");
            return result;
        }

        var startVal = evalLiteralExpr(stmt.tableFunctionArgs.get(0));
        var stopVal = evalLiteralExpr(stmt.tableFunctionArgs.get(1));
        var stepVal = sqlInteger(1);
        if stmt.tableFunctionArgs.count() >= 3 {
            stepVal = evalLiteralExpr(stmt.tableFunctionArgs.get(2));
        }

        var start = startVal.intValue;
        var stop = stopVal.intValue;
        var step = stepVal.intValue;
        if step == 0 {
            result.setError("step size cannot be zero");
            return result;
        }

        var current = start;
        var maxRows = 10000; // Safety limit
        var count = 0;
        if step > 0 {
            while current <= stop && count < maxRows {
                var row = new Row();
                row.init();
                row.addValue(sqlInteger(current));
                result.addRow(row);
                current = current + step;
                count = count + 1;
            }
        } else {
            while current >= stop && count < maxRows {
                var row = new Row();
                row.init();
                row.addValue(sqlInteger(current));
                result.addRow(row);
                current = current + step;
                count = count + 1;
            }
        }

        // Apply LIMIT/OFFSET if specified
        if stmt.limitValue >= 0 {
            var limitOffset = stmt.offsetValue;
            var lim = stmt.limitValue;
            var trimmed: List[Row] = [];
            var ti = 0;
            while ti < result.rows.count() {
                if ti >= limitOffset {
                    if trimmed.count() < lim {
                        trimmed.add(result.rows.get(ti));
                    }
                }
                ti = ti + 1;
            }
            result.rows = trimmed;
        }

        return result;
    }

    // Inheritance-aware SELECT: query parent + all inheriting children
    hide func executeInheritanceSelect(stmt: SelectStmt, parent: Table) -> QueryResult {
        var result = new QueryResult();
        result.init();

        // Build column names from parent schema
        if stmt.selectAll {
            var c = 0;
            while c < parent.columnCount() {
                var col = parent.getColumn(c);
                if col != null {
                    var column = col;
                    result.addColumnName(column.name);
                }
                c = c + 1;
            }
        } else {
            var c = 0;
            while c < stmt.columns.count() {
                var alias = "";
                if c < stmt.columnAliases.count() {
                    alias = stmt.columnAliases.get(c);
                }
                if alias != "" {
                    result.addColumnName(alias);
                } else {
                    var colExpr = stmt.columns.get(c);
                    if colExpr.kind == EXPR_COLUMN {
                        result.addColumnName(colExpr.columnName);
                    } else {
                        result.addColumnName("expr_" + Fmt.Int(c));
                    }
                }
                c = c + 1;
            }
        }

        // Collect matching rows from parent table first
        var allMatchingRows: List[Row] = [];
        var allSourceTables: List[Table] = [];
        exec.currentTableAlias = stmt.tableAlias;
        var ri = 0;
        while ri < parent.rowCount() {
            var maybeRow = parent.getRow(ri);
            if maybeRow != null {
                var rowData = maybeRow;
                if rowData.isVisible(exec.mvccSnapshotId, exec.mvccTxnId) {
                    if exec.evalCondition(stmt.whereClause, rowData, parent) {
                        allMatchingRows.add(rowData);
                        allSourceTables.add(parent);
                    }
                }
            }
            ri = ri + 1;
        }
        exec.recordSeqScan(parent.name, parent.rowCount());

        // Collect matching rows from each child table
        var ci = 0;
        while ci < parent.inheritChildren.count() {
            var childName = parent.inheritChildren.get(ci);
            var childTable = exec.findTable(childName);
            if childTable != null {
                var ct = childTable;
                var cri = 0;
                while cri < ct.rowCount() {
                    var maybeRow2 = ct.getRow(cri);
                    if maybeRow2 != null {
                        var rowData2 = maybeRow2;
                        if rowData2.isVisible(exec.mvccSnapshotId, exec.mvccTxnId) {
                            if exec.evalCondition(stmt.whereClause, rowData2, ct) {
                                allMatchingRows.add(rowData2);
                                allSourceTables.add(ct);
                            }
                        }
                    }
                    cri = cri + 1;
                }
                exec.recordSeqScan(childName, ct.rowCount());
            }
            ci = ci + 1;
        }

        // Project rows into result (use parent columns for consistency)
        var mi = 0;
        while mi < allMatchingRows.count() {
            var rowData = allMatchingRows.get(mi);
            var srcTable = allSourceTables.get(mi);
            var outRow = new Row();
            outRow.init();
            if stmt.selectAll {
                // Project only parent columns (first N columns)
                var vc = 0;
                while vc < parent.columnCount() {
                    if vc < rowData.values.count() {
                        outRow.addValue(rowData.values.get(vc));
                    } else {
                        outRow.addValue(sqlNull());
                    }
                    vc = vc + 1;
                }
            } else {
                var vc = 0;
                while vc < stmt.columns.count() {
                    var val = exec.evalExpr(stmt.columns.get(vc), rowData, srcTable);
                    outRow.addValue(val);
                    vc = vc + 1;
                }
            }
            result.addRow(outRow);
            mi = mi + 1;
        }

        // Apply ORDER BY if specified
        if stmt.orderByExprs.count() > 0 {
            sortResults(result, stmt.orderByExprs, stmt.orderByDir, stmt.orderByNulls, parent, stmt.columns, stmt.columnAliases);
        }

        // Apply LIMIT/OFFSET
        if stmt.limitValue >= 0 {
            var limitOffset = stmt.offsetValue;
            var lim = stmt.limitValue;
            var trimmed: List[Row] = [];
            var ti = 0;
            while ti < result.rows.count() {
                if ti >= limitOffset {
                    if trimmed.count() < lim {
                        trimmed.add(result.rows.get(ti));
                    }
                }
                ti = ti + 1;
            }
            result.rows = trimmed;
        }

        return result;
    }

    hide func executePartitionedSelect(stmt: SelectStmt, parent: Table) -> QueryResult {
        var result = new QueryResult();
        result.init();

        // Build column names from parent schema
        if stmt.selectAll {
            var c = 0;
            while c < parent.columnCount() {
                var col = parent.getColumn(c);
                if col != null {
                    var column = col;
                    result.addColumnName(column.name);
                }
                c = c + 1;
            }
        } else {
            var c = 0;
            while c < stmt.columns.count() {
                var alias = "";
                if c < stmt.columnAliases.count() {
                    alias = stmt.columnAliases.get(c);
                }
                if alias != "" {
                    result.addColumnName(alias);
                } else {
                    var colExpr = stmt.columns.get(c);
                    if colExpr.kind == EXPR_COLUMN {
                        result.addColumnName(colExpr.columnName);
                    } else {
                        result.addColumnName("expr_" + Fmt.Int(c));
                    }
                }
                c = c + 1;
            }
        }

        // Partition pruning: check if WHERE clause constrains the partition column
        var prunedChildren = prunePartitions(parent, stmt.whereClause);

        // Check if this is an aggregate query (COUNT, SUM, etc.)
        var isAggregate = exec.hasAggregates(stmt);

        // Collect all matching rows from child partitions
        var allMatchingRows: List[Row] = [];
        var pi = 0;
        while pi < prunedChildren.count() {
            var childName = prunedChildren.get(pi);
            var childTable = exec.findTable(childName);
            if childTable != null {
                var ct = childTable;
                exec.currentTableAlias = stmt.tableAlias;

                // Scan child partition rows
                var ri = 0;
                while ri < ct.rowCount() {
                    var maybeRow = ct.getRow(ri);
                    if maybeRow != null {
                        var rowData = maybeRow;
                        if rowData.isVisible(exec.mvccSnapshotId, exec.mvccTxnId) {
                            if exec.evalCondition(stmt.whereClause, rowData, ct) {
                                allMatchingRows.add(rowData);
                            }
                        }
                    }
                    ri = ri + 1;
                }
                exec.recordSeqScan(childName, ct.rowCount());
            }
            pi = pi + 1;
        }

        // Handle aggregate queries
        if isAggregate {
            var resultRow = new Row();
            resultRow.init();
            var c = 0;
            while c < stmt.columns.count() {
                var colExpr = stmt.columns.get(c);
                if exec.isAggregateExpr(colExpr) {
                    var aggVal = evalPartitionAggregate(colExpr, allMatchingRows, parent);
                    resultRow.addValue(aggVal);
                } else {
                    if allMatchingRows.count() > 0 {
                        var val = exec.evalExpr(colExpr, allMatchingRows.get(0), parent);
                        resultRow.addValue(val);
                    } else {
                        resultRow.addValue(sqlNull());
                    }
                }
                c = c + 1;
            }
            result.addRow(resultRow);
            return result;
        }

        // Non-aggregate: project rows into result
        var mi = 0;
        while mi < allMatchingRows.count() {
            var rowData = allMatchingRows.get(mi);
            var outRow = new Row();
            outRow.init();
            if stmt.selectAll {
                var vc = 0;
                while vc < parent.columnCount() {
                    outRow.addValue(rowData.values.get(vc));
                    vc = vc + 1;
                }
            } else {
                var vc = 0;
                while vc < stmt.columns.count() {
                    var val = exec.evalExpr(stmt.columns.get(vc), rowData, parent);
                    outRow.addValue(val);
                    vc = vc + 1;
                }
            }
            result.addRow(outRow);
            mi = mi + 1;
        }

        // Apply LIMIT/OFFSET if specified
        if stmt.limitValue >= 0 {
            var limitOffset = stmt.offsetValue;
            var lim = stmt.limitValue;
            var trimmed: List[Row] = [];
            var ti = 0;
            while ti < result.rows.count() {
                if ti >= limitOffset {
                    if trimmed.count() < lim {
                        trimmed.add(result.rows.get(ti));
                    }
                }
                ti = ti + 1;
            }
            result.rows = trimmed;
        }

        return result;
    }

    // Evaluate aggregate function over collected partition rows
    hide func evalPartitionAggregate(expr: Expr, rows: List[Row], table: Table) -> SqlValue {
        // Apply FILTER clause if present
        var filteredPRows = rows;
        if expr.filterExpr != null {
            filteredPRows = [];
            var fi = 0;
            while fi < rows.count() {
                var fRow = rows.get(fi);
                if exec.evalCondition(expr.filterExpr, fRow, table) {
                    filteredPRows.add(fRow);
                }
                fi = fi + 1;
            }
            rows = filteredPRows;
        }

        var funcName = String.ToUpper(expr.funcName);
        var hasArg = expr.args.count() > 0;

        // COUNT(*)
        if funcName == "COUNT" && hasArg {
            var arg0 = expr.args.get(0);
            if arg0.kind == EXPR_STAR {
                return sqlInteger(rows.count());
            }
        }

        // COUNT(column) - count non-NULL
        if funcName == "COUNT" || funcName == "COUNT_DISTINCT" {
            var count = 0;
            var seen: List[String] = [];
            var i = 0;
            while i < rows.count() {
                if hasArg {
                    var argExpr = expr.args.get(0);
                    var val = exec.evalExpr(argExpr, rows.get(i), table);
                    if val.kind != SQL_NULL {
                        if funcName == "COUNT_DISTINCT" {
                            var valStr = val.toString();
                            var found = false;
                            var k = 0;
                            while k < seen.count() {
                                if seen.get(k) == valStr { found = true; k = seen.count(); }
                                k = k + 1;
                            }
                            if found == false {
                                seen.add(valStr);
                                count = count + 1;
                            }
                        } else {
                            count = count + 1;
                        }
                    }
                }
                i = i + 1;
            }
            return sqlInteger(count);
        }

        // SUM
        if funcName == "SUM" && hasArg {
            var sum = 0;
            var i = 0;
            while i < rows.count() {
                var val = exec.evalExpr(expr.args.get(0), rows.get(i), table);
                if val.kind == SQL_INTEGER { sum = sum + val.intValue; }
                i = i + 1;
            }
            return sqlInteger(sum);
        }

        // MIN
        if funcName == "MIN" && hasArg {
            var minVal = sqlNull();
            var i = 0;
            while i < rows.count() {
                var val = exec.evalExpr(expr.args.get(0), rows.get(i), table);
                if val.kind != SQL_NULL {
                    if minVal.kind == SQL_NULL { minVal = val; }
                    else if val.intValue < minVal.intValue { minVal = val; }
                }
                i = i + 1;
            }
            return minVal;
        }

        // MAX
        if funcName == "MAX" && hasArg {
            var maxVal = sqlNull();
            var i = 0;
            while i < rows.count() {
                var val = exec.evalExpr(expr.args.get(0), rows.get(i), table);
                if val.kind != SQL_NULL {
                    if maxVal.kind == SQL_NULL { maxVal = val; }
                    else if val.intValue > maxVal.intValue { maxVal = val; }
                }
                i = i + 1;
            }
            return maxVal;
        }

        // AVG
        if funcName == "AVG" && hasArg {
            var sum = 0;
            var cnt = 0;
            var i = 0;
            while i < rows.count() {
                var val = exec.evalExpr(expr.args.get(0), rows.get(i), table);
                if val.kind == SQL_INTEGER {
                    sum = sum + val.intValue;
                    cnt = cnt + 1;
                }
                i = i + 1;
            }
            if cnt > 0 { return sqlInteger(sum / cnt); }
            return sqlNull();
        }

        // STRING_AGG / GROUP_CONCAT
        if (funcName == "STRING_AGG" || funcName == "GROUP_CONCAT") && hasArg {
            var separator = ",";
            if expr.args.count() >= 2 && rows.count() > 0 {
                separator = exec.evalExpr(expr.args.get(1), rows.get(0), table).toString();
            }
            var result = "";
            var first = true;
            var i = 0;
            while i < rows.count() {
                var val = exec.evalExpr(expr.args.get(0), rows.get(i), table);
                if val.kind != SQL_NULL {
                    if first == false { result = result + separator; }
                    result = result + val.toString();
                    first = false;
                }
                i = i + 1;
            }
            if first { return sqlNull(); }
            return sqlText(result);
        }

        // ARRAY_AGG
        if funcName == "ARRAY_AGG" && hasArg {
            var elements: List[String] = [];
            var i = 0;
            while i < rows.count() {
                var val = exec.evalExpr(expr.args.get(0), rows.get(i), table);
                if val.kind == SQL_NULL { elements.add("NULL"); }
                else { elements.add(val.toString()); }
                i = i + 1;
            }
            return sqlArray(buildArrayString(elements));
        }

        // BOOL_AND
        if funcName == "BOOL_AND" && hasArg {
            var result = true;
            var hasValue = false;
            var i = 0;
            while i < rows.count() {
                var val = exec.evalExpr(expr.args.get(0), rows.get(i), table);
                if val.kind != SQL_NULL {
                    hasValue = true;
                    if val.intValue == 0 { result = false; }
                }
                i = i + 1;
            }
            if hasValue == false { return sqlNull(); }
            if result { return sqlBoolean(true); }
            return sqlBoolean(false);
        }

        // BOOL_OR
        if funcName == "BOOL_OR" && hasArg {
            var result = false;
            var hasValue = false;
            var i = 0;
            while i < rows.count() {
                var val = exec.evalExpr(expr.args.get(0), rows.get(i), table);
                if val.kind != SQL_NULL {
                    hasValue = true;
                    if val.intValue != 0 { result = true; }
                }
                i = i + 1;
            }
            if hasValue == false { return sqlNull(); }
            if result { return sqlBoolean(true); }
            return sqlBoolean(false);
        }

        return sqlNull();
    }

    // Partition pruning: given a WHERE clause, determine which child partitions
    // need to be scanned. Returns a list of child partition names.
    hide func prunePartitions(parent: Table, where: Expr?) -> List[String] {
        // If no WHERE or can't determine, scan all partitions
        if where == null {
            return parent.partitionChildren;
        }

        // Try to extract a constraint on the partition column
        var partColIdx = parent.findColumnIndex(parent.partitionColumn);
        if partColIdx < 0 {
            return parent.partitionChildren;
        }

        // Simple pruning: check if WHERE is a simple equality on partition column
        // e.g., WHERE id = 5
        if where.kind == EXPR_BINARY && where.op == OP_EQ {
            var left = where.getLeft();
            var right = where.getRight();
            if left.kind == EXPR_COLUMN && String.ToUpper(left.columnName) == String.ToUpper(parent.partitionColumn) {
                var val = exec.evalExpr(right, null, parent);
                return pruneByValue(parent, val);
            }
            if right.kind == EXPR_COLUMN && String.ToUpper(right.columnName) == String.ToUpper(parent.partitionColumn) {
                var val = exec.evalExpr(left, null, parent);
                return pruneByValue(parent, val);
            }
        }

        // Can't prune — scan all partitions
        return parent.partitionChildren;
    }

    // Return only the partitions that could contain the given value
    hide func pruneByValue(parent: Table, val: SqlValue) -> List[String] {
        var result: List[String] = [];
        var i = 0;
        while i < parent.partitionChildren.count() {
            var childName = parent.partitionChildren.get(i);
            var child = exec.findTable(childName);
            if child != null {
                var ct = child;
                // Use the DML handler's partition check logic
                if exec.dmlHandler.partitionAcceptsValue(ct, val) {
                    result.add(childName);
                }
            }
            i = i + 1;
        }
        // If pruning eliminates all partitions, return all (safety fallback)
        if result.count() == 0 {
            return parent.partitionChildren;
        }
        return result;
    }

    //=========================================================================
    // PG_STAT VIEWS (Phase 27)
    //=========================================================================

    hide func buildPgStatActivity() -> QueryResult {
        var result = new QueryResult();
        result.init();

        result.addColumnName("datid");
        result.addColumnName("datname");
        result.addColumnName("pid");
        result.addColumnName("usename");
        result.addColumnName("application_name");
        result.addColumnName("client_addr");
        result.addColumnName("backend_start");
        result.addColumnName("state");
        result.addColumnName("query");
        result.addColumnName("query_count");

        // Current session
        var row = new Row();
        row.init();
        row.addValue(sqlInteger(1));
        row.addValue(sqlText(exec.currentDbName));
        row.addValue(sqlInteger(exec.sessionId));
        row.addValue(sqlText(exec.currentUser));
        row.addValue(sqlText("vipersql"));
        row.addValue(sqlText("127.0.0.1"));
        row.addValue(sqlInteger(exec.pgStatSessionStart));
        if exec.inTransaction {
            row.addValue(sqlText("idle in transaction"));
        } else {
            row.addValue(sqlText("active"));
        }
        row.addValue(sqlText(exec.pgStatLastQuery));
        row.addValue(sqlInteger(exec.pgStatQueryCount));
        result.addRow(row);

        return result;
    }

    hide func buildPgStatUserTables() -> QueryResult {
        var result = new QueryResult();
        result.init();

        result.addColumnName("relid");
        result.addColumnName("schemaname");
        result.addColumnName("relname");
        result.addColumnName("seq_scan");
        result.addColumnName("seq_tup_read");
        result.addColumnName("idx_scan");
        result.addColumnName("idx_tup_fetch");
        result.addColumnName("n_tup_ins");
        result.addColumnName("n_tup_upd");
        result.addColumnName("n_tup_del");
        result.addColumnName("n_live_tup");
        result.addColumnName("n_dead_tup");

        var i = 0;
        while i < exec.pgStatTableNames.count() {
            var tblName = exec.pgStatTableNames.get(i);
            var row = new Row();
            row.init();
            row.addValue(sqlInteger(generateOid(exec.currentDbName + "." + tblName)));
            row.addValue(sqlText("public"));
            row.addValue(sqlText(tblName));
            row.addValue(sqlInteger(exec.pgStatSeqScan.get(i)));
            row.addValue(sqlInteger(exec.pgStatSeqTupRead.get(i)));
            row.addValue(sqlInteger(exec.pgStatIdxScan.get(i)));
            row.addValue(sqlInteger(exec.pgStatIdxTupFetch.get(i)));
            row.addValue(sqlInteger(exec.pgStatInsert.get(i)));
            row.addValue(sqlInteger(exec.pgStatUpdate.get(i)));
            row.addValue(sqlInteger(exec.pgStatDelete.get(i)));
            // Live + dead tuples from actual table (if still exists)
            var table = exec.findTable(tblName);
            if table != null {
                var t = table;
                var liveTup = 0;
                var deadTup = 0;
                var ri = 0;
                while ri < t.rowCount() {
                    var maybeRow = t.getRow(ri);
                    if maybeRow != null {
                        var r = maybeRow;
                        if r.deleted {
                            deadTup = deadTup + 1;
                        } else {
                            liveTup = liveTup + 1;
                        }
                    }
                    ri = ri + 1;
                }
                row.addValue(sqlInteger(liveTup));
                row.addValue(sqlInteger(deadTup));
            } else {
                row.addValue(sqlInteger(0));
                row.addValue(sqlInteger(0));
            }
            result.addRow(row);
            i = i + 1;
        }

        return result;
    }

    hide func buildPgStatUserIndexes() -> QueryResult {
        var result = new QueryResult();
        result.init();

        result.addColumnName("relid");
        result.addColumnName("indexrelid");
        result.addColumnName("schemaname");
        result.addColumnName("relname");
        result.addColumnName("indexrelname");
        result.addColumnName("idx_scan");
        result.addColumnName("idx_tup_read");
        result.addColumnName("idx_tup_fetch");

        var i = 0;
        while i < exec.pgStatIndexNames.count() {
            var idxName = exec.pgStatIndexNames.get(i);
            var tblName = exec.pgStatIndexTableNames.get(i);
            var row = new Row();
            row.init();
            row.addValue(sqlInteger(generateOid(exec.currentDbName + "." + tblName)));
            row.addValue(sqlInteger(generateOid(exec.currentDbName + ".idx." + idxName)));
            row.addValue(sqlText("public"));
            row.addValue(sqlText(tblName));
            row.addValue(sqlText(idxName));
            row.addValue(sqlInteger(exec.pgStatIndexIdxScan.get(i)));
            row.addValue(sqlInteger(exec.pgStatIndexTupRead.get(i)));
            row.addValue(sqlInteger(exec.pgStatIndexTupFetch.get(i)));
            result.addRow(row);
            i = i + 1;
        }

        return result;
    }
}
