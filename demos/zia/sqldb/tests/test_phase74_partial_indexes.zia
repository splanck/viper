// test_phase74_partial_indexes.zia — Phase 74: Partial Indexes
// Tests: CREATE INDEX ... WHERE condition for partial index support

module test_phase74_partial_indexes;

bind Terminal = Viper.Terminal;
bind Fmt = Viper.Fmt;

bind "./test_common";
bind "../executor";
bind "../types";

//=========================================================================
// 1. Basic partial index creation and lookup
//=========================================================================

func testBasicPartialIndex() {
    section("Basic partial index — WHERE status = 'active'");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, status TEXT)");
    exec.executeSql("INSERT INTO users VALUES (1, 'Alice', 'active')");
    exec.executeSql("INSERT INTO users VALUES (2, 'Bob', 'inactive')");
    exec.executeSql("INSERT INTO users VALUES (3, 'Charlie', 'active')");
    exec.executeSql("INSERT INTO users VALUES (4, 'Dave', 'inactive')");
    exec.executeSql("INSERT INTO users VALUES (5, 'Eve', 'active')");

    // Create partial index only for active users
    var r1 = exec.executeSql("CREATE INDEX idx_active_users ON users (name) WHERE status = 'active'");
    assertSuccess(r1, "create partial index");

    // Query that matches — should still work correctly
    var r2 = exec.executeSql("SELECT name FROM users WHERE status = 'active' ORDER BY name");
    assertSuccess(r2, "select active users");
    assertRowCount(r2, 3, "3 active users");
    assertEq(val(r2, 0, 0), "Alice", "first active");
    assertEq(val(r2, 1, 0), "Charlie", "second active");
    assertEq(val(r2, 2, 0), "Eve", "third active");

    // Query inactive users — still works (full scan)
    var r3 = exec.executeSql("SELECT name FROM users WHERE status = 'inactive' ORDER BY name");
    assertSuccess(r3, "select inactive users");
    assertRowCount(r3, 2, "2 inactive users");
}

//=========================================================================
// 2. Partial index with numeric comparison
//=========================================================================

func testPartialIndexNumeric() {
    section("Partial index — WHERE price > 100");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, price INTEGER)");
    exec.executeSql("INSERT INTO products VALUES (1, 'Widget', 50)");
    exec.executeSql("INSERT INTO products VALUES (2, 'Gadget', 150)");
    exec.executeSql("INSERT INTO products VALUES (3, 'Doohickey', 200)");
    exec.executeSql("INSERT INTO products VALUES (4, 'Thingamajig', 75)");
    exec.executeSql("INSERT INTO products VALUES (5, 'Gizmo', 300)");

    // Create partial index for expensive products
    var r1 = exec.executeSql("CREATE INDEX idx_expensive ON products (name) WHERE price > 100");
    assertSuccess(r1, "create partial index on expensive");

    // SHOW INDEXES should show partial flag
    var r2 = exec.executeSql("SHOW INDEXES FROM products");
    assertSuccess(r2, "show indexes");
    assertRowCount(r2, 1, "1 index");
    assertEq(val(r2, 0, 4), "YES", "index is partial");

    // Query expensive products
    var r3 = exec.executeSql("SELECT name, price FROM products WHERE price > 100 ORDER BY price");
    assertSuccess(r3, "select expensive");
    assertRowCount(r3, 3, "3 expensive products");
    assertEq(val(r3, 0, 0), "Gadget", "cheapest expensive");
    assertEq(val(r3, 2, 0), "Gizmo", "most expensive");
}

//=========================================================================
// 3. Partial unique index
//=========================================================================

func testPartialUniqueIndex() {
    section("Partial UNIQUE index — WHERE active = true");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE emails (id INTEGER PRIMARY KEY, email TEXT, active BOOLEAN)");
    exec.executeSql("INSERT INTO emails VALUES (1, 'alice@test.com', true)");
    exec.executeSql("INSERT INTO emails VALUES (2, 'bob@test.com', true)");
    exec.executeSql("INSERT INTO emails VALUES (3, 'alice@test.com', false)");

    // Create partial unique index — unique only among active emails
    var r1 = exec.executeSql("CREATE UNIQUE INDEX idx_active_email ON emails (email) WHERE active = true");
    assertSuccess(r1, "create partial unique index");

    // Duplicate active email should fail (unique constraint on partial index)
    var r2 = exec.executeSql("INSERT INTO emails VALUES (4, 'alice@test.com', true)");
    assertFailure(r2, "duplicate active email rejected");

    // Duplicate inactive email should succeed (not in partial index)
    var r3 = exec.executeSql("INSERT INTO emails VALUES (5, 'alice@test.com', false)");
    assertSuccess(r3, "duplicate inactive email allowed");

    var r4 = exec.executeSql("SELECT COUNT(*) FROM emails");
    assertEq(val(r4, 0, 0), "4", "4 total emails");
}

//=========================================================================
// 4. Partial index with IS NOT NULL
//=========================================================================

func testPartialIndexIsNotNull() {
    section("Partial index — WHERE col IS NOT NULL");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE metrics (id INTEGER PRIMARY KEY, sensor TEXT, reading INTEGER)");
    exec.executeSql("INSERT INTO metrics VALUES (1, 'temp', 72)");
    exec.executeSql("INSERT INTO metrics VALUES (2, 'humidity', NULL)");
    exec.executeSql("INSERT INTO metrics VALUES (3, 'temp', 68)");
    exec.executeSql("INSERT INTO metrics VALUES (4, 'pressure', NULL)");
    exec.executeSql("INSERT INTO metrics VALUES (5, 'temp', 75)");

    // Index only non-null readings
    var r1 = exec.executeSql("CREATE INDEX idx_readings ON metrics (sensor) WHERE reading IS NOT NULL");
    assertSuccess(r1, "create IS NOT NULL partial index");

    // Query non-null readings
    var r2 = exec.executeSql("SELECT sensor, reading FROM metrics WHERE reading IS NOT NULL ORDER BY id");
    assertSuccess(r2, "select non-null readings");
    assertRowCount(r2, 3, "3 non-null readings");
    assertEq(val(r2, 0, 0), "temp", "first reading sensor");
    assertEq(val(r2, 0, 1), "72", "first reading value");
}

//=========================================================================
// 5. Index maintenance — inserts respect partial predicate
//=========================================================================

func testPartialIndexMaintenance() {
    section("Partial index — maintenance on INSERT");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE orders (id INTEGER PRIMARY KEY, amount INTEGER, status TEXT)");
    exec.executeSql("CREATE UNIQUE INDEX idx_pending ON orders (amount) WHERE status = 'pending'");

    exec.executeSql("INSERT INTO orders VALUES (1, 100, 'pending')");
    exec.executeSql("INSERT INTO orders VALUES (2, 200, 'shipped')");

    // Same amount but different status — should succeed (shipped not in index)
    var r1 = exec.executeSql("INSERT INTO orders VALUES (3, 100, 'shipped')");
    assertSuccess(r1, "same amount different status OK");

    // Same amount AND pending — should fail (unique in partial index)
    var r2 = exec.executeSql("INSERT INTO orders VALUES (4, 100, 'pending')");
    assertFailure(r2, "duplicate pending amount rejected");

    // Verify all valid rows are present
    var r3 = exec.executeSql("SELECT id, amount, status FROM orders ORDER BY id");
    assertSuccess(r3, "select all orders");
    assertRowCount(r3, 3, "3 orders total");
}

//=========================================================================
// 6. Non-partial index comparison
//=========================================================================

func testNonPartialComparison() {
    section("Non-partial index for comparison");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE items (id INTEGER PRIMARY KEY, name TEXT)");
    exec.executeSql("INSERT INTO items VALUES (1, 'A')");
    exec.executeSql("INSERT INTO items VALUES (2, 'B')");

    // Regular (non-partial) index
    var r1 = exec.executeSql("CREATE INDEX idx_items_name ON items (name)");
    assertSuccess(r1, "create non-partial index");

    var r2 = exec.executeSql("SHOW INDEXES FROM items");
    assertSuccess(r2, "show indexes");
    assertEq(val(r2, 0, 4), "NO", "index is not partial");
}

//=========================================================================
// Main
//=========================================================================

func main() {
    Terminal.Say("=== Phase 74: Partial Indexes ===");

    testBasicPartialIndex();
    testPartialIndexNumeric();
    testPartialUniqueIndex();
    testPartialIndexIsNotNull();
    testPartialIndexMaintenance();
    testNonPartialComparison();

    printResults();
}
