// test_phase73_merge.zia — Phase 73: MERGE INTO
// Tests: MERGE INTO with WHEN MATCHED UPDATE, DELETE, WHEN NOT MATCHED INSERT

module test_phase73_merge;

bind Terminal = Viper.Terminal;
bind Fmt = Viper.Fmt;

bind "./test_common";
bind "../executor";
bind "../types";

//=========================================================================
// 1. MERGE with WHEN MATCHED UPDATE + WHEN NOT MATCHED INSERT
//=========================================================================

func testMergeUpsert() {
    section("MERGE — WHEN MATCHED UPDATE + WHEN NOT MATCHED INSERT");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, price INTEGER, stock INTEGER)");
    exec.executeSql("INSERT INTO products VALUES (1, 'Apple', 100, 50)");
    exec.executeSql("INSERT INTO products VALUES (2, 'Banana', 80, 30)");
    exec.executeSql("INSERT INTO products VALUES (3, 'Cherry', 120, 10)");

    exec.executeSql("CREATE TABLE new_products (id INTEGER PRIMARY KEY, name TEXT, price INTEGER, stock INTEGER)");
    exec.executeSql("INSERT INTO new_products VALUES (2, 'Banana', 90, 40)");
    exec.executeSql("INSERT INTO new_products VALUES (3, 'Cherry', 130, 20)");
    exec.executeSql("INSERT INTO new_products VALUES (4, 'Date', 200, 15)");
    exec.executeSql("INSERT INTO new_products VALUES (5, 'Elderberry', 300, 5)");

    var r1 = exec.executeSql("MERGE INTO products AS t USING new_products AS s ON t.id = s.id WHEN MATCHED THEN UPDATE SET price = s.price, stock = s.stock WHEN NOT MATCHED THEN INSERT (id, name, price, stock) VALUES (s.id, s.name, s.price, s.stock)");
    assertSuccess(r1, "merge upsert");

    var r2 = exec.executeSql("SELECT id, name, price, stock FROM products ORDER BY id");
    assertSuccess(r2, "select after merge");
    assertRowCount(r2, 5, "5 products after merge");

    // Apple unchanged
    assertEq(val(r2, 0, 0), "1", "apple id");
    assertEq(val(r2, 0, 2), "100", "apple price unchanged");
    assertEq(val(r2, 0, 3), "50", "apple stock unchanged");

    // Banana updated
    assertEq(val(r2, 1, 0), "2", "banana id");
    assertEq(val(r2, 1, 2), "90", "banana price updated");
    assertEq(val(r2, 1, 3), "40", "banana stock updated");

    // Cherry updated
    assertEq(val(r2, 2, 0), "3", "cherry id");
    assertEq(val(r2, 2, 2), "130", "cherry price updated");
    assertEq(val(r2, 2, 3), "20", "cherry stock updated");

    // Date inserted
    assertEq(val(r2, 3, 0), "4", "date id");
    assertEq(val(r2, 3, 1), "Date", "date name");
    assertEq(val(r2, 3, 2), "200", "date price");
    assertEq(val(r2, 3, 3), "15", "date stock");

    // Elderberry inserted
    assertEq(val(r2, 4, 0), "5", "elderberry id");
    assertEq(val(r2, 4, 1), "Elderberry", "elderberry name");
    assertEq(val(r2, 4, 2), "300", "elderberry price");
    assertEq(val(r2, 4, 3), "5", "elderberry stock");
}

//=========================================================================
// 2. MERGE with WHEN MATCHED DELETE
//=========================================================================

func testMergeDelete() {
    section("MERGE — WHEN MATCHED DELETE");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE inventory (item_id INTEGER PRIMARY KEY, qty INTEGER)");
    exec.executeSql("INSERT INTO inventory VALUES (1, 100)");
    exec.executeSql("INSERT INTO inventory VALUES (2, 200)");
    exec.executeSql("INSERT INTO inventory VALUES (3, 300)");

    exec.executeSql("CREATE TABLE discontinued (item_id INTEGER PRIMARY KEY)");
    exec.executeSql("INSERT INTO discontinued VALUES (2)");
    exec.executeSql("INSERT INTO discontinued VALUES (3)");

    var r1 = exec.executeSql("MERGE INTO inventory AS i USING discontinued AS d ON i.item_id = d.item_id WHEN MATCHED THEN DELETE");
    assertSuccess(r1, "merge delete");

    var r2 = exec.executeSql("SELECT item_id, qty FROM inventory ORDER BY item_id");
    assertSuccess(r2, "select after merge delete");
    assertRowCount(r2, 1, "only item 1 remains");
    assertEq(val(r2, 0, 0), "1", "remaining item id");
    assertEq(val(r2, 0, 1), "100", "remaining item qty");
}

//=========================================================================
// 3. MERGE with only WHEN NOT MATCHED (insert-only)
//=========================================================================

func testMergeInsertOnly() {
    section("MERGE — WHEN NOT MATCHED only (insert-only)");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE target_t (id INTEGER PRIMARY KEY, val TEXT)");
    exec.executeSql("INSERT INTO target_t VALUES (1, 'existing')");

    exec.executeSql("CREATE TABLE source_t (id INTEGER PRIMARY KEY, val TEXT)");
    exec.executeSql("INSERT INTO source_t VALUES (1, 'updated')");
    exec.executeSql("INSERT INTO source_t VALUES (2, 'new_a')");
    exec.executeSql("INSERT INTO source_t VALUES (3, 'new_b')");

    var r1 = exec.executeSql("MERGE INTO target_t USING source_t ON target_t.id = source_t.id WHEN NOT MATCHED THEN INSERT (id, val) VALUES (source_t.id, source_t.val)");
    assertSuccess(r1, "merge insert-only");

    var r2 = exec.executeSql("SELECT id, val FROM target_t ORDER BY id");
    assertSuccess(r2, "select after insert-only merge");
    assertRowCount(r2, 3, "3 rows after merge");
    assertEq(val(r2, 0, 1), "existing", "existing row unchanged");
    assertEq(val(r2, 1, 1), "new_a", "new row a");
    assertEq(val(r2, 2, 1), "new_b", "new row b");
}

//=========================================================================
// 4. MERGE with empty source (no-op)
//=========================================================================

func testMergeEmptySource() {
    section("MERGE — empty source (no-op)");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE target_e (id INTEGER PRIMARY KEY, val TEXT)");
    exec.executeSql("INSERT INTO target_e VALUES (1, 'a')");
    exec.executeSql("INSERT INTO target_e VALUES (2, 'b')");

    exec.executeSql("CREATE TABLE empty_src (id INTEGER PRIMARY KEY, val TEXT)");

    var r1 = exec.executeSql("MERGE INTO target_e USING empty_src ON target_e.id = empty_src.id WHEN MATCHED THEN UPDATE SET val = empty_src.val WHEN NOT MATCHED THEN INSERT (id, val) VALUES (empty_src.id, empty_src.val)");
    assertSuccess(r1, "merge with empty source");

    var r2 = exec.executeSql("SELECT COUNT(*) FROM target_e");
    assertSuccess(r2, "count after empty merge");
    assertEq(val(r2, 0, 0), "2", "no change from empty source");
}

//=========================================================================
// 5. MERGE without aliases (table-qualified column names)
//=========================================================================

func testMergeNoAliases() {
    section("MERGE — without aliases");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE dest (id INTEGER PRIMARY KEY, score INTEGER)");
    exec.executeSql("INSERT INTO dest VALUES (1, 10)");
    exec.executeSql("INSERT INTO dest VALUES (2, 20)");

    exec.executeSql("CREATE TABLE src (id INTEGER PRIMARY KEY, score INTEGER)");
    exec.executeSql("INSERT INTO src VALUES (2, 99)");
    exec.executeSql("INSERT INTO src VALUES (3, 30)");

    var r1 = exec.executeSql("MERGE INTO dest USING src ON dest.id = src.id WHEN MATCHED THEN UPDATE SET score = src.score WHEN NOT MATCHED THEN INSERT (id, score) VALUES (src.id, src.score)");
    assertSuccess(r1, "merge without aliases");

    var r2 = exec.executeSql("SELECT id, score FROM dest ORDER BY id");
    assertSuccess(r2, "select after no-alias merge");
    assertRowCount(r2, 3, "3 rows");
    assertEq(val(r2, 0, 1), "10", "id=1 unchanged");
    assertEq(val(r2, 1, 1), "99", "id=2 updated");
    assertEq(val(r2, 2, 1), "30", "id=3 inserted");
}

//=========================================================================
// 6. Error: non-existent target table
//=========================================================================

func testMergeErrors() {
    section("MERGE — error cases");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE src2 (id INTEGER)");

    var r1 = exec.executeSql("MERGE INTO no_such_table USING src2 ON no_such_table.id = src2.id WHEN MATCHED THEN DELETE");
    assertFailure(r1, "merge into non-existent table");
}

//=========================================================================
// Main
//=========================================================================

func main() {
    Terminal.Say("=== Phase 73: MERGE INTO ===");

    testMergeUpsert();
    testMergeDelete();
    testMergeInsertOnly();
    testMergeEmptySource();
    testMergeNoAliases();
    testMergeErrors();

    printResults();
}
