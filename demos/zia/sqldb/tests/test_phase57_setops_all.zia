// test_phase57_setops_all.zia — Phase 57: EXCEPT ALL and INTERSECT ALL
// Tests for set operation ALL variants.

module test_phase57_setops_all;

bind Terminal = Viper.Terminal;
bind String = Viper.String;
bind Fmt = Viper.Fmt;

bind "./test_common";
bind "../executor";
bind "../types";

//=========================================================================
// Setup helper
//=========================================================================

func setupExec() -> Executor {
    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE t1 (id INTEGER, name TEXT)");
    exec.executeSql("INSERT INTO t1 VALUES (1, 'Alice')");
    exec.executeSql("INSERT INTO t1 VALUES (2, 'Bob')");
    exec.executeSql("INSERT INTO t1 VALUES (2, 'Bob')");
    exec.executeSql("INSERT INTO t1 VALUES (3, 'Charlie')");
    exec.executeSql("INSERT INTO t1 VALUES (3, 'Charlie')");
    exec.executeSql("INSERT INTO t1 VALUES (3, 'Charlie')");

    exec.executeSql("CREATE TABLE t2 (id INTEGER, name TEXT)");
    exec.executeSql("INSERT INTO t2 VALUES (2, 'Bob')");
    exec.executeSql("INSERT INTO t2 VALUES (3, 'Charlie')");
    exec.executeSql("INSERT INTO t2 VALUES (3, 'Charlie')");
    exec.executeSql("INSERT INTO t2 VALUES (4, 'Diana')");

    return exec;
}

//=========================================================================
// EXCEPT ALL
//=========================================================================

func testExceptAll() {
    section("EXCEPT ALL");

    var exec = setupExec();

    // EXCEPT ALL: t1 has (1,Alice)×1, (2,Bob)×2, (3,Charlie)×3
    //             t2 has (2,Bob)×1, (3,Charlie)×2, (4,Diana)×1
    // Result: (1,Alice)×1, (2,Bob)×1, (3,Charlie)×1
    var r1 = exec.executeSql("SELECT id, name FROM t1 EXCEPT ALL SELECT id, name FROM t2");
    assertSuccess(r1, "EXCEPT ALL");
    assertRowCount(r1, 3, "3 rows after EXCEPT ALL");
    // Should be Alice(1), Bob(1 of 2 remaining), Charlie(1 of 3-2=1 remaining)
    assertEq(val(r1, 0, 0), "1", "row 0 = Alice id");
    assertEq(val(r1, 0, 1), "Alice", "row 0 = Alice");
    assertEq(val(r1, 1, 0), "2", "row 1 = Bob id");
    assertEq(val(r1, 1, 1), "Bob", "row 1 = Bob");
    assertEq(val(r1, 2, 0), "3", "row 2 = Charlie id");
    assertEq(val(r1, 2, 1), "Charlie", "row 2 = Charlie");
}

//=========================================================================
// EXCEPT (without ALL) for comparison
//=========================================================================

func testExceptDistinct() {
    section("EXCEPT (distinct)");

    var exec = setupExec();

    // EXCEPT (distinct): removes all matching rows and deduplicates
    // t1 has Alice, Bob, Charlie; t2 has Bob, Charlie, Diana
    // Result: just Alice (deduplicated)
    var r1 = exec.executeSql("SELECT id, name FROM t1 EXCEPT SELECT id, name FROM t2");
    assertSuccess(r1, "EXCEPT");
    assertRowCount(r1, 1, "1 row after EXCEPT");
    assertEq(val(r1, 0, 1), "Alice", "only Alice");
}

//=========================================================================
// INTERSECT ALL
//=========================================================================

func testIntersectAll() {
    section("INTERSECT ALL");

    var exec = setupExec();

    // INTERSECT ALL: t1 has (2,Bob)×2, (3,Charlie)×3
    //                t2 has (2,Bob)×1, (3,Charlie)×2
    // Result: (2,Bob)×1, (3,Charlie)×2 = 3 rows
    var r1 = exec.executeSql("SELECT id, name FROM t1 INTERSECT ALL SELECT id, name FROM t2");
    assertSuccess(r1, "INTERSECT ALL");
    assertRowCount(r1, 3, "3 rows after INTERSECT ALL");
    assertEq(val(r1, 0, 0), "2", "row 0 = Bob id");
    assertEq(val(r1, 0, 1), "Bob", "row 0 = Bob");
    assertEq(val(r1, 1, 0), "3", "row 1 = Charlie id");
    assertEq(val(r1, 1, 1), "Charlie", "row 1 = Charlie");
    assertEq(val(r1, 2, 0), "3", "row 2 = Charlie id");
    assertEq(val(r1, 2, 1), "Charlie", "row 2 = Charlie");
}

//=========================================================================
// INTERSECT (without ALL) for comparison
//=========================================================================

func testIntersectDistinct() {
    section("INTERSECT (distinct)");

    var exec = setupExec();

    // INTERSECT (distinct): common rows, deduplicated
    // Common: Bob, Charlie (regardless of count)
    var r1 = exec.executeSql("SELECT id, name FROM t1 INTERSECT SELECT id, name FROM t2");
    assertSuccess(r1, "INTERSECT");
    assertRowCount(r1, 2, "2 rows after INTERSECT");
    assertEq(val(r1, 0, 1), "Bob", "Bob");
    assertEq(val(r1, 1, 1), "Charlie", "Charlie");
}

//=========================================================================
// EXCEPT ALL with no overlap
//=========================================================================

func testExceptAllNoOverlap() {
    section("EXCEPT ALL no overlap");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE a (x INTEGER)");
    exec.executeSql("INSERT INTO a VALUES (1)");
    exec.executeSql("INSERT INTO a VALUES (2)");
    exec.executeSql("INSERT INTO a VALUES (3)");

    exec.executeSql("CREATE TABLE b (x INTEGER)");
    exec.executeSql("INSERT INTO b VALUES (4)");
    exec.executeSql("INSERT INTO b VALUES (5)");

    // No overlap: all first rows remain
    var r1 = exec.executeSql("SELECT x FROM a EXCEPT ALL SELECT x FROM b");
    assertSuccess(r1, "EXCEPT ALL no overlap");
    assertRowCount(r1, 3, "all 3 rows kept");
}

//=========================================================================
// EXCEPT ALL with total overlap
//=========================================================================

func testExceptAllTotalOverlap() {
    section("EXCEPT ALL total overlap");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE a (x INTEGER)");
    exec.executeSql("INSERT INTO a VALUES (1)");
    exec.executeSql("INSERT INTO a VALUES (2)");

    exec.executeSql("CREATE TABLE b (x INTEGER)");
    exec.executeSql("INSERT INTO b VALUES (1)");
    exec.executeSql("INSERT INTO b VALUES (2)");
    exec.executeSql("INSERT INTO b VALUES (3)");

    // All first rows consumed
    var r1 = exec.executeSql("SELECT x FROM a EXCEPT ALL SELECT x FROM b");
    assertSuccess(r1, "EXCEPT ALL total");
    assertRowCount(r1, 0, "0 rows left");
}

//=========================================================================
// INTERSECT ALL with no overlap
//=========================================================================

func testIntersectAllNoOverlap() {
    section("INTERSECT ALL no overlap");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE a (x INTEGER)");
    exec.executeSql("INSERT INTO a VALUES (1)");
    exec.executeSql("INSERT INTO a VALUES (2)");

    exec.executeSql("CREATE TABLE b (x INTEGER)");
    exec.executeSql("INSERT INTO b VALUES (3)");
    exec.executeSql("INSERT INTO b VALUES (4)");

    var r1 = exec.executeSql("SELECT x FROM a INTERSECT ALL SELECT x FROM b");
    assertSuccess(r1, "INTERSECT ALL no overlap");
    assertRowCount(r1, 0, "0 rows");
}

//=========================================================================
// INTERSECT ALL with identical sets
//=========================================================================

func testIntersectAllIdentical() {
    section("INTERSECT ALL identical");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE a (x INTEGER)");
    exec.executeSql("INSERT INTO a VALUES (1)");
    exec.executeSql("INSERT INTO a VALUES (1)");
    exec.executeSql("INSERT INTO a VALUES (2)");

    exec.executeSql("CREATE TABLE b (x INTEGER)");
    exec.executeSql("INSERT INTO b VALUES (1)");
    exec.executeSql("INSERT INTO b VALUES (1)");
    exec.executeSql("INSERT INTO b VALUES (2)");

    var r1 = exec.executeSql("SELECT x FROM a INTERSECT ALL SELECT x FROM b");
    assertSuccess(r1, "INTERSECT ALL identical");
    assertRowCount(r1, 3, "all 3 rows");
}

//=========================================================================
// EXCEPT ALL with text values
//=========================================================================

func testExceptAllText() {
    section("EXCEPT ALL text values");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE colors1 (color TEXT)");
    exec.executeSql("INSERT INTO colors1 VALUES ('red')");
    exec.executeSql("INSERT INTO colors1 VALUES ('red')");
    exec.executeSql("INSERT INTO colors1 VALUES ('blue')");
    exec.executeSql("INSERT INTO colors1 VALUES ('green')");

    exec.executeSql("CREATE TABLE colors2 (color TEXT)");
    exec.executeSql("INSERT INTO colors2 VALUES ('red')");
    exec.executeSql("INSERT INTO colors2 VALUES ('green')");

    // 'red' × 2 - 'red' × 1 = 'red' × 1, 'blue' stays, 'green' × 1 - 'green' × 1 = 0
    var r1 = exec.executeSql("SELECT color FROM colors1 EXCEPT ALL SELECT color FROM colors2");
    assertSuccess(r1, "EXCEPT ALL text");
    assertRowCount(r1, 2, "2 rows: red, blue");
    assertEq(val(r1, 0, 0), "red", "remaining red");
    assertEq(val(r1, 1, 0), "blue", "blue");
}

//=========================================================================
// EXCEPT ALL with empty second set
//=========================================================================

func testExceptAllEmptySecond() {
    section("EXCEPT ALL empty second");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE a (x INTEGER)");
    exec.executeSql("INSERT INTO a VALUES (1)");
    exec.executeSql("INSERT INTO a VALUES (2)");
    exec.executeSql("INSERT INTO a VALUES (2)");

    exec.executeSql("CREATE TABLE b (x INTEGER)");

    var r1 = exec.executeSql("SELECT x FROM a EXCEPT ALL SELECT x FROM b");
    assertSuccess(r1, "EXCEPT ALL empty second");
    assertRowCount(r1, 3, "all 3 rows remain");
}

//=========================================================================
// Chained UNION ALL (3 operands)
//=========================================================================

func testChainedUnionAll() {
    section("Chained UNION ALL");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE t1 (x INTEGER)");
    exec.executeSql("INSERT INTO t1 VALUES (1)");

    exec.executeSql("CREATE TABLE t2 (x INTEGER)");
    exec.executeSql("INSERT INTO t2 VALUES (2)");

    exec.executeSql("CREATE TABLE t3 (x INTEGER)");
    exec.executeSql("INSERT INTO t3 VALUES (3)");

    var r1 = exec.executeSql("SELECT x FROM t1 UNION ALL SELECT x FROM t2 UNION ALL SELECT x FROM t3");
    assertSuccess(r1, "chained UNION ALL");
    assertRowCount(r1, 3, "3 rows total");
    assertEq(val(r1, 0, 0), "1", "row 0");
    assertEq(val(r1, 1, 0), "2", "row 1");
    assertEq(val(r1, 2, 0), "3", "row 2");
}

//=========================================================================
// Chained UNION (deduplicate)
//=========================================================================

func testChainedUnion() {
    section("Chained UNION");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE t1 (x INTEGER)");
    exec.executeSql("INSERT INTO t1 VALUES (1)");
    exec.executeSql("INSERT INTO t1 VALUES (2)");

    exec.executeSql("CREATE TABLE t2 (x INTEGER)");
    exec.executeSql("INSERT INTO t2 VALUES (2)");
    exec.executeSql("INSERT INTO t2 VALUES (3)");

    exec.executeSql("CREATE TABLE t3 (x INTEGER)");
    exec.executeSql("INSERT INTO t3 VALUES (3)");
    exec.executeSql("INSERT INTO t3 VALUES (4)");

    var r1 = exec.executeSql("SELECT x FROM t1 UNION SELECT x FROM t2 UNION SELECT x FROM t3");
    assertSuccess(r1, "chained UNION");
    assertRowCount(r1, 4, "4 distinct values: 1,2,3,4");
}

//=========================================================================
// Chained UNION ALL with 4 operands
//=========================================================================

func testChained4Way() {
    section("Chained 4-way UNION ALL");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE a (v TEXT)");
    exec.executeSql("INSERT INTO a VALUES ('a')");
    exec.executeSql("CREATE TABLE b (v TEXT)");
    exec.executeSql("INSERT INTO b VALUES ('b')");
    exec.executeSql("CREATE TABLE c (v TEXT)");
    exec.executeSql("INSERT INTO c VALUES ('c')");
    exec.executeSql("CREATE TABLE d (v TEXT)");
    exec.executeSql("INSERT INTO d VALUES ('d')");

    var r1 = exec.executeSql("SELECT v FROM a UNION ALL SELECT v FROM b UNION ALL SELECT v FROM c UNION ALL SELECT v FROM d");
    assertSuccess(r1, "4-way UNION ALL");
    assertRowCount(r1, 4, "4 rows");
    assertEq(val(r1, 0, 0), "a", "a");
    assertEq(val(r1, 1, 0), "b", "b");
    assertEq(val(r1, 2, 0), "c", "c");
    assertEq(val(r1, 3, 0), "d", "d");
}

//=========================================================================
// Mixed set operations: UNION ALL then EXCEPT
//=========================================================================

func testMixedOps() {
    section("Mixed UNION ALL + EXCEPT");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE t1 (x INTEGER)");
    exec.executeSql("INSERT INTO t1 VALUES (1)");
    exec.executeSql("INSERT INTO t1 VALUES (2)");

    exec.executeSql("CREATE TABLE t2 (x INTEGER)");
    exec.executeSql("INSERT INTO t2 VALUES (3)");
    exec.executeSql("INSERT INTO t2 VALUES (4)");

    exec.executeSql("CREATE TABLE t3 (x INTEGER)");
    exec.executeSql("INSERT INTO t3 VALUES (2)");
    exec.executeSql("INSERT INTO t3 VALUES (3)");

    // (1,2) UNION ALL (3,4) = (1,2,3,4) then EXCEPT (2,3) = (1,4)
    var r1 = exec.executeSql("SELECT x FROM t1 UNION ALL SELECT x FROM t2 EXCEPT SELECT x FROM t3");
    assertSuccess(r1, "UNION ALL + EXCEPT");
    assertRowCount(r1, 2, "2 rows after EXCEPT");
    assertEq(val(r1, 0, 0), "1", "1 remains");
    assertEq(val(r1, 1, 0), "4", "4 remains");
}

//=========================================================================
// Mixed: UNION ALL then INTERSECT
//=========================================================================

func testMixedIntersect() {
    section("Mixed UNION ALL + INTERSECT");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE t1 (x INTEGER)");
    exec.executeSql("INSERT INTO t1 VALUES (1)");
    exec.executeSql("INSERT INTO t1 VALUES (2)");

    exec.executeSql("CREATE TABLE t2 (x INTEGER)");
    exec.executeSql("INSERT INTO t2 VALUES (3)");

    exec.executeSql("CREATE TABLE t3 (x INTEGER)");
    exec.executeSql("INSERT INTO t3 VALUES (2)");
    exec.executeSql("INSERT INTO t3 VALUES (3)");

    // (1,2) UNION ALL (3) = (1,2,3) then INTERSECT (2,3) = (2,3)
    var r1 = exec.executeSql("SELECT x FROM t1 UNION ALL SELECT x FROM t2 INTERSECT SELECT x FROM t3");
    assertSuccess(r1, "UNION ALL + INTERSECT");
    assertRowCount(r1, 2, "2 rows in intersection");
}

//=========================================================================
// MAIN
//=========================================================================

func main() {
    Terminal.Say("=== Phase 57: EXCEPT ALL / INTERSECT ALL / Chained Set Ops ===");

    testExceptAll();
    testExceptDistinct();
    testIntersectAll();
    testIntersectDistinct();
    testExceptAllNoOverlap();
    testExceptAllTotalOverlap();
    testIntersectAllNoOverlap();
    testIntersectAllIdentical();
    testExceptAllText();
    testExceptAllEmptySecond();
    testChainedUnionAll();
    testChainedUnion();
    testChained4Way();
    testMixedOps();
    testMixedIntersect();

    printResults();
}
