// test_pg_wire.zia — Tests for PostgreSQL Wire Protocol v3 (Phase 9)
// Part of ViperSQL
//
// Tests the PG wire protocol by running a server on a random port
// and connecting to it as a PG client, sending binary protocol messages.

module test_pg_wire;

bind Terminal = Viper.Terminal;
bind Fmt = Viper.Fmt;
bind Network = Viper.Network;
bind Threads = Viper.Threads;
bind Viper.Collections;
bind String = Viper.String;

bind "../server";
bind "../server/connection";
bind "../server/pg_wire";

//=============================================================================
// TEST HARNESS
//=============================================================================

Integer passed = 0;
Integer failed = 0;

func assert(cond: Boolean, msg: String) {
    if cond {
        passed = passed + 1;
        Terminal.Say("  PASS: " + msg);
    } else {
        failed = failed + 1;
        Terminal.Say("  FAIL: " + msg);
    }
}

//=============================================================================
// PG CLIENT HELPERS — Simulate a PostgreSQL client
//=============================================================================

// Send a PG v3 startup message
func sendStartupMessage(client: Ptr, user: String, database: String) {
    // Build startup body: int32(version) + key\0value\0...key\0value\0\0
    var body = new PgMsg(128);
    body.writeInt32(196608);  // Protocol v3.0
    body.writeCString("user");
    body.writeCString(user);
    body.writeCString("database");
    body.writeCString(database);
    body.writeByte(0);  // terminal null

    // Startup message has no type byte, just length + body
    var bodyBytes = body.toBytes();
    var length = bodyBytes.Len + 4;  // length includes itself
    var msg = Bytes.New(4 + bodyBytes.Len);
    writeInt32BE(msg, 0, length);
    Bytes.Copy(msg, 4, bodyBytes, 0, bodyBytes.Len);
    Network.Tcp.SendAll(client, msg);
}

// Send a PG Query message
func sendQuery(client: Ptr, query: String) {
    var body = new PgMsg(256);
    body.writeCString(query);
    var bodyBytes = body.toBytes();

    var msgLen = 1 + 4 + bodyBytes.Len;
    var msg = Bytes.New(msgLen);
    msg.Set(0, 81);  // 'Q'
    writeInt32BE(msg, 1, bodyBytes.Len + 4);
    Bytes.Copy(msg, 5, bodyBytes, 0, bodyBytes.Len);
    Network.Tcp.SendAll(client, msg);
}

// Send a PG Password message
func sendPassword(client: Ptr, password: String) {
    var body = new PgMsg(64);
    body.writeCString(password);
    var bodyBytes = body.toBytes();

    var msgLen = 1 + 4 + bodyBytes.Len;
    var msg = Bytes.New(msgLen);
    msg.Set(0, 112);  // 'p' = PasswordMessage
    writeInt32BE(msg, 1, bodyBytes.Len + 4);
    Bytes.Copy(msg, 5, bodyBytes, 0, bodyBytes.Len);
    Network.Tcp.SendAll(client, msg);
}

// Perform full startup + auth handshake, skip to ReadyForQuery
func performStartup(client: Ptr, user: String, database: String, password: String) {
    sendStartupMessage(client, user, database);
    // Receive AuthCleartextPassword (R with auth type 3)
    var authReq = recvResponse(client);
    // Send password
    sendPassword(client, password);
    // Skip AuthOk, params, BackendKeyData — wait for ReadyForQuery
    recvUntil(client, 90);
}

// Send a PG Terminate message
func sendTerminate(client: Ptr) {
    var msg = Bytes.New(5);
    msg.Set(0, 88);  // 'X'
    writeInt32BE(msg, 1, 4);
    Network.Tcp.SendAll(client, msg);
}

// Read a single PG server message (type + length + body)
// Returns: [msgType, bodyLen] and sets bodyBuf
entity PgResponse {
    expose Integer msgType;
    expose Bytes body;
    expose Integer bodyLen;
    expose Boolean valid;

    expose func init() {
        msgType = 0;
        body = Bytes.New(0);
        bodyLen = 0;
        valid = false;
    }
}

func recvResponse(client: Ptr) -> PgResponse {
    var resp = new PgResponse();
    resp.init();

    var typeBuf: Bytes = Network.Tcp.RecvExact(client, 1);
    resp.msgType = typeBuf.Get(0);

    var lenBuf: Bytes = Network.Tcp.RecvExact(client, 4);
    var length = readInt32BE(lenBuf, 0);

    if length > 4 {
        var bodyData: Bytes = Network.Tcp.RecvExact(client, length - 4);
        resp.body = bodyData;
        resp.bodyLen = length - 4;
    }

    resp.valid = true;
    return resp;
}

// Skip all messages until we find a specific type, return it
func recvUntil(client: Ptr, targetType: Integer) -> PgResponse {
    var maxTries = 50;
    var i = 0;
    while i < maxTries {
        var resp = recvResponse(client);
        if resp.msgType == targetType {
            return resp;
        }
        i = i + 1;
    }
    // Failed to find target message
    var empty = new PgResponse();
    empty.init();
    return empty;
}

// Count the number of DataRow messages before a CommandComplete
// Returns the count, and consumes messages up to and including ReadyForQuery
func countDataRows(client: Ptr) -> Integer {
    var count = 0;
    var maxMsgs = 200;
    var i = 0;
    while i < maxMsgs {
        var resp = recvResponse(client);
        if resp.msgType == 68 {  // 'D' DataRow
            count = count + 1;
        } else if resp.msgType == 67 {  // 'C' CommandComplete
            // Next should be ReadyForQuery, consume it
        } else if resp.msgType == 90 {  // 'Z' ReadyForQuery
            return count;
        } else if resp.msgType == 69 {  // 'E' ErrorResponse
            // Skip to ReadyForQuery
        }
        i = i + 1;
    }
    return count;
}

// Extract a C string from bytes at offset, return the string
func extractCString(data: Bytes, offset: Integer) -> String {
    var end = offset;
    while end < data.Len && data.Get(end) != 0 {
        end = end + 1;
    }
    if end == offset { return ""; }
    var slice: Bytes = data.Slice(offset, end);
    return slice.ToStr();
}

//=============================================================================
// SERVER STATE
//=============================================================================

var testPort: Integer;
var serverReady: Boolean;
var serverLock: List[Integer];

func setServerReady() {
    Threads.Monitor.Enter(serverLock);
    serverReady = true;
    Threads.Monitor.PauseAll(serverLock);
    Threads.Monitor.Exit(serverLock);
}

func waitForServer() {
    Threads.Monitor.Enter(serverLock);
    while serverReady == false {
        Threads.Monitor.Wait(serverLock);
    }
    Threads.Monitor.Exit(serverLock);
}

//=============================================================================
// TEST SERVER
//=============================================================================

// Run the test server on a background thread
func testServerWorker(portArg: List[Integer]) {
    var port = portArg.get(0);

    // Initialize shared server
    var dbServer = new DatabaseServer();
    dbServer.init();
    sql_connection_init(dbServer);

    // Start listening
    var server = Network.TcpServer.Listen(port);
    setServerReady();

    // Accept connections (up to 20 for tests)
    var count = 0;
    while count < 20 {
        var client = Network.TcpServer.AcceptFor(server, 10000);  // 10s timeout
        if client != null {
            Threads.Thread.StartSafe(&handlePgClient, client);
            count = count + 1;
        } else {
            // Timeout — no more clients
            break;
        }
    }

    Threads.Thread.Sleep(500);  // Let handlers finish
    Network.TcpServer.Close(server);
}

//=============================================================================
// TESTS
//=============================================================================

func testStartupAndAuth() {
    Terminal.Say("Testing PG startup handshake with auth...");

    Terminal.Say("  [debug] Connecting...");
    var client = Network.Tcp.Connect("localhost", testPort);
    Network.Tcp.SetRecvTimeout(client, 5000);
    Terminal.Say("  [debug] Connected, sending startup...");

    // Send startup message
    sendStartupMessage(client, "admin", "main");
    Terminal.Say("  [debug] Startup sent, receiving auth request...");

    // Should receive AuthenticationCleartextPassword (R, auth type 3)
    var authReq = recvResponse(client);
    Terminal.Say("  [debug] Auth request received, type=" + Fmt.Int(authReq.msgType));
    assert(authReq.msgType == 82, "Received Auth request (R)");
    assert(authReq.bodyLen == 4, "Auth request body is 4 bytes");
    if authReq.bodyLen >= 4 {
        var authType = readInt32BE(authReq.body, 0);
        assert(authType == 3, "Auth type is 3 (CleartextPassword)");
    }

    // Send password
    Terminal.Say("  [debug] Sending password...");
    sendPassword(client, "admin");

    // Should receive AuthenticationOk (R, auth type 0)
    var authOk = recvResponse(client);
    Terminal.Say("  [debug] Auth OK received, type=" + Fmt.Int(authOk.msgType));
    assert(authOk.msgType == 82, "Received AuthenticationOk (R)");
    if authOk.bodyLen >= 4 {
        var authType = readInt32BE(authOk.body, 0);
        assert(authType == 0, "Auth type is 0 (OK)");
    }

    // Should receive ParameterStatus messages
    var gotServerVersion = false;
    var gotEncoding = false;
    var gotReadyForQuery = false;

    var maxMsgs = 30;
    var i = 0;
    while i < maxMsgs {
        var resp = recvResponse(client);
        if resp.msgType == 83 {  // 'S' ParameterStatus
            var paramName = extractCString(resp.body, 0);
            if paramName == "server_version" { gotServerVersion = true; }
            if paramName == "client_encoding" { gotEncoding = true; }
        } else if resp.msgType == 75 {  // 'K' BackendKeyData
            // Expected
        } else if resp.msgType == 90 {  // 'Z' ReadyForQuery
            gotReadyForQuery = true;
            if resp.bodyLen >= 1 {
                var status = resp.body.Get(0);
                assert(status == 73, "ReadyForQuery status is 'I' (idle)");
            }
            break;
        }
        i = i + 1;
    }

    assert(gotServerVersion, "Received server_version parameter");
    assert(gotEncoding, "Received client_encoding parameter");
    assert(gotReadyForQuery, "Received ReadyForQuery");

    sendTerminate(client);
    Network.Tcp.Close(client);
}

func testSimpleQuery() {
    Terminal.Say("Testing PG simple query protocol...");

    var client = Network.Tcp.Connect("localhost", testPort);
    Network.Tcp.SetRecvTimeout(client, 5000);

    // Startup with auth
    performStartup(client, "admin", "main", "admin");

    // Send a simple SELECT query
    sendQuery(client, "SELECT 1 + 2 AS result");

    // Should receive RowDescription
    var rowDesc = recvResponse(client);
    assert(rowDesc.msgType == 84, "Received RowDescription (T)");
    if rowDesc.bodyLen >= 2 {
        var numCols = readInt16BE(rowDesc.body, 0);
        assert(numCols == 1, "RowDescription has 1 column");
    }

    // Should receive DataRow
    var dataRow = recvResponse(client);
    assert(dataRow.msgType == 68, "Received DataRow (D)");
    if dataRow.bodyLen >= 2 {
        var numVals = readInt16BE(dataRow.body, 0);
        assert(numVals == 1, "DataRow has 1 value");
        // Read value: int32(len) + bytes
        if dataRow.bodyLen >= 6 {
            var valLen = readInt32BE(dataRow.body, 2);
            if valLen > 0 && dataRow.bodyLen >= 6 + valLen {
                var valSlice: Bytes = dataRow.body.Slice(6, 6 + valLen);
                var valStr = valSlice.ToStr();
                assert(valStr == "3", "SELECT 1+2 = 3");
            }
        }
    }

    // Should receive CommandComplete
    var cmdComplete = recvResponse(client);
    assert(cmdComplete.msgType == 67, "Received CommandComplete (C)");

    // Should receive ReadyForQuery
    var ready = recvResponse(client);
    assert(ready.msgType == 90, "Received ReadyForQuery (Z)");

    sendTerminate(client);
    Network.Tcp.Close(client);
}

func testCreateAndSelect() {
    Terminal.Say("Testing CREATE TABLE + INSERT + SELECT...");

    var client = Network.Tcp.Connect("localhost", testPort);
    Network.Tcp.SetRecvTimeout(client, 5000);

    // Startup with auth
    performStartup(client, "admin", "main", "admin");

    // Create table
    sendQuery(client, "CREATE TABLE pg_test (id INTEGER, name TEXT)");
    var createResp = recvUntil(client, 67);  // CommandComplete
    assert(createResp.msgType == 67, "CREATE TABLE completed");
    recvUntil(client, 90);  // ReadyForQuery

    // Insert rows
    sendQuery(client, "INSERT INTO pg_test VALUES (1, 'Alice')");
    recvUntil(client, 90);

    sendQuery(client, "INSERT INTO pg_test VALUES (2, 'Bob')");
    recvUntil(client, 90);

    // Select
    sendQuery(client, "SELECT * FROM pg_test ORDER BY id");

    // RowDescription
    var rowDesc = recvResponse(client);
    assert(rowDesc.msgType == 84, "SELECT returns RowDescription");
    if rowDesc.bodyLen >= 2 {
        var numCols = readInt16BE(rowDesc.body, 0);
        assert(numCols == 2, "2 columns (id, name)");
    }

    // Count data rows
    var rowCount = countDataRows(client);
    assert(rowCount == 2, "SELECT returns 2 rows");

    // Cleanup
    sendQuery(client, "DROP TABLE pg_test");
    recvUntil(client, 90);

    sendTerminate(client);
    Network.Tcp.Close(client);
}

func testErrorHandling() {
    Terminal.Say("Testing PG error responses...");

    var client = Network.Tcp.Connect("localhost", testPort);
    Network.Tcp.SetRecvTimeout(client, 5000);

    // Startup with auth
    performStartup(client, "admin", "main", "admin");

    // Send an invalid query
    sendQuery(client, "SELECT * FROM nonexistent_table");

    // Should receive ErrorResponse
    var errResp = recvResponse(client);
    assert(errResp.msgType == 69, "Received ErrorResponse (E)");

    // Should still get ReadyForQuery
    var ready = recvUntil(client, 90);
    assert(ready.msgType == 90, "ReadyForQuery after error");

    // Connection should still work after error
    sendQuery(client, "SELECT 42 AS answer");
    var rowDesc = recvResponse(client);
    assert(rowDesc.msgType == 84, "Can still query after error");
    recvUntil(client, 90);

    sendTerminate(client);
    Network.Tcp.Close(client);
}

func testEmptyQuery() {
    Terminal.Say("Testing PG empty query...");

    var client = Network.Tcp.Connect("localhost", testPort);
    Network.Tcp.SetRecvTimeout(client, 5000);

    performStartup(client, "admin", "main", "admin");

    // Send empty query
    sendQuery(client, "");

    // Should receive EmptyQueryResponse (I)
    var resp = recvResponse(client);
    assert(resp.msgType == 73, "Received EmptyQueryResponse (I)");

    // Should get ReadyForQuery
    var ready = recvUntil(client, 90);
    assert(ready.msgType == 90, "ReadyForQuery after empty query");

    sendTerminate(client);
    Network.Tcp.Close(client);
}

func testTransactionStatus() {
    Terminal.Say("Testing PG transaction status indicators...");

    var client = Network.Tcp.Connect("localhost", testPort);
    Network.Tcp.SetRecvTimeout(client, 5000);

    performStartup(client, "admin", "main", "admin");

    // Create a table for transaction test
    sendQuery(client, "CREATE TABLE txn_test (id INTEGER)");
    recvUntil(client, 90);

    // BEGIN transaction
    sendQuery(client, "BEGIN");
    var beginReady = recvUntil(client, 90);
    assert(beginReady.body.Get(0) == 84, "Status after BEGIN is 'T' (in transaction)");

    // INSERT in transaction
    sendQuery(client, "INSERT INTO txn_test VALUES (1)");
    var insertReady = recvUntil(client, 90);
    assert(insertReady.body.Get(0) == 84, "Status during txn is 'T'");

    // COMMIT
    sendQuery(client, "COMMIT");
    var commitReady = recvUntil(client, 90);
    assert(commitReady.body.Get(0) == 73, "Status after COMMIT is 'I' (idle)");

    // Cleanup
    sendQuery(client, "DROP TABLE txn_test");
    recvUntil(client, 90);

    sendTerminate(client);
    Network.Tcp.Close(client);
}

func testSSLNegotiation() {
    Terminal.Say("Testing SSL negotiation...");

    var client = Network.Tcp.Connect("localhost", testPort);
    Network.Tcp.SetRecvTimeout(client, 5000);

    // Send SSL request first (what real psql does)
    var sslReq = Bytes.New(8);
    writeInt32BE(sslReq, 0, 8);           // length = 8
    writeInt32BE(sslReq, 4, 80877103);    // SSL request code
    Network.Tcp.SendAll(client, sslReq);

    // Should receive 'N' (no SSL)
    var sslResp: Bytes = Network.Tcp.RecvExact(client, 1);
    assert(sslResp.Get(0) == 78, "Server responds 'N' to SSL request");

    // Now send actual startup with auth
    sendStartupMessage(client, "admin", "main");
    // Expect AuthCleartextPassword
    var authReq = recvResponse(client);
    assert(authReq.msgType == 82, "Auth request after SSL negotiation");
    sendPassword(client, "admin");
    // Expect AuthOk then params/ReadyForQuery
    var authOk = recvResponse(client);
    assert(authOk.msgType == 82, "AuthOk after SSL negotiation");
    recvUntil(client, 90);  // ReadyForQuery

    // Verify we can query
    sendQuery(client, "SELECT 1 AS test");
    var rowDesc = recvResponse(client);
    assert(rowDesc.msgType == 84, "Can query after SSL negotiation");
    recvUntil(client, 90);

    sendTerminate(client);
    Network.Tcp.Close(client);
}

func testMultipleQueries() {
    Terminal.Say("Testing multiple queries in sequence...");

    var client = Network.Tcp.Connect("localhost", testPort);
    Network.Tcp.SetRecvTimeout(client, 5000);

    performStartup(client, "admin", "main", "admin");

    // Run several queries in sequence
    sendQuery(client, "CREATE TABLE multi_test (id INTEGER, val TEXT)");
    recvUntil(client, 90);

    var i = 1;
    while i <= 5 {
        sendQuery(client, "INSERT INTO multi_test VALUES (" + Fmt.Int(i) + ", 'row" + Fmt.Int(i) + "')");
        recvUntil(client, 90);
        i = i + 1;
    }

    sendQuery(client, "SELECT * FROM multi_test");
    recvResponse(client);  // RowDescription
    var rowCount = countDataRows(client);
    assert(rowCount == 5, "5 rows after 5 inserts");

    // Cleanup
    sendQuery(client, "DROP TABLE multi_test");
    recvUntil(client, 90);

    sendTerminate(client);
    Network.Tcp.Close(client);
}

func testNullValues() {
    Terminal.Say("Testing NULL value encoding...");

    var client = Network.Tcp.Connect("localhost", testPort);
    Network.Tcp.SetRecvTimeout(client, 5000);

    performStartup(client, "admin", "main", "admin");

    sendQuery(client, "CREATE TABLE null_test (id INTEGER, name TEXT)");
    recvUntil(client, 90);

    sendQuery(client, "INSERT INTO null_test VALUES (1, NULL)");
    recvUntil(client, 90);

    sendQuery(client, "SELECT * FROM null_test");
    var rowDesc = recvResponse(client);  // RowDescription
    var dataRow = recvResponse(client);  // DataRow

    // Check that the NULL is encoded as -1 length
    if dataRow.msgType == 68 && dataRow.bodyLen >= 2 {
        var numCols = readInt16BE(dataRow.body, 0);
        assert(numCols == 2, "2 columns in null row");
        // First column (id=1): int32(len) + bytes
        if dataRow.bodyLen >= 6 {
            var col1Len = readInt32BE(dataRow.body, 2);
            assert(col1Len > 0, "First column is non-null");
            // Second column (NULL): should have len=-1 (0xFFFFFFFF)
            var offset = 2 + 4 + col1Len;
            if dataRow.bodyLen >= offset + 4 {
                var col2LenBytes: Bytes = dataRow.body.Slice(offset, offset + 4);
                var allFF = col2LenBytes.Get(0) == 255 && col2LenBytes.Get(1) == 255 &&
                            col2LenBytes.Get(2) == 255 && col2LenBytes.Get(3) == 255;
                assert(allFF, "NULL encoded as -1 (0xFFFFFFFF)");
            }
        }
    }

    recvUntil(client, 90);

    // Cleanup
    sendQuery(client, "DROP TABLE null_test");
    recvUntil(client, 90);

    sendTerminate(client);
    Network.Tcp.Close(client);
}

func testAuthFailure() {
    Terminal.Say("Testing PG auth failure (wrong password)...");

    var client = Network.Tcp.Connect("localhost", testPort);
    Network.Tcp.SetRecvTimeout(client, 5000);

    sendStartupMessage(client, "admin", "main");

    // Receive AuthCleartextPassword
    var authReq = recvResponse(client);
    assert(authReq.msgType == 82, "Auth failure: received auth request (R)");

    // Send wrong password
    sendPassword(client, "wrongpassword");

    // Should receive ErrorResponse (E) — connection should close
    var resp = recvResponse(client);
    assert(resp.msgType == 69, "Auth failure: received ErrorResponse (E)");

    Network.Tcp.Close(client);
}

func testAuthWrongUser() {
    Terminal.Say("Testing PG auth failure (unknown user)...");

    var client = Network.Tcp.Connect("localhost", testPort);
    Network.Tcp.SetRecvTimeout(client, 5000);

    sendStartupMessage(client, "nobody", "main");

    // Receive AuthCleartextPassword
    var authReq = recvResponse(client);
    assert(authReq.msgType == 82, "Auth wrong user: received auth request (R)");

    // Send any password
    sendPassword(client, "whatever");

    // Should receive ErrorResponse (E) — user doesn't exist
    var resp = recvResponse(client);
    assert(resp.msgType == 69, "Auth wrong user: received ErrorResponse (E)");

    Network.Tcp.Close(client);
}

//=============================================================================
// ENTRY POINT
//=============================================================================

func start() {
    Terminal.Say("=== Phase 9: PostgreSQL Wire Protocol Tests ===");
    Terminal.Say("");

    // Start server on a test port
    testPort = 15432;
    serverReady = false;
    serverLock = [];

    var portArgs: List[Integer] = [];
    portArgs.add(testPort);
    Threads.Thread.StartSafe(&testServerWorker, portArgs);

    // Wait for server to be ready
    waitForServer();
    Threads.Thread.Sleep(100);  // Brief pause for listen socket

    // Run tests
    testStartupAndAuth();
    testAuthFailure();
    testAuthWrongUser();
    testSimpleQuery();
    testCreateAndSelect();
    testErrorHandling();
    testEmptyQuery();
    testTransactionStatus();
    testSSLNegotiation();
    testMultipleQueries();
    testNullValues();

    Terminal.Say("");
    Terminal.Say("=== Results ===");
    Terminal.Say("Passed: " + Fmt.Int(passed));
    Terminal.Say("Failed: " + Fmt.Int(failed));
    if failed == 0 {
        Terminal.Say("ALL TESTS PASSED");
    }
}
