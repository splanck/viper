// test_phase38_expressions.zia â€” Phase 38: SQL Expression Enhancements
// Tests for NULLIF, ILIKE, INITCAP, REPEAT, SPLIT_PART, CHR, ASCII, CONCAT_WS.

module test_phase38_expressions;

bind Terminal = Viper.Terminal;
bind String = Viper.String;
bind Fmt = Viper.Fmt;

bind "./test_common";
bind "../executor";
bind "../types";

//=========================================================================
// NULLIF
//=========================================================================

func testNullif() {
    section("NULLIF");

    var exec = new Executor();
    exec.init();

    // NULLIF returns NULL when args are equal
    var r1 = exec.executeSql("SELECT NULLIF(1, 1)");
    assertSuccess(r1, "NULLIF(1, 1) succeeds");
    assertEq(val(r1, 0, 0), "NULL", "NULLIF returns NULL when equal");

    // NULLIF returns first arg when args differ
    var r2 = exec.executeSql("SELECT NULLIF(1, 2)");
    assertSuccess(r2, "NULLIF(1, 2) succeeds");
    assertEq(val(r2, 0, 0), "1", "NULLIF returns first arg when different");

    // NULLIF with strings
    var r3 = exec.executeSql("SELECT NULLIF('hello', 'hello')");
    assertSuccess(r3, "NULLIF strings equal");
    assertEq(val(r3, 0, 0), "NULL", "NULLIF strings returns NULL");

    var r4 = exec.executeSql("SELECT NULLIF('hello', 'world')");
    assertSuccess(r4, "NULLIF strings differ");
    assertEq(val(r4, 0, 0), "hello", "NULLIF returns first string");

    // NULLIF in division to avoid divide-by-zero
    var r5 = exec.executeSql("SELECT COALESCE(10 / NULLIF(0, 0), -1)");
    assertSuccess(r5, "NULLIF division guard");
    assertEq(val(r5, 0, 0), "-1", "COALESCE catches NULL from NULLIF");
}

//=========================================================================
// ILIKE (case-insensitive LIKE)
//=========================================================================

func testIlike() {
    section("ILIKE");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE names_t (id INTEGER, name TEXT)");
    exec.executeSql("INSERT INTO names_t VALUES (1, 'Alice')");
    exec.executeSql("INSERT INTO names_t VALUES (2, 'BOB')");
    exec.executeSql("INSERT INTO names_t VALUES (3, 'charlie')");

    // ILIKE matches case-insensitively
    var r1 = exec.executeSql("SELECT name FROM names_t WHERE name ILIKE 'alice'");
    assertSuccess(r1, "ILIKE case-insensitive match");
    assertEqInt(r1.rows.count(), 1, "1 match for alice");
    assertEq(val(r1, 0, 0), "Alice", "found Alice");

    // ILIKE with wildcard
    var r2 = exec.executeSql("SELECT name FROM names_t WHERE name ILIKE '%LI%' ORDER BY name");
    assertSuccess(r2, "ILIKE with wildcard");
    assertEqInt(r2.rows.count(), 2, "2 matches for %LI%");

    // NOT ILIKE
    var r3 = exec.executeSql("SELECT name FROM names_t WHERE name NOT ILIKE 'bob' ORDER BY name");
    assertSuccess(r3, "NOT ILIKE");
    assertEqInt(r3.rows.count(), 2, "2 non-bob names");
}

//=========================================================================
// INITCAP
//=========================================================================

func testInitcap() {
    section("INITCAP");

    var exec = new Executor();
    exec.init();

    var r1 = exec.executeSql("SELECT INITCAP('hello world')");
    assertSuccess(r1, "INITCAP basic");
    assertEq(val(r1, 0, 0), "Hello World", "capitalize each word");

    var r2 = exec.executeSql("SELECT INITCAP('HELLO WORLD')");
    assertSuccess(r2, "INITCAP from upper");
    assertEq(val(r2, 0, 0), "Hello World", "lowercases after first");

    var r3 = exec.executeSql("SELECT INITCAP('hELLO wORLD')");
    assertSuccess(r3, "INITCAP mixed case");
    assertEq(val(r3, 0, 0), "Hello World", "normalizes mixed case");
}

//=========================================================================
// REPEAT
//=========================================================================

func testRepeat() {
    section("REPEAT");

    var exec = new Executor();
    exec.init();

    var r1 = exec.executeSql("SELECT REPEAT('ab', 3)");
    assertSuccess(r1, "REPEAT basic");
    assertEq(val(r1, 0, 0), "ababab", "repeated 3 times");

    var r2 = exec.executeSql("SELECT REPEAT('x', 5)");
    assertSuccess(r2, "REPEAT single char");
    assertEq(val(r2, 0, 0), "xxxxx", "5 x's");

    var r3 = exec.executeSql("SELECT REPEAT('hi', 0)");
    assertSuccess(r3, "REPEAT 0 times");
    assertEq(val(r3, 0, 0), "", "empty string");
}

//=========================================================================
// SPLIT_PART
//=========================================================================

func testSplitPart() {
    section("SPLIT_PART");

    var exec = new Executor();
    exec.init();

    var r1 = exec.executeSql("SELECT SPLIT_PART('one,two,three', ',', 2)");
    assertSuccess(r1, "SPLIT_PART basic");
    assertEq(val(r1, 0, 0), "two", "second part");

    var r2 = exec.executeSql("SELECT SPLIT_PART('hello world', ' ', 1)");
    assertSuccess(r2, "SPLIT_PART space");
    assertEq(val(r2, 0, 0), "hello", "first word");

    var r3 = exec.executeSql("SELECT SPLIT_PART('a::b::c', '::', 3)");
    assertSuccess(r3, "SPLIT_PART multi-char delimiter");
    assertEq(val(r3, 0, 0), "c", "third part");

    var r4 = exec.executeSql("SELECT SPLIT_PART('test', ',', 5)");
    assertSuccess(r4, "SPLIT_PART out of range");
    assertEq(val(r4, 0, 0), "", "empty for out of range");
}

//=========================================================================
// CHR and ASCII
//=========================================================================

func testChrAscii() {
    section("CHR and ASCII");

    var exec = new Executor();
    exec.init();

    var r1 = exec.executeSql("SELECT CHR(65)");
    assertSuccess(r1, "CHR(65) succeeds");
    assertEq(val(r1, 0, 0), "A", "CHR(65) = A");

    var r2 = exec.executeSql("SELECT CHR(97)");
    assertSuccess(r2, "CHR(97) succeeds");
    assertEq(val(r2, 0, 0), "a", "CHR(97) = a");

    var r3 = exec.executeSql("SELECT ASCII('A')");
    assertSuccess(r3, "ASCII A succeeds");
    assertEq(val(r3, 0, 0), "65", "ASCII(A) = 65");

    var r4 = exec.executeSql("SELECT ASCII('z')");
    assertSuccess(r4, "ASCII z succeeds");
    assertEq(val(r4, 0, 0), "122", "ASCII(z) = 122");
}

//=========================================================================
// CONCAT_WS
//=========================================================================

func testConcatWs() {
    section("CONCAT_WS");

    var exec = new Executor();
    exec.init();

    var r1 = exec.executeSql("SELECT CONCAT_WS(', ', 'Alice', 'Bob', 'Charlie')");
    assertSuccess(r1, "CONCAT_WS basic");
    assertEq(val(r1, 0, 0), "Alice, Bob, Charlie", "joined with separator");

    var r2 = exec.executeSql("SELECT CONCAT_WS('-', 'a', 'b', 'c')");
    assertSuccess(r2, "CONCAT_WS dash");
    assertEq(val(r2, 0, 0), "a-b-c", "joined with dash");

    // CONCAT_WS skips NULLs
    var r3 = exec.executeSql("SELECT CONCAT_WS(', ', 'a', NULL, 'c')");
    assertSuccess(r3, "CONCAT_WS with NULL");
    assertEq(val(r3, 0, 0), "a, c", "NULL skipped");
}

//=========================================================================
// MAIN
//=========================================================================

func main() {
    Terminal.Say("=== Phase 38: SQL Expression Enhancements ===");

    testNullif();
    testIlike();
    testInitcap();
    testRepeat();
    testSplitPart();
    testChrAscii();
    testConcatWs();

    printResults();
}
