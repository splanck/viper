// test_phase50_datetime.zia — Phase 50: Date/Time Functions
// Tests for DATE_PART, DATE_TRUNC, AGE, TO_CHAR, MAKE_DATE,
// MAKE_TIMESTAMP, MAKE_INTERVAL, ISFINITE, TO_TIMESTAMP, CLOCK_TIMESTAMP, TIMEOFDAY.

module test_phase50_datetime;

bind Terminal = Viper.Terminal;
bind String = Viper.String;
bind Fmt = Viper.Fmt;

bind "./test_common";
bind "../executor";
bind "../types";

//=========================================================================
// DATE_PART — function-syntax alternative to EXTRACT
//=========================================================================

func testDatePart() {
    section("DATE_PART");

    var exec = new Executor();
    exec.init();

    // Create a table with a known timestamp
    exec.executeSql("CREATE TABLE events (id INTEGER, ts TIMESTAMP)");
    exec.executeSql("INSERT INTO events VALUES (1, TIMESTAMP('2024-06-15T14:30:45'))");

    var r1 = exec.executeSql("SELECT DATE_PART('year', ts) FROM events");
    assertSuccess(r1, "DATE_PART year");
    assertEq(val(r1, 0, 0), "2024", "year = 2024");

    var r2 = exec.executeSql("SELECT DATE_PART('month', ts) FROM events");
    assertEq(val(r2, 0, 0), "6", "month = 6");

    var r3 = exec.executeSql("SELECT DATE_PART('day', ts) FROM events");
    assertEq(val(r3, 0, 0), "15", "day = 15");

    var r4 = exec.executeSql("SELECT DATE_PART('hour', ts) FROM events");
    assertEq(val(r4, 0, 0), "14", "hour = 14");

    var r5 = exec.executeSql("SELECT DATE_PART('minute', ts) FROM events");
    assertEq(val(r5, 0, 0), "30", "minute = 30");

    var r6 = exec.executeSql("SELECT DATE_PART('second', ts) FROM events");
    assertEq(val(r6, 0, 0), "45", "second = 45");

    var r7 = exec.executeSql("SELECT DATE_PART('quarter', ts) FROM events");
    assertEq(val(r7, 0, 0), "2", "quarter = 2 (June)");

    var r8 = exec.executeSql("SELECT DATE_PART('epoch', ts) FROM events");
    assertSuccess(r8, "epoch");
    // Just check it's a large positive number
    var epochVal = stringToInt(val(r8, 0, 0));
    assertTrue(epochVal > 1700000000, "epoch > 1.7 billion");
}

//=========================================================================
// DATE_TRUNC — truncate to precision
//=========================================================================

func testDateTrunc() {
    section("DATE_TRUNC");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE dt_test (id INTEGER, ts TIMESTAMP)");
    exec.executeSql("INSERT INTO dt_test VALUES (1, TIMESTAMP('2024-06-15T14:30:45'))");

    var r1 = exec.executeSql("SELECT DATE_TRUNC('year', ts) FROM dt_test");
    assertSuccess(r1, "DATE_TRUNC year");
    var v1 = val(r1, 0, 0);
    assertTrue(stringContains(v1, "2024-01-01"), "truncated to year start");

    var r2 = exec.executeSql("SELECT DATE_TRUNC('month', ts) FROM dt_test");
    var v2 = val(r2, 0, 0);
    assertTrue(stringContains(v2, "2024-06-01"), "truncated to month start");

    var r3 = exec.executeSql("SELECT DATE_TRUNC('day', ts) FROM dt_test");
    var v3 = val(r3, 0, 0);
    assertTrue(stringContains(v3, "2024-06-15"), "truncated to day start");

    var r4 = exec.executeSql("SELECT DATE_TRUNC('hour', ts) FROM dt_test");
    var v4 = val(r4, 0, 0);
    assertTrue(stringContains(v4, "14:00:00") || stringContains(v4, "2024-06-15"), "truncated to hour");

    // Truncate to quarter
    var r5 = exec.executeSql("SELECT DATE_TRUNC('quarter', ts) FROM dt_test");
    var v5 = val(r5, 0, 0);
    assertTrue(stringContains(v5, "2024-04-01"), "quarter start = April 1");
}

//=========================================================================
// AGE — interval between timestamps
//=========================================================================

func testAge() {
    section("AGE");

    var exec = new Executor();
    exec.init();

    // AGE(ts1, ts2) — difference
    var r1 = exec.executeSql("SELECT AGE(TIMESTAMP('2024-06-15T00:00:00'), TIMESTAMP('2020-01-01T00:00:00'))");
    assertSuccess(r1, "AGE two args");
    var v1 = val(r1, 0, 0);
    assertTrue(stringContains(v1, "4 years"), "4 years difference");
    assertTrue(stringContains(v1, "5 mons"), "5 months difference");

    // AGE with same date
    var r2 = exec.executeSql("SELECT AGE(TIMESTAMP('2024-01-01T00:00:00'), TIMESTAMP('2024-01-01T00:00:00'))");
    assertEq(val(r2, 0, 0), "0 days", "same date = 0 days");

    // AGE with just months difference
    var r3 = exec.executeSql("SELECT AGE(TIMESTAMP('2024-06-01T00:00:00'), TIMESTAMP('2024-01-01T00:00:00'))");
    assertSuccess(r3, "AGE months");
    var v3 = val(r3, 0, 0);
    assertTrue(stringContains(v3, "5 mons"), "5 months");
}

//=========================================================================
// TO_CHAR — format datetime as string
//=========================================================================

func testToChar() {
    section("TO_CHAR");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE tc_test (id INTEGER, ts TIMESTAMP)");
    exec.executeSql("INSERT INTO tc_test VALUES (1, TIMESTAMP('2024-06-15T14:30:45'))");

    var r1 = exec.executeSql("SELECT TO_CHAR(ts, 'YYYY-MM-DD') FROM tc_test");
    assertSuccess(r1, "TO_CHAR date");
    assertEq(val(r1, 0, 0), "2024-06-15", "formatted date");

    var r2 = exec.executeSql("SELECT TO_CHAR(ts, 'HH24:MI:SS') FROM tc_test");
    assertEq(val(r2, 0, 0), "14:30:45", "formatted time");

    var r3 = exec.executeSql("SELECT TO_CHAR(ts, 'YYYY') FROM tc_test");
    assertEq(val(r3, 0, 0), "2024", "year only");

    // NULL handling
    var r4 = exec.executeSql("SELECT TO_CHAR(NULL, 'YYYY')");
    assertEq(val(r4, 0, 0), "NULL", "null input");
}

//=========================================================================
// MAKE_DATE / MAKE_TIMESTAMP
//=========================================================================

func testMakeDateTime() {
    section("MAKE_DATE / MAKE_TIMESTAMP");

    var exec = new Executor();
    exec.init();

    // MAKE_DATE
    var r1 = exec.executeSql("SELECT MAKE_DATE(2024, 3, 15)");
    assertSuccess(r1, "MAKE_DATE");
    var v1 = val(r1, 0, 0);
    assertTrue(stringContains(v1, "2024-03-15"), "make_date result");

    // MAKE_TIMESTAMP
    var r2 = exec.executeSql("SELECT MAKE_TIMESTAMP(2024, 3, 15, 10, 30, 0)");
    assertSuccess(r2, "MAKE_TIMESTAMP");
    var v2 = val(r2, 0, 0);
    assertTrue(stringContains(v2, "2024-03-15"), "make_timestamp date part");

    // MAKE_DATE with EXTRACT
    var r3 = exec.executeSql("SELECT EXTRACT(YEAR FROM MAKE_DATE(2024, 7, 4))");
    assertEq(val(r3, 0, 0), "2024", "extract year from make_date");

    var r4 = exec.executeSql("SELECT EXTRACT(MONTH FROM MAKE_DATE(2024, 7, 4))");
    assertEq(val(r4, 0, 0), "7", "extract month from make_date");

    // NULL handling
    var r5 = exec.executeSql("SELECT MAKE_DATE(NULL, 1, 1)");
    assertEq(val(r5, 0, 0), "NULL", "null year");
}

//=========================================================================
// MAKE_INTERVAL
//=========================================================================

func testMakeInterval() {
    section("MAKE_INTERVAL");

    var exec = new Executor();
    exec.init();

    // MAKE_INTERVAL(days)
    var r1 = exec.executeSql("SELECT MAKE_INTERVAL(1)");
    assertSuccess(r1, "MAKE_INTERVAL days");
    var v1 = val(r1, 0, 0);
    assertTrue(stringContains(v1, "1 days"), "1 day interval");

    // MAKE_INTERVAL(days, hours, mins, secs)
    var r2 = exec.executeSql("SELECT MAKE_INTERVAL(0, 2, 30, 0)");
    var v2 = val(r2, 0, 0);
    assertTrue(stringContains(v2, "02:30:00"), "2h30m interval");

    // MAKE_INTERVAL(0) = 00:00:00
    var r3 = exec.executeSql("SELECT MAKE_INTERVAL(0)");
    assertEq(val(r3, 0, 0), "00:00:00", "zero interval");
}

//=========================================================================
// ISFINITE
//=========================================================================

func testIsFinite() {
    section("ISFINITE");

    var exec = new Executor();
    exec.init();

    var r1 = exec.executeSql("SELECT ISFINITE(TIMESTAMP('2024-01-01T00:00:00'))");
    assertSuccess(r1, "ISFINITE");
    assertEq(val(r1, 0, 0), "true", "timestamp is finite");

    var r2 = exec.executeSql("SELECT ISFINITE(CURRENT_DATE)");
    assertEq(val(r2, 0, 0), "true", "current date is finite");

    var r3 = exec.executeSql("SELECT ISFINITE(NULL)");
    assertEq(val(r3, 0, 0), "NULL", "null returns null");
}

//=========================================================================
// TO_TIMESTAMP
//=========================================================================

func testToTimestamp() {
    section("TO_TIMESTAMP");

    var exec = new Executor();
    exec.init();

    // TO_TIMESTAMP(epoch) creates a timestamp from epoch seconds
    var r1 = exec.executeSql("SELECT EXTRACT(EPOCH FROM TO_TIMESTAMP(0))");
    assertSuccess(r1, "TO_TIMESTAMP");
    assertEq(val(r1, 0, 0), "0", "epoch 0 round-trips");

    // Round-trip: EXTRACT(EPOCH FROM ts) -> TO_TIMESTAMP
    var r2 = exec.executeSql("SELECT EXTRACT(EPOCH FROM TO_TIMESTAMP(1718444400))");
    assertEq(val(r2, 0, 0), "1718444400", "round-trip epoch");
}

//=========================================================================
// TO_DATE
//=========================================================================

func testToDate() {
    section("TO_DATE");

    var exec = new Executor();
    exec.init();

    var r1 = exec.executeSql("SELECT TO_DATE('2024-06-15')");
    assertSuccess(r1, "TO_DATE");
    var v1 = val(r1, 0, 0);
    assertTrue(stringContains(v1, "2024-06-15"), "parsed date");

    var r2 = exec.executeSql("SELECT TO_DATE(NULL)");
    assertEq(val(r2, 0, 0), "NULL", "null to_date");
}

//=========================================================================
// CLOCK_TIMESTAMP / TIMEOFDAY
//=========================================================================

func testClockTimestamp() {
    section("CLOCK_TIMESTAMP / TIMEOFDAY");

    var exec = new Executor();
    exec.init();

    var r1 = exec.executeSql("SELECT CLOCK_TIMESTAMP()");
    assertSuccess(r1, "CLOCK_TIMESTAMP");
    var v1 = val(r1, 0, 0);
    assertTrue(stringContains(v1, "202"), "clock_timestamp has year 202x");

    var r2 = exec.executeSql("SELECT TIMEOFDAY()");
    assertSuccess(r2, "TIMEOFDAY");
    var v2 = val(r2, 0, 0);
    assertTrue(stringContains(v2, "202"), "timeofday has year 202x");
}

//=========================================================================
// Existing date functions still work
//=========================================================================

func testExistingDateFunctions() {
    section("Existing date funcs");

    var exec = new Executor();
    exec.init();

    var r1 = exec.executeSql("SELECT NOW()");
    assertSuccess(r1, "NOW");

    var r2 = exec.executeSql("SELECT CURRENT_DATE");
    assertSuccess(r2, "CURRENT_DATE");

    var r3 = exec.executeSql("SELECT DATE_ADD(TIMESTAMP('2024-01-01T00:00:00'), 10)");
    assertSuccess(r3, "DATE_ADD");

    var r4 = exec.executeSql("SELECT DATEDIFF(TIMESTAMP('2024-01-11T00:00:00'), TIMESTAMP('2024-01-01T00:00:00'))");
    assertEq(val(r4, 0, 0), "10", "datediff = 10");

    var r5 = exec.executeSql("SELECT STRFTIME('%Y-%m-%d', TIMESTAMP('2024-06-15T14:30:45'))");
    assertEq(val(r5, 0, 0), "2024-06-15", "strftime");
}

//=========================================================================
// NULL handling
//=========================================================================

func testNullHandling() {
    section("Date/Time NULL handling");

    var exec = new Executor();
    exec.init();

    var r1 = exec.executeSql("SELECT DATE_PART('year', NULL)");
    assertEq(val(r1, 0, 0), "NULL", "date_part null");

    var r2 = exec.executeSql("SELECT DATE_TRUNC('year', NULL)");
    assertEq(val(r2, 0, 0), "NULL", "date_trunc null");

    var r3 = exec.executeSql("SELECT AGE(NULL)");
    assertEq(val(r3, 0, 0), "NULL", "age null");

    var r4 = exec.executeSql("SELECT TO_CHAR(NULL, 'YYYY')");
    assertEq(val(r4, 0, 0), "NULL", "to_char null");

    var r5 = exec.executeSql("SELECT MAKE_TIMESTAMP(NULL, 1, 1, 0, 0, 0)");
    assertEq(val(r5, 0, 0), "NULL", "make_timestamp null");
}

//=========================================================================
// MAIN
//=========================================================================

func main() {
    Terminal.Say("=== Phase 50: Date/Time Functions ===");

    testDatePart();
    testDateTrunc();
    testAge();
    testToChar();
    testMakeDateTime();
    testMakeInterval();
    testIsFinite();
    testToTimestamp();
    testToDate();
    testClockTimestamp();
    testExistingDateFunctions();
    testNullHandling();

    printResults();
}
