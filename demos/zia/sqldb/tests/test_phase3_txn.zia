// test_phase3_txn.zia — Phase 3 Transaction & Data Integrity Tests
// Tests for BEGIN/COMMIT/ROLLBACK, statement-level atomicity,
// ON DELETE/UPDATE CASCADE, and WAL integration

module test_phase3_txn;

bind Terminal = Viper.Terminal;
bind String = Viper.String;
bind Fmt = Viper.Fmt;

bind "../executor";
bind "../types";

var passCount = 0;
var failCount = 0;

func assert(condition: Boolean, msg: String) {
    if condition {
        passCount = passCount + 1;
    } else {
        Terminal.Say("FAIL: " + msg);
        failCount = failCount + 1;
    }
}

func check(result: QueryResult, label: String) {
    if result.success == false {
        Terminal.Say("FAIL: " + label + " => " + result.message);
        failCount = failCount + 1;
    } else {
        passCount = passCount + 1;
    }
}

func val(result: QueryResult, row: Integer, col: Integer) -> String {
    var r = result.getRow(row);
    if r == null { return "NULL_ROW"; }
    var rr = r;
    return rr.getValue(col).toString();
}

func main() {
    Terminal.Say("=== Phase 3: Transaction & Data Integrity Tests ===");

    var exec = new Executor();
    exec.init();

    //=========================================================================
    // BEGIN / COMMIT
    //=========================================================================
    Terminal.Say("");
    Terminal.Say("--- BEGIN / COMMIT ---");

    check(exec.executeSql("CREATE TABLE txn_test (id INTEGER PRIMARY KEY, name TEXT, val INTEGER)"), "create txn_test");
    check(exec.executeSql("INSERT INTO txn_test VALUES (1, 'Alice', 100)"), "insert 1");

    // Test 1: Basic BEGIN/COMMIT
    var r = exec.executeSql("BEGIN");
    check(r, "BEGIN");
    assert(r.message == "BEGIN", "BEGIN returns BEGIN: " + r.message);

    check(exec.executeSql("INSERT INTO txn_test VALUES (2, 'Bob', 200)"), "insert in txn");
    check(exec.executeSql("INSERT INTO txn_test VALUES (3, 'Charlie', 300)"), "insert in txn 2");

    r = exec.executeSql("COMMIT");
    check(r, "COMMIT");
    assert(r.message == "COMMIT", "COMMIT returns COMMIT");

    r = exec.executeSql("SELECT COUNT(*) FROM txn_test");
    assert(val(r, 0, 0) == "3", "after COMMIT: 3 rows");

    // Test 2: Nested BEGIN should fail
    check(exec.executeSql("BEGIN"), "begin 1");
    r = exec.executeSql("BEGIN");
    assert(r.success == false, "nested BEGIN fails");
    check(exec.executeSql("COMMIT"), "commit 1");

    // Test 3: COMMIT without BEGIN should fail
    r = exec.executeSql("COMMIT");
    assert(r.success == false, "COMMIT without BEGIN fails");

    // Test 4: ROLLBACK without BEGIN should fail
    r = exec.executeSql("ROLLBACK");
    assert(r.success == false, "ROLLBACK without BEGIN fails");

    //=========================================================================
    // ROLLBACK
    //=========================================================================
    Terminal.Say("");
    Terminal.Say("--- ROLLBACK ---");

    // Test 5: ROLLBACK undoes INSERT
    check(exec.executeSql("BEGIN"), "begin for rollback");
    check(exec.executeSql("INSERT INTO txn_test VALUES (4, 'Dave', 400)"), "insert in txn");
    check(exec.executeSql("INSERT INTO txn_test VALUES (5, 'Eve', 500)"), "insert in txn 2");

    r = exec.executeSql("SELECT COUNT(*) FROM txn_test");
    assert(val(r, 0, 0) == "5", "during txn: 5 rows visible");

    r = exec.executeSql("ROLLBACK");
    check(r, "ROLLBACK");
    assert(r.message == "ROLLBACK", "ROLLBACK returns ROLLBACK");

    r = exec.executeSql("SELECT COUNT(*) FROM txn_test");
    assert(val(r, 0, 0) == "3", "after ROLLBACK: back to 3 rows");

    // Test 6: ROLLBACK undoes UPDATE
    check(exec.executeSql("BEGIN"), "begin for update rollback");
    check(exec.executeSql("UPDATE txn_test SET val = 999 WHERE id = 1"), "update in txn");

    r = exec.executeSql("SELECT val FROM txn_test WHERE id = 1");
    assert(val(r, 0, 0) == "999", "during txn: val = 999");

    check(exec.executeSql("ROLLBACK"), "rollback update");

    r = exec.executeSql("SELECT val FROM txn_test WHERE id = 1");
    assert(val(r, 0, 0) == "100", "after ROLLBACK: val restored to 100");

    // Test 7: ROLLBACK undoes DELETE
    check(exec.executeSql("BEGIN"), "begin for delete rollback");
    check(exec.executeSql("DELETE FROM txn_test WHERE id = 2"), "delete in txn");

    r = exec.executeSql("SELECT COUNT(*) FROM txn_test");
    assert(val(r, 0, 0) == "2", "during txn: 2 rows (one deleted)");

    check(exec.executeSql("ROLLBACK"), "rollback delete");

    r = exec.executeSql("SELECT COUNT(*) FROM txn_test");
    assert(val(r, 0, 0) == "3", "after ROLLBACK: back to 3 rows");

    r = exec.executeSql("SELECT name FROM txn_test WHERE id = 2");
    assert(val(r, 0, 0) == "Bob", "after ROLLBACK: Bob still exists");

    // Test 8: ROLLBACK undoes mixed operations
    check(exec.executeSql("BEGIN"), "begin mixed");
    check(exec.executeSql("INSERT INTO txn_test VALUES (10, 'Mixed', 1000)"), "mixed insert");
    check(exec.executeSql("UPDATE txn_test SET val = 111 WHERE id = 1"), "mixed update");
    check(exec.executeSql("DELETE FROM txn_test WHERE id = 3"), "mixed delete");

    r = exec.executeSql("SELECT COUNT(*) FROM txn_test");
    assert(val(r, 0, 0) == "3", "during mixed txn: 3 rows");

    check(exec.executeSql("ROLLBACK"), "rollback mixed");

    r = exec.executeSql("SELECT COUNT(*) FROM txn_test");
    assert(val(r, 0, 0) == "3", "after mixed ROLLBACK: still 3 rows");

    r = exec.executeSql("SELECT val FROM txn_test WHERE id = 1");
    assert(val(r, 0, 0) == "100", "after mixed ROLLBACK: val 1 restored");

    r = exec.executeSql("SELECT name FROM txn_test WHERE id = 3");
    assert(val(r, 0, 0) == "Charlie", "after mixed ROLLBACK: Charlie restored");

    //=========================================================================
    // Statement-level atomicity
    //=========================================================================
    Terminal.Say("");
    Terminal.Say("--- Statement-level Atomicity ---");

    check(exec.executeSql("CREATE TABLE atomic_test (id INTEGER PRIMARY KEY, val INTEGER NOT NULL)"), "create atomic_test");
    check(exec.executeSql("INSERT INTO atomic_test VALUES (1, 10)"), "atomic init 1");
    check(exec.executeSql("INSERT INTO atomic_test VALUES (2, 20)"), "atomic init 2");

    // Test 9: Multi-row INSERT with constraint failure — all rows should be undone
    // Insert two rows where the second violates NOT NULL
    r = exec.executeSql("INSERT INTO atomic_test VALUES (3, 30), (4, NULL)");
    assert(r.success == false, "multi-row INSERT with NULL fails");

    r = exec.executeSql("SELECT COUNT(*) FROM atomic_test");
    assert(val(r, 0, 0) == "2", "after failed multi-INSERT: still 2 rows (atomicity): " + val(r, 0, 0));

    // Test 10: Multi-row INSERT with PK violation — all rows should be undone
    r = exec.executeSql("INSERT INTO atomic_test VALUES (3, 30), (1, 40)");
    assert(r.success == false, "multi-row INSERT with PK dup fails");

    r = exec.executeSql("SELECT COUNT(*) FROM atomic_test");
    assert(val(r, 0, 0) == "2", "after failed PK dup: still 2 rows (atomicity): " + val(r, 0, 0));

    // Test 11: UPDATE with constraint violation should undo all changes
    check(exec.executeSql("INSERT INTO atomic_test VALUES (3, 30)"), "add row 3");

    // This creates a scenario where updating id=2 to id=1 violates PK
    r = exec.executeSql("UPDATE atomic_test SET id = 1 WHERE id = 2");
    assert(r.success == false, "UPDATE PK dup fails");

    r = exec.executeSql("SELECT val FROM atomic_test WHERE id = 2");
    assert(val(r, 0, 0) == "20", "after failed UPDATE: row 2 unchanged");

    //=========================================================================
    // ON DELETE CASCADE
    //=========================================================================
    Terminal.Say("");
    Terminal.Say("--- ON DELETE CASCADE ---");

    check(exec.executeSql("CREATE TABLE departments (id INTEGER PRIMARY KEY, name TEXT)"), "create departments");
    check(exec.executeSql("INSERT INTO departments VALUES (1, 'Engineering')"), "dept 1");
    check(exec.executeSql("INSERT INTO departments VALUES (2, 'Sales')"), "dept 2");
    check(exec.executeSql("INSERT INTO departments VALUES (3, 'Marketing')"), "dept 3");

    // Test 12: ON DELETE CASCADE
    check(exec.executeSql("CREATE TABLE employees (id INTEGER PRIMARY KEY, name TEXT, dept_id INTEGER REFERENCES departments(id) ON DELETE CASCADE)"), "create employees with cascade");
    check(exec.executeSql("INSERT INTO employees VALUES (1, 'Alice', 1)"), "emp 1");
    check(exec.executeSql("INSERT INTO employees VALUES (2, 'Bob', 1)"), "emp 2");
    check(exec.executeSql("INSERT INTO employees VALUES (3, 'Charlie', 2)"), "emp 3");
    check(exec.executeSql("INSERT INTO employees VALUES (4, 'Dave', 3)"), "emp 4");

    // Delete department 1 — should cascade and delete Alice and Bob
    r = exec.executeSql("DELETE FROM departments WHERE id = 1");
    check(r, "delete dept with cascade");

    r = exec.executeSql("SELECT COUNT(*) FROM employees");
    assert(val(r, 0, 0) == "2", "after CASCADE delete: 2 employees remain: " + val(r, 0, 0));

    r = exec.executeSql("SELECT name FROM employees ORDER BY name");
    assert(val(r, 0, 0) == "Charlie", "remaining emp 0 = Charlie");
    assert(val(r, 1, 0) == "Dave", "remaining emp 1 = Dave");

    // Test 13: ON DELETE SET NULL
    check(exec.executeSql("CREATE TABLE projects (id INTEGER PRIMARY KEY, name TEXT, lead_id INTEGER REFERENCES employees(id) ON DELETE SET NULL)"), "create projects");
    check(exec.executeSql("INSERT INTO projects VALUES (1, 'ProjectA', 3)"), "proj 1");
    check(exec.executeSql("INSERT INTO projects VALUES (2, 'ProjectB', 4)"), "proj 2");

    // Delete employee 3 (Charlie) — should set lead_id to NULL in ProjectA
    r = exec.executeSql("DELETE FROM employees WHERE id = 3");
    check(r, "delete emp with set null");

    r = exec.executeSql("SELECT lead_id FROM projects WHERE id = 1");
    assert(val(r, 0, 0) == "NULL", "after SET NULL: lead_id is NULL");

    r = exec.executeSql("SELECT lead_id FROM projects WHERE id = 2");
    assert(val(r, 0, 0) == "4", "unaffected project lead unchanged");

    // Test 14: ON DELETE RESTRICT
    check(exec.executeSql("CREATE TABLE categories (id INTEGER PRIMARY KEY, name TEXT)"), "create categories");
    check(exec.executeSql("INSERT INTO categories VALUES (1, 'CatA')"), "cat 1");
    check(exec.executeSql("INSERT INTO categories VALUES (2, 'CatB')"), "cat 2");

    check(exec.executeSql("CREATE TABLE items (id INTEGER PRIMARY KEY, name TEXT, cat_id INTEGER REFERENCES categories(id) ON DELETE RESTRICT)"), "create items with restrict");
    check(exec.executeSql("INSERT INTO items VALUES (1, 'Item1', 1)"), "item 1");
    check(exec.executeSql("INSERT INTO items VALUES (2, 'Item2', 2)"), "item 2");

    // Try to delete category 1 — should be prevented by RESTRICT
    r = exec.executeSql("DELETE FROM categories WHERE id = 1");
    assert(r.success == false, "RESTRICT prevents delete");

    r = exec.executeSql("SELECT COUNT(*) FROM categories");
    assert(val(r, 0, 0) == "2", "after RESTRICT: categories unchanged");

    // Delete category after removing referencing items
    check(exec.executeSql("DELETE FROM items WHERE cat_id = 1"), "remove items first");
    r = exec.executeSql("DELETE FROM categories WHERE id = 1");
    check(r, "delete unreferenced category");

    //=========================================================================
    // ON UPDATE CASCADE
    //=========================================================================
    Terminal.Say("");
    Terminal.Say("--- ON UPDATE CASCADE ---");

    check(exec.executeSql("CREATE TABLE regions (id INTEGER PRIMARY KEY, name TEXT)"), "create regions");
    check(exec.executeSql("INSERT INTO regions VALUES (1, 'North')"), "region 1");
    check(exec.executeSql("INSERT INTO regions VALUES (2, 'South')"), "region 2");

    check(exec.executeSql("CREATE TABLE offices (id INTEGER PRIMARY KEY, city TEXT, region_id INTEGER REFERENCES regions(id) ON UPDATE CASCADE)"), "create offices");
    check(exec.executeSql("INSERT INTO offices VALUES (1, 'NYC', 1)"), "office 1");
    check(exec.executeSql("INSERT INTO offices VALUES (2, 'Boston', 1)"), "office 2");
    check(exec.executeSql("INSERT INTO offices VALUES (3, 'Atlanta', 2)"), "office 3");

    // Test 15: Update region PK — should cascade to offices
    r = exec.executeSql("UPDATE regions SET id = 10 WHERE id = 1");
    check(r, "update region PK with cascade");

    r = exec.executeSql("SELECT region_id FROM offices WHERE id = 1");
    assert(val(r, 0, 0) == "10", "after cascade: NYC region = 10");

    r = exec.executeSql("SELECT region_id FROM offices WHERE id = 2");
    assert(val(r, 0, 0) == "10", "after cascade: Boston region = 10");

    r = exec.executeSql("SELECT region_id FROM offices WHERE id = 3");
    assert(val(r, 0, 0) == "2", "unaffected: Atlanta region = 2");

    // Test 16: ON UPDATE RESTRICT
    check(exec.executeSql("CREATE TABLE brands (id INTEGER PRIMARY KEY, name TEXT)"), "create brands");
    check(exec.executeSql("INSERT INTO brands VALUES (1, 'BrandA')"), "brand 1");

    check(exec.executeSql("CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, brand_id INTEGER REFERENCES brands(id) ON UPDATE RESTRICT)"), "create products");
    check(exec.executeSql("INSERT INTO products VALUES (1, 'Prod1', 1)"), "product 1");

    r = exec.executeSql("UPDATE brands SET id = 99 WHERE id = 1");
    assert(r.success == false, "RESTRICT prevents PK update");

    r = exec.executeSql("SELECT id FROM brands");
    assert(val(r, 0, 0) == "1", "after RESTRICT: brand id unchanged");

    //=========================================================================
    // Transaction + CASCADE interaction
    //=========================================================================
    Terminal.Say("");
    Terminal.Say("--- Transaction + CASCADE ---");

    check(exec.executeSql("CREATE TABLE parent_tbl (id INTEGER PRIMARY KEY, val TEXT)"), "create parent");
    check(exec.executeSql("INSERT INTO parent_tbl VALUES (1, 'A')"), "parent 1");
    check(exec.executeSql("INSERT INTO parent_tbl VALUES (2, 'B')"), "parent 2");

    check(exec.executeSql("CREATE TABLE child_tbl (id INTEGER PRIMARY KEY, pid INTEGER REFERENCES parent_tbl(id) ON DELETE CASCADE, data TEXT)"), "create child");
    check(exec.executeSql("INSERT INTO child_tbl VALUES (1, 1, 'X')"), "child 1");
    check(exec.executeSql("INSERT INTO child_tbl VALUES (2, 1, 'Y')"), "child 2");
    check(exec.executeSql("INSERT INTO child_tbl VALUES (3, 2, 'Z')"), "child 3");

    // Test 17: CASCADE within a transaction, then ROLLBACK
    check(exec.executeSql("BEGIN"), "begin cascade txn");
    r = exec.executeSql("DELETE FROM parent_tbl WHERE id = 1");
    check(r, "cascade delete in txn");

    r = exec.executeSql("SELECT COUNT(*) FROM child_tbl");
    assert(val(r, 0, 0) == "1", "during txn: 1 child remains");

    check(exec.executeSql("ROLLBACK"), "rollback cascade");

    r = exec.executeSql("SELECT COUNT(*) FROM child_tbl");
    assert(val(r, 0, 0) == "3", "after ROLLBACK: all 3 children restored: " + val(r, 0, 0));

    r = exec.executeSql("SELECT COUNT(*) FROM parent_tbl");
    assert(val(r, 0, 0) == "2", "after ROLLBACK: both parents restored");

    //=========================================================================
    // Summary
    //=========================================================================
    Terminal.Say("");
    Terminal.Say("=== Results ===");
    Terminal.Say("Passed: " + Fmt.Int(passCount));
    Terminal.Say("Failed: " + Fmt.Int(failCount));

    Terminal.Say("=== Phase 3: " + Fmt.Int(passCount) + " passed, " + Fmt.Int(failCount) + " failed ===");
}
