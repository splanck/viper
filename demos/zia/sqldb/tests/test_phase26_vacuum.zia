// test_phase26_vacuum.zia — Phase 26: VACUUM, ANALYZE, Dead Row Cleanup
// Tests for VACUUM (with MVCC dead row detection), ANALYZE, VACUUM FULL,
// VACUUM ANALYZE, per-table VACUUM/ANALYZE, and sys.vacuum_stats view.

module test_phase26_vacuum;

bind Terminal = Viper.Terminal;
bind String = Viper.String;
bind Fmt = Viper.Fmt;

bind "./test_common";
bind "../executor";
bind "../types";

func testBasicVacuum() {
    section("Basic VACUUM");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE t1 (id INTEGER, name TEXT)");
    exec.executeSql("INSERT INTO t1 VALUES (1, 'Alice')");
    exec.executeSql("INSERT INTO t1 VALUES (2, 'Bob')");
    exec.executeSql("INSERT INTO t1 VALUES (3, 'Charlie')");
    exec.executeSql("DELETE FROM t1 WHERE id = 2");

    var r1 = exec.executeSql("VACUUM");
    assertSuccess(r1, "VACUUM succeeds");
    assertTrue(stringContains(r1.message, "dead rows removed"), "VACUUM reports removed count");

    var r2 = exec.executeSql("SELECT COUNT(*) FROM t1");
    assertEq(val(r2, 0, 0), "2", "After VACUUM, 2 rows remain");
}

func testMvccVacuum() {
    section("VACUUM with MVCC Dead Rows");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE t2 (id INTEGER, val TEXT)");
    exec.executeSql("INSERT INTO t2 VALUES (1, 'a')");
    exec.executeSql("INSERT INTO t2 VALUES (2, 'b')");
    exec.executeSql("INSERT INTO t2 VALUES (3, 'c')");

    // Use transaction to create MVCC-stamped rows
    exec.executeSql("BEGIN");
    exec.executeSql("DELETE FROM t2 WHERE id = 1");
    exec.executeSql("COMMIT");

    // After commit, the deleted row has xmax set — VACUUM should clean it up
    var r3 = exec.executeSql("VACUUM t2");
    assertSuccess(r3, "VACUUM t2 succeeds");
    assertTrue(stringContains(r3.message, "dead rows removed"), "VACUUM t2 reports removed rows");

    var r4 = exec.executeSql("SELECT COUNT(*) FROM t2");
    assertEq(val(r4, 0, 0), "2", "After MVCC VACUUM, 2 rows remain");
}

func testVacuumPreservesLive() {
    section("VACUUM Preserves Live Rows");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE t3 (id INTEGER, name TEXT)");
    exec.executeSql("INSERT INTO t3 VALUES (1, 'Alice')");
    exec.executeSql("INSERT INTO t3 VALUES (2, 'Bob')");
    exec.executeSql("INSERT INTO t3 VALUES (3, 'Charlie')");

    var r5 = exec.executeSql("VACUUM t3");
    assertSuccess(r5, "VACUUM on clean table succeeds");
    assertTrue(stringContains(r5.message, "0 dead rows removed"), "VACUUM reports 0 removed");

    var r6 = exec.executeSql("SELECT COUNT(*) FROM t3");
    assertEq(val(r6, 0, 0), "3", "All 3 rows preserved after VACUUM");
}

func testVacuumSpecificTable() {
    section("VACUUM Specific Table");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE t4a (id INTEGER, x TEXT)");
    exec.executeSql("CREATE TABLE t4b (id INTEGER, y TEXT)");
    exec.executeSql("INSERT INTO t4a VALUES (1, 'x1')");
    exec.executeSql("INSERT INTO t4a VALUES (2, 'x2')");
    exec.executeSql("INSERT INTO t4b VALUES (1, 'y1')");
    exec.executeSql("DELETE FROM t4a WHERE id = 1");

    var r7 = exec.executeSql("VACUUM t4a");
    assertSuccess(r7, "VACUUM t4a succeeds");

    var r8 = exec.executeSql("SELECT COUNT(*) FROM t4b");
    assertEq(val(r8, 0, 0), "1", "t4b untouched by VACUUM t4a");

    var r9 = exec.executeSql("VACUUM nonexistent");
    assertTrue(r9.success == false, "VACUUM nonexistent table returns error");
}

func testAnalyze() {
    section("ANALYZE Command");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE t5 (id INTEGER, name TEXT, score INTEGER)");
    exec.executeSql("INSERT INTO t5 VALUES (1, 'Alice', 90)");
    exec.executeSql("INSERT INTO t5 VALUES (2, 'Bob', 85)");
    exec.executeSql("INSERT INTO t5 VALUES (3, 'Charlie', 95)");
    exec.executeSql("INSERT INTO t5 VALUES (4, 'Diana', 88)");
    exec.executeSql("INSERT INTO t5 VALUES (5, 'Eve', 92)");

    var r10 = exec.executeSql("ANALYZE");
    assertSuccess(r10, "ANALYZE succeeds");
    assertTrue(stringContains(r10.message, "tables analyzed"), "ANALYZE reports tables analyzed");

    var r11 = exec.executeSql("ANALYZE t5");
    assertSuccess(r11, "ANALYZE t5 succeeds");
    assertTrue(stringContains(r11.message, "5 rows"), "ANALYZE t5 reports row count");

    var r12 = exec.executeSql("ANALYZE nonexistent");
    assertTrue(r12.success == false, "ANALYZE nonexistent table returns error");
}

func testVacuumAnalyze() {
    section("VACUUM ANALYZE Combined");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE t6 (id INTEGER, val TEXT)");
    exec.executeSql("INSERT INTO t6 VALUES (1, 'a')");
    exec.executeSql("INSERT INTO t6 VALUES (2, 'b')");
    exec.executeSql("INSERT INTO t6 VALUES (3, 'c')");
    exec.executeSql("DELETE FROM t6 WHERE id = 2");

    var r13 = exec.executeSql("VACUUM ANALYZE");
    assertSuccess(r13, "VACUUM ANALYZE succeeds");
    assertTrue(stringContains(r13.message, "VACUUM"), "VACUUM ANALYZE includes VACUUM");
    assertTrue(stringContains(r13.message, "ANALYZE"), "VACUUM ANALYZE includes ANALYZE");
}

func testVacuumFull() {
    section("VACUUM FULL");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE t7 (id INTEGER, val TEXT)");
    exec.executeSql("INSERT INTO t7 VALUES (1, 'a')");
    exec.executeSql("INSERT INTO t7 VALUES (2, 'b')");
    exec.executeSql("DELETE FROM t7 WHERE id = 1");

    var r14 = exec.executeSql("VACUUM FULL");
    assertSuccess(r14, "VACUUM FULL succeeds");
    assertTrue(stringContains(r14.message, "FULL"), "VACUUM FULL reports FULL mode");
    assertTrue(stringContains(r14.message, "indexes rebuilt"), "VACUUM FULL reports index rebuild");

    var r15 = exec.executeSql("VACUUM FULL ANALYZE");
    assertSuccess(r15, "VACUUM FULL ANALYZE succeeds");
    assertTrue(stringContains(r15.message, "VACUUM"), "VACUUM FULL ANALYZE includes VACUUM");
    assertTrue(stringContains(r15.message, "ANALYZE"), "VACUUM FULL ANALYZE includes ANALYZE");
}

func testVacuumAnalyzeTable() {
    section("VACUUM ANALYZE Specific Table");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE t9 (id INTEGER, val TEXT)");
    exec.executeSql("INSERT INTO t9 VALUES (1, 'x')");
    exec.executeSql("INSERT INTO t9 VALUES (2, 'y')");
    exec.executeSql("DELETE FROM t9 WHERE id = 1");

    var r16 = exec.executeSql("VACUUM ANALYZE t9");
    assertSuccess(r16, "VACUUM ANALYZE t9 succeeds");
    assertTrue(stringContains(r16.message, "VACUUM"), "VACUUM ANALYZE t9 includes VACUUM");
    assertTrue(stringContains(r16.message, "ANALYZE"), "VACUUM ANALYZE t9 includes ANALYZE");
}

func testVacuumStats() {
    section("sys.vacuum_stats View");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE stats_test (id INTEGER, val TEXT)");
    exec.executeSql("INSERT INTO stats_test VALUES (1, 'a')");
    exec.executeSql("INSERT INTO stats_test VALUES (2, 'b')");
    exec.executeSql("DELETE FROM stats_test WHERE id = 1");

    exec.executeSql("VACUUM stats_test");

    var r17 = exec.executeSql("SELECT * FROM sys.vacuum_stats");
    assertSuccess(r17, "sys.vacuum_stats query succeeds");
    assertTrue(r17.rows.count() > 0, "sys.vacuum_stats has rows");
    assertEqInt(r17.columnNames.count(), 8, "sys.vacuum_stats has 8 columns");

    var found = false;
    var si = 0;
    while si < r17.rows.count() {
        var srow = r17.rows.get(si);
        if srow.values.get(0).textValue == "stats_test" {
            found = true;
            assertEqInt(srow.values.get(1).intValue, 1, "vacuum_count is 1");
        }
        si = si + 1;
    }
    assertTrue(found, "stats_test found in vacuum_stats");

    exec.executeSql("ANALYZE stats_test");
    var r18 = exec.executeSql("SELECT * FROM sys.vacuum_stats");
    assertSuccess(r18, "sys.vacuum_stats after ANALYZE succeeds");
    var si2 = 0;
    while si2 < r18.rows.count() {
        var srow2 = r18.rows.get(si2);
        if srow2.values.get(0).textValue == "stats_test" {
            assertEqInt(srow2.values.get(4).intValue, 1, "analyze_count is 1 after ANALYZE");
            assertEqInt(srow2.values.get(5).intValue, 1, "live_rows reports 1");
        }
        si2 = si2 + 1;
    }
}

func testMvccTransactionCleanup() {
    section("MVCC Dead Row Cleanup — Transactions");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE mvcc_test (id INTEGER, val TEXT)");
    exec.executeSql("INSERT INTO mvcc_test VALUES (1, 'live')");
    exec.executeSql("INSERT INTO mvcc_test VALUES (2, 'will_die')");
    exec.executeSql("INSERT INTO mvcc_test VALUES (3, 'will_die_too')");

    exec.executeSql("BEGIN");
    exec.executeSql("DELETE FROM mvcc_test WHERE id = 2");
    exec.executeSql("COMMIT");

    exec.executeSql("BEGIN");
    exec.executeSql("DELETE FROM mvcc_test WHERE id = 3");
    exec.executeSql("COMMIT");

    // COMMIT already compacts soft-deleted rows, so VACUUM finds 0 dead rows.
    // VACUUM's MVCC dead row detection is a safety net for rows missed by compaction.
    var r19 = exec.executeSql("VACUUM mvcc_test");
    assertSuccess(r19, "MVCC VACUUM succeeds");
    assertTrue(stringContains(r19.message, "0 dead rows removed"), "MVCC VACUUM reports 0 (COMMIT already compacted)");

    var r20 = exec.executeSql("SELECT * FROM mvcc_test");
    assertEqInt(r20.rows.count(), 1, "Only 1 live row remains after txn deletes");
    assertEq(val(r20, 0, 1), "live", "Live row has correct value");
}

func testVacuumAfterUpdate() {
    section("VACUUM After UPDATE");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE update_test (id INTEGER, val TEXT)");
    exec.executeSql("INSERT INTO update_test VALUES (1, 'original')");
    exec.executeSql("INSERT INTO update_test VALUES (2, 'original')");

    exec.executeSql("BEGIN");
    exec.executeSql("UPDATE update_test SET val = 'updated' WHERE id = 1");
    exec.executeSql("COMMIT");

    var r21 = exec.executeSql("VACUUM update_test");
    assertSuccess(r21, "VACUUM after UPDATE succeeds");

    var r22 = exec.executeSql("SELECT val FROM update_test WHERE id = 1");
    assertEq(val(r22, 0, 0), "updated", "Updated value preserved after VACUUM");

    var r23 = exec.executeSql("SELECT COUNT(*) FROM update_test");
    assertEq(val(r23, 0, 0), "2", "Both rows still present after VACUUM");
}

func testAnalyzeOptimizer() {
    section("ANALYZE Updates Optimizer Statistics");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE opt_test (id INTEGER, val TEXT)");
    var ii = 0;
    while ii < 20 {
        exec.executeSql("INSERT INTO opt_test VALUES (" + Fmt.Int(ii) + ", 'v" + Fmt.Int(ii) + "')");
        ii = ii + 1;
    }

    exec.executeSql("ANALYZE opt_test");

    var rowCount = exec.optimizer.stats.getRowCount("opt_test");
    assertEqInt(rowCount, 20, "ANALYZE updated optimizer row count to 20");
}

func testMultipleVacuumPasses() {
    section("Multiple VACUUM Passes");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE multi_vac (id INTEGER)");
    exec.executeSql("INSERT INTO multi_vac VALUES (1)");
    exec.executeSql("INSERT INTO multi_vac VALUES (2)");
    exec.executeSql("INSERT INTO multi_vac VALUES (3)");

    exec.executeSql("DELETE FROM multi_vac WHERE id = 1");
    exec.executeSql("VACUUM multi_vac");

    exec.executeSql("DELETE FROM multi_vac WHERE id = 2");
    exec.executeSql("VACUUM multi_vac");

    var r24 = exec.executeSql("SELECT * FROM sys.vacuum_stats");
    var si3 = 0;
    while si3 < r24.rows.count() {
        var srow3 = r24.rows.get(si3);
        if srow3.values.get(0).textValue == "multi_vac" {
            assertEqInt(srow3.values.get(1).intValue, 2, "vacuum_count is 2 after two passes");
        }
        si3 = si3 + 1;
    }

    var r25 = exec.executeSql("SELECT COUNT(*) FROM multi_vac");
    assertEq(val(r25, 0, 0), "1", "Only 1 row remains after two VACUUM passes");
}

func testVacuumEmptyTable() {
    section("VACUUM/ANALYZE Empty Table");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE empty_t (id INTEGER)");
    var r26 = exec.executeSql("VACUUM empty_t");
    assertSuccess(r26, "VACUUM empty table succeeds");
    assertTrue(stringContains(r26.message, "0 dead rows removed"), "VACUUM empty table reports 0 removed");

    var r27 = exec.executeSql("ANALYZE empty_t");
    assertSuccess(r27, "ANALYZE empty table succeeds");
    assertTrue(stringContains(r27.message, "0 rows"), "ANALYZE empty table reports 0 rows");
}

func main() -> Integer {
    Terminal.Say("=== Phase 26: VACUUM, ANALYZE & Dead Row Cleanup ===");

    testBasicVacuum();
    testMvccVacuum();
    testVacuumPreservesLive();
    testVacuumSpecificTable();
    testAnalyze();
    testVacuumAnalyze();
    testVacuumFull();
    testVacuumAnalyzeTable();
    testVacuumStats();
    testMvccTransactionCleanup();
    testVacuumAfterUpdate();
    testAnalyzeOptimizer();
    testMultipleVacuumPasses();
    testVacuumEmptyTable();

    printResults();
    return 0;
}
