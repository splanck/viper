// test_native_edge.zia — Extreme edge case tests for native codegen
// Part of ViperSQL

module test_native_edge;

bind Terminal = Viper.Terminal;
bind Fmt = Viper.Fmt;
bind String = Viper.String;
bind IO = Viper.IO;

bind "../executor";
bind "./test_common";

//=============================================================================
// EDGE 1: Empty table operations
//=============================================================================

func edge1_empty_table() {
    Terminal.Say("--- Edge 1: Empty table operations ---");
    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE empty (id INTEGER, name TEXT)");

    // SELECT on empty table
    var r1 = exec.executeSql("SELECT * FROM empty");
    assert(r1.success, "empty: select succeeds");
    assert(r1.rowCount() == 0, "empty: 0 rows");

    // Aggregates on empty table
    var r2 = exec.executeSql("SELECT COUNT(*) FROM empty");
    assert(r2.rowCount() == 1, "empty: count returns 1 row");
    if r2.rowCount() > 0 {
        var row = r2.getRow(0);
        if row != null {
            var rr = row;
            assert(rr.getValue(0).toString() == "0", "empty: count is 0");
        }
    }

    var r3 = exec.executeSql("SELECT SUM(id) FROM empty");
    assert(r3.rowCount() == 1, "empty: sum returns 1 row");

    var r4 = exec.executeSql("SELECT MAX(id) FROM empty");
    assert(r4.rowCount() == 1, "empty: max returns 1 row");

    // UPDATE/DELETE on empty table
    var r5 = exec.executeSql("UPDATE empty SET name = 'x' WHERE id = 1");
    assert(r5.success, "empty: update succeeds on empty");

    var r6 = exec.executeSql("DELETE FROM empty WHERE id = 1");
    assert(r6.success, "empty: delete succeeds on empty");

    // ORDER BY on empty
    var r7 = exec.executeSql("SELECT * FROM empty ORDER BY id ASC");
    assert(r7.rowCount() == 0, "empty: order by on empty");

    // GROUP BY on empty
    var r8 = exec.executeSql("SELECT name, COUNT(*) FROM empty GROUP BY name");
    assert(r8.rowCount() == 0, "empty: group by on empty");
}

//=============================================================================
// EDGE 2: Single row table — boundary conditions
//=============================================================================

func edge2_single_row() {
    Terminal.Say("--- Edge 2: Single row table ---");
    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE single (id INTEGER, val TEXT)");
    exec.executeSql("INSERT INTO single VALUES (42, 'only')");

    var r1 = exec.executeSql("SELECT * FROM single");
    assert(r1.rowCount() == 1, "single: 1 row");

    var r2 = exec.executeSql("SELECT * FROM single ORDER BY id ASC");
    assert(r2.rowCount() == 1, "single: order by with 1 row");

    var r3 = exec.executeSql("SELECT COUNT(*), SUM(id), AVG(id), MIN(id), MAX(id) FROM single");
    assert(r3.rowCount() == 1, "single: all aggregates");
    if r3.rowCount() > 0 {
        var row = r3.getRow(0);
        if row != null {
            var rr = row;
            assert(rr.getValue(0).toString() == "1", "single: count=1");
            assert(rr.getValue(1).toString() == "42", "single: sum=42");
            assert(rr.getValue(3).toString() == "42", "single: min=42");
            assert(rr.getValue(4).toString() == "42", "single: max=42");
        }
    }

    var r4 = exec.executeSql("SELECT DISTINCT val FROM single");
    assert(r4.rowCount() == 1, "single: distinct with 1 row");

    // LIMIT 0
    var r5 = exec.executeSql("SELECT * FROM single LIMIT 0");
    assert(r5.rowCount() == 0, "single: limit 0 returns 0 rows");

    // OFFSET past end
    var r6 = exec.executeSql("SELECT * FROM single LIMIT 10 OFFSET 5");
    assert(r6.rowCount() == 0, "single: offset past end");

    // DELETE the only row then re-insert
    exec.executeSql("DELETE FROM single WHERE id = 42");
    var r7 = exec.executeSql("SELECT COUNT(*) FROM single");
    if r7.rowCount() > 0 {
        var row = r7.getRow(0);
        if row != null {
            var rr = row;
            assert(rr.getValue(0).toString() == "0", "single: 0 after delete");
        }
    }

    exec.executeSql("INSERT INTO single VALUES (99, 'back')");
    var r8 = exec.executeSql("SELECT val FROM single WHERE id = 99");
    assert(r8.rowCount() == 1, "single: re-insert works");
}

//=============================================================================
// EDGE 3: Special characters in strings
//=============================================================================

func edge3_special_strings() {
    Terminal.Say("--- Edge 3: Special characters in strings ---");
    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE specials (id INTEGER, txt TEXT)");

    // Strings with single quotes (escaped)
    exec.executeSql("INSERT INTO specials VALUES (1, 'it''s a test')");
    var r1 = exec.executeSql("SELECT txt FROM specials WHERE id = 1");
    assert(r1.rowCount() == 1, "special: escaped quote row found");

    // Empty string
    exec.executeSql("INSERT INTO specials VALUES (2, '')");
    var r2 = exec.executeSql("SELECT txt FROM specials WHERE id = 2");
    assert(r2.rowCount() == 1, "special: empty string row");
    if r2.rowCount() > 0 {
        var row = r2.getRow(0);
        if row != null {
            var rr = row;
            assert(rr.getValue(0).toString() == "", "special: empty string value");
        }
    }

    // Very long string
    var longStr = "";
    var i = 0;
    while i < 500 {
        longStr = longStr + "a";
        i = i + 1;
    }
    exec.executeSql("INSERT INTO specials VALUES (3, '" + longStr + "')");
    var r3 = exec.executeSql("SELECT LENGTH(txt) FROM specials WHERE id = 3");
    assert(r3.rowCount() == 1, "special: long string row");
    if r3.rowCount() > 0 {
        var row = r3.getRow(0);
        if row != null {
            var rr = row;
            assert(rr.getValue(0).toString() == "500", "special: long string length=500");
        }
    }

    // String with spaces
    exec.executeSql("INSERT INTO specials VALUES (4, '   spaces   ')");
    var r4 = exec.executeSql("SELECT TRIM(txt) FROM specials WHERE id = 4");
    assert(r4.rowCount() == 1, "special: trimmed spaces");
    if r4.rowCount() > 0 {
        var row = r4.getRow(0);
        if row != null {
            var rr = row;
            assert(rr.getValue(0).toString() == "spaces", "special: trim result");
        }
    }

    // Numeric strings
    exec.executeSql("INSERT INTO specials VALUES (5, '12345')");
    var r5 = exec.executeSql("SELECT txt FROM specials WHERE txt = '12345'");
    assert(r5.rowCount() == 1, "special: numeric string found");
}

//=============================================================================
// EDGE 4: Integer boundary values
//=============================================================================

func edge4_integer_boundaries() {
    Terminal.Say("--- Edge 4: Integer boundaries ---");
    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE ints (id INTEGER, val INTEGER)");

    // Zero
    exec.executeSql("INSERT INTO ints VALUES (1, 0)");
    // Negative
    exec.executeSql("INSERT INTO ints VALUES (2, -1)");
    exec.executeSql("INSERT INTO ints VALUES (3, -999999)");
    // Large positive
    exec.executeSql("INSERT INTO ints VALUES (4, 999999)");
    exec.executeSql("INSERT INTO ints VALUES (5, 2147483647)");

    // Arithmetic
    var r1 = exec.executeSql("SELECT val + 1 FROM ints WHERE id = 1");
    assert(r1.rowCount() == 1, "int: 0+1");
    if r1.rowCount() > 0 {
        var row = r1.getRow(0);
        if row != null {
            var rr = row;
            assert(rr.getValue(0).toString() == "1", "int: 0+1=1");
        }
    }

    var r2 = exec.executeSql("SELECT val * -1 FROM ints WHERE id = 3");
    assert(r2.rowCount() == 1, "int: negate");
    if r2.rowCount() > 0 {
        var row = r2.getRow(0);
        if row != null {
            var rr = row;
            assert(rr.getValue(0).toString() == "999999", "int: -(-999999)=999999");
        }
    }

    // ORDER BY negative values
    var r3 = exec.executeSql("SELECT val FROM ints ORDER BY val ASC");
    assert(r3.rowCount() == 5, "int: order all 5");
    if r3.rowCount() >= 2 {
        var first = r3.getRow(0);
        if first != null {
            var f = first;
            assert(f.getValue(0).toString() == "-999999", "int: min first in ASC");
        }
    }

    // ABS of negative
    var r4 = exec.executeSql("SELECT ABS(val) FROM ints WHERE id = 3");
    assert(r4.rowCount() == 1, "int: abs");
    if r4.rowCount() > 0 {
        var row = r4.getRow(0);
        if row != null {
            var rr = row;
            assert(rr.getValue(0).toString() == "999999", "int: abs(-999999)=999999");
        }
    }
}

//=============================================================================
// EDGE 5: Multi-table interaction stress
//=============================================================================

func edge5_multi_table() {
    Terminal.Say("--- Edge 5: Multi-table interaction ---");
    var exec = new Executor();
    exec.init();

    // Create several tables
    exec.executeSql("CREATE TABLE ta (id INTEGER, val TEXT)");
    exec.executeSql("CREATE TABLE tb (id INTEGER, ref_a INTEGER, data TEXT)");
    exec.executeSql("CREATE TABLE tc (id INTEGER, ref_b INTEGER, score INTEGER)");

    // Populate
    var i = 0;
    while i < 30 {
        exec.executeSql("INSERT INTO ta VALUES (" + Fmt.Int(i) + ", 'a_" + Fmt.Int(i) + "')");
        i = i + 1;
    }
    i = 0;
    while i < 60 {
        exec.executeSql("INSERT INTO tb VALUES (" + Fmt.Int(i) + ", " + Fmt.Int(i % 30) + ", 'b_" + Fmt.Int(i) + "')");
        i = i + 1;
    }
    i = 0;
    while i < 90 {
        exec.executeSql("INSERT INTO tc VALUES (" + Fmt.Int(i) + ", " + Fmt.Int(i % 60) + ", " + Fmt.Int(i * 11) + ")");
        i = i + 1;
    }

    // Verify counts
    var ra = exec.executeSql("SELECT COUNT(*) FROM ta");
    var rb = exec.executeSql("SELECT COUNT(*) FROM tb");
    var rc = exec.executeSql("SELECT COUNT(*) FROM tc");
    assert(ra.rowCount() == 1, "multi: ta count");
    assert(rb.rowCount() == 1, "multi: tb count");
    assert(rc.rowCount() == 1, "multi: tc count");

    // Cross-table operations
    // Drop one table, verify others unaffected
    exec.executeSql("DROP TABLE tb");
    var ra2 = exec.executeSql("SELECT COUNT(*) FROM ta");
    assert(ra2.rowCount() == 1, "multi: ta still exists after drop tb");
    var rc2 = exec.executeSql("SELECT COUNT(*) FROM tc");
    assert(rc2.rowCount() == 1, "multi: tc still exists after drop tb");

    // Re-create tb
    exec.executeSql("CREATE TABLE tb (id INTEGER, info TEXT)");
    exec.executeSql("INSERT INTO tb VALUES (1, 'recreated')");
    var rb2 = exec.executeSql("SELECT info FROM tb WHERE id = 1");
    assert(rb2.rowCount() == 1, "multi: recreated tb works");
    if rb2.rowCount() > 0 {
        var row = rb2.getRow(0);
        if row != null {
            var rr = row;
            assert(rr.getValue(0).toString() == "recreated", "multi: recreated data correct");
        }
    }
}

//=============================================================================
// EDGE 6: Rapid INSERT-SELECT-DELETE cycles
//=============================================================================

func edge6_rapid_cycles() {
    Terminal.Say("--- Edge 6: Rapid INSERT-SELECT-DELETE ---");
    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE cycle (id INTEGER, step INTEGER)");

    var cycle = 0;
    while cycle < 50 {
        // Insert 10 rows
        var i = 0;
        while i < 10 {
            exec.executeSql("INSERT INTO cycle VALUES (" + Fmt.Int(cycle * 10 + i) + ", " + Fmt.Int(cycle) + ")");
            i = i + 1;
        }

        // Verify count
        var r = exec.executeSql("SELECT COUNT(*) FROM cycle WHERE step = " + Fmt.Int(cycle));
        if r.rowCount() > 0 {
            var row = r.getRow(0);
            if row != null {
                var rr = row;
                if rr.getValue(0).toString() != "10" {
                    assert(false, "cycle " + Fmt.Int(cycle) + ": expected 10 rows");
                }
            }
        }

        // Delete all from this cycle
        exec.executeSql("DELETE FROM cycle WHERE step = " + Fmt.Int(cycle));

        cycle = cycle + 1;
    }

    // Table should be empty
    var finalResult = exec.executeSql("SELECT COUNT(*) FROM cycle");
    if finalResult.rowCount() > 0 {
        var row = finalResult.getRow(0);
        if row != null {
            var rr = row;
            assert(rr.getValue(0).toString() == "0", "cycle: table empty after all cycles");
        }
    }
    assert(true, "rapid cycles: 50 insert/delete cycles completed");
}

//=============================================================================
// EDGE 7: Large persistence round-trip (500 rows)
//=============================================================================

func edge7_large_persistence() {
    Terminal.Say("--- Edge 7: Large persistence (500 rows) ---");
    var exec = new Executor();
    exec.init();

    var dbPath = "/tmp/test_edge7.vdb";
    if IO.File.Exists(dbPath) { IO.File.Delete(dbPath); }

    exec.executeSql("OPEN '" + dbPath + "'");
    exec.executeSql("CREATE TABLE big (id INTEGER PRIMARY KEY, name TEXT, score INTEGER, category TEXT)");

    var i = 0;
    while i < 500 {
        var cat = "cat_" + Fmt.Int(i % 5);
        exec.executeSql("INSERT INTO big VALUES (" + Fmt.Int(i) + ", 'item_" + Fmt.Int(i) + "', " + Fmt.Int(i * 3) + ", '" + cat + "')");
        i = i + 1;
    }

    exec.executeSql("CLOSE");

    // Reopen
    var exec2 = new Executor();
    exec2.init();
    exec2.executeSql("OPEN '" + dbPath + "'");

    var r1 = exec2.executeSql("SELECT COUNT(*) FROM big");
    assert(r1.rowCount() == 1, "persist500: count row");
    if r1.rowCount() > 0 {
        var row = r1.getRow(0);
        if row != null {
            var rr = row;
            assert(rr.getValue(0).toString() == "500", "persist500: 500 rows");
        }
    }

    // Verify specific row
    var r2 = exec2.executeSql("SELECT name, score FROM big WHERE id = 499");
    assert(r2.rowCount() == 1, "persist500: row 499");
    if r2.rowCount() > 0 {
        var row = r2.getRow(0);
        if row != null {
            var rr = row;
            assert(rr.getValue(0).toString() == "item_499", "persist500: name correct");
            assert(rr.getValue(1).toString() == "1497", "persist500: score=1497");
        }
    }

    // GROUP BY on persisted data
    var r3 = exec2.executeSql("SELECT category, COUNT(*) FROM big GROUP BY category");
    assert(r3.rowCount() == 5, "persist500: 5 categories");

    exec2.executeSql("CLOSE");
    if IO.File.Exists(dbPath) { IO.File.Delete(dbPath); }
}

//=============================================================================
// EDGE 8: UNION/EXCEPT/INTERSECT with larger datasets
//=============================================================================

func edge8_set_ops() {
    Terminal.Say("--- Edge 8: Set operations at scale ---");
    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE set_a (id INTEGER, val TEXT)");
    exec.executeSql("CREATE TABLE set_b (id INTEGER, val TEXT)");

    // set_a: 0..99
    var i = 0;
    while i < 100 {
        exec.executeSql("INSERT INTO set_a VALUES (" + Fmt.Int(i) + ", 'v_" + Fmt.Int(i) + "')");
        i = i + 1;
    }
    // set_b: 50..149 (overlap 50..99)
    i = 50;
    while i < 150 {
        exec.executeSql("INSERT INTO set_b VALUES (" + Fmt.Int(i) + ", 'v_" + Fmt.Int(i) + "')");
        i = i + 1;
    }

    // UNION — should be 150 unique rows (0..149)
    var r1 = exec.executeSql("SELECT id, val FROM set_a UNION SELECT id, val FROM set_b");
    assert(r1.rowCount() == 150, "setops: union 150 unique");

    // UNION ALL — should be 200 rows
    var r2 = exec.executeSql("SELECT id, val FROM set_a UNION ALL SELECT id, val FROM set_b");
    assert(r2.rowCount() == 200, "setops: union all 200");

    // EXCEPT — set_a minus overlap = 0..49 = 50 rows
    var r3 = exec.executeSql("SELECT id, val FROM set_a EXCEPT SELECT id, val FROM set_b");
    assert(r3.rowCount() == 50, "setops: except 50");

    // INTERSECT — overlap = 50..99 = 50 rows
    var r4 = exec.executeSql("SELECT id, val FROM set_a INTERSECT SELECT id, val FROM set_b");
    assert(r4.rowCount() == 50, "setops: intersect 50");
}

//=============================================================================
// EDGE 9: Nested CASE with NULL
//=============================================================================

func edge9_nested_case_null() {
    Terminal.Say("--- Edge 9: Nested CASE with NULL ---");
    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE cases (id INTEGER, a INTEGER, b INTEGER)");
    exec.executeSql("INSERT INTO cases VALUES (1, 10, 20)");
    exec.executeSql("INSERT INTO cases VALUES (2, NULL, 20)");
    exec.executeSql("INSERT INTO cases VALUES (3, 10, NULL)");
    exec.executeSql("INSERT INTO cases VALUES (4, NULL, NULL)");

    // CASE with IS NULL
    var r1 = exec.executeSql("SELECT id, CASE WHEN a IS NULL THEN 'no_a' WHEN b IS NULL THEN 'no_b' ELSE 'both' END FROM cases ORDER BY id");
    assert(r1.rowCount() == 4, "nested case null: 4 rows");
    if r1.rowCount() >= 4 {
        var row1 = r1.getRow(0);
        var row2 = r1.getRow(1);
        var row3 = r1.getRow(2);
        var row4 = r1.getRow(3);
        if row1 != null {
            var r = row1;
            assert(r.getValue(1).toString() == "both", "case null: row1 = both");
        }
        if row2 != null {
            var r = row2;
            assert(r.getValue(1).toString() == "no_a", "case null: row2 = no_a");
        }
        if row3 != null {
            var r = row3;
            assert(r.getValue(1).toString() == "no_b", "case null: row3 = no_b");
        }
        if row4 != null {
            var r = row4;
            assert(r.getValue(1).toString() == "no_a", "case null: row4 = no_a (a checked first)");
        }
    }
}

//=============================================================================
// EDGE 10: AUTOINCREMENT stress
//=============================================================================

func edge10_autoincrement() {
    Terminal.Say("--- Edge 10: AUTOINCREMENT stress ---");
    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE auto (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT)");

    // Insert 200 rows
    var i = 0;
    while i < 200 {
        exec.executeSql("INSERT INTO auto VALUES (NULL, 'item_" + Fmt.Int(i) + "')");
        i = i + 1;
    }

    // Verify count
    var r1 = exec.executeSql("SELECT COUNT(*) FROM auto");
    assert(r1.rowCount() == 1, "autoinc: count");
    if r1.rowCount() > 0 {
        var row = r1.getRow(0);
        if row != null {
            var rr = row;
            assert(rr.getValue(0).toString() == "200", "autoinc: 200 rows");
        }
    }

    // Verify last id
    var r2 = exec.executeSql("SELECT MAX(id) FROM auto");
    assert(r2.rowCount() == 1, "autoinc: max id");
    if r2.rowCount() > 0 {
        var row = r2.getRow(0);
        if row != null {
            var rr = row;
            assert(rr.getValue(0).toString() == "200", "autoinc: max id=200");
        }
    }

    // Delete some and re-insert — ids should keep incrementing
    exec.executeSql("DELETE FROM auto WHERE id > 190");
    exec.executeSql("INSERT INTO auto VALUES (NULL, 'after_delete')");
    var r3 = exec.executeSql("SELECT id FROM auto WHERE name = 'after_delete'");
    assert(r3.rowCount() == 1, "autoinc: after delete insert");
    if r3.rowCount() > 0 {
        var row = r3.getRow(0);
        if row != null {
            var rr = row;
            // Should be 201, not reuse deleted ids
            var idStr = rr.getValue(0).toString();
            assert(idStr == "201", "autoinc: id=201 (no reuse)");
        }
    }
}

//=============================================================================
// MAIN
//=============================================================================

func main() {
    Terminal.Say("=== Native Edge Case Tests ===");
    Terminal.Say("");

    edge1_empty_table();
    edge2_single_row();
    edge3_special_strings();
    edge4_integer_boundaries();
    edge5_multi_table();
    edge6_rapid_cycles();
    edge7_large_persistence();
    edge8_set_ops();
    edge9_nested_case_null();
    edge10_autoincrement();

    printResults();
}
