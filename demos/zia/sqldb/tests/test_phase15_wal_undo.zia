// test_phase15_wal_undo.zia — Phase 15: WAL Undo Phase Tests
// Tests for CLR records, UPDATE/DELETE before-image capture,
// undo of uncommitted transactions, and recovery result tracking.

module test_phase15_wal_undo;

bind Terminal = Viper.Terminal;
bind String = Viper.String;
bind Fmt = Viper.Fmt;

bind "./test_common";
bind "../executor";
bind "../types";
bind "../storage/wal";
bind "../storage/page";
bind "../storage/serializer";
bind "../storage/buffer";
bind "../storage/data_page";
bind "../storage/txn";

func main() -> Integer {
    Terminal.Say("=== Phase 15: WAL Undo Phase Tests ===");

    //=========================================================================
    // 1. LOG RECORD TYPES — CLR
    //=========================================================================
    section("CLR Record Type");

    // Test 1: LOG_CLR constant exists and has correct value
    assert(LOG_CLR == 9, "LOG_CLR constant = 9");

    // Test 2: LogRecord.initCLR creates correct record
    var clr = new LogRecord();
    clr.initCLR(42, 1, 100, 5, LOG_INSERT);
    assert(clr.recordType == LOG_CLR, "CLR recordType = LOG_CLR");
    assert(clr.txnId == 42, "CLR txnId = 42");
    assert(clr.tableId == 1, "CLR tableId = 1");
    assert(clr.pageId == 100, "CLR pageId = 100");
    assert(clr.slotId == 5, "CLR slotId = 5");
    assert(clr.recordTypeString() == "CLR", "CLR recordTypeString = 'CLR'");

    // Test 3: CLR afterImage stores undone type
    clr.afterImage.seek(0);
    var undoneType = clr.afterImage.readInt32();
    assert(undoneType == LOG_INSERT, "CLR afterImage stores undone type (INSERT)");

    // Test 4: CLR for UPDATE
    var clrUpdate = new LogRecord();
    clrUpdate.initCLR(43, 2, 200, 3, LOG_UPDATE);
    assert(clrUpdate.recordType == LOG_CLR, "CLR UPDATE recordType");
    clrUpdate.afterImage.seek(0);
    assert(clrUpdate.afterImage.readInt32() == LOG_UPDATE, "CLR stores undone UPDATE type");

    // Test 5: CLR for DELETE
    var clrDelete = new LogRecord();
    clrDelete.initCLR(44, 3, 300, 7, LOG_DELETE);
    assert(clrDelete.recordType == LOG_CLR, "CLR DELETE recordType");
    clrDelete.afterImage.seek(0);
    assert(clrDelete.afterImage.readInt32() == LOG_DELETE, "CLR stores undone DELETE type");

    //=========================================================================
    // 2. CLR SERIALIZATION ROUNDTRIP
    //=========================================================================
    section("CLR Serialization");

    var ser = new LogRecordSerializer();
    ser.init();
    var buf = new BinaryBuffer();
    buf.init();
    ser.serialize(clr, buf);
    buf.seek(0);
    var clr2 = ser.deserialize(buf);
    assert(clr2.recordType == LOG_CLR, "CLR round-trip: recordType preserved");
    assert(clr2.txnId == 42, "CLR round-trip: txnId preserved");
    assert(clr2.tableId == 1, "CLR round-trip: tableId preserved");
    assert(clr2.pageId == 100, "CLR round-trip: pageId preserved");
    assert(clr2.slotId == 5, "CLR round-trip: slotId preserved");
    clr2.afterImage.seek(0);
    assert(clr2.afterImage.readInt32() == LOG_INSERT, "CLR round-trip: undoneType preserved");

    //=========================================================================
    // 3. BEFORE-IMAGE CAPTURE — LogRecord init helpers
    //=========================================================================
    section("Before-Image Capture");

    // Test: initUpdate stores both before and after images
    var beforeBuf = new BinaryBuffer();
    beforeBuf.init();
    beforeBuf.writeInt64(100);
    beforeBuf.writeInt64(200);
    var afterBuf = new BinaryBuffer();
    afterBuf.init();
    afterBuf.writeInt64(300);
    afterBuf.writeInt64(400);
    var updateRec = new LogRecord();
    updateRec.initUpdate(5, 1, 50, 3, beforeBuf, afterBuf);
    assert(updateRec.recordType == LOG_UPDATE, "UPDATE recordType");
    assert(updateRec.beforeImage.size() > 0, "UPDATE beforeImage is non-empty");
    assert(updateRec.afterImage.size() > 0, "UPDATE afterImage is non-empty");
    updateRec.beforeImage.seek(0);
    assert(updateRec.beforeImage.readInt64() == 100, "UPDATE beforeImage[0] = 100");
    assert(updateRec.beforeImage.readInt64() == 200, "UPDATE beforeImage[1] = 200");
    updateRec.afterImage.seek(0);
    assert(updateRec.afterImage.readInt64() == 300, "UPDATE afterImage[0] = 300");
    assert(updateRec.afterImage.readInt64() == 400, "UPDATE afterImage[1] = 400");

    // Test: initDelete stores before-image
    var deleteBuf = new BinaryBuffer();
    deleteBuf.init();
    deleteBuf.writeInt64(999);
    var deleteRec = new LogRecord();
    deleteRec.initDelete(6, 2, 60, 4, deleteBuf);
    assert(deleteRec.recordType == LOG_DELETE, "DELETE recordType");
    assert(deleteRec.beforeImage.size() > 0, "DELETE beforeImage is non-empty");
    deleteRec.beforeImage.seek(0);
    assert(deleteRec.beforeImage.readInt64() == 999, "DELETE beforeImage = 999");

    // Test: initInsert stores after-image (row data)
    var insertBuf = new BinaryBuffer();
    insertBuf.init();
    insertBuf.writeInt64(777);
    var insertRec = new LogRecord();
    insertRec.initInsert(7, 3, 70, 5, insertBuf);
    assert(insertRec.recordType == LOG_INSERT, "INSERT recordType");
    assert(insertRec.afterImage.size() > 0, "INSERT afterImage is non-empty");
    insertRec.afterImage.seek(0);
    assert(insertRec.afterImage.readInt64() == 777, "INSERT afterImage = 777");

    //=========================================================================
    // 4. UPDATE BEFORE-IMAGE SERIALIZATION ROUNDTRIP
    //=========================================================================
    section("Update Before-Image Roundtrip");

    var ser2 = new LogRecordSerializer();
    ser2.init();
    var buf2 = new BinaryBuffer();
    buf2.init();
    ser2.serialize(updateRec, buf2);
    buf2.seek(0);
    var upRec2 = ser2.deserialize(buf2);
    assert(upRec2.recordType == LOG_UPDATE, "UPDATE round-trip: recordType");
    assert(upRec2.beforeImage.size() > 0, "UPDATE round-trip: beforeImage non-empty");
    upRec2.beforeImage.seek(0);
    assert(upRec2.beforeImage.readInt64() == 100, "UPDATE round-trip: beforeImage[0] = 100");
    assert(upRec2.beforeImage.readInt64() == 200, "UPDATE round-trip: beforeImage[1] = 200");
    upRec2.afterImage.seek(0);
    assert(upRec2.afterImage.readInt64() == 300, "UPDATE round-trip: afterImage[0] = 300");
    assert(upRec2.afterImage.readInt64() == 400, "UPDATE round-trip: afterImage[1] = 400");

    //=========================================================================
    // 5. DELETE BEFORE-IMAGE SERIALIZATION ROUNDTRIP
    //=========================================================================
    section("Delete Before-Image Roundtrip");

    var buf3 = new BinaryBuffer();
    buf3.init();
    ser2.serialize(deleteRec, buf3);
    buf3.seek(0);
    var delRec2 = ser2.deserialize(buf3);
    assert(delRec2.recordType == LOG_DELETE, "DELETE round-trip: recordType");
    assert(delRec2.beforeImage.size() > 0, "DELETE round-trip: beforeImage non-empty");
    delRec2.beforeImage.seek(0);
    assert(delRec2.beforeImage.readInt64() == 999, "DELETE round-trip: beforeImage = 999");

    //=========================================================================
    // 6. RECOVERY RESULT — undoCount field
    //=========================================================================
    section("Recovery Result Undo Count");

    var rr = new RecoveryResult();
    rr.init();
    assert(rr.undoCount == 0, "RecoveryResult initial undoCount = 0");
    rr.undoCount = 5;
    assert(rr.undoCount == 5, "RecoveryResult undoCount set to 5");
    var rrStr = rr.toString();
    assert(stringContains(rrStr, "Undo operations: 5"), "RecoveryResult.toString includes undo count");

    // Verify all fields
    rr.redoCount = 3;
    rr.committedTxns = [1, 2, 3];
    rr.abortedTxns = [4, 5];
    rr.activeTxnsAtCrash = [6];
    rr.recoveryComplete = true;
    rrStr = rr.toString();
    assert(stringContains(rrStr, "Committed: 3"), "RecoveryResult committed count");
    assert(stringContains(rrStr, "Aborted: 2"), "RecoveryResult aborted count");
    assert(stringContains(rrStr, "Active at crash: 1"), "RecoveryResult active at crash count");
    assert(stringContains(rrStr, "Redo operations: 3"), "RecoveryResult redo count");

    //=========================================================================
    // 7. TransactionManager.initWithStorage
    //=========================================================================
    section("TransactionManager initWithStorage");

    var wal5 = new WALManager();
    wal5.init();
    var pool5 = new BufferPool();
    pool5.init();
    var dataMgr5 = new DataPageManager();
    dataMgr5.init();

    var txnMgr = new TransactionManager();
    txnMgr.initWithStorage(wal5, pool5, dataMgr5);
    assert(txnMgr.activeCount() == 0, "txnMgr starts with 0 active txns");

    // Begin and commit a transaction
    var txn1 = txnMgr.begin();
    assert(txn1.isActive(), "txn1 is active");
    assert(txnMgr.activeCount() == 1, "1 active txn after begin");
    var committed = txnMgr.commit(txn1);
    assert(committed, "commit succeeds");
    assert(txn1.isCommitted(), "txn1 is committed");
    assert(txnMgr.activeCount() == 0, "0 active txns after commit");

    // Begin and abort a transaction
    var txn2 = txnMgr.begin();
    assert(txn2.isActive(), "txn2 is active");
    var aborted = txnMgr.abort(txn2);
    assert(aborted, "abort succeeds");
    assert(txn2.isAborted(), "txn2 is aborted");
    assert(txnMgr.activeCount() == 0, "0 active txns after abort");

    // Double-abort should fail
    assert(txnMgr.abort(txn2) == false, "double abort fails");
    // Double-commit should fail
    assert(txnMgr.commit(txn1) == false, "double commit fails");

    //=========================================================================
    // 8. SQL-LEVEL ROLLBACK — UNDO INSERT
    //=========================================================================
    section("SQL ROLLBACK: Undo INSERT");

    var exec = new Executor();
    exec.init();

    assertSuccess(exec.executeSql("CREATE TABLE undo_test (id INTEGER PRIMARY KEY, name TEXT, val INTEGER)"), "create undo_test");
    assertSuccess(exec.executeSql("INSERT INTO undo_test VALUES (1, 'Alice', 100)"), "insert Alice");
    assertSuccess(exec.executeSql("INSERT INTO undo_test VALUES (2, 'Bob', 200)"), "insert Bob");

    assertSuccess(exec.executeSql("BEGIN"), "begin insert txn");
    assertSuccess(exec.executeSql("INSERT INTO undo_test VALUES (3, 'Charlie', 300)"), "insert Charlie");
    assertSuccess(exec.executeSql("INSERT INTO undo_test VALUES (4, 'Dave', 400)"), "insert Dave");
    var r = exec.executeSql("SELECT COUNT(*) FROM undo_test");
    assert(val(r, 0, 0) == "4", "during txn: 4 rows visible");
    assertSuccess(exec.executeSql("ROLLBACK"), "rollback inserts");
    r = exec.executeSql("SELECT COUNT(*) FROM undo_test");
    assert(val(r, 0, 0) == "2", "after rollback: 2 rows");

    //=========================================================================
    // 9. SQL-LEVEL ROLLBACK — UNDO UPDATE
    //=========================================================================
    section("SQL ROLLBACK: Undo UPDATE");

    assertSuccess(exec.executeSql("BEGIN"), "begin update txn");
    assertSuccess(exec.executeSql("UPDATE undo_test SET val = 999 WHERE id = 1"), "update Alice val");
    r = exec.executeSql("SELECT val FROM undo_test WHERE id = 1");
    assert(val(r, 0, 0) == "999", "during txn: val = 999");
    assertSuccess(exec.executeSql("ROLLBACK"), "rollback update");
    r = exec.executeSql("SELECT val FROM undo_test WHERE id = 1");
    assert(val(r, 0, 0) == "100", "after rollback: val restored to 100");

    //=========================================================================
    // 10. SQL-LEVEL ROLLBACK — UNDO DELETE
    //=========================================================================
    section("SQL ROLLBACK: Undo DELETE");

    assertSuccess(exec.executeSql("BEGIN"), "begin delete txn");
    assertSuccess(exec.executeSql("DELETE FROM undo_test WHERE id = 2"), "delete Bob");
    r = exec.executeSql("SELECT COUNT(*) FROM undo_test");
    assert(val(r, 0, 0) == "1", "during txn: 1 row");
    assertSuccess(exec.executeSql("ROLLBACK"), "rollback delete");
    r = exec.executeSql("SELECT COUNT(*) FROM undo_test");
    assert(val(r, 0, 0) == "2", "after rollback: 2 rows restored");
    r = exec.executeSql("SELECT name FROM undo_test WHERE id = 2");
    assert(val(r, 0, 0) == "Bob", "after rollback: Bob restored");

    //=========================================================================
    // 11. SQL-LEVEL ROLLBACK — MIXED OPERATIONS
    //=========================================================================
    section("SQL ROLLBACK: Mixed Operations");

    assertSuccess(exec.executeSql("BEGIN"), "begin mixed txn");
    assertSuccess(exec.executeSql("INSERT INTO undo_test VALUES (10, 'Mixed', 1000)"), "mixed insert");
    assertSuccess(exec.executeSql("UPDATE undo_test SET val = 111 WHERE id = 1"), "mixed update");
    assertSuccess(exec.executeSql("DELETE FROM undo_test WHERE id = 2"), "mixed delete");
    r = exec.executeSql("SELECT COUNT(*) FROM undo_test");
    assert(val(r, 0, 0) == "2", "during mixed: 2 rows (1 added, 1 deleted)");
    assertSuccess(exec.executeSql("ROLLBACK"), "rollback mixed");
    r = exec.executeSql("SELECT COUNT(*) FROM undo_test");
    assert(val(r, 0, 0) == "2", "after mixed rollback: 2 rows");
    r = exec.executeSql("SELECT val FROM undo_test WHERE id = 1");
    assert(val(r, 0, 0) == "100", "after mixed rollback: val 1 restored");
    r = exec.executeSql("SELECT name FROM undo_test WHERE id = 2");
    assert(val(r, 0, 0) == "Bob", "after mixed rollback: Bob restored");

    //=========================================================================
    // 12. ROLLBACK FOLLOWED BY NEW TRANSACTION
    //=========================================================================
    section("Rollback Then New Transaction");

    // After rollback, can start a new transaction and commit
    assertSuccess(exec.executeSql("BEGIN"), "begin after rollback");
    assertSuccess(exec.executeSql("INSERT INTO undo_test VALUES (5, 'Eve', 500)"), "insert Eve");
    assertSuccess(exec.executeSql("COMMIT"), "commit after rollback");
    r = exec.executeSql("SELECT COUNT(*) FROM undo_test");
    assert(val(r, 0, 0) == "3", "after commit: 3 rows (Alice, Bob, Eve)");
    r = exec.executeSql("SELECT name FROM undo_test WHERE id = 5");
    assert(val(r, 0, 0) == "Eve", "Eve committed successfully");

    //=========================================================================
    // 13. MULTIPLE ROLLBACKS
    //=========================================================================
    section("Multiple Sequential Rollbacks");

    // First rollback
    assertSuccess(exec.executeSql("BEGIN"), "begin rollback 1");
    assertSuccess(exec.executeSql("INSERT INTO undo_test VALUES (20, 'X', 2000)"), "insert X");
    assertSuccess(exec.executeSql("ROLLBACK"), "rollback 1");
    r = exec.executeSql("SELECT COUNT(*) FROM undo_test");
    assert(val(r, 0, 0) == "3", "after rollback 1: still 3 rows");

    // Second rollback
    assertSuccess(exec.executeSql("BEGIN"), "begin rollback 2");
    assertSuccess(exec.executeSql("UPDATE undo_test SET val = 0 WHERE id = 1"), "update Alice to 0");
    assertSuccess(exec.executeSql("ROLLBACK"), "rollback 2");
    r = exec.executeSql("SELECT val FROM undo_test WHERE id = 1");
    assert(val(r, 0, 0) == "100", "after rollback 2: Alice val = 100");

    // Third rollback
    assertSuccess(exec.executeSql("BEGIN"), "begin rollback 3");
    assertSuccess(exec.executeSql("DELETE FROM undo_test WHERE id = 5"), "delete Eve");
    assertSuccess(exec.executeSql("ROLLBACK"), "rollback 3");
    r = exec.executeSql("SELECT COUNT(*) FROM undo_test");
    assert(val(r, 0, 0) == "3", "after rollback 3: still 3 rows");

    //=========================================================================
    // 14. WAL RECORD TYPE COVERAGE
    //=========================================================================
    section("WAL Record Type Coverage");

    // Verify all record type constants
    assert(LOG_BEGIN == 1, "LOG_BEGIN = 1");
    assert(LOG_COMMIT == 2, "LOG_COMMIT = 2");
    assert(LOG_ABORT == 3, "LOG_ABORT = 3");
    assert(LOG_INSERT == 4, "LOG_INSERT = 4");
    assert(LOG_UPDATE == 5, "LOG_UPDATE = 5");
    assert(LOG_DELETE == 6, "LOG_DELETE = 6");
    assert(LOG_CHECKPOINT == 7, "LOG_CHECKPOINT = 7");
    assert(LOG_PAGE_WRITE == 8, "LOG_PAGE_WRITE = 8");
    assert(LOG_CLR == 9, "LOG_CLR = 9");

    // Verify recordTypeString for all types
    var rec = new LogRecord();
    rec.init();
    rec.recordType = LOG_BEGIN;
    assert(rec.recordTypeString() == "BEGIN", "recordTypeString BEGIN");
    rec.recordType = LOG_COMMIT;
    assert(rec.recordTypeString() == "COMMIT", "recordTypeString COMMIT");
    rec.recordType = LOG_ABORT;
    assert(rec.recordTypeString() == "ABORT", "recordTypeString ABORT");
    rec.recordType = LOG_INSERT;
    assert(rec.recordTypeString() == "INSERT", "recordTypeString INSERT");
    rec.recordType = LOG_UPDATE;
    assert(rec.recordTypeString() == "UPDATE", "recordTypeString UPDATE");
    rec.recordType = LOG_DELETE;
    assert(rec.recordTypeString() == "DELETE", "recordTypeString DELETE");
    rec.recordType = LOG_CHECKPOINT;
    assert(rec.recordTypeString() == "CHECKPOINT", "recordTypeString CHECKPOINT");
    rec.recordType = LOG_PAGE_WRITE;
    assert(rec.recordTypeString() == "PAGE_WRITE", "recordTypeString PAGE_WRITE");
    rec.recordType = LOG_CLR;
    assert(rec.recordTypeString() == "CLR", "recordTypeString CLR");

    //=========================================================================
    // 15. LOG RECORD toString
    //=========================================================================
    section("LogRecord toString");

    var lr = new LogRecord();
    lr.init();
    lr.recordType = LOG_CLR;
    lr.txnId = 99;
    lr.lsn.fileNumber = 1;
    lr.lsn.offset = 42;
    var lrStr = lr.toString();
    assert(stringContains(lrStr, "CLR"), "toString contains CLR");
    assert(stringContains(lrStr, "txn=99"), "toString contains txn=99");
    assert(stringContains(lrStr, "1:42"), "toString contains LSN 1:42");

    //=========================================================================
    // RESULTS
    //=========================================================================
    printResults();

    return failed;
}
