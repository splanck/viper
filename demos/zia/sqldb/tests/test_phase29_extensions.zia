// test_phase29_extensions.zia — Phase 29: Common SQL Extensions
// Tests for TRUNCATE TABLE, INSERT/UPDATE/DELETE RETURNING,
// INSERT ON CONFLICT (UPSERT).

module test_phase29_extensions;

bind Terminal = Viper.Terminal;
bind String = Viper.String;
bind Fmt = Viper.Fmt;

bind "./test_common";
bind "../executor";
bind "../types";

//=========================================================================
// TRUNCATE TABLE
//=========================================================================

func testTruncateTable() {
    section("TRUNCATE TABLE");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE trunc_t (id INTEGER, name TEXT)");
    exec.executeSql("INSERT INTO trunc_t VALUES (1, 'Alice')");
    exec.executeSql("INSERT INTO trunc_t VALUES (2, 'Bob')");
    exec.executeSql("INSERT INTO trunc_t VALUES (3, 'Carol')");

    var r1 = exec.executeSql("SELECT COUNT(*) FROM trunc_t");
    assertEq(val(r1, 0, 0), "3", "Table has 3 rows before truncate");

    var r2 = exec.executeSql("TRUNCATE TABLE trunc_t");
    assertSuccess(r2, "TRUNCATE TABLE succeeds");

    var r3 = exec.executeSql("SELECT COUNT(*) FROM trunc_t");
    assertEq(val(r3, 0, 0), "0", "Table has 0 rows after truncate");

    // Can still insert after truncate
    exec.executeSql("INSERT INTO trunc_t VALUES (10, 'Dave')");
    var r4 = exec.executeSql("SELECT * FROM trunc_t");
    assertEqInt(r4.rows.count(), 1, "Can insert after truncate");
    assertEq(val(r4, 0, 1), "Dave", "Inserted row after truncate is correct");
}

func testTruncateWithoutTableKeyword() {
    section("TRUNCATE (no TABLE keyword)");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE trunc2 (id INTEGER)");
    exec.executeSql("INSERT INTO trunc2 VALUES (1)");
    exec.executeSql("INSERT INTO trunc2 VALUES (2)");

    var r1 = exec.executeSql("TRUNCATE trunc2");
    assertSuccess(r1, "TRUNCATE without TABLE keyword succeeds");

    var r2 = exec.executeSql("SELECT COUNT(*) FROM trunc2");
    assertEq(val(r2, 0, 0), "0", "Table empty after TRUNCATE");
}

func testTruncateNonexistent() {
    section("TRUNCATE nonexistent");

    var exec = new Executor();
    exec.init();

    var r1 = exec.executeSql("TRUNCATE TABLE does_not_exist");
    assertTrue(r1.success == false, "TRUNCATE nonexistent table fails");
}

func testTruncatePartitioned() {
    section("TRUNCATE partitioned table");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE tp (id INTEGER, val TEXT) PARTITION BY RANGE (id)");
    exec.executeSql("CREATE TABLE tp_p1 PARTITION OF tp FOR VALUES FROM (1) TO (100)");
    exec.executeSql("CREATE TABLE tp_p2 PARTITION OF tp FOR VALUES FROM (100) TO (200)");

    exec.executeSql("INSERT INTO tp VALUES (10, 'a')");
    exec.executeSql("INSERT INTO tp VALUES (150, 'b')");

    var r1 = exec.executeSql("SELECT COUNT(*) FROM tp");
    assertEq(val(r1, 0, 0), "2", "Partitioned table has 2 rows");

    var r2 = exec.executeSql("TRUNCATE TABLE tp");
    assertSuccess(r2, "TRUNCATE partitioned table succeeds");

    var r3 = exec.executeSql("SELECT COUNT(*) FROM tp");
    assertEq(val(r3, 0, 0), "0", "Partitioned table empty after truncate");
}

//=========================================================================
// INSERT RETURNING
//=========================================================================

func testInsertReturning() {
    section("INSERT RETURNING");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE ret_t (id INTEGER PRIMARY KEY, name TEXT, score INTEGER DEFAULT 100)");

    var r1 = exec.executeSql("INSERT INTO ret_t VALUES (1, 'Alice', 95) RETURNING *");
    assertEqInt(r1.rows.count(), 1, "INSERT RETURNING * returns 1 row");
    assertEq(val(r1, 0, 0), "1", "RETURNING id = 1");
    assertEq(val(r1, 0, 1), "Alice", "RETURNING name = Alice");
    assertEq(val(r1, 0, 2), "95", "RETURNING score = 95");
}

func testInsertReturningColumns() {
    section("INSERT RETURNING specific columns");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE ret2 (id INTEGER PRIMARY KEY, name TEXT, score INTEGER)");

    var r1 = exec.executeSql("INSERT INTO ret2 VALUES (1, 'Bob', 80) RETURNING id, name");
    assertEqInt(r1.rows.count(), 1, "RETURNING columns returns 1 row");
    assertEq(val(r1, 0, 0), "1", "RETURNING id = 1");
    assertEq(val(r1, 0, 1), "Bob", "RETURNING name = Bob");
    assertEqInt(r1.columnNames.count(), 2, "RETURNING has 2 columns");
}

func testInsertReturningMultiRow() {
    section("INSERT RETURNING multiple rows");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE ret3 (id INTEGER, val TEXT)");

    var r1 = exec.executeSql("INSERT INTO ret3 VALUES (1, 'a'), (2, 'b'), (3, 'c') RETURNING *");
    assertEqInt(r1.rows.count(), 3, "Multi-row INSERT RETURNING returns 3 rows");
    assertEq(val(r1, 0, 0), "1", "Row 0 id = 1");
    assertEq(val(r1, 1, 0), "2", "Row 1 id = 2");
    assertEq(val(r1, 2, 0), "3", "Row 2 id = 3");
}

//=========================================================================
// UPDATE RETURNING
//=========================================================================

func testUpdateReturning() {
    section("UPDATE RETURNING");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE upd_ret (id INTEGER PRIMARY KEY, name TEXT, score INTEGER)");
    exec.executeSql("INSERT INTO upd_ret VALUES (1, 'Alice', 80)");
    exec.executeSql("INSERT INTO upd_ret VALUES (2, 'Bob', 90)");

    var r1 = exec.executeSql("UPDATE upd_ret SET score = score + 10 WHERE id = 1 RETURNING *");
    assertEqInt(r1.rows.count(), 1, "UPDATE RETURNING returns 1 row");
    assertEq(val(r1, 0, 0), "1", "RETURNING id = 1");
    assertEq(val(r1, 0, 2), "90", "RETURNING updated score = 90");
}

func testUpdateReturningMultiRow() {
    section("UPDATE RETURNING multiple rows");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE upd_ret2 (id INTEGER, val INTEGER)");
    exec.executeSql("INSERT INTO upd_ret2 VALUES (1, 10)");
    exec.executeSql("INSERT INTO upd_ret2 VALUES (2, 20)");
    exec.executeSql("INSERT INTO upd_ret2 VALUES (3, 30)");

    var r1 = exec.executeSql("UPDATE upd_ret2 SET val = val * 2 RETURNING id, val");
    assertEqInt(r1.rows.count(), 3, "UPDATE all rows RETURNING returns 3 rows");
    assertEq(val(r1, 0, 1), "20", "Row 0 doubled: 20");
    assertEq(val(r1, 1, 1), "40", "Row 1 doubled: 40");
    assertEq(val(r1, 2, 1), "60", "Row 2 doubled: 60");
}

//=========================================================================
// DELETE RETURNING
//=========================================================================

func testDeleteReturning() {
    section("DELETE RETURNING");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE del_ret (id INTEGER, name TEXT)");
    exec.executeSql("INSERT INTO del_ret VALUES (1, 'Alice')");
    exec.executeSql("INSERT INTO del_ret VALUES (2, 'Bob')");
    exec.executeSql("INSERT INTO del_ret VALUES (3, 'Carol')");

    var r1 = exec.executeSql("DELETE FROM del_ret WHERE id = 2 RETURNING *");
    assertEqInt(r1.rows.count(), 1, "DELETE RETURNING returns 1 row");
    assertEq(val(r1, 0, 0), "2", "RETURNING deleted id = 2");
    assertEq(val(r1, 0, 1), "Bob", "RETURNING deleted name = Bob");
}

func testDeleteReturningMulti() {
    section("DELETE RETURNING multiple rows");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE del_ret2 (id INTEGER, val TEXT)");
    exec.executeSql("INSERT INTO del_ret2 VALUES (1, 'a')");
    exec.executeSql("INSERT INTO del_ret2 VALUES (2, 'b')");
    exec.executeSql("INSERT INTO del_ret2 VALUES (3, 'c')");

    var r1 = exec.executeSql("DELETE FROM del_ret2 WHERE id > 1 RETURNING id");
    assertEqInt(r1.rows.count(), 2, "DELETE RETURNING returns 2 deleted rows");
    assertEq(val(r1, 0, 0), "2", "First deleted id = 2");
    assertEq(val(r1, 1, 0), "3", "Second deleted id = 3");
}

//=========================================================================
// INSERT ON CONFLICT (UPSERT)
//=========================================================================

func testOnConflictDoNothing() {
    section("ON CONFLICT DO NOTHING");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE upsert_t (id INTEGER PRIMARY KEY, name TEXT)");
    exec.executeSql("INSERT INTO upsert_t VALUES (1, 'Alice')");

    var r1 = exec.executeSql("INSERT INTO upsert_t VALUES (1, 'Bob') ON CONFLICT (id) DO NOTHING");
    assertSuccess(r1, "ON CONFLICT DO NOTHING succeeds");

    var r2 = exec.executeSql("SELECT * FROM upsert_t");
    assertEqInt(r2.rows.count(), 1, "Still only 1 row");
    assertEq(val(r2, 0, 1), "Alice", "Original value preserved");
}

func testOnConflictDoUpdate() {
    section("ON CONFLICT DO UPDATE");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE upsert2 (id INTEGER PRIMARY KEY, name TEXT, score INTEGER)");
    exec.executeSql("INSERT INTO upsert2 VALUES (1, 'Alice', 80)");
    exec.executeSql("INSERT INTO upsert2 VALUES (2, 'Bob', 90)");

    var r1 = exec.executeSql("INSERT INTO upsert2 VALUES (1, 'Alice Updated', 95) ON CONFLICT (id) DO UPDATE SET name = 'Alice Updated', score = 95");
    assertSuccess(r1, "ON CONFLICT DO UPDATE succeeds");

    var r2 = exec.executeSql("SELECT * FROM upsert2 WHERE id = 1");
    assertEq(val(r2, 0, 1), "Alice Updated", "Name updated via upsert");
    assertEq(val(r2, 0, 2), "95", "Score updated via upsert");

    // Non-conflicting row should insert normally
    var r3 = exec.executeSql("INSERT INTO upsert2 VALUES (3, 'Carol', 70) ON CONFLICT (id) DO UPDATE SET name = 'Ignored'");
    assertSuccess(r3, "Non-conflicting insert with ON CONFLICT succeeds");

    var r4 = exec.executeSql("SELECT * FROM upsert2 WHERE id = 3");
    assertEq(val(r4, 0, 1), "Carol", "Non-conflicting row inserted normally");
}

func testOnConflictDoNothingMulti() {
    section("ON CONFLICT DO NOTHING multi-row");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE upsert3 (id INTEGER PRIMARY KEY, val TEXT)");
    exec.executeSql("INSERT INTO upsert3 VALUES (1, 'a')");
    exec.executeSql("INSERT INTO upsert3 VALUES (2, 'b')");

    // Insert rows 2 and 3 — 2 conflicts, 3 is new
    var r1 = exec.executeSql("INSERT INTO upsert3 VALUES (2, 'new_b'), (3, 'c') ON CONFLICT (id) DO NOTHING");
    assertSuccess(r1, "Multi-row ON CONFLICT DO NOTHING succeeds");

    var r2 = exec.executeSql("SELECT * FROM upsert3 ORDER BY id");
    assertEqInt(r2.rows.count(), 3, "3 total rows (1 new, 1 skipped, 1 existing)");
    assertEq(val(r2, 1, 1), "b", "Conflicting row kept original value");
    assertEq(val(r2, 2, 1), "c", "New row inserted");
}

//=========================================================================
// GENERATE_SERIES
//=========================================================================

func testGenerateSeriesBasic() {
    section("GENERATE_SERIES basic");

    var exec = new Executor();
    exec.init();

    var r1 = exec.executeSql("SELECT * FROM generate_series(1, 5)");
    assertSuccess(r1, "generate_series(1,5) succeeds");
    assertEqInt(r1.rows.count(), 5, "generate_series(1,5) returns 5 rows");
    assertEq(val(r1, 0, 0), "1", "First value is 1");
    assertEq(val(r1, 4, 0), "5", "Last value is 5");
}

func testGenerateSeriesWithStep() {
    section("GENERATE_SERIES with step");

    var exec = new Executor();
    exec.init();

    var r1 = exec.executeSql("SELECT * FROM generate_series(0, 10, 2)");
    assertSuccess(r1, "generate_series(0,10,2) succeeds");
    assertEqInt(r1.rows.count(), 6, "generate_series(0,10,2) returns 6 rows (0,2,4,6,8,10)");
    assertEq(val(r1, 0, 0), "0", "First = 0");
    assertEq(val(r1, 5, 0), "10", "Last = 10");
}

func testGenerateSeriesDescending() {
    section("GENERATE_SERIES descending");

    var exec = new Executor();
    exec.init();

    var r1 = exec.executeSql("SELECT * FROM generate_series(5, 1, -1)");
    assertSuccess(r1, "Descending generate_series succeeds");
    assertEqInt(r1.rows.count(), 5, "Descending series 5..1 has 5 rows");
    assertEq(val(r1, 0, 0), "5", "First = 5");
    assertEq(val(r1, 4, 0), "1", "Last = 1");
}

func testGenerateSeriesWithLimit() {
    section("GENERATE_SERIES with LIMIT");

    var exec = new Executor();
    exec.init();

    var r1 = exec.executeSql("SELECT * FROM generate_series(1, 100) LIMIT 5");
    assertSuccess(r1, "generate_series with LIMIT succeeds");
    assertEqInt(r1.rows.count(), 5, "LIMIT 5 returns 5 rows");
    assertEq(val(r1, 0, 0), "1", "First = 1");
    assertEq(val(r1, 4, 0), "5", "Fifth = 5");
}

func testGenerateSeriesEmpty() {
    section("GENERATE_SERIES empty");

    var exec = new Executor();
    exec.init();

    // start > stop with positive step → empty
    var r1 = exec.executeSql("SELECT * FROM generate_series(10, 1)");
    assertSuccess(r1, "Empty generate_series succeeds");
    assertEqInt(r1.rows.count(), 0, "generate_series(10,1) returns 0 rows");
}

func main() -> Integer {
    Terminal.Say("=== Phase 29: Common SQL Extensions ===");

    testTruncateTable();
    testTruncateWithoutTableKeyword();
    testTruncateNonexistent();
    testTruncatePartitioned();
    testInsertReturning();
    testInsertReturningColumns();
    testInsertReturningMultiRow();
    testUpdateReturning();
    testUpdateReturningMultiRow();
    testDeleteReturning();
    testDeleteReturningMulti();
    testOnConflictDoNothing();
    testOnConflictDoUpdate();
    testOnConflictDoNothingMulti();
    testGenerateSeriesBasic();
    testGenerateSeriesWithStep();
    testGenerateSeriesDescending();
    testGenerateSeriesWithLimit();
    testGenerateSeriesEmpty();

    printResults();
    return 0;
}
