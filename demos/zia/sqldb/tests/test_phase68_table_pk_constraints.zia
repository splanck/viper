// test_phase68_table_pk_constraints.zia — Phase 68: TABLE expression, composite PK, named constraints
// Tests for TABLE expression, composite PRIMARY KEY, and named constraints.

module test_phase68_table_pk_constraints;

bind Terminal = Viper.Terminal;
bind Fmt = Viper.Fmt;

bind "./test_common";
bind "../executor";
bind "../types";

//=========================================================================
// TABLE expression — shorthand for SELECT * FROM table
//=========================================================================

func testTableExpression() {
    section("TABLE expression");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE colors (id INTEGER PRIMARY KEY, name TEXT)");
    exec.executeSql("INSERT INTO colors VALUES (1, 'Red')");
    exec.executeSql("INSERT INTO colors VALUES (2, 'Green')");
    exec.executeSql("INSERT INTO colors VALUES (3, 'Blue')");

    var r1 = exec.executeSql("TABLE colors");
    assertSuccess(r1, "TABLE expression succeeds");
    assertRowCount(r1, 3, "Returns all rows");
    assertEq(val(r1, 0, 1), "Red", "First row is Red");
    assertEq(val(r1, 1, 1), "Green", "Second row is Green");
    assertEq(val(r1, 2, 1), "Blue", "Third row is Blue");
}

//=========================================================================
// TABLE expression — empty table
//=========================================================================

func testTableExpressionEmpty() {
    section("TABLE expression empty");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE empty_t (id INTEGER, name TEXT)");

    var r1 = exec.executeSql("TABLE empty_t");
    assertSuccess(r1, "TABLE on empty table");
    assertRowCount(r1, 0, "0 rows");
}

//=========================================================================
// Composite PRIMARY KEY — table-level
//=========================================================================

func testCompositePK() {
    section("Composite PRIMARY KEY");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE scores (student_id INTEGER, course_id INTEGER, score INTEGER, PRIMARY KEY (student_id, course_id))");

    // Verify columns have PK set
    var r1 = exec.executeSql("SHOW COLUMNS FROM scores");
    assertSuccess(r1, "SHOW COLUMNS succeeds");
    assertRowCount(r1, 3, "3 columns");
    assertEq(val(r1, 0, 0), "student_id", "Col 0 name");
    assertEq(val(r1, 0, 4), "YES", "student_id is PK");
    assertEq(val(r1, 0, 2), "NO", "student_id NOT NULL");
    assertEq(val(r1, 1, 0), "course_id", "Col 1 name");
    assertEq(val(r1, 1, 4), "YES", "course_id is PK");
    assertEq(val(r1, 2, 4), "NO", "score is not PK");

    // Can insert data
    exec.executeSql("INSERT INTO scores VALUES (1, 101, 95)");
    exec.executeSql("INSERT INTO scores VALUES (1, 102, 88)");
    exec.executeSql("INSERT INTO scores VALUES (2, 101, 92)");

    var r2 = exec.executeSql("SELECT * FROM scores ORDER BY student_id, course_id");
    assertRowCount(r2, 3, "3 rows inserted");
    assertEq(val(r2, 0, 2), "95", "Score for (1,101)");
    assertEq(val(r2, 1, 2), "88", "Score for (1,102)");
}

//=========================================================================
// Composite PRIMARY KEY — SHOW CREATE TABLE reflects it
//=========================================================================

func testCompositePKShowCreate() {
    section("Composite PK in SHOW CREATE TABLE");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE inventory (warehouse_id INTEGER, product_id INTEGER, qty INTEGER, PRIMARY KEY (warehouse_id, product_id))");

    var r1 = exec.executeSql("SHOW CREATE TABLE inventory");
    assertSuccess(r1, "SHOW CREATE TABLE succeeds");

    var ddl = val(r1, 0, 1);
    assertTrue(stringContains(ddl, "warehouse_id INTEGER PRIMARY KEY"), "DDL has warehouse_id PK");
    assertTrue(stringContains(ddl, "product_id INTEGER PRIMARY KEY"), "DDL has product_id PK");
}

//=========================================================================
// Named CONSTRAINT on column CHECK
//=========================================================================

func testNamedConstraint() {
    section("Named CONSTRAINT");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE products (id INTEGER, price INTEGER CONSTRAINT chk_positive CHECK (price > 0), name TEXT)");

    // Verify it works — positive price
    exec.executeSql("INSERT INTO products VALUES (1, 50, 'Widget')");
    var r1 = exec.executeSql("SELECT * FROM products");
    assertSuccess(r1, "Insert with valid price");
    assertRowCount(r1, 1, "1 row");

    // Verify CHECK is enforced
    var r2 = exec.executeSql("INSERT INTO products VALUES (2, -5, 'Bad')");
    assertFailure(r2, "Negative price rejected by CHECK");
}

//=========================================================================
// Table-level CHECK constraint
//=========================================================================

func testTableLevelCheck() {
    section("Table-level CHECK");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE ranges (low INTEGER, high INTEGER, CHECK (low < high))");

    exec.executeSql("INSERT INTO ranges VALUES (1, 10)");
    var r1 = exec.executeSql("SELECT * FROM ranges");
    assertSuccess(r1, "Valid range accepted");
    assertRowCount(r1, 1, "1 row");
}

//=========================================================================
// Table-level PRIMARY KEY with CONSTRAINT name
//=========================================================================

func testNamedCompositePK() {
    section("CONSTRAINT name PRIMARY KEY");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE assignments (employee_id INTEGER, project_id INTEGER, role TEXT, CONSTRAINT pk_assign PRIMARY KEY (employee_id, project_id))");

    var r1 = exec.executeSql("SHOW COLUMNS FROM assignments");
    assertSuccess(r1, "SHOW COLUMNS");
    assertEq(val(r1, 0, 4), "YES", "employee_id is PK");
    assertEq(val(r1, 1, 4), "YES", "project_id is PK");
    assertEq(val(r1, 2, 4), "NO", "role is not PK");

    exec.executeSql("INSERT INTO assignments VALUES (1, 100, 'lead')");
    exec.executeSql("INSERT INTO assignments VALUES (1, 200, 'member')");
    var r2 = exec.executeSql("TABLE assignments");
    assertRowCount(r2, 2, "2 rows via TABLE expression");
}

//=========================================================================
// Composite PK — duplicate rejection
//=========================================================================

func testCompositePKDuplicate() {
    section("Composite PK duplicate rejection");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE enrollments (student INTEGER, course INTEGER, grade TEXT, PRIMARY KEY (student, course))");

    exec.executeSql("INSERT INTO enrollments VALUES (1, 101, 'A')");
    exec.executeSql("INSERT INTO enrollments VALUES (1, 102, 'B')");
    exec.executeSql("INSERT INTO enrollments VALUES (2, 101, 'C')");

    // Exact composite key duplicate should fail
    var r1 = exec.executeSql("INSERT INTO enrollments VALUES (1, 101, 'D')");
    assertFailure(r1, "Composite PK duplicate rejected");

    // Same first column, different second — should succeed
    exec.executeSql("INSERT INTO enrollments VALUES (1, 103, 'A')");
    var r2 = exec.executeSql("TABLE enrollments");
    assertRowCount(r2, 4, "4 rows total");
}

//=========================================================================
// MAIN
//=========================================================================

func main() {
    Terminal.Say("=== Phase 68: TABLE expr, Composite PK, Named Constraints ===");

    testTableExpression();
    testTableExpressionEmpty();
    testCompositePK();
    testCompositePKShowCreate();
    testNamedConstraint();
    testTableLevelCheck();
    testNamedCompositePK();
    testCompositePKDuplicate();

    printResults();
}
