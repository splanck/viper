// test_phase41_do_blocks.zia â€” Phase 41: DO Blocks & Multi-Statement
// Tests for DO anonymous code blocks.

module test_phase41_do_blocks;

bind Terminal = Viper.Terminal;
bind String = Viper.String;
bind Fmt = Viper.Fmt;

bind "./test_common";
bind "../executor";
bind "../types";

//=========================================================================
// DO with string body
//=========================================================================

func testDoBasic() {
    section("DO basic");

    var exec = new Executor();
    exec.init();

    // DO with single statement
    var r1 = exec.executeSql("DO 'CREATE TABLE do_t (id INTEGER, name TEXT)'");
    assertSuccess(r1, "DO single statement");
    assertTrue(stringContains(r1.message, "DO"), "DO message");

    // Verify table was created
    var r2 = exec.executeSql("INSERT INTO do_t VALUES (1, 'hello')");
    assertSuccess(r2, "table exists after DO");

    var r3 = exec.executeSql("SELECT name FROM do_t WHERE id = 1");
    assertSuccess(r3, "query after DO");
    assertEq(val(r3, 0, 0), "hello", "data correct");
}

//=========================================================================
// DO with multiple statements
//=========================================================================

func testDoMulti() {
    section("DO multiple statements");

    var exec = new Executor();
    exec.init();

    // Multiple statements separated by semicolons (integer-only to avoid quote issues)
    var r1 = exec.executeSql("DO 'CREATE TABLE multi_t (id INTEGER, val INTEGER); INSERT INTO multi_t VALUES (1, 10); INSERT INTO multi_t VALUES (2, 20); INSERT INTO multi_t VALUES (3, 30)'");
    assertSuccess(r1, "DO with multiple statements");
    assertTrue(stringContains(r1.message, "4"), "4 statements executed");

    var r2 = exec.executeSql("SELECT COUNT(*) FROM multi_t");
    assertEq(val(r2, 0, 0), "3", "3 rows inserted");
}

//=========================================================================
// DO error stops execution
//=========================================================================

func testDoError() {
    section("DO error handling");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE err_do_t (id INTEGER)");

    // Error in middle of DO block should stop execution
    var r1 = exec.executeSql("DO 'INSERT INTO err_do_t VALUES (1); INSERT INTO nonexistent VALUES (2); INSERT INTO err_do_t VALUES (3)'");
    assertFailure(r1, "DO stops on error");

    // Only first insert should have succeeded
    var r2 = exec.executeSql("SELECT COUNT(*) FROM err_do_t");
    assertEq(val(r2, 0, 0), "1", "only 1 row before error");
}

//=========================================================================
// DO empty
//=========================================================================

func testDoEmpty() {
    section("DO empty block");

    var exec = new Executor();
    exec.init();

    var r1 = exec.executeSql("DO ''");
    assertFailure(r1, "empty DO block fails");
}

//=========================================================================
// DO with DDL + DML combo
//=========================================================================

func testDoDdlDml() {
    section("DO with DDL + DML");

    var exec = new Executor();
    exec.init();

    var r1 = exec.executeSql("DO 'CREATE TABLE combo_t (x INTEGER); INSERT INTO combo_t VALUES (10); INSERT INTO combo_t VALUES (20)'");
    assertSuccess(r1, "DO DDL+DML combo");

    var r2 = exec.executeSql("SELECT SUM(x) FROM combo_t");
    assertEq(val(r2, 0, 0), "30", "sum is 30");
}

//=========================================================================
// MAIN
//=========================================================================

func main() {
    Terminal.Say("=== Phase 41: DO Blocks ===");

    testDoBasic();
    testDoMulti();
    testDoError();
    testDoEmpty();
    testDoDdlDml();

    printResults();
}
