// test_phase5_optimizer.zia â€” Phase 5: Query Optimizer Integration Tests
// Tests for EXPLAIN, cost-based access path selection, stats tracking

module test_phase5_optimizer;

bind Terminal = Viper.Terminal;
bind String = Viper.String;
bind Fmt = Viper.Fmt;

bind "../executor";
bind "../types";

var passCount = 0;
var failCount = 0;

func assert(condition: Boolean, msg: String) {
    if condition {
        passCount = passCount + 1;
    } else {
        Terminal.Say("FAIL: " + msg);
        failCount = failCount + 1;
    }
}

func check(result: QueryResult, label: String) {
    if result.success == false {
        Terminal.Say("FAIL: " + label + " => " + result.message);
        failCount = failCount + 1;
    } else {
        passCount = passCount + 1;
    }
}

func val(result: QueryResult, row: Integer, col: Integer) -> String {
    var r = result.getRow(row);
    if r == null { return "NULL_ROW"; }
    var rr = r;
    return rr.getValue(col).toString();
}

func contains(s: String, sub: String) -> Boolean {
    var sLen = String.Length(s);
    var subLen = String.Length(sub);
    if subLen > sLen { return false; }
    var i = 0;
    while i <= sLen - subLen {
        if String.Substring(s, i, subLen) == sub {
            return true;
        }
        i = i + 1;
    }
    return false;
}

func main() {
    Terminal.Say("=== Phase 5: Query Optimizer Integration Tests ===");

    var exec = new Executor();
    exec.init();

    //=========================================================================
    // 1. EXPLAIN with simple table scan (no index)
    //=========================================================================
    Terminal.Say("--- EXPLAIN Table Scan ---");

    check(exec.executeSql("CREATE TABLE employees (id INTEGER PRIMARY KEY, name TEXT, dept TEXT, salary INTEGER)"), "create employees");
    check(exec.executeSql("INSERT INTO employees VALUES (1, 'Alice', 'Engineering', 90000)"), "insert 1");
    check(exec.executeSql("INSERT INTO employees VALUES (2, 'Bob', 'Marketing', 70000)"), "insert 2");
    check(exec.executeSql("INSERT INTO employees VALUES (3, 'Carol', 'Engineering', 95000)"), "insert 3");
    check(exec.executeSql("INSERT INTO employees VALUES (4, 'Dave', 'Sales', 65000)"), "insert 4");
    check(exec.executeSql("INSERT INTO employees VALUES (5, 'Eve', 'Marketing', 72000)"), "insert 5");

    // EXPLAIN simple SELECT *
    var r1 = exec.executeSql("EXPLAIN SELECT * FROM employees");
    check(r1, "explain select *");
    assert(r1.rowCount() > 0, "explain has output rows");
    var planLine = val(r1, 0, 0);
    // Should mention QueryPlan
    assert(contains(planLine, "QueryPlan"), "explain shows QueryPlan: " + planLine);

    // EXPLAIN with WHERE but no index
    var r2 = exec.executeSql("EXPLAIN SELECT * FROM employees WHERE salary > 80000");
    check(r2, "explain select with where");
    assert(r2.rowCount() > 0, "explain where has output");
    // Should show TableScan since no index on salary
    var found_table_scan = false;
    var ri = 0;
    while ri < r2.rowCount() {
        var line = val(r2, ri, 0);
        if contains(line, "TableScan") {
            found_table_scan = true;
        }
        ri = ri + 1;
    }
    assert(found_table_scan, "explain shows TableScan for non-indexed column");

    //=========================================================================
    // 2. EXPLAIN with index seek
    //=========================================================================
    Terminal.Say("--- EXPLAIN Index Seek ---");

    check(exec.executeSql("CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, price INTEGER, category TEXT)"), "create products");
    // Insert enough data so index is cost-effective
    var pi = 1;
    while pi <= 50 {
        check(exec.executeSql("INSERT INTO products VALUES (" + Fmt.Int(pi) + ", 'Product " + Fmt.Int(pi) + "', " + Fmt.Int(pi * 10) + ", 'cat" + Fmt.Int(pi % 5) + "')"), "insert product " + Fmt.Int(pi));
        pi = pi + 1;
    }

    check(exec.executeSql("CREATE INDEX idx_products_category ON products(category)"), "create category index");

    var r3 = exec.executeSql("EXPLAIN SELECT * FROM products WHERE category = 'cat1'");
    check(r3, "explain with index");
    assert(r3.rowCount() > 0, "explain index has output");
    // Should show IndexSeek since we have an index on category
    var found_index_seek = false;
    ri = 0;
    while ri < r3.rowCount() {
        var line = val(r3, ri, 0);
        if contains(line, "IndexSeek") {
            found_index_seek = true;
        }
        ri = ri + 1;
    }
    assert(found_index_seek, "explain shows IndexSeek for indexed column");

    //=========================================================================
    // 3. Optimizer statistics tracking
    //=========================================================================
    Terminal.Say("--- Optimizer Statistics ---");

    // Stats should reflect current row counts
    var empStats = exec.optimizer.stats.getRowCount("employees");
    assert(empStats == 5, "employees stats = 5, got " + Fmt.Int(empStats));

    var prodStats = exec.optimizer.stats.getRowCount("products");
    assert(prodStats == 50, "products stats = 50, got " + Fmt.Int(prodStats));

    // Stats should update after DELETE
    check(exec.executeSql("DELETE FROM employees WHERE id = 5"), "delete employee 5");
    empStats = exec.optimizer.stats.getRowCount("employees");
    assert(empStats == 4, "employees stats after delete = 4, got " + Fmt.Int(empStats));

    // Stats should update after INSERT
    check(exec.executeSql("INSERT INTO employees VALUES (6, 'Frank', 'Sales', 68000)"), "insert employee 6");
    empStats = exec.optimizer.stats.getRowCount("employees");
    assert(empStats == 5, "employees stats after insert = 5, got " + Fmt.Int(empStats));

    // Stats should update after UPDATE (row count stays same)
    check(exec.executeSql("UPDATE employees SET salary = 100000 WHERE id = 1"), "update employee 1");
    empStats = exec.optimizer.stats.getRowCount("employees");
    assert(empStats == 5, "employees stats after update = 5, got " + Fmt.Int(empStats));

    //=========================================================================
    // 4. EXPLAIN for expression-only SELECT
    //=========================================================================
    Terminal.Say("--- EXPLAIN Expression Select ---");

    var r4 = exec.executeSql("EXPLAIN SELECT 1 + 2");
    check(r4, "explain expression select");
    assert(r4.rowCount() > 0, "explain expr has output");
    var exprLine = val(r4, 0, 0);
    assert(contains(exprLine, "ExpressionScan"), "explain shows ExpressionScan: " + exprLine);

    //=========================================================================
    // 5. EXPLAIN for JOIN queries
    //=========================================================================
    Terminal.Say("--- EXPLAIN Join ---");

    check(exec.executeSql("CREATE TABLE orders (id INTEGER PRIMARY KEY, emp_id INTEGER, amount INTEGER)"), "create orders");
    check(exec.executeSql("INSERT INTO orders VALUES (1, 1, 500)"), "insert order 1");
    check(exec.executeSql("INSERT INTO orders VALUES (2, 2, 300)"), "insert order 2");
    check(exec.executeSql("INSERT INTO orders VALUES (3, 1, 700)"), "insert order 3");

    var r5 = exec.executeSql("EXPLAIN SELECT * FROM employees INNER JOIN orders ON employees.id = orders.emp_id");
    check(r5, "explain join");
    assert(r5.rowCount() > 0, "explain join has output");
    // Should show both tables and join info
    var foundEmployees = false;
    var foundOrders = false;
    var foundJoin = false;
    ri = 0;
    while ri < r5.rowCount() {
        var line = val(r5, ri, 0);
        if contains(line, "employees") {
            foundEmployees = true;
        }
        if contains(line, "orders") {
            foundOrders = true;
        }
        if contains(line, "Join") || contains(line, "join") {
            foundJoin = true;
        }
        ri = ri + 1;
    }
    assert(foundEmployees, "explain join mentions employees");
    assert(foundOrders, "explain join mentions orders");
    assert(foundJoin, "explain join mentions join type");

    //=========================================================================
    // 6. Cost-based access path selection works correctly
    //=========================================================================
    Terminal.Say("--- Cost-Based Selection ---");

    // Verify index is actually used for equality lookup
    // The query should return correct results using index
    var r6 = exec.executeSql("SELECT name, price FROM products WHERE category = 'cat0'");
    check(r6, "index-assisted query");
    assert(r6.rowCount() == 10, "should find 10 products in cat0, got " + Fmt.Int(r6.rowCount()));

    // Verify correctness: no index query also works
    var r7 = exec.executeSql("SELECT name FROM employees WHERE dept = 'Engineering'");
    check(r7, "non-indexed query");
    assert(r7.rowCount() == 2, "should find 2 engineers, got " + Fmt.Int(r7.rowCount()));

    //=========================================================================
    // 7. EXPLAIN error handling
    //=========================================================================
    Terminal.Say("--- EXPLAIN Errors ---");

    var r8 = exec.executeSql("EXPLAIN INSERT INTO employees VALUES (7, 'Grace', 'HR', 60000)");
    assert(r8.success == false, "explain non-select should error");
    assert(contains(r8.message, "SELECT"), "error mentions SELECT");

    //=========================================================================
    // 8. Cost display formatting
    //=========================================================================
    Terminal.Say("--- Cost Formatting ---");

    // Verify cost values are non-zero and properly formatted
    var r9 = exec.executeSql("EXPLAIN SELECT * FROM products");
    check(r9, "explain products");
    var costLine = val(r9, 0, 0);
    assert(contains(costLine, "cost"), "plan shows cost: " + costLine);

    // With 50 rows, cost should be meaningful (50 * 100 / 100 = 50.00)
    assert(contains(costLine, "50.00"), "products table scan cost shows 50.00: " + costLine);

    //=========================================================================
    // 9. Small table optimization (table scan beats index)
    //=========================================================================
    Terminal.Say("--- Small Table Optimization ---");

    check(exec.executeSql("CREATE TABLE tiny (id INTEGER PRIMARY KEY, val TEXT)"), "create tiny");
    check(exec.executeSql("INSERT INTO tiny VALUES (1, 'a')"), "insert tiny 1");
    check(exec.executeSql("CREATE INDEX idx_tiny_val ON tiny(val)"), "create tiny index");

    // For a 1-row table, table scan cost = 1*100 = 100
    // Index seek cost = 100 + 1*30 = 130
    // So table scan should be preferred!
    var r10 = exec.executeSql("EXPLAIN SELECT * FROM tiny WHERE val = 'a'");
    check(r10, "explain tiny table");
    var found_scan_preferred = false;
    ri = 0;
    while ri < r10.rowCount() {
        var line = val(r10, ri, 0);
        if contains(line, "Table scan preferred") || contains(line, "TableScan") {
            found_scan_preferred = true;
        }
        ri = ri + 1;
    }
    assert(found_scan_preferred, "tiny table prefers scan over index");

    //=========================================================================
    // 10. Optimizer with empty table
    //=========================================================================
    Terminal.Say("--- Empty Table ---");

    check(exec.executeSql("CREATE TABLE empty_tbl (id INTEGER PRIMARY KEY, val TEXT)"), "create empty_tbl");

    var r11 = exec.executeSql("EXPLAIN SELECT * FROM empty_tbl");
    check(r11, "explain empty table");
    assert(r11.rowCount() > 0, "explain empty has output");

    // Empty table should use default row estimate (100)
    var emptyPlan = val(r11, 0, 0);
    assert(contains(emptyPlan, "100.00"), "empty table uses default 100 row estimate: " + emptyPlan);

    //=========================================================================
    // Summary
    //=========================================================================
    Terminal.Say("");
    Terminal.Say("=== Phase 5 Optimizer: " + Fmt.Int(passCount) + " passed, " + Fmt.Int(failCount) + " failed ===");
}
