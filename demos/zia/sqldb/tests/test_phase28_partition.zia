// test_phase28_partition.zia — Phase 28: Table Partitioning
// Tests for PARTITION BY RANGE/LIST/HASH, partition routing on INSERT,
// partition-aware SELECT, partition pruning, and error handling.

module test_phase28_partition;

bind Terminal = Viper.Terminal;
bind String = Viper.String;
bind Fmt = Viper.Fmt;

bind "./test_common";
bind "../executor";
bind "../types";

func testRangePartitionCreate() {
    section("RANGE Partition — Create");

    var exec = new Executor();
    exec.init();

    var r1 = exec.executeSql("CREATE TABLE orders (id INTEGER, amount INTEGER, region TEXT) PARTITION BY RANGE (id)");
    assertSuccess(r1, "CREATE partitioned table succeeds");
    assertTrue(stringContains(r1.message, "Partitioned table"), "Reports partitioned table created");
    assertTrue(stringContains(r1.message, "RANGE"), "Reports RANGE partition type");

    // Create child partitions
    var r2 = exec.executeSql("CREATE TABLE orders_p1 PARTITION OF orders FOR VALUES FROM (1) TO (100)");
    assertSuccess(r2, "Create range partition p1 succeeds");
    assertTrue(stringContains(r2.message, "Partition"), "Reports partition created");

    var r3 = exec.executeSql("CREATE TABLE orders_p2 PARTITION OF orders FOR VALUES FROM (100) TO (200)");
    assertSuccess(r3, "Create range partition p2 succeeds");

    var r4 = exec.executeSql("CREATE TABLE orders_p3 PARTITION OF orders FOR VALUES FROM (200) TO (MAXVALUE)");
    assertSuccess(r4, "Create range partition p3 with MAXVALUE succeeds");
}

func testRangePartitionInsert() {
    section("RANGE Partition — INSERT Routing");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE sales (id INTEGER, amount INTEGER) PARTITION BY RANGE (id)");
    exec.executeSql("CREATE TABLE sales_low PARTITION OF sales FOR VALUES FROM (MINVALUE) TO (50)");
    exec.executeSql("CREATE TABLE sales_mid PARTITION OF sales FOR VALUES FROM (50) TO (100)");
    exec.executeSql("CREATE TABLE sales_high PARTITION OF sales FOR VALUES FROM (100) TO (MAXVALUE)");

    exec.executeSql("INSERT INTO sales VALUES (10, 100)");
    exec.executeSql("INSERT INTO sales VALUES (75, 200)");
    exec.executeSql("INSERT INTO sales VALUES (150, 300)");

    // Verify rows are in the correct partitions
    var r1 = exec.executeSql("SELECT * FROM sales_low");
    assertEqInt(r1.rows.count(), 1, "sales_low has 1 row (id=10)");
    assertEq(val(r1, 0, 0), "10", "sales_low row has id=10");

    var r2 = exec.executeSql("SELECT * FROM sales_mid");
    assertEqInt(r2.rows.count(), 1, "sales_mid has 1 row (id=75)");

    var r3 = exec.executeSql("SELECT * FROM sales_high");
    assertEqInt(r3.rows.count(), 1, "sales_high has 1 row (id=150)");
}

func testRangePartitionSelect() {
    section("RANGE Partition — SELECT from Parent");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE items (id INTEGER, name TEXT) PARTITION BY RANGE (id)");
    exec.executeSql("CREATE TABLE items_p1 PARTITION OF items FOR VALUES FROM (1) TO (50)");
    exec.executeSql("CREATE TABLE items_p2 PARTITION OF items FOR VALUES FROM (50) TO (100)");

    exec.executeSql("INSERT INTO items VALUES (5, 'Alpha')");
    exec.executeSql("INSERT INTO items VALUES (25, 'Beta')");
    exec.executeSql("INSERT INTO items VALUES (75, 'Gamma')");

    // SELECT from parent should merge all partition data
    var r1 = exec.executeSql("SELECT * FROM items");
    assertEqInt(r1.rows.count(), 3, "SELECT * FROM parent returns all 3 rows");

    // SELECT with WHERE on partition column
    var r2 = exec.executeSql("SELECT * FROM items WHERE id = 25");
    assertEqInt(r2.rows.count(), 1, "WHERE id=25 returns 1 row");
    assertEq(val(r2, 0, 1), "Beta", "Correct row for id=25");

    // SELECT with non-partition WHERE
    var r3 = exec.executeSql("SELECT * FROM items WHERE name = 'Gamma'");
    assertEqInt(r3.rows.count(), 1, "WHERE name='Gamma' returns 1 row");
}

func testListPartition() {
    section("LIST Partition");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE regions (id INTEGER, region TEXT, val INTEGER) PARTITION BY LIST (region)");
    exec.executeSql("CREATE TABLE regions_us PARTITION OF regions FOR VALUES IN ('US', 'CA')");
    exec.executeSql("CREATE TABLE regions_eu PARTITION OF regions FOR VALUES IN ('UK', 'DE', 'FR')");
    exec.executeSql("CREATE TABLE regions_apac PARTITION OF regions FOR VALUES IN ('JP', 'AU')");

    exec.executeSql("INSERT INTO regions VALUES (1, 'US', 100)");
    exec.executeSql("INSERT INTO regions VALUES (2, 'UK', 200)");
    exec.executeSql("INSERT INTO regions VALUES (3, 'JP', 300)");
    exec.executeSql("INSERT INTO regions VALUES (4, 'CA', 400)");

    var r1 = exec.executeSql("SELECT * FROM regions_us");
    assertEqInt(r1.rows.count(), 2, "US partition has 2 rows (US + CA)");

    var r2 = exec.executeSql("SELECT * FROM regions_eu");
    assertEqInt(r2.rows.count(), 1, "EU partition has 1 row (UK)");

    var r3 = exec.executeSql("SELECT * FROM regions");
    assertEqInt(r3.rows.count(), 4, "Parent SELECT returns all 4 rows");
}

func testHashPartition() {
    section("HASH Partition");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE hdata (id INTEGER, val TEXT) PARTITION BY HASH (id)");
    exec.executeSql("CREATE TABLE hdata_p0 PARTITION OF hdata FOR VALUES WITH (MODULUS 3, REMAINDER 0)");
    exec.executeSql("CREATE TABLE hdata_p1 PARTITION OF hdata FOR VALUES WITH (MODULUS 3, REMAINDER 1)");
    exec.executeSql("CREATE TABLE hdata_p2 PARTITION OF hdata FOR VALUES WITH (MODULUS 3, REMAINDER 2)");

    // Insert values 0-8 (each remainder 0,1,2 gets 3 values)
    var i = 0;
    while i < 9 {
        exec.executeSql("INSERT INTO hdata VALUES (" + Fmt.Int(i) + ", 'v" + Fmt.Int(i) + "')");
        i = i + 1;
    }

    // Verify all 9 rows across partitions
    var r0 = exec.executeSql("SELECT * FROM hdata_p0");
    var r1 = exec.executeSql("SELECT * FROM hdata_p1");
    var r2 = exec.executeSql("SELECT * FROM hdata_p2");

    var totalRows = r0.rows.count() + r1.rows.count() + r2.rows.count();
    assertEqInt(totalRows, 9, "All 9 rows distributed across 3 hash partitions");
    assertTrue(r0.rows.count() > 0, "hash partition 0 has rows");
    assertTrue(r1.rows.count() > 0, "hash partition 1 has rows");
    assertTrue(r2.rows.count() > 0, "hash partition 2 has rows");

    // SELECT from parent returns all
    var r3 = exec.executeSql("SELECT * FROM hdata");
    assertEqInt(r3.rows.count(), 9, "Parent SELECT returns all 9 rows");
}

func testPartitionErrors() {
    section("Partition Error Handling");

    var exec = new Executor();
    exec.init();

    // PARTITION OF nonexistent parent
    var r1 = exec.executeSql("CREATE TABLE bad_child PARTITION OF nonexistent FOR VALUES FROM (1) TO (100)");
    assertTrue(r1.success == false, "PARTITION OF nonexistent parent fails");

    // PARTITION OF non-partitioned table
    exec.executeSql("CREATE TABLE plain_t (id INTEGER)");
    var r2 = exec.executeSql("CREATE TABLE bad_child2 PARTITION OF plain_t FOR VALUES FROM (1) TO (100)");
    assertTrue(r2.success == false, "PARTITION OF non-partitioned table fails");

    // INSERT with no matching partition
    exec.executeSql("CREATE TABLE bounded (id INTEGER) PARTITION BY RANGE (id)");
    exec.executeSql("CREATE TABLE bounded_p1 PARTITION OF bounded FOR VALUES FROM (1) TO (100)");
    var r3 = exec.executeSql("INSERT INTO bounded VALUES (200)");
    assertTrue(r3.success == false, "INSERT with no matching partition fails");

    // INSERT into parent with no partitions
    exec.executeSql("CREATE TABLE empty_part (id INTEGER) PARTITION BY RANGE (id)");
    var r4 = exec.executeSql("INSERT INTO empty_part VALUES (1)");
    assertTrue(r4.success == false, "INSERT into parent with no partitions fails");
}

func testPartitionColumnInheritance() {
    section("Partition Column Inheritance");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE parent_t (id INTEGER, name TEXT, score INTEGER) PARTITION BY RANGE (id)");
    exec.executeSql("CREATE TABLE parent_t_p1 PARTITION OF parent_t FOR VALUES FROM (1) TO (100)");

    // Child should inherit parent's columns
    var r1 = exec.executeSql("SELECT * FROM parent_t_p1");
    assertEqInt(r1.columnNames.count(), 3, "Child partition inherits 3 columns");
    assertEq(r1.columnNames.get(0), "id", "Child col 0 is id");
    assertEq(r1.columnNames.get(1), "name", "Child col 1 is name");
    assertEq(r1.columnNames.get(2), "score", "Child col 2 is score");
}

func testPartitionSelectWithLimit() {
    section("Partition SELECT with LIMIT");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE lim_t (id INTEGER, val TEXT) PARTITION BY RANGE (id)");
    exec.executeSql("CREATE TABLE lim_t_p1 PARTITION OF lim_t FOR VALUES FROM (1) TO (50)");
    exec.executeSql("CREATE TABLE lim_t_p2 PARTITION OF lim_t FOR VALUES FROM (50) TO (100)");

    var i = 1;
    while i <= 10 {
        exec.executeSql("INSERT INTO lim_t VALUES (" + Fmt.Int(i) + ", 'v" + Fmt.Int(i) + "')");
        i = i + 1;
    }
    i = 50;
    while i <= 59 {
        exec.executeSql("INSERT INTO lim_t VALUES (" + Fmt.Int(i) + ", 'v" + Fmt.Int(i) + "')");
        i = i + 1;
    }

    var r1 = exec.executeSql("SELECT * FROM lim_t LIMIT 5");
    assertEqInt(r1.rows.count(), 5, "LIMIT 5 on partitioned table returns 5 rows");

    var r2 = exec.executeSql("SELECT COUNT(*) FROM lim_t");
    // COUNT(*) on parent should aggregate
    // Note: COUNT on partitioned table works since we merge rows
    assertEq(val(r2, 0, 0), "20", "COUNT(*) returns 20 across partitions");
}

func testPartitionDuplicate() {
    section("Duplicate Partition Name");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE dup_parent (id INTEGER) PARTITION BY RANGE (id)");
    exec.executeSql("CREATE TABLE dup_child PARTITION OF dup_parent FOR VALUES FROM (1) TO (100)");

    var r1 = exec.executeSql("CREATE TABLE dup_child PARTITION OF dup_parent FOR VALUES FROM (100) TO (200)");
    assertTrue(r1.success == false, "Duplicate partition name fails");
}

func main() -> Integer {
    Terminal.Say("=== Phase 28: Table Partitioning ===");

    testRangePartitionCreate();
    testRangePartitionInsert();
    testRangePartitionSelect();
    testListPartition();
    testHashPartition();
    testPartitionErrors();
    testPartitionColumnInheritance();
    testPartitionSelectWithLimit();
    testPartitionDuplicate();

    printResults();
    return 0;
}
