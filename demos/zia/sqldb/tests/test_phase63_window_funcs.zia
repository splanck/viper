// test_phase63_window_funcs.zia — Phase 63: Additional Window Functions
// Tests for LAG, LEAD, FIRST_VALUE, LAST_VALUE, NTH_VALUE, NTILE,
// PERCENT_RANK, and CUME_DIST window functions.

module test_phase63_window_funcs;

bind Terminal = Viper.Terminal;
bind String = Viper.String;
bind Fmt = Viper.Fmt;

bind "./test_common";
bind "../executor";
bind "../types";

//=========================================================================
// Setup helper
//=========================================================================

func setupExec() -> Executor {
    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE sales (day INTEGER, amount INTEGER)");
    exec.executeSql("INSERT INTO sales VALUES (1, 100)");
    exec.executeSql("INSERT INTO sales VALUES (2, 200)");
    exec.executeSql("INSERT INTO sales VALUES (3, 150)");
    exec.executeSql("INSERT INTO sales VALUES (4, 300)");
    exec.executeSql("INSERT INTO sales VALUES (5, 250)");

    return exec;
}

//=========================================================================
// LAG — value from previous row
//=========================================================================

func testLag() {
    section("LAG");

    var exec = setupExec();

    // LAG(amount) — default offset 1
    var r1 = exec.executeSql("SELECT day, amount, LAG(amount) OVER (ORDER BY day) FROM sales");
    assertSuccess(r1, "LAG default");
    assertRowCount(r1, 5, "5 rows");
    assertEq(val(r1, 0, 2), "NULL", "day 1: no previous");
    assertEq(val(r1, 1, 2), "100", "day 2: lag=100");
    assertEq(val(r1, 2, 2), "200", "day 3: lag=200");
    assertEq(val(r1, 3, 2), "150", "day 4: lag=150");
    assertEq(val(r1, 4, 2), "300", "day 5: lag=300");
}

func testLagWithOffset() {
    section("LAG with offset");

    var exec = setupExec();

    // LAG(amount, 2) — offset 2
    var r1 = exec.executeSql("SELECT day, amount, LAG(amount, 2) OVER (ORDER BY day) FROM sales");
    assertSuccess(r1, "LAG offset 2");
    assertRowCount(r1, 5, "5 rows");
    assertEq(val(r1, 0, 2), "NULL", "day 1: no row -2");
    assertEq(val(r1, 1, 2), "NULL", "day 2: no row -2");
    assertEq(val(r1, 2, 2), "100", "day 3: lag=100");
    assertEq(val(r1, 3, 2), "200", "day 4: lag=200");
    assertEq(val(r1, 4, 2), "150", "day 5: lag=150");
}

func testLagWithDefault() {
    section("LAG with default");

    var exec = setupExec();

    // LAG(amount, 1, 0) — default value 0
    var r1 = exec.executeSql("SELECT day, amount, LAG(amount, 1, 0) OVER (ORDER BY day) FROM sales");
    assertSuccess(r1, "LAG with default");
    assertRowCount(r1, 5, "5 rows");
    assertEq(val(r1, 0, 2), "0", "day 1: default 0");
    assertEq(val(r1, 1, 2), "100", "day 2: lag=100");
    assertEq(val(r1, 2, 2), "200", "day 3: lag=200");
}

//=========================================================================
// LEAD — value from next row
//=========================================================================

func testLead() {
    section("LEAD");

    var exec = setupExec();

    // LEAD(amount) — default offset 1
    var r1 = exec.executeSql("SELECT day, amount, LEAD(amount) OVER (ORDER BY day) FROM sales");
    assertSuccess(r1, "LEAD default");
    assertRowCount(r1, 5, "5 rows");
    assertEq(val(r1, 0, 2), "200", "day 1: lead=200");
    assertEq(val(r1, 1, 2), "150", "day 2: lead=150");
    assertEq(val(r1, 2, 2), "300", "day 3: lead=300");
    assertEq(val(r1, 3, 2), "250", "day 4: lead=250");
    assertEq(val(r1, 4, 2), "NULL", "day 5: no next");
}

func testLeadWithOffset() {
    section("LEAD with offset");

    var exec = setupExec();

    // LEAD(amount, 2) — offset 2
    var r1 = exec.executeSql("SELECT day, amount, LEAD(amount, 2) OVER (ORDER BY day) FROM sales");
    assertSuccess(r1, "LEAD offset 2");
    assertRowCount(r1, 5, "5 rows");
    assertEq(val(r1, 0, 2), "150", "day 1: lead=150");
    assertEq(val(r1, 1, 2), "300", "day 2: lead=300");
    assertEq(val(r1, 2, 2), "250", "day 3: lead=250");
    assertEq(val(r1, 3, 2), "NULL", "day 4: no row +2");
    assertEq(val(r1, 4, 2), "NULL", "day 5: no row +2");
}

func testLeadWithDefault() {
    section("LEAD with default");

    var exec = setupExec();

    // LEAD(amount, 1, -1) — default value -1
    var r1 = exec.executeSql("SELECT day, amount, LEAD(amount, 1, -1) OVER (ORDER BY day) FROM sales");
    assertSuccess(r1, "LEAD with default");
    assertRowCount(r1, 5, "5 rows");
    assertEq(val(r1, 3, 2), "250", "day 4: lead=250");
    assertEq(val(r1, 4, 2), "-1", "day 5: default -1");
}

//=========================================================================
// FIRST_VALUE — first value in partition
//=========================================================================

func testFirstValue() {
    section("FIRST_VALUE");

    var exec = setupExec();

    var r1 = exec.executeSql("SELECT day, amount, FIRST_VALUE(amount) OVER (ORDER BY day) FROM sales");
    assertSuccess(r1, "FIRST_VALUE");
    assertRowCount(r1, 5, "5 rows");
    // All rows should see the first value (day 1, amount 100)
    assertEq(val(r1, 0, 2), "100", "day 1: first=100");
    assertEq(val(r1, 1, 2), "100", "day 2: first=100");
    assertEq(val(r1, 2, 2), "100", "day 3: first=100");
    assertEq(val(r1, 3, 2), "100", "day 4: first=100");
    assertEq(val(r1, 4, 2), "100", "day 5: first=100");
}

func testFirstValuePartitioned() {
    section("FIRST_VALUE with PARTITION BY");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE data (grp TEXT, val INTEGER)");
    exec.executeSql("INSERT INTO data VALUES ('A', 10)");
    exec.executeSql("INSERT INTO data VALUES ('A', 20)");
    exec.executeSql("INSERT INTO data VALUES ('A', 30)");
    exec.executeSql("INSERT INTO data VALUES ('B', 100)");
    exec.executeSql("INSERT INTO data VALUES ('B', 200)");

    var r1 = exec.executeSql("SELECT grp, val, FIRST_VALUE(val) OVER (PARTITION BY grp ORDER BY val) FROM data");
    assertSuccess(r1, "FIRST_VALUE partitioned");
    assertRowCount(r1, 5, "5 rows");
    // Find A rows
    var ri = 0;
    while ri < 5 {
        if val(r1, ri, 0) == "A" {
            assertEq(val(r1, ri, 2), "10", "A: first=10");
        }
        if val(r1, ri, 0) == "B" {
            assertEq(val(r1, ri, 2), "100", "B: first=100");
        }
        ri = ri + 1;
    }
}

//=========================================================================
// LAST_VALUE — last value in partition
//=========================================================================

func testLastValue() {
    section("LAST_VALUE");

    var exec = setupExec();

    var r1 = exec.executeSql("SELECT day, amount, LAST_VALUE(amount) OVER (ORDER BY day) FROM sales");
    assertSuccess(r1, "LAST_VALUE");
    assertRowCount(r1, 5, "5 rows");
    // All rows should see the last value (day 5, amount 250)
    assertEq(val(r1, 0, 2), "250", "day 1: last=250");
    assertEq(val(r1, 4, 2), "250", "day 5: last=250");
}

//=========================================================================
// NTH_VALUE — nth value in partition
//=========================================================================

func testNthValue() {
    section("NTH_VALUE");

    var exec = setupExec();

    // NTH_VALUE(amount, 3) — third value
    var r1 = exec.executeSql("SELECT day, amount, NTH_VALUE(amount, 3) OVER (ORDER BY day) FROM sales");
    assertSuccess(r1, "NTH_VALUE");
    assertRowCount(r1, 5, "5 rows");
    // Third value is day 3, amount 150
    assertEq(val(r1, 0, 2), "150", "nth 3 = 150");
    assertEq(val(r1, 4, 2), "150", "nth 3 = 150 (all rows)");

    // NTH_VALUE(amount, 1) — same as FIRST_VALUE
    var r2 = exec.executeSql("SELECT day, amount, NTH_VALUE(amount, 1) OVER (ORDER BY day) FROM sales");
    assertSuccess(r2, "NTH_VALUE(1)");
    assertEq(val(r2, 0, 2), "100", "nth 1 = 100");

    // NTH_VALUE(amount, 10) — out of range
    var r3 = exec.executeSql("SELECT day, amount, NTH_VALUE(amount, 10) OVER (ORDER BY day) FROM sales");
    assertSuccess(r3, "NTH_VALUE out of range");
    assertEq(val(r3, 0, 2), "NULL", "nth 10 = NULL");
}

//=========================================================================
// NTILE — divide partition into buckets
//=========================================================================

func testNtile() {
    section("NTILE");

    var exec = setupExec();

    // NTILE(3) — 5 rows into 3 buckets: [2, 2, 1]
    var r1 = exec.executeSql("SELECT day, amount, NTILE(3) OVER (ORDER BY day) FROM sales");
    assertSuccess(r1, "NTILE(3)");
    assertRowCount(r1, 5, "5 rows");
    assertEq(val(r1, 0, 2), "1", "day 1: bucket 1");
    assertEq(val(r1, 1, 2), "1", "day 2: bucket 1");
    assertEq(val(r1, 2, 2), "2", "day 3: bucket 2");
    assertEq(val(r1, 3, 2), "2", "day 4: bucket 2");
    assertEq(val(r1, 4, 2), "3", "day 5: bucket 3");

    // NTILE(5) — 5 rows into 5 buckets: [1, 1, 1, 1, 1]
    var r2 = exec.executeSql("SELECT day, amount, NTILE(5) OVER (ORDER BY day) FROM sales");
    assertSuccess(r2, "NTILE(5)");
    assertEq(val(r2, 0, 2), "1", "day 1: bucket 1");
    assertEq(val(r2, 4, 2), "5", "day 5: bucket 5");

    // NTILE(2) — 5 rows into 2 buckets: [3, 2]
    var r3 = exec.executeSql("SELECT day, amount, NTILE(2) OVER (ORDER BY day) FROM sales");
    assertSuccess(r3, "NTILE(2)");
    assertEq(val(r3, 0, 2), "1", "day 1: bucket 1");
    assertEq(val(r3, 1, 2), "1", "day 2: bucket 1");
    assertEq(val(r3, 2, 2), "1", "day 3: bucket 1");
    assertEq(val(r3, 3, 2), "2", "day 4: bucket 2");
    assertEq(val(r3, 4, 2), "2", "day 5: bucket 2");
}

//=========================================================================
// PERCENT_RANK
//=========================================================================

func testPercentRank() {
    section("PERCENT_RANK");

    var exec = setupExec();

    // PERCENT_RANK: (rank-1)/(total-1)
    // day 1(100)=0/4=0, day 2(150)=1/4=0.25, day 3(200)=2/4=0.5, day 4(250)=3/4=0.75, day 5(300)=4/4=1
    var r1 = exec.executeSql("SELECT day, amount, PERCENT_RANK() OVER (ORDER BY amount) FROM sales");
    assertSuccess(r1, "PERCENT_RANK");
    assertRowCount(r1, 5, "5 rows");
    // day 1(100): rank=1→0/4=0, day 4(300): rank=5→4/4=1
    var ri = 0;
    while ri < 5 {
        if val(r1, ri, 0) == "1" {
            assertEq(val(r1, ri, 2), "0", "day 1(100): rank=0");
        }
        if val(r1, ri, 0) == "4" {
            assertEq(val(r1, ri, 2), "1", "day 4(300): rank=1");
        }
        ri = ri + 1;
    }
}

func testPercentRankSingleRow() {
    section("PERCENT_RANK single row");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE one (val INTEGER)");
    exec.executeSql("INSERT INTO one VALUES (42)");

    var r1 = exec.executeSql("SELECT val, PERCENT_RANK() OVER (ORDER BY val) FROM one");
    assertSuccess(r1, "single row");
    assertRowCount(r1, 1, "1 row");
    assertEq(val(r1, 0, 1), "0", "single row = 0");
}

//=========================================================================
// CUME_DIST
//=========================================================================

func testCumeDist() {
    section("CUME_DIST");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE scores (name TEXT, score INTEGER)");
    exec.executeSql("INSERT INTO scores VALUES ('A', 10)");
    exec.executeSql("INSERT INTO scores VALUES ('B', 20)");
    exec.executeSql("INSERT INTO scores VALUES ('C', 20)");
    exec.executeSql("INSERT INTO scores VALUES ('D', 30)");

    // CUME_DIST: score 10 → 1/4=0.25, score 20 → 3/4=0.75 (3 rows <= 20), score 30 → 4/4=1
    var r1 = exec.executeSql("SELECT name, score, CUME_DIST() OVER (ORDER BY score) FROM scores");
    assertSuccess(r1, "CUME_DIST");
    assertRowCount(r1, 4, "4 rows");
    var ri = 0;
    while ri < 4 {
        if val(r1, ri, 0) == "A" {
            assertEq(val(r1, ri, 2), "0.25", "A: 1/4 = 0.25");
        }
        if val(r1, ri, 0) == "B" {
            assertEq(val(r1, ri, 2), "0.75", "B: 3/4 = 0.75");
        }
        if val(r1, ri, 0) == "D" {
            assertEq(val(r1, ri, 2), "1", "D: 4/4 = 1");
        }
        ri = ri + 1;
    }
}

//=========================================================================
// LAG/LEAD with PARTITION BY
//=========================================================================

func testLagLeadPartitioned() {
    section("LAG/LEAD with PARTITION BY");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE emp (dept TEXT, name TEXT, salary INTEGER)");
    exec.executeSql("INSERT INTO emp VALUES ('Sales', 'Alice', 50)");
    exec.executeSql("INSERT INTO emp VALUES ('Sales', 'Bob', 60)");
    exec.executeSql("INSERT INTO emp VALUES ('Sales', 'Carol', 55)");
    exec.executeSql("INSERT INTO emp VALUES ('IT', 'Dave', 70)");
    exec.executeSql("INSERT INTO emp VALUES ('IT', 'Eve', 80)");

    // LAG within partition
    var r1 = exec.executeSql("SELECT dept, name, salary, LAG(salary) OVER (PARTITION BY dept ORDER BY salary) FROM emp");
    assertSuccess(r1, "LAG partitioned");
    assertRowCount(r1, 5, "5 rows");
    // In Sales partition (sorted by salary: Alice=50, Carol=55, Bob=60):
    //   Alice: LAG=NULL, Carol: LAG=50, Bob: LAG=55
    // In IT partition (sorted by salary: Dave=70, Eve=80):
    //   Dave: LAG=NULL, Eve: LAG=70
    var ri = 0;
    while ri < 5 {
        if val(r1, ri, 1) == "Alice" {
            assertEq(val(r1, ri, 3), "NULL", "Alice: no prev");
        }
        if val(r1, ri, 1) == "Carol" {
            assertEq(val(r1, ri, 3), "50", "Carol: lag=50");
        }
        if val(r1, ri, 1) == "Bob" {
            assertEq(val(r1, ri, 3), "55", "Bob: lag=55");
        }
        if val(r1, ri, 1) == "Dave" {
            assertEq(val(r1, ri, 3), "NULL", "Dave: no prev");
        }
        if val(r1, ri, 1) == "Eve" {
            assertEq(val(r1, ri, 3), "70", "Eve: lag=70");
        }
        ri = ri + 1;
    }
}

//=========================================================================
// Regression: existing window functions still work
//=========================================================================

func testRegressionExisting() {
    section("Regression: existing window functions");

    var exec = setupExec();

    var r1 = exec.executeSql("SELECT day, ROW_NUMBER() OVER (ORDER BY day) FROM sales");
    assertSuccess(r1, "ROW_NUMBER");
    assertEq(val(r1, 0, 1), "1", "rn 1");
    assertEq(val(r1, 4, 1), "5", "rn 5");

    var r2 = exec.executeSql("SELECT day, RANK() OVER (ORDER BY day) FROM sales");
    assertSuccess(r2, "RANK");
    assertEq(val(r2, 0, 1), "1", "rank 1");
    assertEq(val(r2, 4, 1), "5", "rank 5");

    var r3 = exec.executeSql("SELECT day, DENSE_RANK() OVER (ORDER BY day) FROM sales");
    assertSuccess(r3, "DENSE_RANK");
    assertEq(val(r3, 0, 1), "1", "dense_rank 1");
    assertEq(val(r3, 4, 1), "5", "dense_rank 5");
}

//=========================================================================
// MAIN
//=========================================================================

func main() {
    Terminal.Say("=== Phase 63: Additional Window Functions ===");

    testLag();
    testLagWithOffset();
    testLagWithDefault();
    testLead();
    testLeadWithOffset();
    testLeadWithDefault();
    testFirstValue();
    testFirstValuePartitioned();
    testLastValue();
    testNthValue();
    testNtile();
    testPercentRank();
    testPercentRankSingleRow();
    testCumeDist();
    testLagLeadPartitioned();
    testRegressionExisting();

    printResults();
}
