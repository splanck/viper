// test_phase25_json.zia â€” Phase 25: JSON/JSONB Type & Functions
// Tests for JSON data type, validation, extraction, construction, and querying.

module test_phase25_json;

bind Terminal = Viper.Terminal;
bind String = Viper.String;
bind Fmt = Viper.Fmt;

bind "./test_common";
bind "../executor";
bind "../types";
bind "../json";

func main() -> Integer {
    Terminal.Say("=== Phase 25: JSON/JSONB Type & Functions ===");

    var exec = new Executor();
    exec.init();

    //=========================================================================
    // 1. JSON TYPE BASICS
    //=========================================================================
    section("JSON Type Basics");

    // Test 1: Create table with JSON column
    var r1 = exec.executeSql("CREATE TABLE docs (id INTEGER PRIMARY KEY, data JSON)");
    assertSuccess(r1, "CREATE TABLE with JSON column succeeds");

    // Test 2: DESCRIBE shows JSON type
    var r2 = exec.executeSql("DESCRIBE docs");
    assertSuccess(r2, "DESCRIBE succeeds");
    var foundJson = false;
    var di = 0;
    while di < r2.rows.count() {
        var row = r2.rows.get(di);
        if row.values.get(0).textValue == "data" && row.values.get(1).textValue == "JSON" {
            foundJson = true;
        }
        di = di + 1;
    }
    assert(foundJson == true, "DESCRIBE shows JSON type for data column");

    // Test 3: Insert JSON object
    exec.executeSql("INSERT INTO docs VALUES (1, '{\"name\":\"Alice\",\"age\":30}')");
    var r3 = exec.executeSql("SELECT data FROM docs WHERE id = 1");
    assertSuccess(r3, "SELECT JSON column succeeds");
    assertRowCount(r3, 1, "One row returned");
    var jsonVal = r3.rows.get(0).values.get(0);
    assertEq(jsonVal.toString(), "{\"name\":\"Alice\",\"age\":30}", "JSON value preserved");

    // Test 4: Insert JSON array
    exec.executeSql("INSERT INTO docs VALUES (2, '[1,2,3]')");
    var r4 = exec.executeSql("SELECT data FROM docs WHERE id = 2");
    assertSuccess(r4, "SELECT JSON array succeeds");
    assertEq(r4.rows.get(0).values.get(0).toString(), "[1,2,3]", "JSON array preserved");

    // Test 5: Insert JSON null
    exec.executeSql("INSERT INTO docs VALUES (3, 'null')");
    var r5 = exec.executeSql("SELECT data FROM docs WHERE id = 3");
    assertSuccess(r5, "SELECT JSON null succeeds");
    assertEq(r5.rows.get(0).values.get(0).toString(), "null", "JSON null preserved");

    // Test 6: Insert JSON number
    exec.executeSql("INSERT INTO docs VALUES (4, '42')");
    var r6 = exec.executeSql("SELECT data FROM docs WHERE id = 4");
    assertSuccess(r6, "SELECT JSON number succeeds");
    assertEq(r6.rows.get(0).values.get(0).toString(), "42", "JSON number preserved");

    // Test 7: TYPEOF returns 'json'
    var r7 = exec.executeSql("SELECT TYPEOF(data) FROM docs WHERE id = 1");
    assertSuccess(r7, "TYPEOF on JSON column succeeds");
    assertEq(r7.rows.get(0).values.get(0).textValue, "json", "TYPEOF returns 'json'");

    //=========================================================================
    // 2. JSON_VALID
    //=========================================================================
    section("JSON_VALID");

    // Test 8: Valid JSON object
    var r8 = exec.executeSql("SELECT JSON_VALID('{\"key\":\"value\"}')");
    assertSuccess(r8, "JSON_VALID object query succeeds");
    assertEqInt(r8.rows.get(0).values.get(0).intValue, 1, "JSON_VALID({...}) = true");

    // Test 9: Valid JSON array
    var r9 = exec.executeSql("SELECT JSON_VALID('[1,2,3]')");
    assertEqInt(r9.rows.get(0).values.get(0).intValue, 1, "JSON_VALID([...]) = true");

    // Test 10: Valid JSON string
    var r10 = exec.executeSql("SELECT JSON_VALID('\"hello\"')");
    assertEqInt(r10.rows.get(0).values.get(0).intValue, 1, "JSON_VALID(string) = true");

    // Test 11: Valid JSON number
    var r11 = exec.executeSql("SELECT JSON_VALID('42')");
    assertEqInt(r11.rows.get(0).values.get(0).intValue, 1, "JSON_VALID(number) = true");

    // Test 12: Valid JSON true/false/null
    var r12 = exec.executeSql("SELECT JSON_VALID('true')");
    assertEqInt(r12.rows.get(0).values.get(0).intValue, 1, "JSON_VALID(true) = true");

    // Test 13: Invalid JSON
    var r13 = exec.executeSql("SELECT JSON_VALID('{invalid}')");
    assertEqInt(r13.rows.get(0).values.get(0).intValue, 0, "JSON_VALID(invalid) = false");

    // Test 14: Invalid - trailing content
    var r14 = exec.executeSql("SELECT JSON_VALID('{} extra')");
    assertEqInt(r14.rows.get(0).values.get(0).intValue, 0, "JSON_VALID with trailing content = false");

    // Test 15: Empty string is not valid JSON
    var r15 = exec.executeSql("SELECT JSON_VALID('')");
    assertEqInt(r15.rows.get(0).values.get(0).intValue, 0, "JSON_VALID('') = false");

    //=========================================================================
    // 3. JSON_TYPE
    //=========================================================================
    section("JSON_TYPE");

    // Test 16: Object type
    var r16 = exec.executeSql("SELECT JSON_TYPE('{\"a\":1}')");
    assertEq(r16.rows.get(0).values.get(0).textValue, "object", "JSON_TYPE object");

    // Test 17: Array type
    var r17 = exec.executeSql("SELECT JSON_TYPE('[1,2]')");
    assertEq(r17.rows.get(0).values.get(0).textValue, "array", "JSON_TYPE array");

    // Test 18: String type
    var r18 = exec.executeSql("SELECT JSON_TYPE('\"hello\"')");
    assertEq(r18.rows.get(0).values.get(0).textValue, "string", "JSON_TYPE string");

    // Test 19: Number type
    var r19 = exec.executeSql("SELECT JSON_TYPE('42')");
    assertEq(r19.rows.get(0).values.get(0).textValue, "number", "JSON_TYPE number");

    // Test 20: Boolean types
    var r20 = exec.executeSql("SELECT JSON_TYPE('true')");
    assertEq(r20.rows.get(0).values.get(0).textValue, "true", "JSON_TYPE true");
    var r20b = exec.executeSql("SELECT JSON_TYPE('false')");
    assertEq(r20b.rows.get(0).values.get(0).textValue, "false", "JSON_TYPE false");

    // Test 21: Null type
    var r21 = exec.executeSql("SELECT JSON_TYPE('null')");
    assertEq(r21.rows.get(0).values.get(0).textValue, "null", "JSON_TYPE null");

    //=========================================================================
    // 4. JSON_EXTRACT
    //=========================================================================
    section("JSON_EXTRACT");

    // Test 22: Extract simple key
    var r22 = exec.executeSql("SELECT JSON_EXTRACT('{\"name\":\"Alice\",\"age\":30}', '$.name')");
    assertSuccess(r22, "JSON_EXTRACT succeeds");
    assertEq(r22.rows.get(0).values.get(0).textValue, "\"Alice\"", "JSON_EXTRACT $.name returns quoted string");

    // Test 23: Extract numeric value
    var r23 = exec.executeSql("SELECT JSON_EXTRACT('{\"name\":\"Alice\",\"age\":30}', '$.age')");
    assertEq(r23.rows.get(0).values.get(0).textValue, "30", "JSON_EXTRACT $.age returns 30");

    // Test 24: Extract nested key
    var r24 = exec.executeSql("SELECT JSON_EXTRACT('{\"user\":{\"name\":\"Bob\"}}', '$.user.name')");
    assertEq(r24.rows.get(0).values.get(0).textValue, "\"Bob\"", "JSON_EXTRACT nested key");

    // Test 25: Extract array element
    var r25 = exec.executeSql("SELECT JSON_EXTRACT('[10,20,30]', '$[1]')");
    assertEq(r25.rows.get(0).values.get(0).textValue, "20", "JSON_EXTRACT array index [1]");

    // Test 26: Extract missing key returns NULL
    var r26 = exec.executeSql("SELECT JSON_EXTRACT('{\"a\":1}', '$.b')");
    assert(r26.rows.get(0).values.get(0).kind == SQL_NULL, "JSON_EXTRACT missing key returns NULL");

    // Test 27: Extract with simple key (no $ prefix)
    var r27 = exec.executeSql("SELECT JSON_EXTRACT('{\"color\":\"red\"}', 'color')");
    assertEq(r27.rows.get(0).values.get(0).textValue, "\"red\"", "JSON_EXTRACT simple key (no $)");

    //=========================================================================
    // 5. JSON_EXTRACT_TEXT
    //=========================================================================
    section("JSON_EXTRACT_TEXT");

    // Test 28: Extract text unwraps string quotes
    var r28 = exec.executeSql("SELECT JSON_EXTRACT_TEXT('{\"name\":\"Alice\"}', 'name')");
    assertSuccess(r28, "JSON_EXTRACT_TEXT succeeds");
    assertEq(r28.rows.get(0).values.get(0).textValue, "Alice", "JSON_EXTRACT_TEXT unwraps string");

    // Test 29: Extract text for non-string returns raw value
    var r29 = exec.executeSql("SELECT JSON_EXTRACT_TEXT('{\"age\":30}', 'age')");
    assertEq(r29.rows.get(0).values.get(0).textValue, "30", "JSON_EXTRACT_TEXT number as text");

    // Test 30: Extract text missing key returns NULL
    var r30 = exec.executeSql("SELECT JSON_EXTRACT_TEXT('{\"a\":1}', 'b')");
    assert(r30.rows.get(0).values.get(0).kind == SQL_NULL, "JSON_EXTRACT_TEXT missing key = NULL");

    //=========================================================================
    // 6. JSON_ARRAY_LENGTH
    //=========================================================================
    section("JSON_ARRAY_LENGTH");

    // Test 31: Array length
    var r31 = exec.executeSql("SELECT JSON_ARRAY_LENGTH('[1,2,3,4,5]')");
    assertSuccess(r31, "JSON_ARRAY_LENGTH succeeds");
    assertEqInt(r31.rows.get(0).values.get(0).intValue, 5, "JSON_ARRAY_LENGTH = 5");

    // Test 32: Empty array
    var r32 = exec.executeSql("SELECT JSON_ARRAY_LENGTH('[]')");
    assertEqInt(r32.rows.get(0).values.get(0).intValue, 0, "JSON_ARRAY_LENGTH empty = 0");

    // Test 33: Non-array returns NULL
    var r33 = exec.executeSql("SELECT JSON_ARRAY_LENGTH('{\"a\":1}')");
    assert(r33.rows.get(0).values.get(0).kind == SQL_NULL, "JSON_ARRAY_LENGTH non-array = NULL");

    //=========================================================================
    // 7. JSON_OBJECT_KEYS
    //=========================================================================
    section("JSON_OBJECT_KEYS");

    // Test 34: Get keys from object
    var r34 = exec.executeSql("SELECT JSON_OBJECT_KEYS('{\"name\":\"Alice\",\"age\":30}')");
    assertSuccess(r34, "JSON_OBJECT_KEYS succeeds");
    var keysVal = r34.rows.get(0).values.get(0);
    // Should be a JSON array of keys
    assert(keysVal.kind == SQL_JSON, "JSON_OBJECT_KEYS returns JSON type");
    // Keys should contain "name" and "age"
    var keysStr = keysVal.textValue;
    var hasName = false;
    var hasAge = false;
    if String.Length(keysStr) > 0 {
        // Check if "name" and "age" appear in the keys array
        var ki = 0;
        var kLen = String.Length(keysStr);
        while ki < kLen {
            if ki + 6 <= kLen && String.Substring(keysStr, ki, 6) == "\"name\"" {
                hasName = true;
            }
            if ki + 5 <= kLen && String.Substring(keysStr, ki, 5) == "\"age\"" {
                hasAge = true;
            }
            ki = ki + 1;
        }
    }
    assert(hasName == true, "JSON_OBJECT_KEYS contains 'name'");
    assert(hasAge == true, "JSON_OBJECT_KEYS contains 'age'");

    // Test 35: Empty object
    var r35 = exec.executeSql("SELECT JSON_OBJECT_KEYS('{}')");
    assertEq(r35.rows.get(0).values.get(0).textValue, "[]", "JSON_OBJECT_KEYS empty = []");

    //=========================================================================
    // 8. JSON_BUILD_OBJECT
    //=========================================================================
    section("JSON_BUILD_OBJECT");

    // Test 36: Build simple object
    var r36 = exec.executeSql("SELECT JSON_BUILD_OBJECT('name', 'Alice', 'age', 30)");
    assertSuccess(r36, "JSON_BUILD_OBJECT succeeds");
    var builtObj = r36.rows.get(0).values.get(0);
    assert(builtObj.kind == SQL_JSON, "JSON_BUILD_OBJECT returns JSON type");
    // Validate the built JSON
    var validator = new JsonParser();
    validator.initWithSource(builtObj.textValue);
    assert(validator.isValid() == true, "JSON_BUILD_OBJECT produces valid JSON");
    // Extract values to verify
    var parser36 = new JsonParser();
    parser36.initWithSource(builtObj.textValue);
    var nameVal = parser36.extractKey("name");
    assertEq(nameVal, "\"Alice\"", "JSON_BUILD_OBJECT name = Alice");

    // Test 37: Build with various types
    var r37 = exec.executeSql("SELECT JSON_BUILD_OBJECT('active', TRUE, 'count', 42)");
    assertSuccess(r37, "JSON_BUILD_OBJECT with bool/int succeeds");
    var obj37 = r37.rows.get(0).values.get(0).textValue;
    var v37 = new JsonParser();
    v37.initWithSource(obj37);
    assert(v37.isValid() == true, "JSON_BUILD_OBJECT multi-type is valid JSON");

    //=========================================================================
    // 9. JSON_BUILD_ARRAY
    //=========================================================================
    section("JSON_BUILD_ARRAY");

    // Test 38: Build array
    var r38 = exec.executeSql("SELECT JSON_BUILD_ARRAY(1, 2, 3)");
    assertSuccess(r38, "JSON_BUILD_ARRAY succeeds");
    var arr38 = r38.rows.get(0).values.get(0);
    assert(arr38.kind == SQL_JSON, "JSON_BUILD_ARRAY returns JSON type");
    assertEq(arr38.textValue, "[1,2,3]", "JSON_BUILD_ARRAY [1,2,3]");

    // Test 39: Build mixed-type array
    var r39 = exec.executeSql("SELECT JSON_BUILD_ARRAY('hello', 42, TRUE, NULL)");
    assertSuccess(r39, "JSON_BUILD_ARRAY mixed types succeeds");
    var arr39 = r39.rows.get(0).values.get(0);
    var v39 = new JsonParser();
    v39.initWithSource(arr39.textValue);
    assert(v39.isValid() == true, "JSON_BUILD_ARRAY mixed-type is valid JSON");

    // Test 40: Empty array
    var r40 = exec.executeSql("SELECT JSON_BUILD_ARRAY()");
    assertEq(r40.rows.get(0).values.get(0).textValue, "[]", "JSON_BUILD_ARRAY() = []");

    //=========================================================================
    // 10. JSON_QUOTE
    //=========================================================================
    section("JSON_QUOTE");

    // Test 41: Quote string
    var r41 = exec.executeSql("SELECT JSON_QUOTE('hello')");
    assertSuccess(r41, "JSON_QUOTE succeeds");
    assertEq(r41.rows.get(0).values.get(0).textValue, "\"hello\"", "JSON_QUOTE string");

    // Test 42: Quote number
    var r42 = exec.executeSql("SELECT JSON_QUOTE(42)");
    assertEq(r42.rows.get(0).values.get(0).textValue, "42", "JSON_QUOTE number");

    // Test 43: Quote NULL
    var r43 = exec.executeSql("SELECT JSON_QUOTE(NULL)");
    assertEq(r43.rows.get(0).values.get(0).textValue, "null", "JSON_QUOTE NULL = null");

    //=========================================================================
    // 11. JSON() FUNCTION (validate and cast)
    //=========================================================================
    section("JSON Function");

    // Test 44: JSON() validates and returns JSON type
    var r44 = exec.executeSql("SELECT JSON('{\"a\":1}')");
    assertSuccess(r44, "JSON() succeeds");
    assert(r44.rows.get(0).values.get(0).kind == SQL_JSON, "JSON() returns JSON type");

    // Test 45: JSON() with invalid input returns NULL
    var r45 = exec.executeSql("SELECT JSON('{bad}')");
    assert(r45.rows.get(0).values.get(0).kind == SQL_NULL, "JSON(invalid) = NULL");

    //=========================================================================
    // 12. CAST(x AS JSON)
    //=========================================================================
    section("CAST AS JSON");

    // Test 46: CAST text to JSON
    var r46 = exec.executeSql("SELECT CAST('{\"x\":1}' AS JSON)");
    assertSuccess(r46, "CAST AS JSON succeeds");
    assert(r46.rows.get(0).values.get(0).kind == SQL_JSON, "CAST AS JSON returns JSON type");
    assertEq(r46.rows.get(0).values.get(0).textValue, "{\"x\":1}", "CAST AS JSON preserves value");

    //=========================================================================
    // 13. JSON IN QUERIES
    //=========================================================================
    section("JSON in Queries");

    // Test 47: JSON column with WHERE
    exec.executeSql("CREATE TABLE config (id INTEGER PRIMARY KEY, settings JSON)");
    exec.executeSql("INSERT INTO config VALUES (1, '{\"theme\":\"dark\",\"lang\":\"en\"}')");
    exec.executeSql("INSERT INTO config VALUES (2, '{\"theme\":\"light\",\"lang\":\"fr\"}')");
    exec.executeSql("INSERT INTO config VALUES (3, '{\"theme\":\"dark\",\"lang\":\"de\"}')");

    var r47 = exec.executeSql("SELECT id FROM config");
    assertSuccess(r47, "SELECT from JSON table succeeds");
    assertRowCount(r47, 3, "3 config rows");

    // Test 48: Use JSON_EXTRACT_TEXT in WHERE
    var r48 = exec.executeSql("SELECT id FROM config WHERE JSON_EXTRACT_TEXT(settings, 'theme') = 'dark'");
    assertSuccess(r48, "WHERE with JSON_EXTRACT_TEXT succeeds");
    assertRowCount(r48, 2, "2 rows with dark theme");

    // Test 49: Use JSON_EXTRACT in SELECT
    var r49 = exec.executeSql("SELECT id, JSON_EXTRACT(settings, '$.lang') FROM config WHERE id = 1");
    assertSuccess(r49, "SELECT JSON_EXTRACT succeeds");
    assertEq(r49.rows.get(0).values.get(1).textValue, "\"en\"", "JSON_EXTRACT in SELECT");

    // Test 50: UPDATE JSON column
    exec.executeSql("UPDATE config SET settings = '{\"theme\":\"auto\",\"lang\":\"en\"}' WHERE id = 1");
    var r50 = exec.executeSql("SELECT JSON_EXTRACT_TEXT(settings, 'theme') FROM config WHERE id = 1");
    assertSuccess(r50, "SELECT after UPDATE JSON succeeds");
    assertEq(r50.rows.get(0).values.get(0).textValue, "auto", "Updated JSON value");

    // Test 51: DELETE row with JSON column
    exec.executeSql("DELETE FROM config WHERE id = 3");
    var r51 = exec.executeSql("SELECT COUNT(*) FROM config");
    assertEqInt(r51.rows.get(0).values.get(0).intValue, 2, "DELETE JSON row works");

    //=========================================================================
    // 14. JSON PARSER ENTITY DIRECT TESTS
    //=========================================================================
    section("JsonParser Entity");

    // Test 52: Nested object parsing
    var p52 = new JsonParser();
    p52.initWithSource("{\"a\":{\"b\":{\"c\":42}}}");
    assert(p52.isValid() == true, "Nested object is valid JSON");

    // Test 53: Nested array parsing
    var p53 = new JsonParser();
    p53.initWithSource("[[1,2],[3,4],[5,6]]");
    assert(p53.isValid() == true, "Nested array is valid JSON");

    // Test 54: Mixed nesting
    var p54 = new JsonParser();
    p54.initWithSource("{\"items\":[{\"id\":1},{\"id\":2}]}");
    assert(p54.isValid() == true, "Mixed nesting is valid JSON");
    var p54b = new JsonParser();
    p54b.initWithSource("{\"items\":[{\"id\":1},{\"id\":2}]}");
    var items = p54b.extractKey("items");
    assertEq(items, "[{\"id\":1},{\"id\":2}]", "Extract nested array");

    // Test 55: String with escapes
    var p55 = new JsonParser();
    p55.initWithSource("{\"msg\":\"hello\\nworld\"}");
    assert(p55.isValid() == true, "String with escapes is valid JSON");

    // Test 56: Negative number
    var p56 = new JsonParser();
    p56.initWithSource("{\"temp\":-10}");
    assert(p56.isValid() == true, "Negative number is valid JSON");
    p56.initWithSource("{\"temp\":-10}");
    var temp = p56.extractKey("temp");
    assertEq(temp, "-10", "Extract negative number");

    // Test 57: Decimal number
    var p57 = new JsonParser();
    p57.initWithSource("{\"pi\":3.14159}");
    assert(p57.isValid() == true, "Decimal number is valid JSON");

    // Test 58: Array length on various arrays
    var p58 = new JsonParser();
    p58.initWithSource("[1]");
    assertEqInt(p58.arrayLength(), 1, "Single-element array length = 1");
    p58.initWithSource("[1,2,3,4,5,6,7,8,9,10]");
    assertEqInt(p58.arrayLength(), 10, "10-element array length = 10");

    // Test 59: Object keys order
    var p59 = new JsonParser();
    p59.initWithSource("{\"z\":1,\"a\":2,\"m\":3}");
    var keys59 = p59.objectKeys();
    // Keys should be in insertion order: z, a, m
    var v59 = new JsonParser();
    v59.initWithSource(keys59);
    assertEqInt(v59.arrayLength(), 3, "objectKeys returns 3 keys");

    //=========================================================================
    // 15. JSON PATH EXTRACTION
    //=========================================================================
    section("JSON Path Extraction");

    // Test 60: Deep nested path
    var deep = "{\"a\":{\"b\":{\"c\":{\"d\":\"found\"}}}}";
    var p60 = new JsonParser();
    p60.initWithSource(deep);
    assert(p60.isValid() == true, "Deep nested JSON is valid");
    var r60 = jsonExtractPath(deep, "$.a.b.c.d");
    assertEq(r60, "\"found\"", "Deep nested path extraction");

    // Test 61: Array then key
    var mixed = "{\"users\":[{\"name\":\"Alice\"},{\"name\":\"Bob\"}]}";
    var r61 = jsonExtractPath(mixed, "$.users[0].name");
    assertEq(r61, "\"Alice\"", "Array[0].name extraction");

    var r61b = jsonExtractPath(mixed, "$.users[1].name");
    assertEq(r61b, "\"Bob\"", "Array[1].name extraction");

    // Test 62: Root array access
    var rootArr = "[\"a\",\"b\",\"c\"]";
    var r62 = jsonExtractPath(rootArr, "$[2]");
    assertEq(r62, "\"c\"", "Root array [2] extraction");

    //=========================================================================
    // 16. JSON_TYPEOF (PostgreSQL alias)
    //=========================================================================
    section("JSON_TYPEOF");

    // Test 63: JSON_TYPEOF works same as JSON_TYPE
    var r63 = exec.executeSql("SELECT JSON_TYPEOF('{\"a\":1}')");
    assertEq(r63.rows.get(0).values.get(0).textValue, "object", "JSON_TYPEOF = object");

    var r63b = exec.executeSql("SELECT JSON_TYPEOF('[1]')");
    assertEq(r63b.rows.get(0).values.get(0).textValue, "array", "JSON_TYPEOF = array");

    //=========================================================================
    // 17. JSON WITH NULL HANDLING
    //=========================================================================
    section("JSON NULL Handling");

    // Test 64: JSON functions with SQL NULL
    var r64 = exec.executeSql("SELECT JSON_VALID(NULL)");
    assert(r64.rows.get(0).values.get(0).kind == SQL_NULL, "JSON_VALID(NULL) = NULL");

    var r65 = exec.executeSql("SELECT JSON_TYPE(NULL)");
    assert(r65.rows.get(0).values.get(0).kind == SQL_NULL, "JSON_TYPE(NULL) = NULL");

    var r66 = exec.executeSql("SELECT JSON_EXTRACT(NULL, '$.key')");
    assert(r66.rows.get(0).values.get(0).kind == SQL_NULL, "JSON_EXTRACT(NULL, path) = NULL");

    var r67 = exec.executeSql("SELECT JSON_ARRAY_LENGTH(NULL)");
    assert(r67.rows.get(0).values.get(0).kind == SQL_NULL, "JSON_ARRAY_LENGTH(NULL) = NULL");

    //=========================================================================
    // 18. JSON IN INSERT...SELECT
    //=========================================================================
    section("JSON with INSERT...SELECT");

    // Test 65: Copy JSON between tables
    exec.executeSql("CREATE TABLE docs_backup (id INTEGER, data JSON)");
    exec.executeSql("INSERT INTO docs_backup SELECT id, data FROM docs");
    var r68 = exec.executeSql("SELECT COUNT(*) FROM docs_backup");
    assertSuccess(r68, "INSERT...SELECT with JSON succeeds");
    assertEqInt(r68.rows.get(0).values.get(0).intValue, 4, "4 rows copied");

    // Test 66: Verify JSON data preserved in copy
    var r69 = exec.executeSql("SELECT data FROM docs_backup WHERE id = 2");
    assertEq(r69.rows.get(0).values.get(0).toString(), "[1,2,3]", "JSON preserved in INSERT...SELECT");

    //=========================================================================
    // 19. JSON BUILD WITH TABLE DATA
    //=========================================================================
    section("JSON Build with Table Data");

    exec.executeSql("CREATE TABLE people (id INTEGER PRIMARY KEY, name TEXT, age INTEGER)");
    exec.executeSql("INSERT INTO people VALUES (1, 'Alice', 30)");
    exec.executeSql("INSERT INTO people VALUES (2, 'Bob', 25)");

    // Test 67: JSON_BUILD_OBJECT from column values
    var r70 = exec.executeSql("SELECT JSON_BUILD_OBJECT('name', name, 'age', age) FROM people WHERE id = 1");
    assertSuccess(r70, "JSON_BUILD_OBJECT from columns succeeds");
    var built70 = r70.rows.get(0).values.get(0);
    assert(built70.kind == SQL_JSON, "Result is JSON type");
    var v70 = new JsonParser();
    v70.initWithSource(built70.textValue);
    assert(v70.isValid() == true, "Built JSON is valid");

    // Test 68: JSON_BUILD_ARRAY from column values
    var r71 = exec.executeSql("SELECT JSON_BUILD_ARRAY(id, name, age) FROM people WHERE id = 2");
    assertSuccess(r71, "JSON_BUILD_ARRAY from columns succeeds");
    var arr71 = r71.rows.get(0).values.get(0);
    var v71 = new JsonParser();
    v71.initWithSource(arr71.textValue);
    assert(v71.isValid() == true, "Built array is valid JSON");
    assertEqInt(v71.arrayLength(), 3, "Built array has 3 elements");

    //=========================================================================
    // 20. EDGE CASES
    //=========================================================================
    section("Edge Cases");

    // Test 69: Whitespace in JSON
    var p69 = new JsonParser();
    p69.initWithSource("  {  \"a\"  :  1  }  ");
    assert(p69.isValid() == true, "JSON with whitespace is valid");

    // Test 70: Empty object and array
    var p70a = new JsonParser();
    p70a.initWithSource("{}");
    assert(p70a.isValid() == true, "Empty object is valid");
    var p70b = new JsonParser();
    p70b.initWithSource("[]");
    assert(p70b.isValid() == true, "Empty array is valid");

    // Test 71: Boolean and null values
    var p71 = new JsonParser();
    p71.initWithSource("{\"a\":true,\"b\":false,\"c\":null}");
    assert(p71.isValid() == true, "Booleans and null in object are valid");
    p71.initWithSource("{\"a\":true,\"b\":false,\"c\":null}");
    var bVal = p71.extractKey("a");
    assertEq(bVal, "true", "Extract boolean true");
    p71.initWithSource("{\"a\":true,\"b\":false,\"c\":null}");
    var nVal = p71.extractKey("c");
    assertEq(nVal, "null", "Extract null value");

    // Test 72: String with special characters
    var p72 = new JsonParser();
    p72.initWithSource("{\"msg\":\"hello \\\"world\\\"\"}");
    assert(p72.isValid() == true, "String with escaped quotes is valid");

    //=========================================================================
    // RESULTS
    //=========================================================================
    printResults();
    return 0;
}
