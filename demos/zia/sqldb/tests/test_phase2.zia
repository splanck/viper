// test_phase2.zia â€” Phase 2 Performance Tests
// Tests for quicksort, hash-based GROUP BY, hash-based DISTINCT,
// bucket-based index lookup, and short-circuit AND/OR

module test_phase2;

bind Terminal = Viper.Terminal;
bind String = Viper.String;
bind Fmt = Viper.Fmt;

bind "../executor";
bind "../types";

var passCount = 0;
var failCount = 0;

func assert(condition: Boolean, msg: String) {
    if condition {
        passCount = passCount + 1;
    } else {
        Terminal.Say("FAIL: " + msg);
        failCount = failCount + 1;
    }
}

func check(result: QueryResult, label: String) {
    if result.success == false {
        Terminal.Say("FAIL: " + label + " => " + result.message);
        failCount = failCount + 1;
    } else {
        passCount = passCount + 1;
    }
}

func val(result: QueryResult, row: Integer, col: Integer) -> String {
    var r = result.getRow(row);
    if r == null { return "NULL_ROW"; }
    var rr = r;
    return rr.getValue(col).toString();
}

func main() {
    Terminal.Say("=== Phase 2 Performance Tests ===");

    var exec = new Executor();
    exec.init();

    //=========================================================================
    // ORDER BY with quicksort (larger dataset)
    //=========================================================================
    Terminal.Say("");
    Terminal.Say("--- ORDER BY (quicksort) ---");

    check(exec.executeSql("CREATE TABLE sortdata (id INTEGER PRIMARY KEY, val INTEGER, name TEXT)"), "create sortdata");

    // Insert 50 rows in reverse order
    var i = 50;
    while i >= 1 {
        check(exec.executeSql("INSERT INTO sortdata VALUES (" + Fmt.Int(i) + ", " + Fmt.Int(i * 7 % 53) + ", 'item" + Fmt.Int(i) + "')"), "insert " + Fmt.Int(i));
        i = i - 1;
    }

    // Test ascending sort
    var r = exec.executeSql("SELECT id FROM sortdata ORDER BY id");
    check(r, "ORDER BY id ASC");
    assert(val(r, 0, 0) == "1", "first row id=1");
    assert(val(r, 49, 0) == "50", "last row id=50");
    assert(val(r, 24, 0) == "25", "middle row id=25");

    // Test descending sort
    r = exec.executeSql("SELECT id FROM sortdata ORDER BY id DESC");
    check(r, "ORDER BY id DESC");
    assert(val(r, 0, 0) == "50", "DESC first row id=50");
    assert(val(r, 49, 0) == "1", "DESC last row id=1");

    // Test sort by computed column
    r = exec.executeSql("SELECT id, val FROM sortdata ORDER BY val");
    check(r, "ORDER BY val");
    // Verify sorted order: each row's val should be <= next row's val
    var sortedCorrectly = true;
    var j = 0;
    while j < r.rowCount() - 1 {
        var row1 = r.getRow(j);
        var row2 = r.getRow(j + 1);
        if row1 != null && row2 != null {
            var r1 = row1;
            var r2 = row2;
            var v1 = r1.getValue(1).intValue;
            var v2 = r2.getValue(1).intValue;
            if v1 > v2 {
                sortedCorrectly = false;
            }
        }
        j = j + 1;
    }
    assert(sortedCorrectly, "50 rows sorted by val correctly");

    // Test multi-column sort
    check(exec.executeSql("CREATE TABLE multisort (a INTEGER, b INTEGER, c TEXT)"), "create multisort");
    check(exec.executeSql("INSERT INTO multisort VALUES (1, 3, 'x')"), "ms1");
    check(exec.executeSql("INSERT INTO multisort VALUES (2, 1, 'y')"), "ms2");
    check(exec.executeSql("INSERT INTO multisort VALUES (1, 1, 'z')"), "ms3");
    check(exec.executeSql("INSERT INTO multisort VALUES (2, 3, 'w')"), "ms4");
    check(exec.executeSql("INSERT INTO multisort VALUES (1, 2, 'v')"), "ms5");

    r = exec.executeSql("SELECT a, b, c FROM multisort ORDER BY a, b");
    check(r, "ORDER BY a, b");
    assert(val(r, 0, 2) == "z", "multisort row 0 = z (a=1,b=1)");
    assert(val(r, 1, 2) == "v", "multisort row 1 = v (a=1,b=2)");
    assert(val(r, 2, 2) == "x", "multisort row 2 = x (a=1,b=3)");
    assert(val(r, 3, 2) == "y", "multisort row 3 = y (a=2,b=1)");
    assert(val(r, 4, 2) == "w", "multisort row 4 = w (a=2,b=3)");

    // Test sort with LIMIT
    r = exec.executeSql("SELECT id FROM sortdata ORDER BY id LIMIT 5");
    check(r, "ORDER BY with LIMIT");
    assert(r.rowCount() == 5, "LIMIT 5 returns 5 rows");
    assert(val(r, 0, 0) == "1", "LIMIT first = 1");
    assert(val(r, 4, 0) == "5", "LIMIT last = 5");

    //=========================================================================
    // GROUP BY (hash-based)
    //=========================================================================
    Terminal.Say("");
    Terminal.Say("--- GROUP BY (hash-based) ---");

    check(exec.executeSql("CREATE TABLE sales (id INTEGER PRIMARY KEY, dept TEXT, region TEXT, amount INTEGER)"), "create sales");

    // Insert 30 rows across 3 departments and 2 regions
    check(exec.executeSql("INSERT INTO sales VALUES (1, 'Engineering', 'East', 100)"), "s1");
    check(exec.executeSql("INSERT INTO sales VALUES (2, 'Engineering', 'West', 200)"), "s2");
    check(exec.executeSql("INSERT INTO sales VALUES (3, 'Engineering', 'East', 150)"), "s3");
    check(exec.executeSql("INSERT INTO sales VALUES (4, 'Sales', 'East', 300)"), "s4");
    check(exec.executeSql("INSERT INTO sales VALUES (5, 'Sales', 'West', 250)"), "s5");
    check(exec.executeSql("INSERT INTO sales VALUES (6, 'Sales', 'East', 100)"), "s6");
    check(exec.executeSql("INSERT INTO sales VALUES (7, 'Marketing', 'West', 175)"), "s7");
    check(exec.executeSql("INSERT INTO sales VALUES (8, 'Marketing', 'East', 225)"), "s8");
    check(exec.executeSql("INSERT INTO sales VALUES (9, 'Engineering', 'West', 300)"), "s9");
    check(exec.executeSql("INSERT INTO sales VALUES (10, 'Sales', 'West', 400)"), "s10");
    check(exec.executeSql("INSERT INTO sales VALUES (11, 'Marketing', 'East', 125)"), "s11");
    check(exec.executeSql("INSERT INTO sales VALUES (12, 'Engineering', 'East', 275)"), "s12");
    check(exec.executeSql("INSERT INTO sales VALUES (13, 'Sales', 'East', 350)"), "s13");
    check(exec.executeSql("INSERT INTO sales VALUES (14, 'Marketing', 'West', 200)"), "s14");
    check(exec.executeSql("INSERT INTO sales VALUES (15, 'Engineering', 'West', 175)"), "s15");

    // Test single-column GROUP BY
    r = exec.executeSql("SELECT dept, COUNT(*) FROM sales GROUP BY dept ORDER BY dept");
    check(r, "GROUP BY dept");
    assert(r.rowCount() == 3, "3 departments: " + Fmt.Int(r.rowCount()));
    assert(val(r, 0, 0) == "Engineering", "group 0 = Engineering");
    assert(val(r, 0, 1) == "6", "Engineering count = 6");
    assert(val(r, 1, 0) == "Marketing", "group 1 = Marketing");
    assert(val(r, 1, 1) == "4", "Marketing count = 4");
    assert(val(r, 2, 0) == "Sales", "group 2 = Sales");
    assert(val(r, 2, 1) == "5", "Sales count = 5: " + val(r, 2, 1));

    // Test multi-column GROUP BY
    r = exec.executeSql("SELECT dept, region, SUM(amount) FROM sales GROUP BY dept, region ORDER BY dept, region");
    check(r, "GROUP BY dept, region");
    assert(r.rowCount() == 6, "6 dept-region groups: " + Fmt.Int(r.rowCount()));

    // Test GROUP BY with HAVING
    r = exec.executeSql("SELECT dept, SUM(amount) FROM sales GROUP BY dept HAVING SUM(amount) > 1000 ORDER BY dept");
    check(r, "GROUP BY with HAVING");
    assert(r.rowCount() == 2, "HAVING filters to 2 groups: " + Fmt.Int(r.rowCount()));

    // Test GROUP BY with aggregates
    r = exec.executeSql("SELECT dept, AVG(amount), MIN(amount), MAX(amount) FROM sales GROUP BY dept ORDER BY dept");
    check(r, "GROUP BY with multiple aggregates");
    assert(r.rowCount() == 3, "3 groups with aggregates");

    //=========================================================================
    // DISTINCT (hash-based)
    //=========================================================================
    Terminal.Say("");
    Terminal.Say("--- DISTINCT (hash-based) ---");

    // Test basic DISTINCT
    r = exec.executeSql("SELECT DISTINCT dept FROM sales ORDER BY dept");
    check(r, "DISTINCT dept");
    assert(r.rowCount() == 3, "DISTINCT dept = 3 unique: " + Fmt.Int(r.rowCount()));
    assert(val(r, 0, 0) == "Engineering", "DISTINCT dept 0 = Engineering");
    assert(val(r, 1, 0) == "Marketing", "DISTINCT dept 1 = Marketing");
    assert(val(r, 2, 0) == "Sales", "DISTINCT dept 2 = Sales");

    // Test DISTINCT on multiple columns
    r = exec.executeSql("SELECT DISTINCT dept, region FROM sales ORDER BY dept, region");
    check(r, "DISTINCT dept, region");
    assert(r.rowCount() == 6, "DISTINCT dept,region = 6 pairs: " + Fmt.Int(r.rowCount()));

    // Test DISTINCT with WHERE
    r = exec.executeSql("SELECT DISTINCT region FROM sales WHERE dept = 'Engineering'");
    check(r, "DISTINCT with WHERE");
    assert(r.rowCount() == 2, "DISTINCT region for Engineering = 2");

    // Test DISTINCT on all-unique data (no dedup)
    r = exec.executeSql("SELECT DISTINCT id FROM sales");
    check(r, "DISTINCT on unique column");
    assert(r.rowCount() == 15, "DISTINCT on PK = 15 rows");

    // Test DISTINCT on single-value column
    check(exec.executeSql("CREATE TABLE sameval (id INTEGER, x INTEGER)"), "create sameval");
    check(exec.executeSql("INSERT INTO sameval VALUES (1, 42)"), "sv1");
    check(exec.executeSql("INSERT INTO sameval VALUES (2, 42)"), "sv2");
    check(exec.executeSql("INSERT INTO sameval VALUES (3, 42)"), "sv3");
    check(exec.executeSql("INSERT INTO sameval VALUES (4, 42)"), "sv4");
    check(exec.executeSql("INSERT INTO sameval VALUES (5, 42)"), "sv5");
    r = exec.executeSql("SELECT DISTINCT x FROM sameval");
    check(r, "DISTINCT single value");
    assert(r.rowCount() == 1, "DISTINCT single val = 1 row");
    assert(val(r, 0, 0) == "42", "DISTINCT single val = 42");

    //=========================================================================
    // Index lookup (bucket-based)
    //=========================================================================
    Terminal.Say("");
    Terminal.Say("--- Index Lookup (bucket-based) ---");

    check(exec.executeSql("CREATE TABLE indexed_tbl (id INTEGER PRIMARY KEY, code TEXT, val INTEGER)"), "create indexed_tbl");
    check(exec.executeSql("CREATE INDEX idx_code ON indexed_tbl (code)"), "create index");

    // Insert multiple rows with various codes
    check(exec.executeSql("INSERT INTO indexed_tbl VALUES (1, 'AAA', 10)"), "idx1");
    check(exec.executeSql("INSERT INTO indexed_tbl VALUES (2, 'BBB', 20)"), "idx2");
    check(exec.executeSql("INSERT INTO indexed_tbl VALUES (3, 'CCC', 30)"), "idx3");
    check(exec.executeSql("INSERT INTO indexed_tbl VALUES (4, 'AAA', 40)"), "idx4");
    check(exec.executeSql("INSERT INTO indexed_tbl VALUES (5, 'BBB', 50)"), "idx5");
    check(exec.executeSql("INSERT INTO indexed_tbl VALUES (6, 'DDD', 60)"), "idx6");
    check(exec.executeSql("INSERT INTO indexed_tbl VALUES (7, 'AAA', 70)"), "idx7");
    check(exec.executeSql("INSERT INTO indexed_tbl VALUES (8, 'EEE', 80)"), "idx8");

    // Lookup via index
    r = exec.executeSql("SELECT val FROM indexed_tbl WHERE code = 'AAA' ORDER BY val");
    check(r, "index lookup AAA");
    assert(r.rowCount() == 3, "AAA has 3 rows: " + Fmt.Int(r.rowCount()));
    assert(val(r, 0, 0) == "10", "AAA row 0 = 10");
    assert(val(r, 1, 0) == "40", "AAA row 1 = 40");
    assert(val(r, 2, 0) == "70", "AAA row 2 = 70");

    r = exec.executeSql("SELECT val FROM indexed_tbl WHERE code = 'BBB' ORDER BY val");
    check(r, "index lookup BBB");
    assert(r.rowCount() == 2, "BBB has 2 rows");

    r = exec.executeSql("SELECT val FROM indexed_tbl WHERE code = 'ZZZ'");
    check(r, "index lookup miss");
    assert(r.rowCount() == 0, "ZZZ has 0 rows");

    // Test unique index
    check(exec.executeSql("CREATE TABLE unique_tbl (id INTEGER PRIMARY KEY, email TEXT)"), "create unique_tbl");
    check(exec.executeSql("CREATE UNIQUE INDEX idx_email ON unique_tbl (email)"), "create unique index");
    check(exec.executeSql("INSERT INTO unique_tbl VALUES (1, 'alice@test.com')"), "unique1");
    check(exec.executeSql("INSERT INTO unique_tbl VALUES (2, 'bob@test.com')"), "unique2");

    r = exec.executeSql("INSERT INTO unique_tbl VALUES (3, 'alice@test.com')");
    assert(r.success == false, "unique index rejects duplicate");

    // Test index after DELETE
    check(exec.executeSql("DELETE FROM indexed_tbl WHERE id = 4"), "delete idx4");
    r = exec.executeSql("SELECT val FROM indexed_tbl WHERE code = 'AAA' ORDER BY val");
    check(r, "index after delete");
    assert(r.rowCount() == 2, "AAA has 2 rows after delete: " + Fmt.Int(r.rowCount()));

    //=========================================================================
    // Short-circuit AND/OR
    //=========================================================================
    Terminal.Say("");
    Terminal.Say("--- Short-circuit AND/OR ---");

    check(exec.executeSql("CREATE TABLE sc_test (id INTEGER PRIMARY KEY, x INTEGER, y INTEGER)"), "create sc_test");
    check(exec.executeSql("INSERT INTO sc_test VALUES (1, 10, 0)"), "sc1");
    check(exec.executeSql("INSERT INTO sc_test VALUES (2, 20, 5)"), "sc2");
    check(exec.executeSql("INSERT INTO sc_test VALUES (3, 0, 10)"), "sc3");

    // AND short-circuit: left is false, right not evaluated
    r = exec.executeSql("SELECT * FROM sc_test WHERE 0 AND x > 0");
    check(r, "AND short-circuit false");
    assert(r.rowCount() == 0, "AND false short-circuits to 0 rows");

    // AND both true
    r = exec.executeSql("SELECT * FROM sc_test WHERE x > 5 AND y >= 0");
    check(r, "AND both true");
    assert(r.rowCount() == 2, "AND both true = 2 rows: " + Fmt.Int(r.rowCount()));

    // OR short-circuit: left is true, right not evaluated
    r = exec.executeSql("SELECT * FROM sc_test WHERE 1 OR x > 100");
    check(r, "OR short-circuit true");
    assert(r.rowCount() == 3, "OR true short-circuits to all rows");

    // OR both false
    r = exec.executeSql("SELECT * FROM sc_test WHERE x > 100 OR y > 100");
    check(r, "OR both false");
    assert(r.rowCount() == 0, "OR both false = 0 rows");

    // Complex: AND with OR
    r = exec.executeSql("SELECT * FROM sc_test WHERE (x > 5 OR y > 5) AND id < 3");
    check(r, "complex AND/OR");
    assert(r.rowCount() == 2, "complex AND/OR = 2 rows: " + Fmt.Int(r.rowCount()));

    // Short-circuit avoids division by zero in subexpression
    // (in Zia, division by zero doesn't crash, but this tests the pattern)
    r = exec.executeSql("SELECT * FROM sc_test WHERE y = 0 OR x / y > 0");
    check(r, "OR short-circuit avoids error");
    assert(r.rowCount() >= 1, "OR with divide: at least 1 row");

    //=========================================================================
    // Summary
    //=========================================================================
    Terminal.Say("");
    Terminal.Say("=== Results ===");
    Terminal.Say("Passed: " + Fmt.Int(passCount));
    Terminal.Say("Failed: " + Fmt.Int(failCount));

    Terminal.Say("=== Phase 2: " + Fmt.Int(passCount) + " passed, " + Fmt.Int(failCount) + " failed ===");
}
