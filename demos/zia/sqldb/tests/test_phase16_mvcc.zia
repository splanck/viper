// test_phase16_mvcc.zia — Phase 16: MVCC (Multi-Version Concurrency Control) Tests
// Tests for row versioning (xmin/xmax), visibility rules, snapshot isolation,
// and MVCC integration with INSERT/UPDATE/DELETE/SELECT.

module test_phase16_mvcc;

bind Terminal = Viper.Terminal;
bind String = Viper.String;
bind Fmt = Viper.Fmt;

bind "./test_common";
bind "../executor";
bind "../types";
bind "../schema";

func main() -> Integer {
    Terminal.Say("=== Phase 16: MVCC Tests ===");

    //=========================================================================
    // 1. ROW ENTITY — XMIN/XMAX FIELDS
    //=========================================================================
    section("Row xmin/xmax Fields");

    // Test 1: New row has xmin=0, xmax=0 by default
    var row = new Row();
    row.init();
    assertEqInt(row.xmin, 0, "New row xmin = 0");
    assertEqInt(row.xmax, 0, "New row xmax = 0");

    // Test 2: initWithCount preserves xmin/xmax = 0
    var row2 = new Row();
    row2.initWithCount(3);
    assertEqInt(row2.xmin, 0, "initWithCount xmin = 0");
    assertEqInt(row2.xmax, 0, "initWithCount xmax = 0");

    // Test 3: xmin/xmax can be set
    row.xmin = 42;
    row.xmax = 99;
    assertEqInt(row.xmin, 42, "Set xmin = 42");
    assertEqInt(row.xmax, 99, "Set xmax = 99");

    // Test 4: clone copies xmin/xmax
    var cloned = row.clone();
    assertEqInt(cloned.xmin, 42, "Cloned row xmin = 42");
    assertEqInt(cloned.xmax, 99, "Cloned row xmax = 99");

    //=========================================================================
    // 2. VISIBILITY RULES — isVisible()
    //=========================================================================
    section("isVisible() — Non-MVCC Mode");

    // Test 5: snapshotId=0 falls back to deleted flag
    var r1 = new Row();
    r1.init();
    assertTrue(r1.isVisible(0, 0), "Non-MVCC: live row is visible");

    // Test 6: deleted row is not visible in non-MVCC mode
    var r2 = new Row();
    r2.init();
    r2.deleted = true;
    assertFalse(r2.isVisible(0, 0), "Non-MVCC: deleted row not visible");

    section("isVisible() — MVCC Snapshot Isolation");

    // Test 7: Row created by current transaction is visible
    var r3 = new Row();
    r3.init();
    r3.xmin = 5;
    assertTrue(r3.isVisible(5, 5), "Row created by current txn is visible");

    // Test 8: Row created by older committed txn is visible
    var r4 = new Row();
    r4.init();
    r4.xmin = 3;
    assertTrue(r4.isVisible(5, 5), "Row from committed txn (xmin=3 < snapshot=5) visible");

    // Test 9: Row created by future txn is NOT visible
    var r5 = new Row();
    r5.init();
    r5.xmin = 10;
    assertFalse(r5.isVisible(5, 5), "Row from future txn (xmin=10 > snapshot=5) not visible");

    // Test 10: Row deleted by current txn is NOT visible
    var r6 = new Row();
    r6.init();
    r6.xmin = 2;
    r6.xmax = 5;
    assertFalse(r6.isVisible(5, 5), "Row deleted by current txn (xmax=5) not visible");

    // Test 11: Row deleted by committed txn is NOT visible
    var r7 = new Row();
    r7.init();
    r7.xmin = 2;
    r7.xmax = 3;
    assertFalse(r7.isVisible(5, 5), "Row deleted by committed txn (xmax=3 < snapshot=5) not visible");

    // Test 12: Row deleted by future txn IS visible (delete not yet committed)
    var r8 = new Row();
    r8.init();
    r8.xmin = 2;
    r8.xmax = 8;
    assertTrue(r8.isVisible(5, 5), "Row deleted by future txn (xmax=8 > snapshot=5) still visible");

    // Test 13: Row with no xmin (legacy row, xmin=0) and no xmax is visible
    var r9 = new Row();
    r9.init();
    assertTrue(r9.isVisible(5, 5), "Legacy row (xmin=0, xmax=0) visible");

    // Test 14: Deleted flag overrides MVCC
    var r10 = new Row();
    r10.init();
    r10.xmin = 2;
    r10.deleted = true;
    assertFalse(r10.isVisible(5, 5), "Soft-deleted row not visible even with valid xmin");

    // Test 15: Row visible to creator but not to earlier snapshot
    var r11 = new Row();
    r11.init();
    r11.xmin = 7;
    assertTrue(r11.isVisible(7, 7), "Creator sees own row (xmin=snapshot=txn)");
    assertFalse(r11.isVisible(5, 5), "Earlier snapshot doesn't see newer row");

    //=========================================================================
    // 3. EXECUTOR MVCC STATE
    //=========================================================================
    section("Executor MVCC State");

    var exec = new Executor();
    exec.init();

    // Test 16: Initial MVCC state
    assertEqInt(exec.mvccTxnCounter, 1, "Initial mvccTxnCounter = 1");
    assertEqInt(exec.mvccTxnId, 0, "Initial mvccTxnId = 0");
    assertEqInt(exec.mvccSnapshotId, 0, "Initial mvccSnapshotId = 0");

    // Test 17: BEGIN assigns txn ID and snapshot
    var beginResult = exec.executeSql("BEGIN");
    assertSuccess(beginResult, "BEGIN");
    assertEqInt(exec.mvccTxnId, 1, "After BEGIN: mvccTxnId = 1");
    assertEqInt(exec.mvccSnapshotId, 1, "After BEGIN: mvccSnapshotId = 1");
    assertEqInt(exec.mvccTxnCounter, 2, "After BEGIN: mvccTxnCounter = 2");

    // Test 18: COMMIT clears MVCC state
    var commitResult = exec.executeSql("COMMIT");
    assertSuccess(commitResult, "COMMIT");
    assertEqInt(exec.mvccTxnId, 0, "After COMMIT: mvccTxnId = 0");
    assertEqInt(exec.mvccSnapshotId, 0, "After COMMIT: mvccSnapshotId = 0");

    // Test 19: Counter increments across transactions
    exec.executeSql("BEGIN");
    assertEqInt(exec.mvccTxnId, 2, "Second txn: mvccTxnId = 2");
    assertEqInt(exec.mvccSnapshotId, 2, "Second txn: mvccSnapshotId = 2");
    assertEqInt(exec.mvccTxnCounter, 3, "Second txn: mvccTxnCounter = 3");

    // Test 20: ROLLBACK clears MVCC state
    var rollbackResult = exec.executeSql("ROLLBACK");
    assertSuccess(rollbackResult, "ROLLBACK");
    assertEqInt(exec.mvccTxnId, 0, "After ROLLBACK: mvccTxnId = 0");
    assertEqInt(exec.mvccSnapshotId, 0, "After ROLLBACK: mvccSnapshotId = 0");

    // Test 21: Counter preserved after rollback
    assertEqInt(exec.mvccTxnCounter, 3, "Counter preserved after ROLLBACK = 3");

    //=========================================================================
    // 4. INSERT STAMPS XMIN
    //=========================================================================
    section("INSERT — MVCC xmin Stamping");

    var exec2 = new Executor();
    exec2.init();
    exec2.executeSql("CREATE TABLE t1 (id INTEGER, name TEXT)");

    // Test 22: INSERT outside transaction (xmin=0, non-MVCC)
    exec2.executeSql("INSERT INTO t1 VALUES (1, 'alice')");
    var sel1 = exec2.executeSql("SELECT id, name FROM t1");
    assertRowCount(sel1, 1, "Non-txn INSERT: 1 row");
    assertEq(val(sel1, 0, 1), "alice", "Non-txn INSERT: alice");

    // Test 23: INSERT inside transaction stamps xmin
    exec2.executeSql("BEGIN");
    var txnId = exec2.mvccTxnId;
    exec2.executeSql("INSERT INTO t1 VALUES (2, 'bob')");
    var sel2 = exec2.executeSql("SELECT id, name FROM t1 WHERE id = 2");
    assertRowCount(sel2, 1, "Txn INSERT: bob visible to own txn");
    exec2.executeSql("COMMIT");

    // Test 24: After commit, row visible to all
    var sel3 = exec2.executeSql("SELECT id, name FROM t1 ORDER BY id");
    assertRowCount(sel3, 2, "After COMMIT: 2 rows visible");

    //=========================================================================
    // 5. DELETE STAMPS XMAX
    //=========================================================================
    section("DELETE — MVCC xmax Stamping");

    var exec3 = new Executor();
    exec3.init();
    exec3.executeSql("CREATE TABLE t2 (id INTEGER, val TEXT)");
    exec3.executeSql("INSERT INTO t2 VALUES (1, 'keep')");
    exec3.executeSql("INSERT INTO t2 VALUES (2, 'remove')");
    exec3.executeSql("INSERT INTO t2 VALUES (3, 'keep2')");

    // Test 25: DELETE in transaction
    exec3.executeSql("BEGIN");
    exec3.executeSql("DELETE FROM t2 WHERE id = 2");

    // Test 26: Deleted row not visible in same txn
    var sel4 = exec3.executeSql("SELECT id FROM t2 ORDER BY id");
    assertRowCount(sel4, 2, "After DELETE in txn: 2 rows visible");
    assertEq(val(sel4, 0, 0), "1", "First remaining row: id=1");
    assertEq(val(sel4, 1, 0), "3", "Second remaining row: id=3");

    exec3.executeSql("COMMIT");

    // Test 27: After commit, deletion persists
    var sel5 = exec3.executeSql("SELECT id FROM t2 ORDER BY id");
    assertRowCount(sel5, 2, "After COMMIT: deletion persisted, 2 rows");

    //=========================================================================
    // 6. UPDATE STAMPS XMIN
    //=========================================================================
    section("UPDATE — MVCC xmin Stamping");

    var exec4 = new Executor();
    exec4.init();
    exec4.executeSql("CREATE TABLE t3 (id INTEGER, val TEXT)");
    exec4.executeSql("INSERT INTO t3 VALUES (1, 'old')");
    exec4.executeSql("INSERT INTO t3 VALUES (2, 'unchanged')");

    // Test 28: UPDATE inside transaction
    exec4.executeSql("BEGIN");
    exec4.executeSql("UPDATE t3 SET val = 'new' WHERE id = 1");

    // Test 29: Updated row visible in same transaction
    var sel6 = exec4.executeSql("SELECT id, val FROM t3 WHERE id = 1");
    assertRowCount(sel6, 1, "Updated row visible in txn");
    assertEq(val(sel6, 0, 1), "new", "Updated value = 'new'");

    exec4.executeSql("COMMIT");

    // Test 30: After commit, update persists
    var sel7 = exec4.executeSql("SELECT id, val FROM t3 ORDER BY id");
    assertRowCount(sel7, 2, "After COMMIT: 2 rows");
    assertEq(val(sel7, 0, 1), "new", "Row 1 val = 'new' after commit");
    assertEq(val(sel7, 1, 1), "unchanged", "Row 2 val = 'unchanged'");

    //=========================================================================
    // 7. ROLLBACK UNDO — MVCC INTERACTION
    //=========================================================================
    section("ROLLBACK with MVCC");

    var exec5 = new Executor();
    exec5.init();
    exec5.executeSql("CREATE TABLE t4 (id INTEGER, name TEXT)");
    exec5.executeSql("INSERT INTO t4 VALUES (1, 'alice')");
    exec5.executeSql("INSERT INTO t4 VALUES (2, 'bob')");

    // Test 31: INSERT then ROLLBACK
    exec5.executeSql("BEGIN");
    exec5.executeSql("INSERT INTO t4 VALUES (3, 'charlie')");
    var sel8 = exec5.executeSql("SELECT COUNT(*) FROM t4");
    assertEq(val(sel8, 0, 0), "3", "During txn: 3 rows");
    exec5.executeSql("ROLLBACK");

    var sel9 = exec5.executeSql("SELECT COUNT(*) FROM t4");
    assertEq(val(sel9, 0, 0), "2", "After ROLLBACK INSERT: 2 rows");

    // Test 32: DELETE then ROLLBACK
    exec5.executeSql("BEGIN");
    exec5.executeSql("DELETE FROM t4 WHERE id = 1");
    var sel10 = exec5.executeSql("SELECT COUNT(*) FROM t4");
    assertEq(val(sel10, 0, 0), "1", "During DELETE txn: 1 row");
    exec5.executeSql("ROLLBACK");

    var sel11 = exec5.executeSql("SELECT COUNT(*) FROM t4");
    assertEq(val(sel11, 0, 0), "2", "After ROLLBACK DELETE: 2 rows restored");

    // Test 33: UPDATE then ROLLBACK
    exec5.executeSql("BEGIN");
    exec5.executeSql("UPDATE t4 SET name = 'MODIFIED' WHERE id = 2");
    var sel12 = exec5.executeSql("SELECT name FROM t4 WHERE id = 2");
    assertEq(val(sel12, 0, 0), "MODIFIED", "During UPDATE txn: modified");
    exec5.executeSql("ROLLBACK");

    var sel13 = exec5.executeSql("SELECT name FROM t4 WHERE id = 2");
    assertEq(val(sel13, 0, 0), "bob", "After ROLLBACK UPDATE: restored to 'bob'");

    //=========================================================================
    // 8. SEQUENTIAL TRANSACTIONS
    //=========================================================================
    section("Sequential MVCC Transactions");

    var exec6 = new Executor();
    exec6.init();
    exec6.executeSql("CREATE TABLE t5 (id INTEGER, val INTEGER)");

    // Test 34: Multiple sequential transactions
    exec6.executeSql("BEGIN");
    assertEqInt(exec6.mvccTxnId, 1, "First txn: id=1");
    exec6.executeSql("INSERT INTO t5 VALUES (1, 100)");
    exec6.executeSql("COMMIT");

    exec6.executeSql("BEGIN");
    assertEqInt(exec6.mvccTxnId, 2, "Second txn: id=2");
    exec6.executeSql("INSERT INTO t5 VALUES (2, 200)");
    exec6.executeSql("COMMIT");

    exec6.executeSql("BEGIN");
    assertEqInt(exec6.mvccTxnId, 3, "Third txn: id=3");
    exec6.executeSql("INSERT INTO t5 VALUES (3, 300)");
    exec6.executeSql("COMMIT");

    // Test 35: All committed rows visible
    var sel14 = exec6.executeSql("SELECT id, val FROM t5 ORDER BY id");
    assertRowCount(sel14, 3, "All 3 committed rows visible");
    assertEq(val(sel14, 0, 1), "100", "Row 1: val=100");
    assertEq(val(sel14, 1, 1), "200", "Row 2: val=200");
    assertEq(val(sel14, 2, 1), "300", "Row 3: val=300");

    //=========================================================================
    // 9. MIXED OPERATIONS IN TRANSACTION
    //=========================================================================
    section("Mixed INSERT/UPDATE/DELETE in Transaction");

    var exec7 = new Executor();
    exec7.init();
    exec7.executeSql("CREATE TABLE t6 (id INTEGER PRIMARY KEY, name TEXT, score INTEGER)");
    exec7.executeSql("INSERT INTO t6 VALUES (1, 'alice', 80)");
    exec7.executeSql("INSERT INTO t6 VALUES (2, 'bob', 90)");
    exec7.executeSql("INSERT INTO t6 VALUES (3, 'charlie', 70)");

    // Test 36: Mixed operations in a single transaction
    exec7.executeSql("BEGIN");
    exec7.executeSql("INSERT INTO t6 VALUES (4, 'diana', 95)");
    exec7.executeSql("UPDATE t6 SET score = 85 WHERE id = 1");
    exec7.executeSql("DELETE FROM t6 WHERE id = 3");

    // Test 37: All changes visible during txn
    var sel15 = exec7.executeSql("SELECT id, name, score FROM t6 ORDER BY id");
    assertRowCount(sel15, 3, "During mixed txn: 3 rows (added 1, removed 1)");
    assertEq(val(sel15, 0, 0), "1", "Row 1: alice");
    assertEq(val(sel15, 0, 2), "85", "alice updated to score=85");
    assertEq(val(sel15, 1, 0), "2", "Row 2: bob");
    assertEq(val(sel15, 2, 0), "4", "Row 3: diana (new)");

    exec7.executeSql("COMMIT");

    // Test 38: All committed changes visible
    var sel16 = exec7.executeSql("SELECT id, name, score FROM t6 ORDER BY id");
    assertRowCount(sel16, 3, "After COMMIT mixed: 3 rows");
    assertEq(val(sel16, 0, 2), "85", "alice score=85 persisted");
    assertEq(val(sel16, 2, 1), "diana", "diana persisted");

    //=========================================================================
    // 10. AGGREGATE QUERIES WITH MVCC
    //=========================================================================
    section("Aggregate Queries with MVCC Visibility");

    var exec8 = new Executor();
    exec8.init();
    exec8.executeSql("CREATE TABLE t7 (id INTEGER, amount INTEGER)");
    exec8.executeSql("INSERT INTO t7 VALUES (1, 10)");
    exec8.executeSql("INSERT INTO t7 VALUES (2, 20)");
    exec8.executeSql("INSERT INTO t7 VALUES (3, 30)");

    // Test 39: Aggregates respect visibility
    var sumBefore = exec8.executeSql("SELECT SUM(amount), COUNT(*) FROM t7");
    assertEq(val(sumBefore, 0, 0), "60", "SUM before txn = 60");
    assertEq(val(sumBefore, 0, 1), "3", "COUNT before txn = 3");

    // Test 40: Aggregates during transaction
    exec8.executeSql("BEGIN");
    exec8.executeSql("INSERT INTO t7 VALUES (4, 40)");
    exec8.executeSql("DELETE FROM t7 WHERE id = 1");

    var sumDuring = exec8.executeSql("SELECT SUM(amount), COUNT(*) FROM t7");
    assertEq(val(sumDuring, 0, 0), "90", "SUM during txn = 90 (20+30+40)");
    assertEq(val(sumDuring, 0, 1), "3", "COUNT during txn = 3");

    exec8.executeSql("ROLLBACK");

    // Test 41: Aggregates after rollback
    var sumAfter = exec8.executeSql("SELECT SUM(amount), COUNT(*) FROM t7");
    assertEq(val(sumAfter, 0, 0), "60", "SUM after ROLLBACK = 60");
    assertEq(val(sumAfter, 0, 1), "3", "COUNT after ROLLBACK = 3");

    //=========================================================================
    // 11. JOIN VISIBILITY
    //=========================================================================
    section("JOIN with MVCC Visibility");

    var exec9 = new Executor();
    exec9.init();
    exec9.executeSql("CREATE TABLE orders (id INTEGER, customer TEXT)");
    exec9.executeSql("CREATE TABLE items (id INTEGER, order_id INTEGER, product TEXT)");
    exec9.executeSql("INSERT INTO orders VALUES (1, 'alice')");
    exec9.executeSql("INSERT INTO orders VALUES (2, 'bob')");
    exec9.executeSql("INSERT INTO items VALUES (1, 1, 'widget')");
    exec9.executeSql("INSERT INTO items VALUES (2, 2, 'gadget')");

    // Test 42: JOIN works normally outside transaction
    var join1 = exec9.executeSql("SELECT o.customer, i.product FROM orders o INNER JOIN items i ON o.id = i.order_id ORDER BY o.customer");
    assertRowCount(join1, 2, "JOIN: 2 rows before txn");
    assertEq(val(join1, 0, 0), "alice", "JOIN row 1: alice");

    // Test 43: JOIN respects in-transaction deletes
    exec9.executeSql("BEGIN");
    exec9.executeSql("DELETE FROM orders WHERE id = 2");
    var join2 = exec9.executeSql("SELECT o.customer, i.product FROM orders o INNER JOIN items i ON o.id = i.order_id ORDER BY o.customer");
    assertRowCount(join2, 1, "JOIN during txn: 1 row (bob's order deleted)");
    assertEq(val(join2, 0, 0), "alice", "JOIN during txn: alice remains");
    exec9.executeSql("ROLLBACK");

    // Test 44: JOIN back to normal after rollback
    var join3 = exec9.executeSql("SELECT o.customer FROM orders o INNER JOIN items i ON o.id = i.order_id ORDER BY o.customer");
    assertRowCount(join3, 2, "JOIN after ROLLBACK: 2 rows restored");

    //=========================================================================
    // 12. INDEX-BASED LOOKUPS WITH MVCC
    //=========================================================================
    section("Index Lookups with MVCC");

    var exec10 = new Executor();
    exec10.init();
    exec10.executeSql("CREATE TABLE indexed_t (id INTEGER, name TEXT)");
    exec10.executeSql("CREATE INDEX idx_name ON indexed_t (name)");
    exec10.executeSql("INSERT INTO indexed_t VALUES (1, 'alpha')");
    exec10.executeSql("INSERT INTO indexed_t VALUES (2, 'beta')");
    exec10.executeSql("INSERT INTO indexed_t VALUES (3, 'gamma')");

    // Test 45: Index lookup works
    var idx1 = exec10.executeSql("SELECT id FROM indexed_t WHERE name = 'beta'");
    assertRowCount(idx1, 1, "Index lookup: found beta");
    assertEq(val(idx1, 0, 0), "2", "Index lookup: id=2");

    // Test 46: Index lookup after DELETE in transaction
    exec10.executeSql("BEGIN");
    exec10.executeSql("DELETE FROM indexed_t WHERE id = 2");
    var idx2 = exec10.executeSql("SELECT id FROM indexed_t WHERE name = 'beta'");
    assertRowCount(idx2, 0, "Index lookup after DELETE: beta not found");
    exec10.executeSql("ROLLBACK");

    // Test 47: Index lookup restored after rollback
    var idx3 = exec10.executeSql("SELECT id FROM indexed_t WHERE name = 'beta'");
    assertRowCount(idx3, 1, "Index lookup after ROLLBACK: beta found again");

    //=========================================================================
    // 13. MVCC WITH WHERE CONDITIONS
    //=========================================================================
    section("MVCC with WHERE Conditions");

    var exec11 = new Executor();
    exec11.init();
    exec11.executeSql("CREATE TABLE scored (id INTEGER, score INTEGER, grade TEXT)");
    exec11.executeSql("INSERT INTO scored VALUES (1, 90, 'A')");
    exec11.executeSql("INSERT INTO scored VALUES (2, 75, 'B')");
    exec11.executeSql("INSERT INTO scored VALUES (3, 60, 'C')");
    exec11.executeSql("INSERT INTO scored VALUES (4, 45, 'D')");

    // Test 48: WHERE filter before transaction
    var w1 = exec11.executeSql("SELECT COUNT(*) FROM scored WHERE score >= 70");
    assertEq(val(w1, 0, 0), "2", "WHERE score>=70: 2 rows");

    // Test 49: WHERE filter during transaction with updates
    exec11.executeSql("BEGIN");
    exec11.executeSql("UPDATE scored SET score = 80 WHERE id = 3");
    var w2 = exec11.executeSql("SELECT COUNT(*) FROM scored WHERE score >= 70");
    assertEq(val(w2, 0, 0), "3", "After UPDATE in txn: 3 rows >= 70");
    exec11.executeSql("ROLLBACK");

    // Test 50: WHERE filter after rollback
    var w3 = exec11.executeSql("SELECT COUNT(*) FROM scored WHERE score >= 70");
    assertEq(val(w3, 0, 0), "2", "After ROLLBACK: back to 2 rows >= 70");

    //=========================================================================
    // 14. NON-TRANSACTIONAL OPERATIONS (snapshotId=0)
    //=========================================================================
    section("Non-Transactional Operations (snapshotId=0)");

    var exec12 = new Executor();
    exec12.init();
    exec12.executeSql("CREATE TABLE auto_t (id INTEGER, val TEXT)");

    // Test 51: Outside transaction, operations work with deleted flag (no MVCC)
    assertEqInt(exec12.mvccSnapshotId, 0, "No txn: snapshotId = 0");
    exec12.executeSql("INSERT INTO auto_t VALUES (1, 'a')");
    exec12.executeSql("INSERT INTO auto_t VALUES (2, 'b')");
    exec12.executeSql("INSERT INTO auto_t VALUES (3, 'c')");

    var auto1 = exec12.executeSql("SELECT COUNT(*) FROM auto_t");
    assertEq(val(auto1, 0, 0), "3", "Non-txn: 3 rows");

    // Test 52: Auto-commit DELETE works without MVCC
    exec12.executeSql("DELETE FROM auto_t WHERE id = 2");
    var auto2 = exec12.executeSql("SELECT COUNT(*) FROM auto_t");
    assertEq(val(auto2, 0, 0), "2", "Non-txn DELETE: 2 rows remaining");

    // Test 53: Auto-commit UPDATE works without MVCC
    exec12.executeSql("UPDATE auto_t SET val = 'updated' WHERE id = 1");
    var auto3 = exec12.executeSql("SELECT val FROM auto_t WHERE id = 1");
    assertEq(val(auto3, 0, 0), "updated", "Non-txn UPDATE: val = 'updated'");

    //=========================================================================
    // 15. EDGE CASES
    //=========================================================================
    section("Edge Cases");

    // Test 54: Empty table in transaction
    var exec13 = new Executor();
    exec13.init();
    exec13.executeSql("CREATE TABLE empty_t (id INTEGER)");
    exec13.executeSql("BEGIN");
    var empty1 = exec13.executeSql("SELECT COUNT(*) FROM empty_t");
    assertEq(val(empty1, 0, 0), "0", "Empty table in txn: COUNT=0");
    exec13.executeSql("COMMIT");

    // Test 55: DELETE all rows then SELECT
    var exec14 = new Executor();
    exec14.init();
    exec14.executeSql("CREATE TABLE del_all (id INTEGER)");
    exec14.executeSql("INSERT INTO del_all VALUES (1)");
    exec14.executeSql("INSERT INTO del_all VALUES (2)");
    exec14.executeSql("BEGIN");
    exec14.executeSql("DELETE FROM del_all WHERE id > 0");
    var delAll = exec14.executeSql("SELECT COUNT(*) FROM del_all");
    assertEq(val(delAll, 0, 0), "0", "DELETE all in txn: 0 rows");
    exec14.executeSql("ROLLBACK");
    var delAllAfter = exec14.executeSql("SELECT COUNT(*) FROM del_all");
    assertEq(val(delAllAfter, 0, 0), "2", "After ROLLBACK DELETE all: 2 rows");

    // Test 56: Multiple UPDATEs to same row in one transaction
    var exec15 = new Executor();
    exec15.init();
    exec15.executeSql("CREATE TABLE multi_upd (id INTEGER, val INTEGER)");
    exec15.executeSql("INSERT INTO multi_upd VALUES (1, 10)");
    exec15.executeSql("BEGIN");
    exec15.executeSql("UPDATE multi_upd SET val = 20 WHERE id = 1");
    exec15.executeSql("UPDATE multi_upd SET val = 30 WHERE id = 1");
    exec15.executeSql("UPDATE multi_upd SET val = 40 WHERE id = 1");
    var multiUpd = exec15.executeSql("SELECT val FROM multi_upd WHERE id = 1");
    assertEq(val(multiUpd, 0, 0), "40", "Multiple UPDATEs: final val = 40");
    exec15.executeSql("COMMIT");
    var multiUpdAfter = exec15.executeSql("SELECT val FROM multi_upd WHERE id = 1");
    assertEq(val(multiUpdAfter, 0, 0), "40", "After COMMIT: val = 40 persisted");

    // Test 57: INSERT + DELETE same row in one transaction
    var exec16 = new Executor();
    exec16.init();
    exec16.executeSql("CREATE TABLE ins_del (id INTEGER)");
    exec16.executeSql("BEGIN");
    exec16.executeSql("INSERT INTO ins_del VALUES (1)");
    exec16.executeSql("DELETE FROM ins_del WHERE id = 1");
    var insDel = exec16.executeSql("SELECT COUNT(*) FROM ins_del");
    assertEq(val(insDel, 0, 0), "0", "INSERT+DELETE same row: 0 rows");
    exec16.executeSql("ROLLBACK");
    var insDelAfter = exec16.executeSql("SELECT COUNT(*) FROM ins_del");
    assertEq(val(insDelAfter, 0, 0), "0", "After ROLLBACK: still 0 (insert was undone too)");

    //=========================================================================
    // 16. SUBQUERY WITH MVCC
    //=========================================================================
    section("Subquery with MVCC Visibility");

    var exec17 = new Executor();
    exec17.init();
    exec17.executeSql("CREATE TABLE parent_t (id INTEGER, name TEXT)");
    exec17.executeSql("CREATE TABLE child_t (id INTEGER, parent_id INTEGER, item TEXT)");
    exec17.executeSql("INSERT INTO parent_t VALUES (1, 'alice')");
    exec17.executeSql("INSERT INTO parent_t VALUES (2, 'bob')");
    exec17.executeSql("INSERT INTO child_t VALUES (1, 1, 'toy')");
    exec17.executeSql("INSERT INTO child_t VALUES (2, 2, 'book')");

    // Test 58: Subquery before transaction
    var sub1 = exec17.executeSql("SELECT name FROM parent_t WHERE id IN (SELECT parent_id FROM child_t)");
    assertRowCount(sub1, 2, "Subquery: 2 parents have children");

    // Test 59: Subquery after DELETE in transaction
    exec17.executeSql("BEGIN");
    exec17.executeSql("DELETE FROM child_t WHERE parent_id = 2");
    var sub2 = exec17.executeSql("SELECT name FROM parent_t WHERE id IN (SELECT parent_id FROM child_t)");
    assertRowCount(sub2, 1, "Subquery in txn: 1 parent after deleting bob's child");
    assertEq(val(sub2, 0, 0), "alice", "Subquery in txn: alice only");
    exec17.executeSql("ROLLBACK");

    // Test 60: Subquery restored after rollback
    var sub3 = exec17.executeSql("SELECT name FROM parent_t WHERE id IN (SELECT parent_id FROM child_t) ORDER BY name");
    assertRowCount(sub3, 2, "Subquery after ROLLBACK: 2 parents again");

    //=========================================================================
    // RESULTS
    //=========================================================================
    printResults();

    if failed > 0 {
        return 1;
    }
    return 0;
}
