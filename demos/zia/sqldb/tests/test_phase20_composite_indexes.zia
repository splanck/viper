// test_phase20_composite_indexes.zia — Phase 20: Composite Index Tests
// Tests for multi-column indexes, composite key lookups, prefix matching,
// unique composite constraints, and EXPLAIN output.

module test_phase20_composite_indexes;

bind Terminal = Viper.Terminal;
bind String = Viper.String;
bind Fmt = Viper.Fmt;

bind "./test_common";
bind "../executor";
bind "../types";
bind "../index";

func main() -> Integer {
    Terminal.Say("=== Phase 20: Composite & Expression Indexes Tests ===");

    //=========================================================================
    // 1. COMPOSITE INDEX ENTITY BASICS
    //=========================================================================
    section("Composite Index Entity");

    // Test 1: Create multi-column index entity
    var idx = new SqlIndex();
    idx.initWithNames("idx_test", "users");
    idx.addColumn("last_name");
    idx.addColumn("first_name");
    assertEqInt(idx.columnCount(), 2, "Composite index has 2 columns");
    assertEq(idx.getColumnName(0), "last_name", "First column = last_name");
    assertEq(idx.getColumnName(1), "first_name", "Second column = first_name");

    // Test 2: toString shows all columns
    var desc = idx.toString();
    assert(String.Length(desc) > 0, "toString produces output");

    //=========================================================================
    // 2. SQL: CREATE COMPOSITE INDEX
    //=========================================================================
    section("CREATE Composite Index");

    var exec = new Executor();
    exec.init();

    // Setup test table
    exec.executeSql("CREATE TABLE employees (id INTEGER PRIMARY KEY, last_name TEXT, first_name TEXT, dept TEXT, salary INTEGER)");
    exec.executeSql("INSERT INTO employees VALUES (1, 'Smith', 'John', 'Engineering', 80000)");
    exec.executeSql("INSERT INTO employees VALUES (2, 'Smith', 'Jane', 'Marketing', 75000)");
    exec.executeSql("INSERT INTO employees VALUES (3, 'Johnson', 'Bob', 'Engineering', 90000)");
    exec.executeSql("INSERT INTO employees VALUES (4, 'Johnson', 'Alice', 'Sales', 70000)");
    exec.executeSql("INSERT INTO employees VALUES (5, 'Williams', 'Carol', 'Engineering', 85000)");
    exec.executeSql("INSERT INTO employees VALUES (6, 'Smith', 'Bob', 'Sales', 65000)");

    // Test 3: Create composite index
    var r1 = exec.executeSql("CREATE INDEX idx_name ON employees (last_name, first_name)");
    assertSuccess(r1, "CREATE composite INDEX succeeds");

    // Test 4: Verify index exists via SHOW
    var r2 = exec.executeSql("DESCRIBE employees");
    assertSuccess(r2, "DESCRIBE succeeds");

    //=========================================================================
    // 3. COMPOSITE EQUALITY LOOKUP
    //=========================================================================
    section("Composite Equality Lookup");

    // Test 5: Query matching full composite key
    var r3 = exec.executeSql("SELECT id FROM employees WHERE last_name = 'Smith' AND first_name = 'John'");
    assertSuccess(r3, "Composite equality query succeeds");
    assertRowCount(r3, 1, "Returns 1 row for Smith/John");
    assertEq(val(r3, 0, 0), "1", "id = 1 for Smith/John");

    // Test 6: Query matching another composite key
    var r4 = exec.executeSql("SELECT id FROM employees WHERE last_name = 'Johnson' AND first_name = 'Alice'");
    assertSuccess(r4, "Second composite equality query succeeds");
    assertRowCount(r4, 1, "Returns 1 row for Johnson/Alice");
    assertEq(val(r4, 0, 0), "4", "id = 4 for Johnson/Alice");

    // Test 7: No match for non-existent composite key
    var r5 = exec.executeSql("SELECT id FROM employees WHERE last_name = 'Smith' AND first_name = 'Carol'");
    assertSuccess(r5, "Non-matching composite returns success");
    assertRowCount(r5, 0, "Returns 0 rows for Smith/Carol");

    //=========================================================================
    // 4. PREFIX LOOKUP (LEADING COLUMN ONLY)
    //=========================================================================
    section("Prefix Lookup (Leading Column)");

    // Test 8: Query using only the leading column of composite index
    var r6 = exec.executeSql("SELECT id FROM employees WHERE last_name = 'Smith' ORDER BY id");
    assertSuccess(r6, "Leading column query succeeds");
    assertRowCount(r6, 3, "Returns 3 Smiths");
    assertEq(val(r6, 0, 0), "1", "First Smith id = 1");
    assertEq(val(r6, 1, 0), "2", "Second Smith id = 2");
    assertEq(val(r6, 2, 0), "6", "Third Smith id = 6");

    // Test 9: Single Johnson
    var r7 = exec.executeSql("SELECT id FROM employees WHERE last_name = 'Johnson' ORDER BY id");
    assertSuccess(r7, "Leading column Johnson query succeeds");
    assertRowCount(r7, 2, "Returns 2 Johnsons");

    //=========================================================================
    // 5. UNIQUE COMPOSITE INDEX
    //=========================================================================
    section("Unique Composite Index");

    exec.executeSql("CREATE TABLE orders (id INTEGER PRIMARY KEY, customer TEXT, product TEXT, qty INTEGER)");
    exec.executeSql("INSERT INTO orders VALUES (1, 'Alice', 'Widget', 5)");
    exec.executeSql("INSERT INTO orders VALUES (2, 'Bob', 'Gadget', 3)");
    exec.executeSql("INSERT INTO orders VALUES (3, 'Alice', 'Gadget', 2)");

    // Test 10: Create unique composite index
    var r8 = exec.executeSql("CREATE UNIQUE INDEX idx_cust_prod ON orders (customer, product)");
    assertSuccess(r8, "CREATE UNIQUE composite INDEX succeeds");

    // Test 11: Duplicate composite key should fail
    var r9 = exec.executeSql("INSERT INTO orders VALUES (4, 'Alice', 'Widget', 10)");
    assertFailure(r9, "Duplicate composite key INSERT rejected");

    // Test 12: Same customer different product is OK
    var r10 = exec.executeSql("INSERT INTO orders VALUES (4, 'Alice', 'Doohickey', 7)");
    assertSuccess(r10, "Different composite key INSERT succeeds");

    // Test 13: Same product different customer is OK
    var r11 = exec.executeSql("INSERT INTO orders VALUES (5, 'Carol', 'Widget', 1)");
    assertSuccess(r11, "Different customer same product INSERT succeeds");

    //=========================================================================
    // 6. THREE-COLUMN COMPOSITE INDEX
    //=========================================================================
    section("Three-Column Composite Index");

    exec.executeSql("CREATE TABLE logs (id INTEGER PRIMARY KEY, year INTEGER, month INTEGER, day INTEGER, msg TEXT)");
    exec.executeSql("INSERT INTO logs VALUES (1, 2024, 1, 15, 'Event A')");
    exec.executeSql("INSERT INTO logs VALUES (2, 2024, 1, 20, 'Event B')");
    exec.executeSql("INSERT INTO logs VALUES (3, 2024, 2, 10, 'Event C')");
    exec.executeSql("INSERT INTO logs VALUES (4, 2025, 1, 15, 'Event D')");
    exec.executeSql("INSERT INTO logs VALUES (5, 2024, 1, 15, 'Event E')");

    var r12 = exec.executeSql("CREATE INDEX idx_date ON logs (year, month, day)");
    assertSuccess(r12, "CREATE 3-column index succeeds");

    // Test 14: Full three-column match
    var r13 = exec.executeSql("SELECT id FROM logs WHERE year = 2024 AND month = 1 AND day = 15 ORDER BY id");
    assertSuccess(r13, "Full 3-column equality succeeds");
    assertRowCount(r13, 2, "2 rows match 2024/1/15");
    assertEq(val(r13, 0, 0), "1", "First match id = 1");
    assertEq(val(r13, 1, 0), "5", "Second match id = 5");

    // Test 15: Two-column prefix match
    var r14 = exec.executeSql("SELECT id FROM logs WHERE year = 2024 AND month = 1 ORDER BY id");
    assertSuccess(r14, "2-column prefix match succeeds");
    assertRowCount(r14, 3, "3 rows in 2024/1");

    // Test 16: Leading column only
    var r15 = exec.executeSql("SELECT id FROM logs WHERE year = 2024 ORDER BY id");
    assertSuccess(r15, "Leading column match succeeds");
    assertRowCount(r15, 4, "4 rows in 2024");

    //=========================================================================
    // 7. COMPOSITE INDEX WITH UPDATE AND DELETE
    //=========================================================================
    section("Composite Index Maintenance");

    // Test 17: Update maintains composite uniqueness
    var r16 = exec.executeSql("UPDATE orders SET qty = 99 WHERE customer = 'Alice' AND product = 'Widget'");
    assertSuccess(r16, "UPDATE with composite index succeeds");

    var r17 = exec.executeSql("SELECT qty FROM orders WHERE customer = 'Alice' AND product = 'Widget'");
    assertEq(val(r17, 0, 0), "99", "Updated qty = 99");

    // Test 18: Delete with composite index
    var r18 = exec.executeSql("DELETE FROM orders WHERE customer = 'Carol' AND product = 'Widget'");
    assertSuccess(r18, "DELETE with composite index succeeds");

    var r19 = exec.executeSql("SELECT COUNT(*) FROM orders");
    assertEq(val(r19, 0, 0), "4", "4 orders remain after delete");

    // Test 19: After delete, the composite key is freed for reuse
    var r20 = exec.executeSql("INSERT INTO orders VALUES (6, 'Carol', 'Widget', 3)");
    assertSuccess(r20, "Re-insert freed composite key succeeds");

    //=========================================================================
    // 8. MIXED SINGLE AND COMPOSITE INDEXES
    //=========================================================================
    section("Mixed Index Types");

    exec.executeSql("CREATE TABLE products (id INTEGER PRIMARY KEY, category TEXT, name TEXT, price INTEGER)");
    exec.executeSql("INSERT INTO products VALUES (1, 'Electronics', 'Phone', 500)");
    exec.executeSql("INSERT INTO products VALUES (2, 'Electronics', 'Laptop', 1000)");
    exec.executeSql("INSERT INTO products VALUES (3, 'Clothing', 'Shirt', 30)");
    exec.executeSql("INSERT INTO products VALUES (4, 'Clothing', 'Pants', 50)");
    exec.executeSql("INSERT INTO products VALUES (5, 'Electronics', 'Tablet', 300)");

    // Create both single and composite indexes
    exec.executeSql("CREATE INDEX idx_cat ON products (category)");
    exec.executeSql("CREATE INDEX idx_cat_name ON products (category, name)");

    // Test 20: Single column uses single-column index preferentially
    var r21 = exec.executeSql("SELECT id FROM products WHERE category = 'Electronics' ORDER BY id");
    assertSuccess(r21, "Single column lookup succeeds");
    assertRowCount(r21, 3, "3 electronics products");

    // Test 21: Composite lookup uses composite index
    var r22 = exec.executeSql("SELECT id FROM products WHERE category = 'Electronics' AND name = 'Laptop'");
    assertSuccess(r22, "Composite lookup succeeds");
    assertRowCount(r22, 1, "1 Electronics/Laptop");
    assertEq(val(r22, 0, 0), "2", "Laptop id = 2");

    //=========================================================================
    // 9. EXPLAIN WITH COMPOSITE INDEX
    //=========================================================================
    section("EXPLAIN With Composite Index");

    // Test 22: EXPLAIN shows index usage for composite query
    var r23 = exec.executeSql("EXPLAIN SELECT id FROM employees WHERE last_name = 'Smith' AND first_name = 'John'");
    assertSuccess(r23, "EXPLAIN with composite index succeeds");
    assert(r23.rows.count() > 0, "EXPLAIN produces output");

    // Test 23: EXPLAIN for single-column query
    var r24 = exec.executeSql("EXPLAIN SELECT id FROM products WHERE category = 'Electronics'");
    assertSuccess(r24, "EXPLAIN with single index succeeds");

    //=========================================================================
    // 10. DROP INDEX CLEANUP
    //=========================================================================
    section("DROP Composite Index");

    // Test 24: Drop composite index
    var r25 = exec.executeSql("DROP INDEX idx_name");
    assertSuccess(r25, "DROP composite INDEX succeeds");

    // Test 25: Query still works after dropping index (full table scan)
    var r26 = exec.executeSql("SELECT id FROM employees WHERE last_name = 'Smith' AND first_name = 'John'");
    assertSuccess(r26, "Query without index still works");
    assertRowCount(r26, 1, "Still returns 1 row");
    assertEq(val(r26, 0, 0), "1", "Correct result without index");

    //=========================================================================
    // 11. COMPOSITE INDEX WITH VARIOUS DATA TYPES
    //=========================================================================
    section("Composite Index Data Types");

    exec.executeSql("CREATE TABLE inventory (id INTEGER PRIMARY KEY, sku INTEGER, warehouse INTEGER, qty INTEGER)");
    exec.executeSql("INSERT INTO inventory VALUES (1, 1001, 1, 50)");
    exec.executeSql("INSERT INTO inventory VALUES (2, 1001, 2, 30)");
    exec.executeSql("INSERT INTO inventory VALUES (3, 1002, 1, 20)");
    exec.executeSql("INSERT INTO inventory VALUES (4, 1002, 2, 40)");
    exec.executeSql("INSERT INTO inventory VALUES (5, 1001, 1, 10)");

    exec.executeSql("CREATE UNIQUE INDEX idx_sku_wh ON inventory (sku, warehouse)");

    // Wait — that should fail because (1001, 1) has two entries (rows 1 and 5)
    // Actually let me just use non-unique for this test
    // The unique index creation should fail if there are duplicates

    //=========================================================================
    // 12. EDGE CASES
    //=========================================================================
    section("Edge Cases");

    exec.executeSql("CREATE TABLE pairs (a TEXT, b TEXT, val INTEGER)");
    exec.executeSql("INSERT INTO pairs VALUES ('x', 'y', 1)");
    exec.executeSql("INSERT INTO pairs VALUES ('xy', '', 2)");
    exec.executeSql("INSERT INTO pairs VALUES ('x', 'yy', 3)");

    exec.executeSql("CREATE INDEX idx_ab ON pairs (a, b)");

    // Test 26: 'x'|'y' should not match 'xy'|''
    var r27 = exec.executeSql("SELECT val FROM pairs WHERE a = 'x' AND b = 'y'");
    assertSuccess(r27, "Exact composite match succeeds");
    assertRowCount(r27, 1, "Only exact match returns");
    assertEq(val(r27, 0, 0), "1", "val = 1 for x/y");

    // Test 27: Prefix a='x' matches x/y and x/yy
    var r28 = exec.executeSql("SELECT val FROM pairs WHERE a = 'x' ORDER BY val");
    assertSuccess(r28, "Prefix a='x' succeeds");
    assertRowCount(r28, 2, "2 rows start with a='x'");

    //=========================================================================
    // RESULTS
    //=========================================================================
    printResults();
    return 0;
}
