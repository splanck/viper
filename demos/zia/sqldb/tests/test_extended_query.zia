// test_extended_query.zia — Tests for PostgreSQL Extended Query Protocol (Phase 11)
// Part of ViperSQL
//
// Tests the Parse/Bind/Describe/Execute/Sync message flow by running a server
// on a test port and connecting as a PG client using binary protocol messages.

module test_extended_query;

bind Terminal = Viper.Terminal;
bind Fmt = Viper.Fmt;
bind Network = Viper.Network;
bind Threads = Viper.Threads;
bind Viper.Collections;
bind String = Viper.String;

bind "../server";
bind "../server/connection";
bind "../server/pg_wire";

//=============================================================================
// TEST HARNESS
//=============================================================================

Integer passed = 0;
Integer failed = 0;

func assert(cond: Boolean, msg: String) {
    if cond {
        passed = passed + 1;
        Terminal.Say("  PASS: " + msg);
    } else {
        failed = failed + 1;
        Terminal.Say("  FAIL: " + msg);
    }
}

//=============================================================================
// PG CLIENT HELPERS — Simple Query (reused from test_pg_wire)
//=============================================================================

func sendStartupMessage(client: Ptr, user: String, database: String) {
    var body = new PgMsg(128);
    body.writeInt32(196608);
    body.writeCString("user");
    body.writeCString(user);
    body.writeCString("database");
    body.writeCString(database);
    body.writeByte(0);

    var bodyBytes = body.toBytes();
    var length = bodyBytes.Len + 4;
    var msg = Bytes.New(4 + bodyBytes.Len);
    writeInt32BE(msg, 0, length);
    Bytes.Copy(msg, 4, bodyBytes, 0, bodyBytes.Len);
    Network.Tcp.SendAll(client, msg);
}

func sendPassword(client: Ptr, password: String) {
    var body = new PgMsg(64);
    body.writeCString(password);
    var bodyBytes = body.toBytes();

    var msgLen = 1 + 4 + bodyBytes.Len;
    var msg = Bytes.New(msgLen);
    msg.Set(0, 112);
    writeInt32BE(msg, 1, bodyBytes.Len + 4);
    Bytes.Copy(msg, 5, bodyBytes, 0, bodyBytes.Len);
    Network.Tcp.SendAll(client, msg);
}

func sendQuery(client: Ptr, query: String) {
    var body = new PgMsg(256);
    body.writeCString(query);
    var bodyBytes = body.toBytes();

    var msgLen = 1 + 4 + bodyBytes.Len;
    var msg = Bytes.New(msgLen);
    msg.Set(0, 81);
    writeInt32BE(msg, 1, bodyBytes.Len + 4);
    Bytes.Copy(msg, 5, bodyBytes, 0, bodyBytes.Len);
    Network.Tcp.SendAll(client, msg);
}

func sendTerminate(client: Ptr) {
    var msg = Bytes.New(5);
    msg.Set(0, 88);
    writeInt32BE(msg, 1, 4);
    Network.Tcp.SendAll(client, msg);
}

//=============================================================================
// PG CLIENT HELPERS — Extended Query Protocol
//=============================================================================

// Send a Parse message
// Format: 'P' + len + stmtName\0 + query\0 + int16(nParamTypes) + int32[](oids)
func sendParse(client: Ptr, stmtName: String, query: String, paramOids: List[Integer]) {
    var body = new PgMsg(512);
    body.writeCString(stmtName);
    body.writeCString(query);
    body.writeInt16(paramOids.count());
    var i = 0;
    while i < paramOids.count() {
        body.writeInt32(paramOids.get(i));
        i = i + 1;
    }
    var bodyBytes = body.toBytes();
    var msgLen = 1 + 4 + bodyBytes.Len;
    var msg = Bytes.New(msgLen);
    msg.Set(0, 80);  // 'P'
    writeInt32BE(msg, 1, bodyBytes.Len + 4);
    Bytes.Copy(msg, 5, bodyBytes, 0, bodyBytes.Len);
    Network.Tcp.SendAll(client, msg);
}

// Send a Bind message
// Format: 'B' + len + portalName\0 + stmtName\0 + int16(nFormats) + int16(nParams) + [int32(len) + bytes]* + int16(0)
func sendBind(client: Ptr, portalName: String, stmtName: String, paramValues: List[String], paramNulls: List[Integer]) {
    var body = new PgMsg(512);
    body.writeCString(portalName);
    body.writeCString(stmtName);
    body.writeInt16(0);  // 0 format codes = all text
    body.writeInt16(paramValues.count());  // number of parameters
    var i = 0;
    while i < paramValues.count() {
        if paramNulls.get(i) == 1 {
            body.writeInt32(-1);  // NULL
        } else {
            var valBytes = Bytes.FromStr(paramValues.get(i));
            body.writeInt32(valBytes.Len);
            body.writeRawBytes(valBytes);
        }
        i = i + 1;
    }
    body.writeInt16(0);  // 0 result format codes = all text
    var bodyBytes = body.toBytes();
    var msgLen = 1 + 4 + bodyBytes.Len;
    var msg = Bytes.New(msgLen);
    msg.Set(0, 66);  // 'B'
    writeInt32BE(msg, 1, bodyBytes.Len + 4);
    Bytes.Copy(msg, 5, bodyBytes, 0, bodyBytes.Len);
    Network.Tcp.SendAll(client, msg);
}

// Send a Describe message
// Format: 'D' + len + byte('S'|'P') + name\0
func sendDescribe(client: Ptr, descType: Integer, name: String) {
    var body = new PgMsg(64);
    body.writeByte(descType);
    body.writeCString(name);
    var bodyBytes = body.toBytes();
    var msgLen = 1 + 4 + bodyBytes.Len;
    var msg = Bytes.New(msgLen);
    msg.Set(0, 68);  // 'D'
    writeInt32BE(msg, 1, bodyBytes.Len + 4);
    Bytes.Copy(msg, 5, bodyBytes, 0, bodyBytes.Len);
    Network.Tcp.SendAll(client, msg);
}

// Send an Execute message
// Format: 'E' + len + portalName\0 + int32(maxRows)
func sendExecute(client: Ptr, portalName: String, maxRows: Integer) {
    var body = new PgMsg(64);
    body.writeCString(portalName);
    body.writeInt32(maxRows);
    var bodyBytes = body.toBytes();
    var msgLen = 1 + 4 + bodyBytes.Len;
    var msg = Bytes.New(msgLen);
    msg.Set(0, 69);  // 'E'
    writeInt32BE(msg, 1, bodyBytes.Len + 4);
    Bytes.Copy(msg, 5, bodyBytes, 0, bodyBytes.Len);
    Network.Tcp.SendAll(client, msg);
}

// Send a Sync message
// Format: 'S' + int32(4)
func sendSync(client: Ptr) {
    var msg = Bytes.New(5);
    msg.Set(0, 83);  // 'S'
    writeInt32BE(msg, 1, 4);
    Network.Tcp.SendAll(client, msg);
}

// Send a Close message
// Format: 'C' + len + byte('S'|'P') + name\0
func sendCloseMsg(client: Ptr, closeType: Integer, name: String) {
    var body = new PgMsg(64);
    body.writeByte(closeType);
    body.writeCString(name);
    var bodyBytes = body.toBytes();
    var msgLen = 1 + 4 + bodyBytes.Len;
    var msg = Bytes.New(msgLen);
    msg.Set(0, 67);  // 'C'
    writeInt32BE(msg, 1, bodyBytes.Len + 4);
    Bytes.Copy(msg, 5, bodyBytes, 0, bodyBytes.Len);
    Network.Tcp.SendAll(client, msg);
}

//=============================================================================
// RESPONSE READING HELPERS
//=============================================================================

entity PgResponse {
    expose Integer msgType;
    expose Bytes body;
    expose Integer bodyLen;
    expose Boolean valid;

    expose func init() {
        msgType = 0;
        body = Bytes.New(0);
        bodyLen = 0;
        valid = false;
    }
}

func recvResponse(client: Ptr) -> PgResponse {
    var resp = new PgResponse();
    resp.init();

    var typeBuf: Bytes = Network.Tcp.RecvExact(client, 1);
    resp.msgType = typeBuf.Get(0);

    var lenBuf: Bytes = Network.Tcp.RecvExact(client, 4);
    var length = readInt32BE(lenBuf, 0);

    if length > 4 {
        var bodyData: Bytes = Network.Tcp.RecvExact(client, length - 4);
        resp.body = bodyData;
        resp.bodyLen = length - 4;
    }

    resp.valid = true;
    return resp;
}

func recvUntil(client: Ptr, targetType: Integer) -> PgResponse {
    var maxTries = 50;
    var i = 0;
    while i < maxTries {
        var resp = recvResponse(client);
        if resp.msgType == targetType {
            return resp;
        }
        i = i + 1;
    }
    var empty = new PgResponse();
    empty.init();
    return empty;
}

func performStartup(client: Ptr, user: String, database: String, password: String) {
    sendStartupMessage(client, user, database);
    var authReq = recvResponse(client);
    sendPassword(client, password);
    recvUntil(client, 90);
}

func extractCString(data: Bytes, offset: Integer) -> String {
    var end = offset;
    while end < data.Len && data.Get(end) != 0 {
        end = end + 1;
    }
    if end == offset { return ""; }
    var slice: Bytes = data.Slice(offset, end);
    return slice.ToStr();
}

// Count DataRow messages until CommandComplete, then consume ReadyForQuery
func countDataRows(client: Ptr) -> Integer {
    var count = 0;
    var maxMsgs = 200;
    var i = 0;
    while i < maxMsgs {
        var resp = recvResponse(client);
        if resp.msgType == 68 {
            count = count + 1;
        } else if resp.msgType == 90 {
            return count;
        }
        i = i + 1;
    }
    return count;
}

// Count DataRow messages until CommandComplete or PortalSuspended (no Sync expected)
func countDataRowsExtended(client: Ptr) -> Integer {
    var count = 0;
    var maxMsgs = 200;
    var i = 0;
    while i < maxMsgs {
        var resp = recvResponse(client);
        if resp.msgType == 68 {
            count = count + 1;
        } else if resp.msgType == 67 || resp.msgType == 115 {
            // CommandComplete or PortalSuspended
            return count;
        } else if resp.msgType == 69 {
            // ErrorResponse
            return -1;
        }
        i = i + 1;
    }
    return count;
}

//=============================================================================
// SERVER STATE
//=============================================================================

var testPort: Integer;
var serverReady: Boolean;
var serverLock: List[Integer];

func setServerReady() {
    Threads.Monitor.Enter(serverLock);
    serverReady = true;
    Threads.Monitor.PauseAll(serverLock);
    Threads.Monitor.Exit(serverLock);
}

func waitForServer() {
    Threads.Monitor.Enter(serverLock);
    while serverReady == false {
        Threads.Monitor.Wait(serverLock);
    }
    Threads.Monitor.Exit(serverLock);
}

func testServerWorker(portArg: List[Integer]) {
    var port = portArg.get(0);

    var dbServer = new DatabaseServer();
    dbServer.init();
    sql_connection_init(dbServer);

    var server = Network.TcpServer.Listen(port);
    setServerReady();

    var count = 0;
    while count < 30 {
        var client = Network.TcpServer.AcceptFor(server, 10000);
        if client != null {
            Threads.Thread.StartSafe(&handlePgClient, client);
            count = count + 1;
        } else {
            break;
        }
    }

    Threads.Thread.Sleep(500);
    Network.TcpServer.Close(server);
}

//=============================================================================
// TESTS
//=============================================================================

func testBasicExtendedQuery() {
    Terminal.Say("Testing basic Parse+Bind+Execute+Sync...");

    var client = Network.Tcp.Connect("localhost", testPort);
    Network.Tcp.SetRecvTimeout(client, 5000);
    performStartup(client, "admin", "main", "admin");

    // Parse: SELECT 1 + 2 AS result (no params)
    var noOids: List[Integer] = [];
    sendParse(client, "", "SELECT 1 + 2 AS result", noOids);

    // Expect ParseComplete ('1' = 49)
    var parseResp = recvResponse(client);
    assert(parseResp.msgType == 49, "ParseComplete received");

    // Bind (no params)
    var noVals: List[String] = [];
    var noNulls: List[Integer] = [];
    sendBind(client, "", "", noVals, noNulls);

    // Expect BindComplete ('2' = 50)
    var bindResp = recvResponse(client);
    assert(bindResp.msgType == 50, "BindComplete received");

    // Execute
    sendExecute(client, "", 0);

    // Expect DataRow with "3"
    var dataRow = recvResponse(client);
    assert(dataRow.msgType == 68, "DataRow received from Execute");

    // Expect CommandComplete
    var cmdComplete = recvResponse(client);
    assert(cmdComplete.msgType == 67, "CommandComplete received from Execute");

    // Sync
    sendSync(client);
    var ready = recvResponse(client);
    assert(ready.msgType == 90, "ReadyForQuery after Sync");

    sendTerminate(client);
    Network.Tcp.Close(client);
}

func testParameterizedSelect() {
    Terminal.Say("Testing parameterized SELECT with $1...");

    var client = Network.Tcp.Connect("localhost", testPort);
    Network.Tcp.SetRecvTimeout(client, 5000);
    performStartup(client, "admin", "main", "admin");

    // Create test table
    sendQuery(client, "CREATE TABLE ext_test1 (id INTEGER, name TEXT)");
    recvUntil(client, 90);
    sendQuery(client, "INSERT INTO ext_test1 VALUES (1, 'Alice')");
    recvUntil(client, 90);
    sendQuery(client, "INSERT INTO ext_test1 VALUES (2, 'Bob')");
    recvUntil(client, 90);
    sendQuery(client, "INSERT INTO ext_test1 VALUES (3, 'Charlie')");
    recvUntil(client, 90);

    // Parse: SELECT * FROM ext_test1 WHERE id = $1
    var noOids: List[Integer] = [];
    sendParse(client, "", "SELECT * FROM ext_test1 WHERE id = $1", noOids);
    var parseResp = recvResponse(client);
    assert(parseResp.msgType == 49, "Parse with $1 succeeds");

    // Bind with param $1 = "2"
    var vals: List[String] = [];
    vals.add("2");
    var nulls: List[Integer] = [];
    nulls.add(0);
    sendBind(client, "", "", vals, nulls);
    var bindResp = recvResponse(client);
    assert(bindResp.msgType == 50, "Bind with param value succeeds");

    // Execute
    sendExecute(client, "", 0);

    // Should get exactly 1 DataRow (id=2, Bob)
    var rowCount = countDataRowsExtended(client);
    assert(rowCount == 1, "Parameterized SELECT returns 1 row");

    // Sync
    sendSync(client);
    recvResponse(client);  // ReadyForQuery

    // Cleanup
    sendQuery(client, "DROP TABLE ext_test1");
    recvUntil(client, 90);

    sendTerminate(client);
    Network.Tcp.Close(client);
}

func testParameterizedInsert() {
    Terminal.Say("Testing parameterized INSERT with $1, $2...");

    var client = Network.Tcp.Connect("localhost", testPort);
    Network.Tcp.SetRecvTimeout(client, 5000);
    performStartup(client, "admin", "main", "admin");

    sendQuery(client, "CREATE TABLE ext_test2 (id INTEGER, name TEXT)");
    recvUntil(client, 90);

    // Parse INSERT
    var noOids: List[Integer] = [];
    sendParse(client, "", "INSERT INTO ext_test2 VALUES ($1, $2)", noOids);
    var parseResp = recvResponse(client);
    assert(parseResp.msgType == 49, "Parse INSERT with params succeeds");

    // Bind params: $1=10, $2='Dave'
    var vals: List[String] = [];
    vals.add("10");
    vals.add("Dave");
    var nulls: List[Integer] = [];
    nulls.add(0);
    nulls.add(0);
    sendBind(client, "", "", vals, nulls);
    var bindResp = recvResponse(client);
    assert(bindResp.msgType == 50, "Bind INSERT params succeeds");

    // Execute
    sendExecute(client, "", 0);
    var cmdResp = recvResponse(client);
    assert(cmdResp.msgType == 67, "INSERT CommandComplete received");

    sendSync(client);
    recvResponse(client);

    // Verify the row was inserted
    sendQuery(client, "SELECT * FROM ext_test2 WHERE id = 10");
    recvResponse(client);  // RowDescription
    var rowCount = countDataRows(client);
    assert(rowCount == 1, "Parameterized INSERT created 1 row");

    // Cleanup
    sendQuery(client, "DROP TABLE ext_test2");
    recvUntil(client, 90);

    sendTerminate(client);
    Network.Tcp.Close(client);
}

func testNullParameter() {
    Terminal.Say("Testing NULL parameter binding...");

    var client = Network.Tcp.Connect("localhost", testPort);
    Network.Tcp.SetRecvTimeout(client, 5000);
    performStartup(client, "admin", "main", "admin");

    sendQuery(client, "CREATE TABLE ext_test3 (id INTEGER, name TEXT)");
    recvUntil(client, 90);

    // INSERT with NULL $2
    var noOids: List[Integer] = [];
    sendParse(client, "", "INSERT INTO ext_test3 VALUES ($1, $2)", noOids);
    recvResponse(client);  // ParseComplete

    var vals: List[String] = [];
    vals.add("1");
    vals.add("");
    var nulls: List[Integer] = [];
    nulls.add(0);
    nulls.add(1);  // $2 is NULL
    sendBind(client, "", "", vals, nulls);
    recvResponse(client);  // BindComplete

    sendExecute(client, "", 0);
    recvResponse(client);  // CommandComplete

    sendSync(client);
    recvResponse(client);

    // Verify NULL was stored
    sendQuery(client, "SELECT name FROM ext_test3 WHERE id = 1");
    recvResponse(client);  // RowDescription
    var dataRow = recvResponse(client);
    // name should be NULL: int16(numCols=1) + int32(-1)
    if dataRow.msgType == 68 && dataRow.bodyLen >= 6 {
        var colLen = readInt32BE(dataRow.body, 2);
        // NULL = 0xFFFFFFFF = 4294967295
        assert(colLen >= 4294967295, "NULL parameter stored as NULL");
    }
    recvUntil(client, 90);

    sendQuery(client, "DROP TABLE ext_test3");
    recvUntil(client, 90);

    sendTerminate(client);
    Network.Tcp.Close(client);
}

func testDescribeStatement() {
    Terminal.Say("Testing Describe statement...");

    var client = Network.Tcp.Connect("localhost", testPort);
    Network.Tcp.SetRecvTimeout(client, 5000);
    performStartup(client, "admin", "main", "admin");

    // Parse a query with 2 parameters
    var noOids: List[Integer] = [];
    sendParse(client, "", "SELECT $1 AS val1, $2 AS val2", noOids);
    recvResponse(client);  // ParseComplete

    // Describe statement
    sendDescribe(client, 83, "");  // 'S' = 83
    // Should receive ParameterDescription ('t' = 116)
    var paramDesc = recvResponse(client);
    assert(paramDesc.msgType == 116, "ParameterDescription received");
    if paramDesc.bodyLen >= 2 {
        var numParams = readInt16BE(paramDesc.body, 0);
        assert(numParams == 2, "ParameterDescription shows 2 params");
    }

    // Should receive RowDescription or NoData
    var rowDescOrNoData = recvResponse(client);
    var isRowDesc = rowDescOrNoData.msgType == 84;
    var isNoData = rowDescOrNoData.msgType == 110;
    assert(isRowDesc || isNoData, "Describe returns RowDescription or NoData");

    sendSync(client);
    recvUntil(client, 90);

    sendTerminate(client);
    Network.Tcp.Close(client);
}

func testDescribePortal() {
    Terminal.Say("Testing Describe portal...");

    var client = Network.Tcp.Connect("localhost", testPort);
    Network.Tcp.SetRecvTimeout(client, 5000);
    performStartup(client, "admin", "main", "admin");

    sendQuery(client, "CREATE TABLE ext_test4 (id INTEGER, name TEXT)");
    recvUntil(client, 90);
    sendQuery(client, "INSERT INTO ext_test4 VALUES (1, 'Test')");
    recvUntil(client, 90);

    // Parse + Bind
    var noOids: List[Integer] = [];
    sendParse(client, "", "SELECT * FROM ext_test4", noOids);
    recvResponse(client);  // ParseComplete

    var noVals: List[String] = [];
    var noNulls: List[Integer] = [];
    sendBind(client, "", "", noVals, noNulls);
    recvResponse(client);  // BindComplete

    // Describe portal
    sendDescribe(client, 80, "");  // 'P' = 80
    var rowDesc = recvResponse(client);
    assert(rowDesc.msgType == 84, "Describe portal returns RowDescription");
    if rowDesc.bodyLen >= 2 {
        var numCols = readInt16BE(rowDesc.body, 0);
        assert(numCols == 2, "RowDescription has 2 columns (id, name)");
    }

    // Execute should still work (result cached from Describe)
    sendExecute(client, "", 0);
    var dataRow = recvResponse(client);
    assert(dataRow.msgType == 68, "Execute returns DataRow after Describe");
    var cmdComplete = recvResponse(client);
    assert(cmdComplete.msgType == 67, "Execute returns CommandComplete");

    sendSync(client);
    recvUntil(client, 90);

    sendQuery(client, "DROP TABLE ext_test4");
    recvUntil(client, 90);

    sendTerminate(client);
    Network.Tcp.Close(client);
}

func testUnnamedStatementReuse() {
    Terminal.Say("Testing unnamed statement reuse...");

    var client = Network.Tcp.Connect("localhost", testPort);
    Network.Tcp.SetRecvTimeout(client, 5000);
    performStartup(client, "admin", "main", "admin");

    // First Parse + Bind + Execute: SELECT 1
    var noOids: List[Integer] = [];
    sendParse(client, "", "SELECT 1 AS a", noOids);
    recvResponse(client);  // ParseComplete
    var noVals: List[String] = [];
    var noNulls: List[Integer] = [];
    sendBind(client, "", "", noVals, noNulls);
    recvResponse(client);  // BindComplete
    sendExecute(client, "", 0);
    recvResponse(client);  // DataRow
    recvResponse(client);  // CommandComplete
    sendSync(client);
    recvResponse(client);  // ReadyForQuery

    // Second Parse (replaces unnamed): SELECT 2
    sendParse(client, "", "SELECT 2 AS b", noOids);
    var parseResp2 = recvResponse(client);
    assert(parseResp2.msgType == 49, "Unnamed statement replaced without error");

    sendBind(client, "", "", noVals, noNulls);
    recvResponse(client);  // BindComplete
    sendExecute(client, "", 0);
    var dataRow2 = recvResponse(client);
    assert(dataRow2.msgType == 68, "Second unnamed query returns DataRow");
    recvResponse(client);  // CommandComplete
    sendSync(client);
    recvResponse(client);  // ReadyForQuery

    sendTerminate(client);
    Network.Tcp.Close(client);
}

func testNamedStatementLifecycle() {
    Terminal.Say("Testing named statement lifecycle...");

    var client = Network.Tcp.Connect("localhost", testPort);
    Network.Tcp.SetRecvTimeout(client, 5000);
    performStartup(client, "admin", "main", "admin");

    // Parse with name "my_stmt"
    var noOids: List[Integer] = [];
    sendParse(client, "my_stmt", "SELECT 42 AS answer", noOids);
    var parseResp = recvResponse(client);
    assert(parseResp.msgType == 49, "Named Parse succeeds");

    // Bind and Execute using named statement
    var noVals: List[String] = [];
    var noNulls: List[Integer] = [];
    sendBind(client, "", "my_stmt", noVals, noNulls);
    recvResponse(client);  // BindComplete
    sendExecute(client, "", 0);
    recvResponse(client);  // DataRow
    recvResponse(client);  // CommandComplete
    sendSync(client);
    recvResponse(client);  // ReadyForQuery

    // Try to Parse same name again — should get error
    sendParse(client, "my_stmt", "SELECT 99 AS x", noOids);
    var errResp = recvResponse(client);
    assert(errResp.msgType == 69, "Duplicate named Parse returns ErrorResponse");
    sendSync(client);
    recvResponse(client);  // ReadyForQuery

    // Close the statement
    sendCloseMsg(client, 83, "my_stmt");  // 'S' = 83
    var closeResp = recvResponse(client);
    assert(closeResp.msgType == 51, "CloseComplete received");
    sendSync(client);
    recvResponse(client);  // ReadyForQuery

    // Now Parse with same name should work
    sendParse(client, "my_stmt", "SELECT 99 AS x", noOids);
    var parseResp2 = recvResponse(client);
    assert(parseResp2.msgType == 49, "Re-Parse after Close succeeds");
    sendSync(client);
    recvResponse(client);  // ReadyForQuery

    sendTerminate(client);
    Network.Tcp.Close(client);
}

func testPortalSuspension() {
    Terminal.Say("Testing portal suspension with maxRows...");

    var client = Network.Tcp.Connect("localhost", testPort);
    Network.Tcp.SetRecvTimeout(client, 5000);
    performStartup(client, "admin", "main", "admin");

    // Create table with 5 rows
    sendQuery(client, "CREATE TABLE ext_test5 (id INTEGER)");
    recvUntil(client, 90);
    var i = 1;
    while i <= 5 {
        sendQuery(client, "INSERT INTO ext_test5 VALUES (" + Fmt.Int(i) + ")");
        recvUntil(client, 90);
        i = i + 1;
    }

    // Parse + Bind
    var noOids: List[Integer] = [];
    sendParse(client, "", "SELECT * FROM ext_test5 ORDER BY id", noOids);
    recvResponse(client);  // ParseComplete
    var noVals: List[String] = [];
    var noNulls: List[Integer] = [];
    sendBind(client, "", "", noVals, noNulls);
    recvResponse(client);  // BindComplete

    // Execute with maxRows=2
    sendExecute(client, "", 2);
    var count1 = countDataRowsExtended(client);
    assert(count1 == 2, "First Execute returns 2 rows");

    // Execute again with maxRows=2 (should get rows 3-4)
    sendExecute(client, "", 2);
    var count2 = countDataRowsExtended(client);
    assert(count2 == 2, "Second Execute returns 2 more rows");

    // Execute with maxRows=0 (fetch remaining — should get row 5)
    sendExecute(client, "", 0);
    var count3 = countDataRowsExtended(client);
    assert(count3 == 1, "Final Execute returns 1 remaining row");

    sendSync(client);
    recvResponse(client);  // ReadyForQuery

    sendQuery(client, "DROP TABLE ext_test5");
    recvUntil(client, 90);

    sendTerminate(client);
    Network.Tcp.Close(client);
}

func testErrorRecovery() {
    Terminal.Say("Testing error recovery in extended query...");

    var client = Network.Tcp.Connect("localhost", testPort);
    Network.Tcp.SetRecvTimeout(client, 5000);
    performStartup(client, "admin", "main", "admin");

    // Parse invalid SQL
    var noOids: List[Integer] = [];
    sendParse(client, "", "SELECT * FROM nonexistent_table_xyz", noOids);
    var parseResp = recvResponse(client);
    assert(parseResp.msgType == 49, "Parse of bad SQL succeeds (validation deferred)");

    // Bind
    var noVals: List[String] = [];
    var noNulls: List[Integer] = [];
    sendBind(client, "", "", noVals, noNulls);
    recvResponse(client);  // BindComplete

    // Execute — should fail
    sendExecute(client, "", 0);
    var errResp = recvResponse(client);
    assert(errResp.msgType == 69, "Execute of bad SQL returns ErrorResponse");

    // After error, send Sync to recover
    sendSync(client);
    var ready = recvResponse(client);
    assert(ready.msgType == 90, "ReadyForQuery after error recovery");

    // Connection should still work
    sendParse(client, "", "SELECT 1 AS test", noOids);
    var parseOk = recvResponse(client);
    assert(parseOk.msgType == 49, "Parse works after error recovery");

    sendBind(client, "", "", noVals, noNulls);
    recvResponse(client);
    sendExecute(client, "", 0);
    var dataRow = recvResponse(client);
    assert(dataRow.msgType == 68, "Execute works after error recovery");
    recvResponse(client);  // CommandComplete
    sendSync(client);
    recvResponse(client);

    sendTerminate(client);
    Network.Tcp.Close(client);
}

func testDdlViaExtendedQuery() {
    Terminal.Say("Testing DDL via extended query...");

    var client = Network.Tcp.Connect("localhost", testPort);
    Network.Tcp.SetRecvTimeout(client, 5000);
    performStartup(client, "admin", "main", "admin");

    // Parse CREATE TABLE
    var noOids: List[Integer] = [];
    sendParse(client, "", "CREATE TABLE ext_test6 (id INTEGER, name TEXT)", noOids);
    var parseResp = recvResponse(client);
    assert(parseResp.msgType == 49, "Parse CREATE TABLE succeeds");

    var noVals: List[String] = [];
    var noNulls: List[Integer] = [];
    sendBind(client, "", "", noVals, noNulls);
    recvResponse(client);  // BindComplete

    sendExecute(client, "", 0);
    var cmdResp = recvResponse(client);
    assert(cmdResp.msgType == 67, "CREATE TABLE via extended query returns CommandComplete");
    // Verify tag
    var tag = extractCString(cmdResp.body, 0);
    assert(tag == "CREATE TABLE", "CommandComplete tag is CREATE TABLE");

    sendSync(client);
    recvResponse(client);

    // Verify table exists by inserting
    sendQuery(client, "INSERT INTO ext_test6 VALUES (1, 'test')");
    recvUntil(client, 90);
    sendQuery(client, "SELECT * FROM ext_test6");
    recvResponse(client);  // RowDescription
    var rowCount = countDataRows(client);
    assert(rowCount == 1, "Table created via extended query works");

    // Cleanup
    sendQuery(client, "DROP TABLE ext_test6");
    recvUntil(client, 90);

    sendTerminate(client);
    Network.Tcp.Close(client);
}

func testMultipleParameters() {
    Terminal.Say("Testing query with multiple parameters $1, $2, $3...");

    var client = Network.Tcp.Connect("localhost", testPort);
    Network.Tcp.SetRecvTimeout(client, 5000);
    performStartup(client, "admin", "main", "admin");

    sendQuery(client, "CREATE TABLE ext_test7 (a INTEGER, b INTEGER, c INTEGER)");
    recvUntil(client, 90);
    sendQuery(client, "INSERT INTO ext_test7 VALUES (1, 2, 3)");
    recvUntil(client, 90);
    sendQuery(client, "INSERT INTO ext_test7 VALUES (4, 5, 6)");
    recvUntil(client, 90);
    sendQuery(client, "INSERT INTO ext_test7 VALUES (7, 8, 9)");
    recvUntil(client, 90);

    // SELECT with 3 params
    var noOids: List[Integer] = [];
    sendParse(client, "", "SELECT * FROM ext_test7 WHERE a = $1 AND b = $2 AND c = $3", noOids);
    recvResponse(client);  // ParseComplete

    var vals: List[String] = [];
    vals.add("4");
    vals.add("5");
    vals.add("6");
    var nulls: List[Integer] = [];
    nulls.add(0);
    nulls.add(0);
    nulls.add(0);
    sendBind(client, "", "", vals, nulls);
    recvResponse(client);  // BindComplete

    sendExecute(client, "", 0);
    var rowCount = countDataRowsExtended(client);
    assert(rowCount == 1, "3-param query returns correct row");

    sendSync(client);
    recvResponse(client);

    sendQuery(client, "DROP TABLE ext_test7");
    recvUntil(client, 90);

    sendTerminate(client);
    Network.Tcp.Close(client);
}

//=============================================================================
// ENTRY POINT
//=============================================================================

func start() {
    Terminal.Say("=== Phase 11: Extended Query Protocol Tests ===");
    Terminal.Say("");

    testPort = 15433;
    serverReady = false;
    serverLock = [];

    var portArgs: List[Integer] = [];
    portArgs.add(testPort);
    Threads.Thread.StartSafe(&testServerWorker, portArgs);

    waitForServer();
    Threads.Thread.Sleep(100);

    // Run tests
    testBasicExtendedQuery();
    testParameterizedSelect();
    testParameterizedInsert();
    testNullParameter();
    testDescribeStatement();
    testDescribePortal();
    testUnnamedStatementReuse();
    testNamedStatementLifecycle();
    testPortalSuspension();
    testErrorRecovery();
    testDdlViaExtendedQuery();
    testMultipleParameters();

    Terminal.Say("");
    Terminal.Say("=== Results ===");
    Terminal.Say("Passed: " + Fmt.Int(passed));
    Terminal.Say("Failed: " + Fmt.Int(failed));
    if failed == 0 {
        Terminal.Say("ALL TESTS PASSED");
    }
}
