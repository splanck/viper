// test_phase14_row_locks.zia — Phase 14: Row-Level Locking Tests
// Part of ViperSQL Test Suite
//
// Tests: SELECT ... FOR UPDATE / FOR SHARE syntax, RowLockManager,
// lock lifecycle (COMMIT/ROLLBACK releases), conflict detection,
// NOWAIT error behavior, SKIP LOCKED, and token collision fix.

module test_phase14_row_locks;

bind Terminal = Viper.Terminal;
bind Fmt = Viper.Fmt;
bind String = Viper.String;

bind "./test_common";
bind "../executor";
bind "../server";
bind "../session";
bind "../result";
bind "../types";
bind "../storage/txn";

//=============================================================================
// HELPERS
//=============================================================================

func makeTestExecutor() -> Executor {
    var server = new DatabaseServer();
    server.init();
    var exec = new Executor();
    exec.initWithServer(server, 1);
    return exec;
}

func makeSharedServer() -> DatabaseServer {
    var server = new DatabaseServer();
    server.init();
    return server;
}

func makeSession(server: DatabaseServer, id: Integer) -> Session {
    var s = new Session();
    s.initWithServer(id, "test-host", server);
    return s;
}

//=============================================================================
// TEST: Basic FOR UPDATE syntax
//=============================================================================

func testForUpdateSyntax() {
    section("FOR UPDATE Syntax");
    var exec = makeTestExecutor();

    exec.executeSql("CREATE TABLE items (id INTEGER, name TEXT, price REAL)");
    exec.executeSql("INSERT INTO items VALUES (1, 'apple', 1.50)");
    exec.executeSql("INSERT INTO items VALUES (2, 'banana', 0.75)");
    exec.executeSql("INSERT INTO items VALUES (3, 'cherry', 3.00)");

    // SELECT ... FOR UPDATE should parse and execute
    var r1 = exec.executeSql("SELECT * FROM items FOR UPDATE");
    assertSuccess(r1, "SELECT FOR UPDATE succeeds");
    assertRowCount(r1, 3, "FOR UPDATE returns all rows");

    // SELECT ... FOR UPDATE with WHERE clause
    var r2 = exec.executeSql("SELECT * FROM items WHERE id = 1 FOR UPDATE");
    assertSuccess(r2, "SELECT WHERE FOR UPDATE succeeds");
    assertRowCount(r2, 1, "FOR UPDATE WHERE returns 1 row");
    assertEq(val(r2, 0, 1), "apple", "Correct row returned");
}

//=============================================================================
// TEST: Basic FOR SHARE syntax
//=============================================================================

func testForShareSyntax() {
    section("FOR SHARE Syntax");
    var exec = makeTestExecutor();

    exec.executeSql("CREATE TABLE products (id INTEGER, name TEXT)");
    exec.executeSql("INSERT INTO products VALUES (1, 'widget')");
    exec.executeSql("INSERT INTO products VALUES (2, 'gadget')");

    // SELECT ... FOR SHARE should parse and execute
    var r1 = exec.executeSql("SELECT * FROM products FOR SHARE");
    assertSuccess(r1, "SELECT FOR SHARE succeeds");
    assertRowCount(r1, 2, "FOR SHARE returns all rows");

    // FOR SHARE with ORDER BY
    var r2 = exec.executeSql("SELECT * FROM products ORDER BY id FOR SHARE");
    assertSuccess(r2, "SELECT ORDER BY FOR SHARE succeeds");
    assertRowCount(r2, 2, "Ordered FOR SHARE returns all rows");
}

//=============================================================================
// TEST: FOR UPDATE NOWAIT syntax
//=============================================================================

func testForUpdateNowait() {
    section("FOR UPDATE NOWAIT Syntax");
    var exec = makeTestExecutor();

    exec.executeSql("CREATE TABLE accounts (id INTEGER, balance REAL)");
    exec.executeSql("INSERT INTO accounts VALUES (1, 100.00)");

    var r1 = exec.executeSql("SELECT * FROM accounts FOR UPDATE NOWAIT");
    assertSuccess(r1, "SELECT FOR UPDATE NOWAIT succeeds");
    assertRowCount(r1, 1, "NOWAIT returns correct rows");
}

//=============================================================================
// TEST: FOR UPDATE SKIP LOCKED syntax
//=============================================================================

func testForUpdateSkipLocked() {
    section("FOR UPDATE SKIP LOCKED Syntax");
    var exec = makeTestExecutor();

    exec.executeSql("CREATE TABLE tasks (id INTEGER, status TEXT)");
    exec.executeSql("INSERT INTO tasks VALUES (1, 'pending')");
    exec.executeSql("INSERT INTO tasks VALUES (2, 'pending')");

    var r1 = exec.executeSql("SELECT * FROM tasks FOR UPDATE SKIP LOCKED");
    assertSuccess(r1, "SELECT FOR UPDATE SKIP LOCKED succeeds");
    assertRowCount(r1, 2, "SKIP LOCKED returns all rows (no conflicts)");
}

//=============================================================================
// TEST: FOR SHARE NOWAIT and SKIP LOCKED syntax
//=============================================================================

func testForShareModifiers() {
    section("FOR SHARE Modifiers");
    var exec = makeTestExecutor();

    exec.executeSql("CREATE TABLE docs (id INTEGER, title TEXT)");
    exec.executeSql("INSERT INTO docs VALUES (1, 'readme')");

    var r1 = exec.executeSql("SELECT * FROM docs FOR SHARE NOWAIT");
    assertSuccess(r1, "SELECT FOR SHARE NOWAIT succeeds");

    var r2 = exec.executeSql("SELECT * FROM docs FOR SHARE SKIP LOCKED");
    assertSuccess(r2, "SELECT FOR SHARE SKIP LOCKED succeeds");
}

//=============================================================================
// TEST: Syntax errors
//=============================================================================

func testSyntaxErrors() {
    section("Syntax Errors");
    var exec = makeTestExecutor();

    exec.executeSql("CREATE TABLE errs (id INTEGER)");

    // FOR without UPDATE or SHARE
    var r1 = exec.executeSql("SELECT * FROM errs FOR DELETE");
    assertFailure(r1, "FOR DELETE should fail (expected UPDATE or SHARE)");

    // SKIP without LOCKED
    var r2 = exec.executeSql("SELECT * FROM errs FOR UPDATE SKIP");
    assertFailure(r2, "SKIP without LOCKED should fail");
}

//=============================================================================
// TEST: RowLockManager unit tests
//=============================================================================

func testRowLockManagerBasic() {
    section("RowLockManager Basic");
    var rlm = new RowLockManager();
    rlm.init();

    // Acquire a shared lock
    var ok = rlm.tryAcquireRowLock(1, "users", 0, LOCK_SHARED);
    assertTrue(ok, "Session 1 acquires S lock on row 0");
    assertEqInt(rlm.rowLockCount(), 1, "Total lock count is 1");
    assertEqInt(rlm.sessionRowLockCount(1), 1, "Session 1 holds 1 lock");

    // Acquire an exclusive lock on a different row
    ok = rlm.tryAcquireRowLock(1, "users", 1, LOCK_EXCLUSIVE);
    assertTrue(ok, "Session 1 acquires X lock on row 1");
    assertEqInt(rlm.rowLockCount(), 2, "Total lock count is 2");

    // Release all locks
    rlm.releaseAllRowLocks(1);
    assertEqInt(rlm.rowLockCount(), 0, "Locks released");
}

func testRowLockManagerSharedCompatible() {
    section("RowLockManager S+S Compatible");
    var rlm = new RowLockManager();
    rlm.init();

    // Session 1 acquires S lock
    var ok1 = rlm.tryAcquireRowLock(1, "data", 0, LOCK_SHARED);
    assertTrue(ok1, "Session 1 S lock granted");

    // Session 2 acquires S lock on same row (S+S compatible)
    var ok2 = rlm.tryAcquireRowLock(2, "data", 0, LOCK_SHARED);
    assertTrue(ok2, "Session 2 S lock granted (S+S compatible)");

    assertEqInt(rlm.rowLockCount(), 2, "Both S locks held");

    rlm.releaseAllRowLocks(1);
    rlm.releaseAllRowLocks(2);
}

func testRowLockManagerExclusiveConflict() {
    section("RowLockManager X Conflicts");
    var rlm = new RowLockManager();
    rlm.init();

    // Session 1 acquires X lock
    rlm.tryAcquireRowLock(1, "orders", 0, LOCK_EXCLUSIVE);

    // Session 2 cannot acquire S on same row (X blocks S)
    var ok1 = rlm.tryAcquireRowLock(2, "orders", 0, LOCK_SHARED);
    assertFalse(ok1, "S blocked by X on same row");

    // Session 2 cannot acquire X on same row (X blocks X)
    var ok2 = rlm.tryAcquireRowLock(2, "orders", 0, LOCK_EXCLUSIVE);
    assertFalse(ok2, "X blocked by X on same row");

    // Session 2 CAN lock a different row
    var ok3 = rlm.tryAcquireRowLock(2, "orders", 1, LOCK_EXCLUSIVE);
    assertTrue(ok3, "X on different row succeeds");

    // Session 2 CAN lock a different table same row
    var ok4 = rlm.tryAcquireRowLock(2, "orders2", 0, LOCK_EXCLUSIVE);
    assertTrue(ok4, "X on different table succeeds");

    rlm.releaseAllRowLocks(1);
    rlm.releaseAllRowLocks(2);
}

func testRowLockManagerSharedBlocksExclusive() {
    section("RowLockManager S blocks X");
    var rlm = new RowLockManager();
    rlm.init();

    // Sessions 1 and 2 hold S locks
    rlm.tryAcquireRowLock(1, "data", 5, LOCK_SHARED);
    rlm.tryAcquireRowLock(2, "data", 5, LOCK_SHARED);

    // Session 3 cannot acquire X (S blocks X)
    var ok = rlm.tryAcquireRowLock(3, "data", 5, LOCK_EXCLUSIVE);
    assertFalse(ok, "X blocked by existing S locks");

    // Release S locks → X should succeed
    rlm.releaseAllRowLocks(1);
    rlm.releaseAllRowLocks(2);
    ok = rlm.tryAcquireRowLock(3, "data", 5, LOCK_EXCLUSIVE);
    assertTrue(ok, "X succeeds after S locks released");

    rlm.releaseAllRowLocks(3);
}

func testRowLockManagerReentry() {
    section("RowLockManager Re-entry");
    var rlm = new RowLockManager();
    rlm.init();

    // Session 1 acquires S lock
    rlm.tryAcquireRowLock(1, "t", 0, LOCK_SHARED);

    // Same session acquires S again (already held — should succeed without adding)
    var ok = rlm.tryAcquireRowLock(1, "t", 0, LOCK_SHARED);
    assertTrue(ok, "Re-entry S succeeds");

    // Same session acquires X (X > S, so not "adequate" — creates new entry)
    ok = rlm.tryAcquireRowLock(1, "t", 0, LOCK_EXCLUSIVE);
    assertTrue(ok, "Same session X after S succeeds");

    rlm.releaseAllRowLocks(1);
}

func testRowLockManagerReleaseByTable() {
    section("RowLockManager Release by Table");
    var rlm = new RowLockManager();
    rlm.init();

    rlm.tryAcquireRowLock(1, "a", 0, LOCK_SHARED);
    rlm.tryAcquireRowLock(1, "a", 1, LOCK_SHARED);
    rlm.tryAcquireRowLock(1, "b", 0, LOCK_EXCLUSIVE);
    assertEqInt(rlm.sessionRowLockCount(1), 3, "Session 1 holds 3 locks");

    // Release only table 'a' locks
    rlm.releaseTableRowLocks(1, "a");
    assertEqInt(rlm.sessionRowLockCount(1), 1, "Session 1 holds 1 lock after release table 'a'");

    // Session 2 can now lock table 'a' rows
    var ok = rlm.tryAcquireRowLock(2, "a", 0, LOCK_EXCLUSIVE);
    assertTrue(ok, "Session 2 X on 'a' row 0 succeeds after release");

    rlm.releaseAllRowLocks(1);
    rlm.releaseAllRowLocks(2);
}

//=============================================================================
// TEST: Row locks released on COMMIT
//=============================================================================

func testLockReleaseOnCommit() {
    section("Lock Release on COMMIT");
    var server = makeSharedServer();
    var s1 = makeSession(server, 1);
    var s2 = makeSession(server, 2);

    // Setup
    s1.executeSql("CREATE TABLE inventory (id INTEGER, qty INTEGER)");
    s1.executeSql("INSERT INTO inventory VALUES (1, 100)");
    s1.executeSql("INSERT INTO inventory VALUES (2, 200)");

    // Session 1 begins transaction and locks rows
    s1.executeSql("BEGIN");
    var r1 = s1.executeSql("SELECT * FROM inventory WHERE id = 1 FOR UPDATE");
    assertSuccess(r1, "S1 SELECT FOR UPDATE succeeds");
    assertRowCount(r1, 1, "S1 locks 1 row");

    // Session 2 tries to lock same row — should fail (non-blocking)
    s2.executeSql("BEGIN");
    var r2 = s2.executeSql("SELECT * FROM inventory WHERE id = 1 FOR UPDATE NOWAIT");
    assertFailure(r2, "S2 FOR UPDATE NOWAIT fails (row locked by S1)");

    // Session 1 commits — releases locks
    s1.executeSql("COMMIT");

    // Session 2 can now lock the row
    var r3 = s2.executeSql("SELECT * FROM inventory WHERE id = 1 FOR UPDATE NOWAIT");
    assertSuccess(r3, "S2 FOR UPDATE NOWAIT succeeds after S1 COMMIT");
    s2.executeSql("COMMIT");
}

//=============================================================================
// TEST: Row locks released on ROLLBACK
//=============================================================================

func testLockReleaseOnRollback() {
    section("Lock Release on ROLLBACK");
    var server = makeSharedServer();
    var s1 = makeSession(server, 1);
    var s2 = makeSession(server, 2);

    s1.executeSql("CREATE TABLE stock (id INTEGER, amount INTEGER)");
    s1.executeSql("INSERT INTO stock VALUES (1, 50)");

    // Session 1 locks row
    s1.executeSql("BEGIN");
    var r1 = s1.executeSql("SELECT * FROM stock WHERE id = 1 FOR UPDATE");
    assertSuccess(r1, "S1 locks row");

    // Session 2 can't get it
    s2.executeSql("BEGIN");
    var r2 = s2.executeSql("SELECT * FROM stock WHERE id = 1 FOR UPDATE NOWAIT");
    assertFailure(r2, "S2 blocked by S1 row lock");

    // Session 1 rollback — releases locks
    s1.executeSql("ROLLBACK");

    // Session 2 can now lock
    var r3 = s2.executeSql("SELECT * FROM stock WHERE id = 1 FOR UPDATE NOWAIT");
    assertSuccess(r3, "S2 succeeds after S1 ROLLBACK");
    s2.executeSql("COMMIT");
}

//=============================================================================
// TEST: SKIP LOCKED excludes locked rows
//=============================================================================

func testSkipLocked() {
    section("SKIP LOCKED");
    var server = makeSharedServer();
    var s1 = makeSession(server, 1);
    var s2 = makeSession(server, 2);

    s1.executeSql("CREATE TABLE jobs (id INTEGER, status TEXT)");
    s1.executeSql("INSERT INTO jobs VALUES (1, 'pending')");
    s1.executeSql("INSERT INTO jobs VALUES (2, 'pending')");
    s1.executeSql("INSERT INTO jobs VALUES (3, 'pending')");

    // Session 1 locks row 1 in a transaction
    s1.executeSql("BEGIN");
    var r1 = s1.executeSql("SELECT * FROM jobs WHERE id = 1 FOR UPDATE");
    assertSuccess(r1, "S1 locks job 1");

    // Session 2 uses SKIP LOCKED — should skip the locked row
    s2.executeSql("BEGIN");
    var r2 = s2.executeSql("SELECT * FROM jobs FOR UPDATE SKIP LOCKED");
    assertSuccess(r2, "S2 SKIP LOCKED succeeds");
    // Should return 2 rows (jobs 2 and 3, skipping job 1)
    assertRowCount(r2, 2, "SKIP LOCKED returns 2 unlocked rows");

    s1.executeSql("COMMIT");
    s2.executeSql("COMMIT");
}

//=============================================================================
// TEST: Shared locks allow concurrent shared access
//=============================================================================

func testSharedLockConcurrency() {
    section("Shared Lock Concurrency");
    var server = makeSharedServer();
    var s1 = makeSession(server, 1);
    var s2 = makeSession(server, 2);

    s1.executeSql("CREATE TABLE reports (id INTEGER, title TEXT)");
    s1.executeSql("INSERT INTO reports VALUES (1, 'Q1 Report')");
    s1.executeSql("INSERT INTO reports VALUES (2, 'Q2 Report')");

    // Both sessions acquire FOR SHARE on same rows (S+S compatible)
    s1.executeSql("BEGIN");
    var r1 = s1.executeSql("SELECT * FROM reports FOR SHARE");
    assertSuccess(r1, "S1 FOR SHARE succeeds");
    assertRowCount(r1, 2, "S1 sees 2 rows");

    s2.executeSql("BEGIN");
    var r2 = s2.executeSql("SELECT * FROM reports FOR SHARE");
    assertSuccess(r2, "S2 FOR SHARE succeeds (S+S compatible)");
    assertRowCount(r2, 2, "S2 sees 2 rows");

    // Session 3 cannot get exclusive lock while shared locks held
    var s3 = makeSession(server, 3);
    s3.executeSql("BEGIN");
    var r3 = s3.executeSql("SELECT * FROM reports WHERE id = 1 FOR UPDATE NOWAIT");
    assertFailure(r3, "S3 FOR UPDATE NOWAIT fails (S locks held)");

    s1.executeSql("COMMIT");
    s2.executeSql("COMMIT");
    s3.executeSql("COMMIT");
}

//=============================================================================
// TEST: Non-transactional FOR UPDATE releases locks after statement
//=============================================================================

func testNonTransactionalRelease() {
    section("Non-Transactional Lock Release");
    var server = makeSharedServer();
    var s1 = makeSession(server, 1);
    var s2 = makeSession(server, 2);

    s1.executeSql("CREATE TABLE quick (id INTEGER)");
    s1.executeSql("INSERT INTO quick VALUES (1)");

    // Session 1 executes FOR UPDATE outside transaction — lock acquired and released
    var r1 = s1.executeSql("SELECT * FROM quick FOR UPDATE");
    assertSuccess(r1, "S1 non-txn FOR UPDATE succeeds");

    // Session 2 should be able to lock immediately (S1 already released)
    var r2 = s2.executeSql("SELECT * FROM quick FOR UPDATE NOWAIT");
    assertSuccess(r2, "S2 NOWAIT succeeds (S1 lock was released)");
}

//=============================================================================
// TEST: Token collision fix verification (BUG-TOKEN-001)
//=============================================================================

func testTokenCollisionFix() {
    section("Token Collision Fix (BUG-TOKEN-001)");
    var exec = makeTestExecutor();

    // EXCEPT and INTERSECT should work correctly (they previously collided
    // with CLOSE and FILE token values)
    exec.executeSql("CREATE TABLE t1 (id INTEGER, name TEXT)");
    exec.executeSql("INSERT INTO t1 VALUES (1, 'a')");
    exec.executeSql("INSERT INTO t1 VALUES (2, 'b')");

    exec.executeSql("CREATE TABLE t2 (id INTEGER, name TEXT)");
    exec.executeSql("INSERT INTO t2 VALUES (2, 'b')");
    exec.executeSql("INSERT INTO t2 VALUES (3, 'c')");

    // EXCEPT should return rows in t1 but not in t2
    var r1 = exec.executeSql("SELECT id FROM t1 EXCEPT SELECT id FROM t2");
    assertSuccess(r1, "EXCEPT query succeeds");
    assertRowCount(r1, 1, "EXCEPT returns 1 row");
    assertEq(val(r1, 0, 0), "1", "EXCEPT returns correct value");

    // INTERSECT should return rows in both
    var r2 = exec.executeSql("SELECT id FROM t1 INTERSECT SELECT id FROM t2");
    assertSuccess(r2, "INTERSECT query succeeds");
    assertRowCount(r2, 1, "INTERSECT returns 1 row");
    assertEq(val(r2, 0, 0), "2", "INTERSECT returns correct value");
}

//=============================================================================
// TEST: FOR UPDATE with LIMIT
//=============================================================================

func testForUpdateWithLimit() {
    section("FOR UPDATE with LIMIT");
    var exec = makeTestExecutor();

    exec.executeSql("CREATE TABLE ranked (id INTEGER, score INTEGER)");
    exec.executeSql("INSERT INTO ranked VALUES (1, 90)");
    exec.executeSql("INSERT INTO ranked VALUES (2, 80)");
    exec.executeSql("INSERT INTO ranked VALUES (3, 70)");

    var r1 = exec.executeSql("SELECT * FROM ranked ORDER BY score DESC LIMIT 2 FOR UPDATE");
    assertSuccess(r1, "FOR UPDATE with LIMIT succeeds");
    assertRowCount(r1, 2, "Returns limited rows");
}

//=============================================================================
// TEST: Multiple row locks per session
//=============================================================================

func testMultipleRowLocks() {
    section("Multiple Row Locks");
    var server = makeSharedServer();
    var s1 = makeSession(server, 1);
    var s2 = makeSession(server, 2);

    s1.executeSql("CREATE TABLE multi (id INTEGER, val TEXT)");
    s1.executeSql("INSERT INTO multi VALUES (1, 'one')");
    s1.executeSql("INSERT INTO multi VALUES (2, 'two')");
    s1.executeSql("INSERT INTO multi VALUES (3, 'three')");

    // Session 1 locks all rows
    s1.executeSql("BEGIN");
    var r1 = s1.executeSql("SELECT * FROM multi FOR UPDATE");
    assertSuccess(r1, "S1 locks all rows");
    assertRowCount(r1, 3, "All 3 rows locked");

    // Session 2 can't get any of them
    s2.executeSql("BEGIN");
    var r2 = s2.executeSql("SELECT * FROM multi WHERE id = 1 FOR UPDATE NOWAIT");
    assertFailure(r2, "S2 blocked on row 1");

    var r3 = s2.executeSql("SELECT * FROM multi WHERE id = 3 FOR UPDATE NOWAIT");
    assertFailure(r3, "S2 blocked on row 3");

    // SKIP LOCKED returns 0 rows (all locked)
    var r4 = s2.executeSql("SELECT * FROM multi FOR UPDATE SKIP LOCKED");
    assertSuccess(r4, "SKIP LOCKED succeeds");
    assertRowCount(r4, 0, "SKIP LOCKED returns 0 rows (all locked)");

    s1.executeSql("COMMIT");
    s2.executeSql("COMMIT");
}

//=============================================================================
// ENTRY POINT
//=============================================================================

func main() -> Integer {
    Terminal.Say("=== Phase 14: Row-Level Locking Tests ===");

    // Syntax tests
    testForUpdateSyntax();
    testForShareSyntax();
    testForUpdateNowait();
    testForUpdateSkipLocked();
    testForShareModifiers();
    testSyntaxErrors();

    // RowLockManager unit tests
    testRowLockManagerBasic();
    testRowLockManagerSharedCompatible();
    testRowLockManagerExclusiveConflict();
    testRowLockManagerSharedBlocksExclusive();
    testRowLockManagerReentry();
    testRowLockManagerReleaseByTable();

    // Integration tests (multi-session)
    testLockReleaseOnCommit();
    testLockReleaseOnRollback();
    testSkipLocked();
    testSharedLockConcurrency();
    testNonTransactionalRelease();

    // Regression and edge cases
    testTokenCollisionFix();
    testForUpdateWithLimit();
    testMultipleRowLocks();

    printResults();
    return 0;
}
