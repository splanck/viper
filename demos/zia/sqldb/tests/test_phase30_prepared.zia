// test_phase30_prepared.zia â€” Phase 30: Prepared Statements & EXPLAIN ANALYZE
// Tests for PREPARE/EXECUTE/DEALLOCATE and EXPLAIN ANALYZE.

module test_phase30_prepared;

bind Terminal = Viper.Terminal;
bind String = Viper.String;
bind Fmt = Viper.Fmt;

bind "./test_common";
bind "../executor";
bind "../types";

//=========================================================================
// PREPARE / EXECUTE
//=========================================================================

func testPrepareExecuteBasic() {
    section("PREPARE/EXECUTE basic");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE prep_t (id INTEGER PRIMARY KEY, name TEXT, score INTEGER)");
    exec.executeSql("INSERT INTO prep_t VALUES (1, 'Alice', 80)");
    exec.executeSql("INSERT INTO prep_t VALUES (2, 'Bob', 90)");
    exec.executeSql("INSERT INTO prep_t VALUES (3, 'Carol', 70)");

    var r1 = exec.executeSql("PREPARE my_query AS SELECT * FROM prep_t WHERE id = $1");
    assertSuccess(r1, "PREPARE succeeds");
    assertTrue(stringContains(r1.message, "PREPARE"), "PREPARE message");

    var r2 = exec.executeSql("EXECUTE my_query (2)");
    assertEqInt(r2.rows.count(), 1, "EXECUTE returns 1 row");
    assertEq(val(r2, 0, 1), "Bob", "EXECUTE finds Bob with id=2");
}

func testPrepareExecuteMultiParam() {
    section("PREPARE/EXECUTE multi-param");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE prep2 (id INTEGER, name TEXT, score INTEGER)");
    exec.executeSql("INSERT INTO prep2 VALUES (1, 'Alice', 80)");
    exec.executeSql("INSERT INTO prep2 VALUES (2, 'Bob', 90)");
    exec.executeSql("INSERT INTO prep2 VALUES (3, 'Carol', 70)");

    exec.executeSql("PREPARE range_query AS SELECT * FROM prep2 WHERE score >= $1 AND score <= $2");

    var r1 = exec.executeSql("EXECUTE range_query (75, 85)");
    assertEqInt(r1.rows.count(), 1, "Range query returns 1 row (score 75-85)");
    assertEq(val(r1, 0, 1), "Alice", "Alice has score 80");
}

func testPrepareExecuteInsert() {
    section("PREPARE/EXECUTE INSERT");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE prep3 (id INTEGER, name TEXT)");

    exec.executeSql("PREPARE insert_stmt AS INSERT INTO prep3 VALUES ($1, $2)");

    exec.executeSql("EXECUTE insert_stmt (1, 'Alice')");
    exec.executeSql("EXECUTE insert_stmt (2, 'Bob')");

    var r1 = exec.executeSql("SELECT * FROM prep3 ORDER BY id");
    assertEqInt(r1.rows.count(), 2, "Two rows inserted via prepared statement");
    assertEq(val(r1, 0, 1), "Alice", "First row is Alice");
    assertEq(val(r1, 1, 1), "Bob", "Second row is Bob");
}

func testPrepareExecuteReuse() {
    section("PREPARE/EXECUTE reuse");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE prep4 (id INTEGER, val INTEGER)");
    var i = 1;
    while i <= 10 {
        exec.executeSql("INSERT INTO prep4 VALUES (" + Fmt.Int(i) + ", " + Fmt.Int(i * 10) + ")");
        i = i + 1;
    }

    exec.executeSql("PREPARE find_val AS SELECT val FROM prep4 WHERE id = $1");

    var r1 = exec.executeSql("EXECUTE find_val (5)");
    assertEq(val(r1, 0, 0), "50", "id=5 has val=50");

    var r2 = exec.executeSql("EXECUTE find_val (8)");
    assertEq(val(r2, 0, 0), "80", "id=8 has val=80");

    var r3 = exec.executeSql("EXECUTE find_val (1)");
    assertEq(val(r3, 0, 0), "10", "id=1 has val=10");
}

//=========================================================================
// DEALLOCATE
//=========================================================================

func testDeallocate() {
    section("DEALLOCATE");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE dealloc_t (id INTEGER)");

    exec.executeSql("PREPARE stmt1 AS SELECT * FROM dealloc_t");
    var r1 = exec.executeSql("DEALLOCATE stmt1");
    assertSuccess(r1, "DEALLOCATE succeeds");

    // Executing deallocated statement should fail
    var r2 = exec.executeSql("EXECUTE stmt1");
    assertTrue(r2.success == false, "EXECUTE after DEALLOCATE fails");
}

func testDeallocateAll() {
    section("DEALLOCATE ALL");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE dealloc2 (id INTEGER)");

    exec.executeSql("PREPARE q1 AS SELECT * FROM dealloc2");
    exec.executeSql("PREPARE q2 AS SELECT * FROM dealloc2");

    var r1 = exec.executeSql("DEALLOCATE ALL");
    assertSuccess(r1, "DEALLOCATE ALL succeeds");

    var r2 = exec.executeSql("EXECUTE q1");
    assertTrue(r2.success == false, "q1 deallocated");

    var r3 = exec.executeSql("EXECUTE q2");
    assertTrue(r3.success == false, "q2 deallocated");
}

func testDuplicatePrepare() {
    section("Duplicate PREPARE");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE dup_prep (id INTEGER)");

    exec.executeSql("PREPARE my_stmt AS SELECT * FROM dup_prep");
    var r1 = exec.executeSql("PREPARE my_stmt AS SELECT * FROM dup_prep");
    assertTrue(r1.success == false, "Duplicate PREPARE fails");
}

//=========================================================================
// EXPLAIN ANALYZE
//=========================================================================

func testExplainAnalyze() {
    section("EXPLAIN ANALYZE");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE explain_t (id INTEGER, name TEXT)");
    exec.executeSql("INSERT INTO explain_t VALUES (1, 'Alice')");
    exec.executeSql("INSERT INTO explain_t VALUES (2, 'Bob')");

    var r1 = exec.executeSql("EXPLAIN ANALYZE SELECT * FROM explain_t");
    assertSuccess(r1, "EXPLAIN ANALYZE succeeds");
    assertTrue(r1.rows.count() > 0, "EXPLAIN ANALYZE produces output");

    // Check that execution stats are included
    var foundExecTime = false;
    var foundRowsReturned = false;
    var i = 0;
    while i < r1.rows.count() {
        var planLine = val(r1, i, 0);
        if stringContains(planLine, "Execution Time") {
            foundExecTime = true;
        }
        if stringContains(planLine, "Rows Returned") {
            foundRowsReturned = true;
        }
        i = i + 1;
    }
    assertTrue(foundExecTime, "EXPLAIN ANALYZE includes Execution Time");
    assertTrue(foundRowsReturned, "EXPLAIN ANALYZE includes Rows Returned");
}

func testExplainAnalyzeWithWhere() {
    section("EXPLAIN ANALYZE with WHERE");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE explain2 (id INTEGER, val INTEGER)");
    var i = 1;
    while i <= 20 {
        exec.executeSql("INSERT INTO explain2 VALUES (" + Fmt.Int(i) + ", " + Fmt.Int(i * 5) + ")");
        i = i + 1;
    }

    var r1 = exec.executeSql("EXPLAIN ANALYZE SELECT * FROM explain2 WHERE id > 15");
    assertSuccess(r1, "EXPLAIN ANALYZE with WHERE succeeds");

    // Check rows returned info
    var foundRows = false;
    i = 0;
    while i < r1.rows.count() {
        var planLine = val(r1, i, 0);
        if stringContains(planLine, "Rows Returned: 5") {
            foundRows = true;
        }
        i = i + 1;
    }
    assertTrue(foundRows, "EXPLAIN ANALYZE reports 5 rows returned");
}

func main() -> Integer {
    Terminal.Say("=== Phase 30: Prepared Statements & EXPLAIN ANALYZE ===");

    testPrepareExecuteBasic();
    testPrepareExecuteMultiParam();
    testPrepareExecuteInsert();
    testPrepareExecuteReuse();
    testDeallocate();
    testDeallocateAll();
    testDuplicatePrepare();
    testExplainAnalyze();
    testExplainAnalyzeWithWhere();

    printResults();
    return 0;
}
