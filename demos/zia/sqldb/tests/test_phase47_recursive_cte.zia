// test_phase47_recursive_cte.zia — Phase 47: Recursive CTEs
// Tests for WITH RECURSIVE with iterative fixpoint evaluation.

module test_phase47_recursive_cte;

bind Terminal = Viper.Terminal;
bind String = Viper.String;
bind Fmt = Viper.Fmt;

bind "./test_common";
bind "../executor";
bind "../types";

//=========================================================================
// Basic counting (1 to 10)
//=========================================================================

func testCountTo10() {
    section("Recursive count 1..10");

    var exec = new Executor();
    exec.init();

    var r1 = exec.executeSql("WITH RECURSIVE cnt(n) AS (SELECT 1 UNION ALL SELECT n + 1 FROM cnt WHERE n < 10) SELECT n FROM cnt");
    assertSuccess(r1, "recursive count");
    assertRowCount(r1, 10, "10 rows");
    assertEq(val(r1, 0, 0), "1", "first is 1");
    assertEq(val(r1, 9, 0), "10", "last is 10");
}

//=========================================================================
// Factorial computation
//=========================================================================

func testFactorial() {
    section("Recursive factorial");

    var exec = new Executor();
    exec.init();

    var r1 = exec.executeSql("WITH RECURSIVE fact(n, f) AS (SELECT 1, 1 UNION ALL SELECT n + 1, f * (n + 1) FROM fact WHERE n < 6) SELECT n, f FROM fact");
    assertSuccess(r1, "recursive factorial");
    assertRowCount(r1, 6, "6 rows");
    assertEq(val(r1, 0, 0), "1", "n=1");
    assertEq(val(r1, 0, 1), "1", "1! = 1");
    assertEq(val(r1, 4, 0), "5", "n=5");
    assertEq(val(r1, 4, 1), "120", "5! = 120");
    assertEq(val(r1, 5, 0), "6", "n=6");
    assertEq(val(r1, 5, 1), "720", "6! = 720");
}

//=========================================================================
// Fibonacci sequence
//=========================================================================

func testFibonacci() {
    section("Recursive Fibonacci");

    var exec = new Executor();
    exec.init();

    var r1 = exec.executeSql("WITH RECURSIVE fib(n, a, b) AS (SELECT 1, 0, 1 UNION ALL SELECT n + 1, b, a + b FROM fib WHERE n < 8) SELECT n, a FROM fib");
    assertSuccess(r1, "recursive fibonacci");
    assertRowCount(r1, 8, "8 rows");
    assertEq(val(r1, 0, 1), "0", "fib(1) = 0");
    assertEq(val(r1, 1, 1), "1", "fib(2) = 1");
    assertEq(val(r1, 2, 1), "1", "fib(3) = 1");
    assertEq(val(r1, 3, 1), "2", "fib(4) = 2");
    assertEq(val(r1, 4, 1), "3", "fib(5) = 3");
    assertEq(val(r1, 5, 1), "5", "fib(6) = 5");
    assertEq(val(r1, 6, 1), "8", "fib(7) = 8");
    assertEq(val(r1, 7, 1), "13", "fib(8) = 13");
}

//=========================================================================
// Tree traversal (employee hierarchy)
//=========================================================================

func testTreeTraversal() {
    section("Recursive tree traversal");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE employees (id INTEGER, name TEXT, manager_id INTEGER)");
    exec.executeSql("INSERT INTO employees VALUES (1, 'CEO', NULL)");
    exec.executeSql("INSERT INTO employees VALUES (2, 'VP1', 1)");
    exec.executeSql("INSERT INTO employees VALUES (3, 'VP2', 1)");
    exec.executeSql("INSERT INTO employees VALUES (4, 'Mgr1', 2)");
    exec.executeSql("INSERT INTO employees VALUES (5, 'Mgr2', 2)");
    exec.executeSql("INSERT INTO employees VALUES (6, 'Dev1', 4)");

    // Find all reports under CEO (id=1)
    var r1 = exec.executeSql("WITH RECURSIVE reports(id, name, lvl) AS (SELECT id, name, 0 FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, r.lvl + 1 FROM employees e JOIN reports r ON e.manager_id = r.id) SELECT id, name, lvl FROM reports ORDER BY id");
    assertSuccess(r1, "tree traversal");
    assertRowCount(r1, 6, "6 employees in tree");
    // CEO at level 0
    assertEq(val(r1, 0, 2), "0", "CEO at level 0");
    // VPs at level 1
    assertEq(val(r1, 1, 2), "1", "VP1 at level 1");
    assertEq(val(r1, 2, 2), "1", "VP2 at level 1");
}

//=========================================================================
// Single-row anchor (no recursion needed)
//=========================================================================

func testNoRecursion() {
    section("Recursive CTE with no recursion");

    var exec = new Executor();
    exec.init();

    // Anchor produces rows, recursive part produces 0 rows immediately
    var r1 = exec.executeSql("WITH RECURSIVE t(n) AS (SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n > 100) SELECT * FROM t");
    assertSuccess(r1, "no recursion");
    assertRowCount(r1, 1, "1 row only");
    assertEq(val(r1, 0, 0), "1", "just the anchor");
}

//=========================================================================
// UNION (not ALL) — deduplication
//=========================================================================

func testUnionDedup() {
    section("Recursive UNION (dedup)");

    var exec = new Executor();
    exec.init();

    // Count 1..5 with UNION (not ALL) — should still work, just dedup
    var r1 = exec.executeSql("WITH RECURSIVE cnt AS (SELECT 1 AS n UNION SELECT n + 1 FROM cnt WHERE n < 5) SELECT n FROM cnt");
    assertSuccess(r1, "recursive UNION");
    assertRowCount(r1, 5, "5 rows");
    assertEq(val(r1, 0, 0), "1", "starts at 1");
    assertEq(val(r1, 4, 0), "5", "ends at 5");
}

//=========================================================================
// Recursive CTE with WHERE filter in main query
//=========================================================================

func testWithMainFilter() {
    section("Recursive CTE + main query filter");

    var exec = new Executor();
    exec.init();

    var r1 = exec.executeSql("WITH RECURSIVE cnt(n) AS (SELECT 1 UNION ALL SELECT n + 1 FROM cnt WHERE n < 20) SELECT n FROM cnt WHERE n > 15");
    assertSuccess(r1, "filtered recursive");
    assertRowCount(r1, 5, "5 rows > 15");
    assertEq(val(r1, 0, 0), "16", "starts at 16");
    assertEq(val(r1, 4, 0), "20", "ends at 20");
}

//=========================================================================
// Recursive CTE with string concatenation
//=========================================================================

func testStringRecursion() {
    section("Recursive string building");

    var exec = new Executor();
    exec.init();

    var r1 = exec.executeSql("WITH RECURSIVE s(n, txt) AS (SELECT 1, 'a' UNION ALL SELECT n + 1, txt || 'a' FROM s WHERE n < 5) SELECT n, txt FROM s");
    assertSuccess(r1, "string recursion");
    assertRowCount(r1, 5, "5 rows");
    assertEq(val(r1, 0, 1), "a", "1 char");
    assertEq(val(r1, 4, 1), "aaaaa", "5 chars");
}

//=========================================================================
// Recursive CTE with aggregate in main query
//=========================================================================

func testRecursiveWithAggregate() {
    section("Recursive CTE + aggregate");

    var exec = new Executor();
    exec.init();

    var r1 = exec.executeSql("WITH RECURSIVE cnt(n) AS (SELECT 1 UNION ALL SELECT n + 1 FROM cnt WHERE n < 10) SELECT SUM(n), COUNT(n) FROM cnt");
    assertSuccess(r1, "aggregate on recursive");
    assertEq(val(r1, 0, 0), "55", "sum 1..10 = 55");
    assertEq(val(r1, 0, 1), "10", "count = 10");
}

//=========================================================================
// MAIN
//=========================================================================

func main() {
    Terminal.Say("=== Phase 47: Recursive CTEs ===");

    testCountTo10();
    testFactorial();
    testFibonacci();
    testTreeTraversal();
    testNoRecursion();
    testUnionDedup();
    testWithMainFilter();
    testStringRecursion();
    testRecursiveWithAggregate();

    printResults();
}
