// test_phase27_pg_stat.zia — Phase 27: pg_stat Views
// Tests for pg_stat_activity, pg_stat_user_tables, pg_stat_user_indexes,
// statement-level counting, and DML tracking.

module test_phase27_pg_stat;

bind Terminal = Viper.Terminal;
bind String = Viper.String;
bind Fmt = Viper.Fmt;

bind "./test_common";
bind "../executor";
bind "../types";

func testPgStatActivity() {
    section("pg_stat_activity");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE act_test (id INTEGER)");
    exec.executeSql("INSERT INTO act_test VALUES (1)");

    var r1 = exec.executeSql("SELECT * FROM pg_stat_activity");
    assertSuccess(r1, "pg_stat_activity query succeeds");
    assertTrue(r1.rows.count() > 0, "pg_stat_activity has at least 1 row");
    assertEqInt(r1.columnNames.count(), 10, "pg_stat_activity has 10 columns");

    // Verify column names
    assertEq(r1.columnNames.get(0), "datid", "col 0 is datid");
    assertEq(r1.columnNames.get(1), "datname", "col 1 is datname");
    assertEq(r1.columnNames.get(3), "usename", "col 3 is usename");
    assertEq(r1.columnNames.get(7), "state", "col 7 is state");
    assertEq(r1.columnNames.get(8), "query", "col 8 is query");

    // Verify session data
    var row0 = r1.rows.get(0);
    assertEq(row0.values.get(1).textValue, "main", "datname is main");
    assertEq(row0.values.get(3).textValue, "admin", "usename is admin");
    assertEq(row0.values.get(7).textValue, "active", "state is active");
    assertTrue(row0.values.get(9).intValue > 0, "query_count > 0");
}

func testPgStatActivityTxn() {
    section("pg_stat_activity — Transaction State");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE txn_act (id INTEGER)");
    exec.executeSql("BEGIN");

    var r2 = exec.executeSql("SELECT * FROM pg_stat_activity");
    assertSuccess(r2, "pg_stat_activity in txn succeeds");
    var row0 = r2.rows.get(0);
    assertEq(row0.values.get(7).textValue, "idle in transaction", "state is 'idle in transaction' during txn");

    exec.executeSql("ROLLBACK");
}

func testPgStatActivityCatalogPrefix() {
    section("pg_stat_activity — pg_catalog prefix");

    var exec = new Executor();
    exec.init();

    var r3 = exec.executeSql("SELECT * FROM pg_catalog.pg_stat_activity");
    assertSuccess(r3, "pg_catalog.pg_stat_activity query succeeds");
    assertTrue(r3.rows.count() > 0, "pg_catalog prefix works for pg_stat_activity");
}

func testPgStatUserTablesBasic() {
    section("pg_stat_user_tables — Basic");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE stat_t1 (id INTEGER, name TEXT)");
    exec.executeSql("INSERT INTO stat_t1 VALUES (1, 'Alice')");
    exec.executeSql("INSERT INTO stat_t1 VALUES (2, 'Bob')");
    exec.executeSql("INSERT INTO stat_t1 VALUES (3, 'Charlie')");

    var r4 = exec.executeSql("SELECT * FROM pg_stat_user_tables");
    assertSuccess(r4, "pg_stat_user_tables query succeeds");
    assertTrue(r4.rows.count() > 0, "pg_stat_user_tables has rows");
    assertEqInt(r4.columnNames.count(), 12, "pg_stat_user_tables has 12 columns");

    // Verify column names
    assertEq(r4.columnNames.get(2), "relname", "col 2 is relname");
    assertEq(r4.columnNames.get(3), "seq_scan", "col 3 is seq_scan");
    assertEq(r4.columnNames.get(7), "n_tup_ins", "col 7 is n_tup_ins");

    // Find stat_t1 in results
    var found = false;
    var si = 0;
    while si < r4.rows.count() {
        var srow = r4.rows.get(si);
        if srow.values.get(2).textValue == "stat_t1" {
            found = true;
            // 3 inserts (one row each)
            assertEqInt(srow.values.get(7).intValue, 3, "n_tup_ins is 3");
            // n_live_tup should be 3
            assertEqInt(srow.values.get(10).intValue, 3, "n_live_tup is 3");
        }
        si = si + 1;
    }
    assertTrue(found, "stat_t1 found in pg_stat_user_tables");
}

func testPgStatUserTablesDML() {
    section("pg_stat_user_tables — DML Tracking");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE stat_t2 (id INTEGER, val TEXT)");
    exec.executeSql("INSERT INTO stat_t2 VALUES (1, 'a')");
    exec.executeSql("INSERT INTO stat_t2 VALUES (2, 'b')");
    exec.executeSql("INSERT INTO stat_t2 VALUES (3, 'c')");
    exec.executeSql("UPDATE stat_t2 SET val = 'updated' WHERE id = 1");
    exec.executeSql("DELETE FROM stat_t2 WHERE id = 3");

    var r5 = exec.executeSql("SELECT * FROM pg_stat_user_tables");
    assertSuccess(r5, "pg_stat_user_tables after DML succeeds");

    var si = 0;
    while si < r5.rows.count() {
        var srow = r5.rows.get(si);
        if srow.values.get(2).textValue == "stat_t2" {
            assertEqInt(srow.values.get(7).intValue, 3, "n_tup_ins is 3 for stat_t2");
            assertEqInt(srow.values.get(8).intValue, 1, "n_tup_upd is 1 for stat_t2");
            assertEqInt(srow.values.get(9).intValue, 1, "n_tup_del is 1 for stat_t2");
        }
        si = si + 1;
    }
}

func testPgStatUserTablesSeqScan() {
    section("pg_stat_user_tables — Sequential Scan Tracking");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE stat_t3 (id INTEGER, val TEXT)");
    exec.executeSql("INSERT INTO stat_t3 VALUES (1, 'a')");
    exec.executeSql("INSERT INTO stat_t3 VALUES (2, 'b')");

    // This SELECT triggers a sequential scan
    exec.executeSql("SELECT * FROM stat_t3 WHERE val = 'a'");
    exec.executeSql("SELECT * FROM stat_t3 WHERE id = 1");

    var r6 = exec.executeSql("SELECT * FROM pg_stat_user_tables");
    assertSuccess(r6, "pg_stat_user_tables after SELECTs succeeds");

    var si = 0;
    while si < r6.rows.count() {
        var srow = r6.rows.get(si);
        if srow.values.get(2).textValue == "stat_t3" {
            assertTrue(srow.values.get(3).intValue >= 2, "seq_scan >= 2 after two SELECTs");
            assertTrue(srow.values.get(4).intValue > 0, "seq_tup_read > 0 after SELECTs");
        }
        si = si + 1;
    }
}

func testPgStatUserTablesIdx() {
    section("pg_stat_user_tables — Index Scan Tracking");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE stat_t4 (id INTEGER, val TEXT)");
    exec.executeSql("CREATE INDEX idx_stat_t4_id ON stat_t4(id)");
    exec.executeSql("INSERT INTO stat_t4 VALUES (1, 'a')");
    exec.executeSql("INSERT INTO stat_t4 VALUES (2, 'b')");
    exec.executeSql("INSERT INTO stat_t4 VALUES (3, 'c')");

    // Force an index scan by using the indexed column
    exec.executeSql("SELECT * FROM stat_t4 WHERE id = 2");

    var r7 = exec.executeSql("SELECT * FROM pg_stat_user_tables");
    assertSuccess(r7, "pg_stat_user_tables after index lookup succeeds");

    var si = 0;
    while si < r7.rows.count() {
        var srow = r7.rows.get(si);
        if srow.values.get(2).textValue == "stat_t4" {
            assertTrue(srow.values.get(5).intValue >= 1, "idx_scan >= 1 after index SELECT");
        }
        si = si + 1;
    }
}

func testPgStatUserIndexes() {
    section("pg_stat_user_indexes");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE idx_stat_t (id INTEGER, val TEXT)");
    exec.executeSql("CREATE INDEX idx_stat_t_id ON idx_stat_t(id)");
    exec.executeSql("INSERT INTO idx_stat_t VALUES (1, 'a')");
    exec.executeSql("INSERT INTO idx_stat_t VALUES (2, 'b')");
    exec.executeSql("INSERT INTO idx_stat_t VALUES (3, 'c')");

    // Trigger index scans
    exec.executeSql("SELECT * FROM idx_stat_t WHERE id = 1");
    exec.executeSql("SELECT * FROM idx_stat_t WHERE id = 2");

    var r8 = exec.executeSql("SELECT * FROM pg_stat_user_indexes");
    assertSuccess(r8, "pg_stat_user_indexes query succeeds");
    assertEqInt(r8.columnNames.count(), 8, "pg_stat_user_indexes has 8 columns");

    // Verify column names
    assertEq(r8.columnNames.get(4), "indexrelname", "col 4 is indexrelname");
    assertEq(r8.columnNames.get(5), "idx_scan", "col 5 is idx_scan");

    if r8.rows.count() > 0 {
        var found = false;
        var si = 0;
        while si < r8.rows.count() {
            var srow = r8.rows.get(si);
            if srow.values.get(4).textValue == "idx_stat_t_id" {
                found = true;
                assertTrue(srow.values.get(5).intValue >= 2, "idx_scan >= 2 for idx_stat_t_id");
            }
            si = si + 1;
        }
        assertTrue(found, "idx_stat_t_id found in pg_stat_user_indexes");
    }
}

func testPgStatUserIndexesCatalogPrefix() {
    section("pg_stat_user_indexes — pg_catalog prefix");

    var exec = new Executor();
    exec.init();

    var r9 = exec.executeSql("SELECT * FROM pg_catalog.pg_stat_user_indexes");
    assertSuccess(r9, "pg_catalog.pg_stat_user_indexes query succeeds");
    assertEqInt(r9.columnNames.count(), 8, "pg_catalog prefix works for pg_stat_user_indexes");
}

func testPgStatMultipleTables() {
    section("pg_stat — Multiple Tables");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE multi_a (id INTEGER)");
    exec.executeSql("CREATE TABLE multi_b (id INTEGER)");
    exec.executeSql("INSERT INTO multi_a VALUES (1)");
    exec.executeSql("INSERT INTO multi_a VALUES (2)");
    exec.executeSql("INSERT INTO multi_b VALUES (10)");

    var r10 = exec.executeSql("SELECT * FROM pg_stat_user_tables");
    assertSuccess(r10, "pg_stat_user_tables with multiple tables succeeds");

    var foundA = false;
    var foundB = false;
    var si = 0;
    while si < r10.rows.count() {
        var srow = r10.rows.get(si);
        if srow.values.get(2).textValue == "multi_a" {
            foundA = true;
            assertEqInt(srow.values.get(7).intValue, 2, "multi_a: n_tup_ins is 2");
        }
        if srow.values.get(2).textValue == "multi_b" {
            foundB = true;
            assertEqInt(srow.values.get(7).intValue, 1, "multi_b: n_tup_ins is 1");
        }
        si = si + 1;
    }
    assertTrue(foundA, "multi_a found in pg_stat_user_tables");
    assertTrue(foundB, "multi_b found in pg_stat_user_tables");
}

func testPgStatQueryCount() {
    section("pg_stat — Query Count");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE qc_test (id INTEGER)");
    exec.executeSql("INSERT INTO qc_test VALUES (1)");
    exec.executeSql("SELECT * FROM qc_test");

    // At this point: CREATE + INSERT + SELECT = 3 queries
    var r11 = exec.executeSql("SELECT * FROM pg_stat_activity");
    assertSuccess(r11, "pg_stat_activity for query count succeeds");
    var row0 = r11.rows.get(0);
    // The SELECT on pg_stat_activity is the 4th query
    assertTrue(row0.values.get(9).intValue >= 4, "query_count >= 4 after 4 statements");
}

func main() -> Integer {
    Terminal.Say("=== Phase 27: pg_stat Views ===");

    testPgStatActivity();
    testPgStatActivityTxn();
    testPgStatActivityCatalogPrefix();
    testPgStatUserTablesBasic();
    testPgStatUserTablesDML();
    testPgStatUserTablesSeqScan();
    testPgStatUserTablesIdx();
    testPgStatUserIndexes();
    testPgStatUserIndexesCatalogPrefix();
    testPgStatMultipleTables();
    testPgStatQueryCount();

    printResults();
    return 0;
}
