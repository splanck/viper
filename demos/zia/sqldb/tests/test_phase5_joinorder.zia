// test_phase5_joinorder.zia â€” Join Ordering Optimization Tests
// Part of ViperSQL Test Suite
//
// Tests multi-table INNER JOIN ordering optimization, verifying that
// the optimizer reorders tables by size for 3+ table joins while
// preserving correctness.
//
// Dependencies: executor.zia, types.zia, result.zia

module test_phase5_joinorder;

bind Terminal = Viper.Terminal;
bind Fmt = Viper.Fmt;

bind "./test_common";
bind "../executor";
bind "../types";
bind "../result";

func main() -> Integer {
    Terminal.Say("=== Phase 5: Join Ordering Tests ===");

    var exec = new Executor();
    exec.init();

    //=========================================================================
    // Test 1: Two-table INNER JOIN (no reordering for 2 tables)
    //=========================================================================
    section("Two-table INNER JOIN");

    exec.executeSql("CREATE TABLE small2 (id INTEGER PRIMARY KEY, val TEXT)");
    exec.executeSql("CREATE TABLE big2 (id INTEGER PRIMARY KEY, name TEXT, small_id INTEGER)");

    exec.executeSql("INSERT INTO small2 VALUES (1, 'A')");
    exec.executeSql("INSERT INTO small2 VALUES (2, 'B')");

    var i = 1;
    while i <= 10 {
        var sid = 1;
        if i > 5 { sid = 2; }
        exec.executeSql("INSERT INTO big2 VALUES (" + Fmt.Int(i) + ", 'Row" + Fmt.Int(i) + "', " + Fmt.Int(sid) + ")");
        i = i + 1;
    }

    var r = exec.executeSql("SELECT s.val, b.name FROM small2 s INNER JOIN big2 b ON s.id = b.small_id ORDER BY b.id");
    assertTrue(r.success, "2-table INNER JOIN succeeds");
    assertEqInt(r.rowCount(), 10, "2-table INNER JOIN row count");

    //=========================================================================
    // Test 2: Three-table INNER JOIN (reordering should apply)
    //=========================================================================
    section("Three-table INNER JOIN");

    exec.executeSql("CREATE TABLE dept3 (id INTEGER PRIMARY KEY, name TEXT)");
    exec.executeSql("CREATE TABLE proj3 (id INTEGER PRIMARY KEY, name TEXT, dept_id INTEGER)");
    exec.executeSql("CREATE TABLE emp3 (id INTEGER PRIMARY KEY, name TEXT, proj_id INTEGER)");

    exec.executeSql("INSERT INTO dept3 VALUES (1, 'Engineering')");
    exec.executeSql("INSERT INTO dept3 VALUES (2, 'Marketing')");

    exec.executeSql("INSERT INTO proj3 VALUES (1, 'Alpha', 1)");
    exec.executeSql("INSERT INTO proj3 VALUES (2, 'Beta', 1)");
    exec.executeSql("INSERT INTO proj3 VALUES (3, 'Gamma', 2)");

    i = 1;
    while i <= 20 {
        var pid = 1;
        if i > 10 { pid = 2; }
        if i > 15 { pid = 3; }
        exec.executeSql("INSERT INTO emp3 VALUES (" + Fmt.Int(i) + ", 'Emp" + Fmt.Int(i) + "', " + Fmt.Int(pid) + ")");
        i = i + 1;
    }

    // Query with largest table first in SQL (should be reordered to smallest first)
    r = exec.executeSql("SELECT e.name, p.name, d.name FROM emp3 e INNER JOIN proj3 p ON e.proj_id = p.id INNER JOIN dept3 d ON p.dept_id = d.id");
    assertTrue(r.success, "3-table INNER JOIN succeeds");
    assertEqInt(r.rowCount(), 20, "3-table INNER JOIN row count");

    // Verify all departments are present
    r = exec.executeSql("SELECT DISTINCT d.name FROM emp3 e INNER JOIN proj3 p ON e.proj_id = p.id INNER JOIN dept3 d ON p.dept_id = d.id ORDER BY d.name");
    assertTrue(r.success, "3-table DISTINCT depts succeeds");
    assertEqInt(r.rowCount(), 2, "3-table DISTINCT dept count");

    //=========================================================================
    // Test 3: Three-table join with different column ordering
    //=========================================================================
    section("Three-table with WHERE");

    r = exec.executeSql("SELECT d.name, p.name, e.name FROM emp3 e INNER JOIN proj3 p ON e.proj_id = p.id INNER JOIN dept3 d ON p.dept_id = d.id WHERE d.name = 'Engineering' ORDER BY e.id");
    assertTrue(r.success, "3-table with WHERE succeeds");
    assertEqInt(r.rowCount(), 15, "3-table with WHERE row count");

    //=========================================================================
    // Test 4: Four-table INNER JOIN
    //=========================================================================
    section("Four-table INNER JOIN");

    exec.executeSql("CREATE TABLE region (id INTEGER PRIMARY KEY, name TEXT)");
    exec.executeSql("INSERT INTO region VALUES (1, 'West')");
    exec.executeSql("INSERT INTO region VALUES (2, 'East')");

    exec.executeSql("CREATE TABLE office (id INTEGER PRIMARY KEY, name TEXT, region_id INTEGER, dept_id INTEGER)");
    exec.executeSql("INSERT INTO office VALUES (1, 'SF', 1, 1)");
    exec.executeSql("INSERT INTO office VALUES (2, 'NYC', 2, 1)");
    exec.executeSql("INSERT INTO office VALUES (3, 'LA', 1, 2)");

    exec.executeSql("CREATE TABLE worker (id INTEGER PRIMARY KEY, name TEXT, office_id INTEGER)");
    i = 1;
    while i <= 12 {
        var oid = 1;
        if i > 4 { oid = 2; }
        if i > 8 { oid = 3; }
        exec.executeSql("INSERT INTO worker VALUES (" + Fmt.Int(i) + ", 'W" + Fmt.Int(i) + "', " + Fmt.Int(oid) + ")");
        i = i + 1;
    }

    r = exec.executeSql("SELECT w.name, o.name, d.name, re.name FROM worker w INNER JOIN office o ON w.office_id = o.id INNER JOIN dept3 d ON o.dept_id = d.id INNER JOIN region re ON o.region_id = re.id");
    assertTrue(r.success, "4-table INNER JOIN succeeds");
    assertEqInt(r.rowCount(), 12, "4-table INNER JOIN row count");

    //=========================================================================
    // Test 5: Mixed join types (no reordering for non-INNER)
    //=========================================================================
    section("Mixed join types");

    exec.executeSql("CREATE TABLE a5 (id INTEGER PRIMARY KEY, val TEXT)");
    exec.executeSql("CREATE TABLE b5 (id INTEGER PRIMARY KEY, a_id INTEGER, val TEXT)");
    exec.executeSql("CREATE TABLE c5 (id INTEGER PRIMARY KEY, b_id INTEGER, val TEXT)");

    exec.executeSql("INSERT INTO a5 VALUES (1, 'A1')");
    exec.executeSql("INSERT INTO a5 VALUES (2, 'A2')");
    exec.executeSql("INSERT INTO a5 VALUES (3, 'A3')");

    exec.executeSql("INSERT INTO b5 VALUES (1, 1, 'B1')");
    exec.executeSql("INSERT INTO b5 VALUES (2, 2, 'B2')");

    exec.executeSql("INSERT INTO c5 VALUES (1, 1, 'C1')");

    // LEFT JOIN prevents reordering
    r = exec.executeSql("SELECT a.val, b.val, c.val FROM a5 a LEFT JOIN b5 b ON a.id = b.a_id INNER JOIN c5 c ON b.id = c.b_id");
    assertTrue(r.success, "Mixed LEFT+INNER JOIN succeeds");
    // A3 doesn't match B, so LEFT adds NULL for B, which can't match C
    assertEqInt(r.rowCount(), 1, "Mixed join row count");

    //=========================================================================
    // Test 6: Aggregation with 3-table join (tests reordered results are correct)
    //=========================================================================
    section("Aggregation with reordered join");

    r = exec.executeSql("SELECT d.name, COUNT(*) FROM emp3 e INNER JOIN proj3 p ON e.proj_id = p.id INNER JOIN dept3 d ON p.dept_id = d.id GROUP BY d.name ORDER BY d.name");
    assertTrue(r.success, "3-table with GROUP BY succeeds");
    assertEqInt(r.rowCount(), 2, "3-table GROUP BY row count");
    if r.rowCount() == 2 {
        assertEq(val(r, 0, 1), "15", "Dept Engineering count");
        assertEq(val(r, 1, 1), "5", "Dept Marketing count");
    }

    //=========================================================================
    // Test 7: Self-join (same table twice) with reordering
    //=========================================================================
    section("Self-join");

    exec.executeSql("CREATE TABLE nums (id INTEGER PRIMARY KEY, val INTEGER, ref_id INTEGER)");
    exec.executeSql("INSERT INTO nums VALUES (1, 10, 2)");
    exec.executeSql("INSERT INTO nums VALUES (2, 20, 3)");
    exec.executeSql("INSERT INTO nums VALUES (3, 30, 1)");

    // Self-join: find pairs where n1.ref_id = n2.id
    r = exec.executeSql("SELECT n1.val, n2.val FROM nums n1 INNER JOIN nums n2 ON n1.ref_id = n2.id");
    assertTrue(r.success, "Self-join succeeds");
    assertEqInt(r.rowCount(), 3, "Self-join row count");
    // Verify correct data via aggregation (order is non-deterministic in join queries)
    r = exec.executeSql("SELECT SUM(n1.val), SUM(n2.val) FROM nums n1 INNER JOIN nums n2 ON n1.ref_id = n2.id");
    assertTrue(r.success, "Self-join SUM succeeds");
    if r.rowCount() == 1 {
        assertEq(val(r, 0, 0), "60", "Self-join SUM left");
        assertEq(val(r, 0, 1), "60", "Self-join SUM right");
    }

    //=========================================================================
    // Test 8: Verify correct results with tables written in reverse size order
    //=========================================================================
    section("Reverse size order");

    // SQL deliberately lists the LARGEST table first
    r = exec.executeSql("SELECT e.name, d.name FROM emp3 e INNER JOIN proj3 p ON e.proj_id = p.id INNER JOIN dept3 d ON p.dept_id = d.id WHERE e.id <= 5 ORDER BY e.id");
    assertTrue(r.success, "Reverse-order 3-table succeeds");
    assertEqInt(r.rowCount(), 5, "Reverse-order row count");
    if r.rowCount() == 5 {
        assertEq(val(r, 0, 1), "Engineering", "Row 0 dept");
        assertEq(val(r, 4, 1), "Engineering", "Row 4 dept");
    }

    printResults();
    return 0;
}
