// test_phase5_joinorder.zia â€” Phase 5: Join ordering optimization tests
module test_phase5_joinorder;

bind Terminal = Viper.Terminal;
bind Fmt = Viper.Fmt;

bind "../executor";
bind "../types";
bind "../result";

var passed = 0;
var failed = 0;

func check(label: String, got: String, expected: String) {
    if got == expected {
        passed = passed + 1;
    } else {
        Terminal.Say("FAIL: " + label);
        Terminal.Say("  expected: " + expected);
        Terminal.Say("  got:      " + got);
        failed = failed + 1;
    }
}

func checkInt(label: String, got: Integer, expected: Integer) {
    if got == expected {
        passed = passed + 1;
    } else {
        Terminal.Say("FAIL: " + label + " expected=" + Fmt.Int(expected) + " got=" + Fmt.Int(got));
        failed = failed + 1;
    }
}

func checkTrue(label: String, cond: Boolean) {
    if cond {
        passed = passed + 1;
    } else {
        Terminal.Say("FAIL: " + label);
        failed = failed + 1;
    }
}

func getVal(result: QueryResult, row: Integer, col: Integer) -> String {
    var r = result.getRow(row);
    if r == null { return "NULL_ROW"; }
    var rr = r;
    return rr.getValue(col).toString();
}

func main() {
    var exec = new Executor();
    exec.init();

    //=========================================================================
    // Test 1: Two-table INNER JOIN (no reordering for 2 tables)
    //=========================================================================
    exec.executeSql("CREATE TABLE small2 (id INTEGER PRIMARY KEY, val TEXT)");
    exec.executeSql("CREATE TABLE big2 (id INTEGER PRIMARY KEY, name TEXT, small_id INTEGER)");

    exec.executeSql("INSERT INTO small2 VALUES (1, 'A')");
    exec.executeSql("INSERT INTO small2 VALUES (2, 'B')");

    var i = 1;
    while i <= 10 {
        var sid = 1;
        if i > 5 { sid = 2; }
        exec.executeSql("INSERT INTO big2 VALUES (" + Fmt.Int(i) + ", 'Row" + Fmt.Int(i) + "', " + Fmt.Int(sid) + ")");
        i = i + 1;
    }

    var r = exec.executeSql("SELECT s.val, b.name FROM small2 s INNER JOIN big2 b ON s.id = b.small_id ORDER BY b.id");
    checkTrue("2-table INNER JOIN succeeds", r.success);
    checkInt("2-table INNER JOIN row count", r.rowCount(), 10);

    //=========================================================================
    // Test 2: Three-table INNER JOIN (reordering should apply)
    //=========================================================================
    exec.executeSql("CREATE TABLE dept3 (id INTEGER PRIMARY KEY, name TEXT)");
    exec.executeSql("CREATE TABLE proj3 (id INTEGER PRIMARY KEY, name TEXT, dept_id INTEGER)");
    exec.executeSql("CREATE TABLE emp3 (id INTEGER PRIMARY KEY, name TEXT, proj_id INTEGER)");

    exec.executeSql("INSERT INTO dept3 VALUES (1, 'Engineering')");
    exec.executeSql("INSERT INTO dept3 VALUES (2, 'Marketing')");

    exec.executeSql("INSERT INTO proj3 VALUES (1, 'Alpha', 1)");
    exec.executeSql("INSERT INTO proj3 VALUES (2, 'Beta', 1)");
    exec.executeSql("INSERT INTO proj3 VALUES (3, 'Gamma', 2)");

    i = 1;
    while i <= 20 {
        var pid = 1;
        if i > 10 { pid = 2; }
        if i > 15 { pid = 3; }
        exec.executeSql("INSERT INTO emp3 VALUES (" + Fmt.Int(i) + ", 'Emp" + Fmt.Int(i) + "', " + Fmt.Int(pid) + ")");
        i = i + 1;
    }

    // Query with largest table first in SQL (should be reordered to smallest first)
    r = exec.executeSql("SELECT e.name, p.name, d.name FROM emp3 e INNER JOIN proj3 p ON e.proj_id = p.id INNER JOIN dept3 d ON p.dept_id = d.id");
    checkTrue("3-table INNER JOIN succeeds", r.success);
    checkInt("3-table INNER JOIN row count", r.rowCount(), 20);

    // Verify all departments are present
    r = exec.executeSql("SELECT DISTINCT d.name FROM emp3 e INNER JOIN proj3 p ON e.proj_id = p.id INNER JOIN dept3 d ON p.dept_id = d.id ORDER BY d.name");
    checkTrue("3-table DISTINCT depts succeeds", r.success);
    checkInt("3-table DISTINCT dept count", r.rowCount(), 2);

    //=========================================================================
    // Test 3: Three-table join with different column ordering
    //=========================================================================
    r = exec.executeSql("SELECT d.name, p.name, e.name FROM emp3 e INNER JOIN proj3 p ON e.proj_id = p.id INNER JOIN dept3 d ON p.dept_id = d.id WHERE d.name = 'Engineering' ORDER BY e.id");
    checkTrue("3-table with WHERE succeeds", r.success);
    checkInt("3-table with WHERE row count", r.rowCount(), 15);

    //=========================================================================
    // Test 4: Four-table INNER JOIN
    //=========================================================================
    exec.executeSql("CREATE TABLE region (id INTEGER PRIMARY KEY, name TEXT)");
    exec.executeSql("INSERT INTO region VALUES (1, 'West')");
    exec.executeSql("INSERT INTO region VALUES (2, 'East')");

    exec.executeSql("CREATE TABLE office (id INTEGER PRIMARY KEY, name TEXT, region_id INTEGER, dept_id INTEGER)");
    exec.executeSql("INSERT INTO office VALUES (1, 'SF', 1, 1)");
    exec.executeSql("INSERT INTO office VALUES (2, 'NYC', 2, 1)");
    exec.executeSql("INSERT INTO office VALUES (3, 'LA', 1, 2)");

    exec.executeSql("CREATE TABLE worker (id INTEGER PRIMARY KEY, name TEXT, office_id INTEGER)");
    i = 1;
    while i <= 12 {
        var oid = 1;
        if i > 4 { oid = 2; }
        if i > 8 { oid = 3; }
        exec.executeSql("INSERT INTO worker VALUES (" + Fmt.Int(i) + ", 'W" + Fmt.Int(i) + "', " + Fmt.Int(oid) + ")");
        i = i + 1;
    }

    r = exec.executeSql("SELECT w.name, o.name, d.name, re.name FROM worker w INNER JOIN office o ON w.office_id = o.id INNER JOIN dept3 d ON o.dept_id = d.id INNER JOIN region re ON o.region_id = re.id");
    checkTrue("4-table INNER JOIN succeeds", r.success);
    checkInt("4-table INNER JOIN row count", r.rowCount(), 12);

    //=========================================================================
    // Test 5: Mixed join types (no reordering for non-INNER)
    //=========================================================================
    exec.executeSql("CREATE TABLE a5 (id INTEGER PRIMARY KEY, val TEXT)");
    exec.executeSql("CREATE TABLE b5 (id INTEGER PRIMARY KEY, a_id INTEGER, val TEXT)");
    exec.executeSql("CREATE TABLE c5 (id INTEGER PRIMARY KEY, b_id INTEGER, val TEXT)");

    exec.executeSql("INSERT INTO a5 VALUES (1, 'A1')");
    exec.executeSql("INSERT INTO a5 VALUES (2, 'A2')");
    exec.executeSql("INSERT INTO a5 VALUES (3, 'A3')");

    exec.executeSql("INSERT INTO b5 VALUES (1, 1, 'B1')");
    exec.executeSql("INSERT INTO b5 VALUES (2, 2, 'B2')");

    exec.executeSql("INSERT INTO c5 VALUES (1, 1, 'C1')");

    // LEFT JOIN prevents reordering
    r = exec.executeSql("SELECT a.val, b.val, c.val FROM a5 a LEFT JOIN b5 b ON a.id = b.a_id INNER JOIN c5 c ON b.id = c.b_id");
    checkTrue("Mixed LEFT+INNER JOIN succeeds", r.success);
    // A3 doesn't match B, so LEFT adds NULL for B, which can't match C
    checkInt("Mixed join row count", r.rowCount(), 1);

    //=========================================================================
    // Test 6: Aggregation with 3-table join (tests reordered results are correct)
    //=========================================================================
    r = exec.executeSql("SELECT d.name, COUNT(*) FROM emp3 e INNER JOIN proj3 p ON e.proj_id = p.id INNER JOIN dept3 d ON p.dept_id = d.id GROUP BY d.name ORDER BY d.name");
    checkTrue("3-table with GROUP BY succeeds", r.success);
    checkInt("3-table GROUP BY row count", r.rowCount(), 2);
    if r.rowCount() == 2 {
        check("Dept Engineering count", getVal(r, 0, 1), "15");
        check("Dept Marketing count", getVal(r, 1, 1), "5");
    }

    //=========================================================================
    // Test 7: Self-join (same table twice) with reordering
    //=========================================================================
    exec.executeSql("CREATE TABLE nums (id INTEGER PRIMARY KEY, val INTEGER, ref_id INTEGER)");
    exec.executeSql("INSERT INTO nums VALUES (1, 10, 2)");
    exec.executeSql("INSERT INTO nums VALUES (2, 20, 3)");
    exec.executeSql("INSERT INTO nums VALUES (3, 30, 1)");

    // Self-join: find pairs where n1.ref_id = n2.id
    r = exec.executeSql("SELECT n1.val, n2.val FROM nums n1 INNER JOIN nums n2 ON n1.ref_id = n2.id");
    checkTrue("Self-join succeeds", r.success);
    checkInt("Self-join row count", r.rowCount(), 3);
    // Verify correct data via aggregation (order is non-deterministic in join queries)
    r = exec.executeSql("SELECT SUM(n1.val), SUM(n2.val) FROM nums n1 INNER JOIN nums n2 ON n1.ref_id = n2.id");
    checkTrue("Self-join SUM succeeds", r.success);
    if r.rowCount() == 1 {
        check("Self-join SUM left", getVal(r, 0, 0), "60");
        check("Self-join SUM right", getVal(r, 0, 1), "60");
    }

    //=========================================================================
    // Test 8: Verify correct results with tables written in reverse size order
    //=========================================================================
    // SQL deliberately lists the LARGEST table first
    r = exec.executeSql("SELECT e.name, d.name FROM emp3 e INNER JOIN proj3 p ON e.proj_id = p.id INNER JOIN dept3 d ON p.dept_id = d.id WHERE e.id <= 5 ORDER BY e.id");
    checkTrue("Reverse-order 3-table succeeds", r.success);
    checkInt("Reverse-order row count", r.rowCount(), 5);
    if r.rowCount() == 5 {
        check("Row 0 dept", getVal(r, 0, 1), "Engineering");
        check("Row 4 dept", getVal(r, 4, 1), "Engineering");
    }

    Terminal.Say("");
    Terminal.Say("=== Phase 5 Join Ordering: " + Fmt.Int(passed) + " passed, " + Fmt.Int(failed) + " failed ===");
}
