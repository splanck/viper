// test_native_torture.zia — Torture tests for native codegen
// Part of ViperSQL
// Pushes sqldb + Viper runtime to extremes: multi-JOIN, complex ORDER BY,
// aggregation combos, UPDATE with subqueries, deep expressions, and data integrity.

module test_native_torture;

bind Terminal = Viper.Terminal;
bind Fmt = Viper.Fmt;
bind String = Viper.String;
bind IO = Viper.IO;

bind "../executor";
bind "./test_common";

//=============================================================================
// TORTURE 1: ORDER BY with expressions (not just column names)
//=============================================================================

func torture1_order_by_expressions() {
    Terminal.Say("--- Torture 1: ORDER BY with expressions ---");
    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE items (id INTEGER, price INTEGER, qty INTEGER)");
    exec.executeSql("INSERT INTO items VALUES (1, 10, 5)");    // total=50
    exec.executeSql("INSERT INTO items VALUES (2, 3, 100)");   // total=300
    exec.executeSql("INSERT INTO items VALUES (3, 20, 2)");    // total=40
    exec.executeSql("INSERT INTO items VALUES (4, 7, 7)");     // total=49
    exec.executeSql("INSERT INTO items VALUES (5, 1, 1000)");  // total=1000

    // ORDER BY price * qty DESC
    var r = exec.executeSql("SELECT id, price, qty FROM items ORDER BY price * qty DESC");
    assert(r.rowCount() == 5, "expr order: 5 rows");
    var row0 = r.getRow(0);
    if row0 != null {
        var rr = row0;
        assert(rr.getValue(0).toString() == "5", "expr order: first row id=5 (total=1000)");
    }
    var row1 = r.getRow(1);
    if row1 != null {
        var rr = row1;
        assert(rr.getValue(0).toString() == "2", "expr order: second row id=2 (total=300)");
    }
    var row4 = r.getRow(4);
    if row4 != null {
        var rr = row4;
        assert(rr.getValue(0).toString() == "3", "expr order: last row id=3 (total=40)");
    }
}

//=============================================================================
// TORTURE 2: GROUP BY + HAVING + ORDER BY combo
//=============================================================================

func torture2_groupby_having_orderby() {
    Terminal.Say("--- Torture 2: GROUP BY + HAVING + ORDER BY ---");
    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE sales (product TEXT, region TEXT, amount INTEGER)");
    exec.executeSql("INSERT INTO sales VALUES ('Widget', 'North', 100)");
    exec.executeSql("INSERT INTO sales VALUES ('Widget', 'South', 200)");
    exec.executeSql("INSERT INTO sales VALUES ('Widget', 'East', 50)");
    exec.executeSql("INSERT INTO sales VALUES ('Gadget', 'North', 300)");
    exec.executeSql("INSERT INTO sales VALUES ('Gadget', 'South', 150)");
    exec.executeSql("INSERT INTO sales VALUES ('Doohickey', 'North', 10)");
    exec.executeSql("INSERT INTO sales VALUES ('Doohickey', 'South', 20)");
    exec.executeSql("INSERT INTO sales VALUES ('Thingamajig', 'East', 500)");

    // GROUP BY product, HAVING SUM(amount) > 50, ORDER BY SUM(amount) DESC
    var r = exec.executeSql("SELECT product, SUM(amount) FROM sales GROUP BY product HAVING SUM(amount) > 50 ORDER BY SUM(amount) DESC");
    assert(r.rowCount() == 3, "grp-hav-ord: 3 products with SUM>50");
    var row0 = r.getRow(0);
    if row0 != null {
        var rr = row0;
        assert(rr.getValue(0).toString() == "Thingamajig", "grp-hav-ord: first = Thingamajig (500)");
    }
    var row1 = r.getRow(1);
    if row1 != null {
        var rr = row1;
        assert(rr.getValue(0).toString() == "Gadget", "grp-hav-ord: second = Gadget (450)");
    }
    var row2 = r.getRow(2);
    if row2 != null {
        var rr = row2;
        assert(rr.getValue(0).toString() == "Widget", "grp-hav-ord: third = Widget (350)");
    }
}

//=============================================================================
// TORTURE 3: Multiple JOINs (3-table join)
//=============================================================================

func torture3_multi_join() {
    Terminal.Say("--- Torture 3: 3-table JOIN ---");
    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE authors (id INTEGER, name TEXT)");
    exec.executeSql("CREATE TABLE books (id INTEGER, title TEXT, author_id INTEGER)");
    exec.executeSql("CREATE TABLE reviews (book_id INTEGER, rating INTEGER)");

    exec.executeSql("INSERT INTO authors VALUES (1, 'Alice')");
    exec.executeSql("INSERT INTO authors VALUES (2, 'Bob')");
    exec.executeSql("INSERT INTO authors VALUES (3, 'Carol')");

    exec.executeSql("INSERT INTO books VALUES (10, 'Book_A', 1)");
    exec.executeSql("INSERT INTO books VALUES (11, 'Book_B', 1)");
    exec.executeSql("INSERT INTO books VALUES (12, 'Book_C', 2)");
    exec.executeSql("INSERT INTO books VALUES (13, 'Book_D', 3)");

    exec.executeSql("INSERT INTO reviews VALUES (10, 5)");
    exec.executeSql("INSERT INTO reviews VALUES (10, 4)");
    exec.executeSql("INSERT INTO reviews VALUES (11, 3)");
    exec.executeSql("INSERT INTO reviews VALUES (12, 5)");
    exec.executeSql("INSERT INTO reviews VALUES (12, 5)");
    exec.executeSql("INSERT INTO reviews VALUES (13, 2)");

    // 3-way cross join with WHERE conditions acts as inner join
    var r = exec.executeSql("SELECT authors.name, books.title, reviews.rating FROM authors, books, reviews WHERE authors.id = books.author_id AND books.id = reviews.book_id");
    assert(r.rowCount() == 6, "3-join: 6 rows");

    // Check that Alice appears in results (she has 2 books with reviews)
    var aliceCount = 0;
    var i = 0;
    while i < r.rowCount() {
        var row = r.getRow(i);
        if row != null {
            var rr = row;
            if rr.getValue(0).toString() == "Alice" {
                aliceCount = aliceCount + 1;
            }
        }
        i = i + 1;
    }
    assert(aliceCount == 3, "3-join: Alice has 3 review rows (2 for Book_A + 1 for Book_B)");
}

//=============================================================================
// TORTURE 4: Correlated-style subqueries
//=============================================================================

func torture4_subquery_stress() {
    Terminal.Say("--- Torture 4: Subquery combinations ---");
    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE employees (id INTEGER, name TEXT, dept TEXT, salary INTEGER)");
    exec.executeSql("INSERT INTO employees VALUES (1, 'Alice', 'Engineering', 120000)");
    exec.executeSql("INSERT INTO employees VALUES (2, 'Bob', 'Engineering', 100000)");
    exec.executeSql("INSERT INTO employees VALUES (3, 'Carol', 'Marketing', 90000)");
    exec.executeSql("INSERT INTO employees VALUES (4, 'Dave', 'Marketing', 85000)");
    exec.executeSql("INSERT INTO employees VALUES (5, 'Eve', 'Sales', 95000)");
    exec.executeSql("INSERT INTO employees VALUES (6, 'Frank', 'Sales', 70000)");

    // Subquery in WHERE: employees earning more than the average (93333)
    var r = exec.executeSql("SELECT name, salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees) ORDER BY salary DESC");
    assert(r.rowCount() == 3, "subq avg: 3 above average");
    var row0 = r.getRow(0);
    if row0 != null {
        var rr = row0;
        assert(rr.getValue(0).toString() == "Alice", "subq avg: highest is Alice");
    }

    // Subquery in SELECT: scalar subquery
    var r2 = exec.executeSql("SELECT name, salary, (SELECT MAX(salary) FROM employees) FROM employees WHERE dept = 'Sales'");
    assert(r2.rowCount() == 2, "subq scalar: 2 sales employees");
    var row = r2.getRow(0);
    if row != null {
        var rr = row;
        assert(rr.getValue(2).toString() == "120000", "subq scalar: max salary = 120000");
    }

    // IN subquery
    var r3 = exec.executeSql("SELECT name FROM employees WHERE dept IN (SELECT dept FROM employees WHERE salary > 100000)");
    assert(r3.rowCount() == 2, "subq IN: 2 engineering employees");
}

//=============================================================================
// TORTURE 5: UPDATE/DELETE with complex WHERE
//=============================================================================

func torture5_update_delete_complex() {
    Terminal.Say("--- Torture 5: UPDATE/DELETE with complex conditions ---");
    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE inventory (id INTEGER, product TEXT, stock INTEGER, price INTEGER)");
    var i = 0;
    while i < 100 {
        exec.executeSql("INSERT INTO inventory VALUES (" + Fmt.Int(i) + ", 'prod_" + Fmt.Int(i) + "', " + Fmt.Int(i * 3) + ", " + Fmt.Int(10 + i) + ")");
        i = i + 1;
    }

    // UPDATE with compound WHERE
    exec.executeSql("UPDATE inventory SET stock = 0 WHERE stock < 30 AND price > 15");
    var r = exec.executeSql("SELECT COUNT(*) FROM inventory WHERE stock = 0");
    var row = r.getRow(0);
    if row != null {
        var rr = row;
        // stock < 30 means i*3 < 30, so i < 10
        // price > 15 means 10+i > 15, so i > 5
        // Both: i in {6,7,8,9} = 4 rows, plus i=0 starts with stock=0
        assert(rr.getValue(0).toString() == "5", "upd complex: 5 rows with stock=0");
    }

    // DELETE with OR
    exec.executeSql("DELETE FROM inventory WHERE id > 95 OR id < 3");
    var r2 = exec.executeSql("SELECT COUNT(*) FROM inventory");
    var row2 = r2.getRow(0);
    if row2 != null {
        var rr = row2;
        // Original 100 rows. Delete id>95 (96,97,98,99=4) and id<3 (0,1,2=3) = 7 deleted
        assert(rr.getValue(0).toString() == "93", "del complex: 93 remaining");
    }

    // Verify data integrity after mutations
    var r3 = exec.executeSql("SELECT id, stock FROM inventory WHERE id = 7");
    assert(r3.rowCount() == 1, "integrity: row 7 exists");
    var row3 = r3.getRow(0);
    if row3 != null {
        var rr = row3;
        assert(rr.getValue(1).toString() == "0", "integrity: id=7 stock zeroed by UPDATE");
    }
}

//=============================================================================
// TORTURE 6: Deep string concatenation & long values
//=============================================================================

func torture6_string_pressure() {
    Terminal.Say("--- Torture 6: String pressure ---");
    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE strings (id INTEGER, val TEXT)");

    // Build progressively longer strings
    var i = 0;
    while i < 50 {
        var s = "";
        var j = 0;
        while j <= i {
            s = s + "abcdefghij";
            j = j + 1;
        }
        exec.executeSql("INSERT INTO strings VALUES (" + Fmt.Int(i) + ", '" + s + "')");
        i = i + 1;
    }

    // Row 49 has 500 chars
    var r = exec.executeSql("SELECT val FROM strings WHERE id = 49");
    assert(r.rowCount() == 1, "strpress: row 49 exists");
    var row = r.getRow(0);
    if row != null {
        var rr = row;
        var val = rr.getValue(0).toString();
        assert(String.Length(val) == 500, "strpress: row 49 has 500 chars");
    }

    // LIKE on long strings
    var r2 = exec.executeSql("SELECT COUNT(*) FROM strings WHERE val LIKE '%abcdefghij%'");
    var row2 = r2.getRow(0);
    if row2 != null {
        var rr = row2;
        assert(rr.getValue(0).toString() == "50", "strpress: all 50 match LIKE");
    }

    // ORDER BY on strings
    var r3 = exec.executeSql("SELECT id FROM strings ORDER BY val ASC");
    assert(r3.rowCount() == 50, "strpress: 50 rows sorted");
    // All strings start with "abcdefghij" but shorter ones sort first
    var row3 = r3.getRow(0);
    if row3 != null {
        var rr = row3;
        assert(rr.getValue(0).toString() == "0", "strpress: shortest string first (id=0)");
    }
}

//=============================================================================
// TORTURE 7: Multi-column ORDER BY
//=============================================================================

func torture7_multi_column_sort() {
    Terminal.Say("--- Torture 7: Multi-column ORDER BY ---");
    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE scores (name TEXT, subject TEXT, score INTEGER)");
    exec.executeSql("INSERT INTO scores VALUES ('Alice', 'Math', 90)");
    exec.executeSql("INSERT INTO scores VALUES ('Alice', 'English', 85)");
    exec.executeSql("INSERT INTO scores VALUES ('Alice', 'Science', 95)");
    exec.executeSql("INSERT INTO scores VALUES ('Bob', 'Math', 90)");
    exec.executeSql("INSERT INTO scores VALUES ('Bob', 'English', 92)");
    exec.executeSql("INSERT INTO scores VALUES ('Bob', 'Science', 88)");
    exec.executeSql("INSERT INTO scores VALUES ('Carol', 'Math', 75)");
    exec.executeSql("INSERT INTO scores VALUES ('Carol', 'English', 85)");

    // ORDER BY score DESC, name ASC — ties in score broken by name
    var r = exec.executeSql("SELECT name, subject, score FROM scores ORDER BY score DESC, name ASC");
    assert(r.rowCount() == 8, "multi-sort: 8 rows");

    // First row: score=95 (Alice Science)
    var row0 = r.getRow(0);
    if row0 != null {
        var rr = row0;
        assert(rr.getValue(0).toString() == "Alice", "multi-sort: row0 = Alice");
        assert(rr.getValue(2).toString() == "95", "multi-sort: row0 score = 95");
    }

    // score=90 has Alice Math and Bob Math — Alice should come first (name ASC)
    var row2 = r.getRow(2);
    if row2 != null {
        var rr = row2;
        assert(rr.getValue(0).toString() == "Alice", "multi-sort: score=90 Alice before Bob");
        assert(rr.getValue(2).toString() == "90", "multi-sort: row2 score = 90");
    }
    var row3 = r.getRow(3);
    if row3 != null {
        var rr = row3;
        assert(rr.getValue(0).toString() == "Bob", "multi-sort: score=90 Bob after Alice");
    }
}

//=============================================================================
// TORTURE 8: NULL arithmetic and comparisons
//=============================================================================

func torture8_null_arithmetic() {
    Terminal.Say("--- Torture 8: NULL arithmetic ---");
    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE nullmath (id INTEGER, a INTEGER, b INTEGER)");
    exec.executeSql("INSERT INTO nullmath VALUES (1, 10, 5)");
    exec.executeSql("INSERT INTO nullmath VALUES (2, NULL, 5)");
    exec.executeSql("INSERT INTO nullmath VALUES (3, 10, NULL)");
    exec.executeSql("INSERT INTO nullmath VALUES (4, NULL, NULL)");

    // NULL + anything = NULL
    var r = exec.executeSql("SELECT id, a + b FROM nullmath ORDER BY id ASC");
    assert(r.rowCount() == 4, "null arith: 4 rows");
    var row0 = r.getRow(0);
    if row0 != null {
        var rr = row0;
        assert(rr.getValue(1).toString() == "15", "null arith: 10+5=15");
    }
    var row1 = r.getRow(1);
    if row1 != null {
        var rr = row1;
        assert(rr.getValue(1).kind == SQL_NULL, "null arith: NULL+5=NULL");
    }
    var row2 = r.getRow(2);
    if row2 != null {
        var rr = row2;
        assert(rr.getValue(1).kind == SQL_NULL, "null arith: 10+NULL=NULL");
    }

    // COUNT excludes NULLs, COUNT(*) includes them
    var r2 = exec.executeSql("SELECT COUNT(*), COUNT(a), COUNT(b) FROM nullmath");
    var row = r2.getRow(0);
    if row != null {
        var rr = row;
        assert(rr.getValue(0).toString() == "4", "null count: COUNT(*)=4");
        assert(rr.getValue(1).toString() == "2", "null count: COUNT(a)=2");
        assert(rr.getValue(2).toString() == "2", "null count: COUNT(b)=2");
    }

    // SUM/AVG should ignore NULLs
    var r3 = exec.executeSql("SELECT SUM(a), AVG(a) FROM nullmath");
    var row3 = r3.getRow(0);
    if row3 != null {
        var rr = row3;
        assert(rr.getValue(0).toString() == "20", "null agg: SUM(a)=20 (10+10)");
        assert(rr.getValue(1).toString() == "10", "null agg: AVG(a)=10 (20/2)");
    }
}

//=============================================================================
// TORTURE 9: Rapid schema changes (CREATE, ALTER, DROP cycle)
//=============================================================================

func torture9_schema_churn() {
    Terminal.Say("--- Torture 9: Schema churn ---");
    var exec = new Executor();
    exec.init();

    // Note: Uses inline concatenation instead of var tbl = "churn_" + Fmt.Int(i)
    // to work around native codegen string lifetime bug (BUG-NAT-005)
    var i = 0;
    while i < 30 {
        exec.executeSql("CREATE TABLE churn_" + Fmt.Int(i) + " (id INTEGER, val TEXT)");
        exec.executeSql("INSERT INTO churn_" + Fmt.Int(i) + " VALUES (1, 'test_" + Fmt.Int(i) + "')");
        exec.executeSql("ALTER TABLE churn_" + Fmt.Int(i) + " ADD COLUMN extra INTEGER DEFAULT 0");
        exec.executeSql("INSERT INTO churn_" + Fmt.Int(i) + " VALUES (2, 'more_" + Fmt.Int(i) + "', 42)");

        if i > 0 {
            exec.executeSql("DROP TABLE churn_" + Fmt.Int(i - 1));
        }
        i = i + 1;
    }

    // Only churn_29 should survive
    var r = exec.executeSql("SELECT COUNT(*) FROM churn_29");
    var row = r.getRow(0);
    if row != null {
        var rr = row;
        assert(rr.getValue(0).toString() == "2", "schema churn: churn_29 has 2 rows");
    }

    // Verify the extra column works
    var r2 = exec.executeSql("SELECT extra FROM churn_29 WHERE id = 2");
    assert(r2.rowCount() == 1, "schema churn: found row id=2");
    var row2 = r2.getRow(0);
    if row2 != null {
        var rr = row2;
        assert(rr.getValue(0).toString() == "42", "schema churn: extra=42");
    }

    assert(true, "schema churn: 30 create/alter/drop cycles OK");
}

//=============================================================================
// TORTURE 10: INSERT SELECT (insert from query results)
//=============================================================================

func torture10_copy_via_query() {
    Terminal.Say("--- Torture 10: Copy between tables via query ---");
    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE source (id INTEGER, val TEXT, score INTEGER)");
    exec.executeSql("CREATE TABLE dest (id INTEGER, val TEXT, score INTEGER)");

    var i = 0;
    while i < 50 {
        exec.executeSql("INSERT INTO source VALUES (" + Fmt.Int(i) + ", 'item_" + Fmt.Int(i) + "', " + Fmt.Int(i * 10) + ")");
        i = i + 1;
    }

    // Copy qualifying rows from source to dest using query + insert loop
    var sourceRows = exec.executeSql("SELECT id, val, score FROM source WHERE score >= 200");
    i = 0;
    while i < sourceRows.rowCount() {
        var row = sourceRows.getRow(i);
        if row != null {
            var rr = row;
            exec.executeSql("INSERT INTO dest VALUES (" + rr.getValue(0).toString() + ", '" + rr.getValue(1).toString() + "', " + rr.getValue(2).toString() + ")");
        }
        i = i + 1;
    }
    var r = exec.executeSql("SELECT COUNT(*) FROM dest");
    var row = r.getRow(0);
    if row != null {
        var rr = row;
        // score >= 200 means i*10 >= 200, so i >= 20, that's 30 rows (20..49)
        assert(rr.getValue(0).toString() == "30", "copy: 30 rows copied");
    }

    // Verify specific row
    var r2 = exec.executeSql("SELECT val, score FROM dest WHERE id = 25");
    assert(r2.rowCount() == 1, "copy: row 25 exists in dest");
    var row2 = r2.getRow(0);
    if row2 != null {
        var rr = row2;
        assert(rr.getValue(0).toString() == "item_25", "copy: val=item_25");
        assert(rr.getValue(1).toString() == "250", "copy: score=250");
    }
}

//=============================================================================
// TORTURE 11: SELECT DISTINCT with ORDER BY
//=============================================================================

func torture11_distinct_ordered() {
    Terminal.Say("--- Torture 11: DISTINCT + ORDER BY ---");
    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE dupes (category TEXT, val INTEGER)");
    exec.executeSql("INSERT INTO dupes VALUES ('C', 30)");
    exec.executeSql("INSERT INTO dupes VALUES ('A', 10)");
    exec.executeSql("INSERT INTO dupes VALUES ('B', 20)");
    exec.executeSql("INSERT INTO dupes VALUES ('A', 10)");
    exec.executeSql("INSERT INTO dupes VALUES ('C', 30)");
    exec.executeSql("INSERT INTO dupes VALUES ('B', 20)");
    exec.executeSql("INSERT INTO dupes VALUES ('A', 10)");

    var r = exec.executeSql("SELECT DISTINCT category, val FROM dupes ORDER BY val ASC");
    assert(r.rowCount() == 3, "distinct-ord: 3 unique rows");
    var row0 = r.getRow(0);
    if row0 != null {
        var rr = row0;
        assert(rr.getValue(0).toString() == "A", "distinct-ord: first = A (val=10)");
    }
    var row2 = r.getRow(2);
    if row2 != null {
        var rr = row2;
        assert(rr.getValue(0).toString() == "C", "distinct-ord: last = C (val=30)");
    }
}

//=============================================================================
// TORTURE 12: Cross-join with GROUP BY and aggregation
//=============================================================================

func torture12_join_aggregate() {
    Terminal.Say("--- Torture 12: JOIN + GROUP BY + aggregate ---");
    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE depts (id INTEGER, name TEXT)");
    exec.executeSql("CREATE TABLE emps (id INTEGER, dept_id INTEGER, salary INTEGER)");

    exec.executeSql("INSERT INTO depts VALUES (1, 'Engineering')");
    exec.executeSql("INSERT INTO depts VALUES (2, 'Marketing')");
    exec.executeSql("INSERT INTO depts VALUES (3, 'Sales')");

    exec.executeSql("INSERT INTO emps VALUES (1, 1, 100)");
    exec.executeSql("INSERT INTO emps VALUES (2, 1, 120)");
    exec.executeSql("INSERT INTO emps VALUES (3, 1, 110)");
    exec.executeSql("INSERT INTO emps VALUES (4, 2, 80)");
    exec.executeSql("INSERT INTO emps VALUES (5, 2, 90)");
    exec.executeSql("INSERT INTO emps VALUES (6, 3, 70)");

    // JOIN + GROUP BY dept name + aggregate
    var r = exec.executeSql("SELECT depts.name, COUNT(*), SUM(emps.salary) FROM depts, emps WHERE depts.id = emps.dept_id GROUP BY depts.name ORDER BY SUM(emps.salary) DESC");
    assert(r.rowCount() == 3, "join-agg: 3 departments");
    var row0 = r.getRow(0);
    if row0 != null {
        var rr = row0;
        assert(rr.getValue(0).toString() == "Engineering", "join-agg: Engineering has highest total");
        assert(rr.getValue(1).toString() == "3", "join-agg: Engineering has 3 emps");
        assert(rr.getValue(2).toString() == "330", "join-agg: Engineering total=330");
    }
    var row2 = r.getRow(2);
    if row2 != null {
        var rr = row2;
        assert(rr.getValue(0).toString() == "Sales", "join-agg: Sales has lowest total");
        assert(rr.getValue(2).toString() == "70", "join-agg: Sales total=70");
    }
}

//=============================================================================
// TORTURE 13: Nested CASE in ORDER BY
//=============================================================================

func torture13_case_in_orderby() {
    Terminal.Say("--- Torture 13: CASE in ORDER BY ---");
    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE priorities (id INTEGER, status TEXT, priority INTEGER)");
    exec.executeSql("INSERT INTO priorities VALUES (1, 'critical', 1)");
    exec.executeSql("INSERT INTO priorities VALUES (2, 'low', 4)");
    exec.executeSql("INSERT INTO priorities VALUES (3, 'medium', 3)");
    exec.executeSql("INSERT INTO priorities VALUES (4, 'high', 2)");
    exec.executeSql("INSERT INTO priorities VALUES (5, 'critical', 1)");

    // Order by priority ASC (numeric)
    var r = exec.executeSql("SELECT id, status, priority FROM priorities ORDER BY priority ASC, id ASC");
    assert(r.rowCount() == 5, "case-ord: 5 rows");
    var row0 = r.getRow(0);
    if row0 != null {
        var rr = row0;
        assert(rr.getValue(1).toString() == "critical", "case-ord: first = critical");
        assert(rr.getValue(0).toString() == "1", "case-ord: first id=1");
    }
    var row1 = r.getRow(1);
    if row1 != null {
        var rr = row1;
        assert(rr.getValue(0).toString() == "5", "case-ord: second critical id=5");
    }
    var row4 = r.getRow(4);
    if row4 != null {
        var rr = row4;
        assert(rr.getValue(1).toString() == "low", "case-ord: last = low");
    }
}

//=============================================================================
// TORTURE 14: Large GROUP BY with many groups
//=============================================================================

func torture14_large_groupby() {
    Terminal.Say("--- Torture 14: Large GROUP BY (100 groups) ---");
    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE biggroup (category INTEGER, val INTEGER)");
    var i = 0;
    while i < 500 {
        var cat = i % 100;
        exec.executeSql("INSERT INTO biggroup VALUES (" + Fmt.Int(cat) + ", " + Fmt.Int(i) + ")");
        i = i + 1;
    }

    // 100 groups, each with 5 rows
    var r = exec.executeSql("SELECT category, COUNT(*), SUM(val) FROM biggroup GROUP BY category ORDER BY category ASC");
    assert(r.rowCount() == 100, "big-grp: 100 groups");

    // Check first group (category=0): vals are 0,100,200,300,400 => sum=1000
    var row0 = r.getRow(0);
    if row0 != null {
        var rr = row0;
        assert(rr.getValue(0).toString() == "0", "big-grp: first cat=0");
        assert(rr.getValue(1).toString() == "5", "big-grp: count=5");
        assert(rr.getValue(2).toString() == "1000", "big-grp: sum=1000 for cat 0");
    }

    // Check last group (category=99): vals are 99,199,299,399,499 => sum=1495
    var row99 = r.getRow(99);
    if row99 != null {
        var rr = row99;
        assert(rr.getValue(0).toString() == "99", "big-grp: last cat=99");
        assert(rr.getValue(2).toString() == "1495", "big-grp: sum=1495 for cat 99");
    }
}

//=============================================================================
// TORTURE 15: Multi-table UPDATE verification
//=============================================================================

func torture15_update_verify() {
    Terminal.Say("--- Torture 15: Bulk UPDATE + verification ---");
    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE accounts (id INTEGER, name TEXT, balance INTEGER)");
    var i = 0;
    while i < 200 {
        exec.executeSql("INSERT INTO accounts VALUES (" + Fmt.Int(i) + ", 'user_" + Fmt.Int(i) + "', " + Fmt.Int(1000 + i) + ")");
        i = i + 1;
    }

    // Deduct 100 from balances > 1100
    exec.executeSql("UPDATE accounts SET balance = balance - 100 WHERE balance > 1100");
    // Balances > 1100 means 1000+i > 1100, so i > 100, that's i in {101..199} = 99 rows

    // Verify total balance
    var r = exec.executeSql("SELECT SUM(balance) FROM accounts");
    var row = r.getRow(0);
    if row != null {
        var rr = row;
        // Original total: SUM(1000+i for i in 0..199) = 200*1000 + 199*200/2 = 200000 + 19900 = 219900
        // Deducted: 99 * 100 = 9900
        // Expected: 219900 - 9900 = 210000
        assert(rr.getValue(0).toString() == "210000", "bulk-upd: total balance = 210000");
    }

    // Verify boundary cases
    var r2 = exec.executeSql("SELECT balance FROM accounts WHERE id = 100");
    var row2 = r2.getRow(0);
    if row2 != null {
        var rr = row2;
        // id=100 has original balance 1100, NOT > 1100, so unchanged
        assert(rr.getValue(0).toString() == "1100", "bulk-upd: id=100 unchanged (boundary)");
    }

    var r3 = exec.executeSql("SELECT balance FROM accounts WHERE id = 101");
    var row3 = r3.getRow(0);
    if row3 != null {
        var rr = row3;
        // id=101 has original balance 1101, > 1100, so deducted 100 => 1001
        assert(rr.getValue(0).toString() == "1001", "bulk-upd: id=101 deducted (1101-100=1001)");
    }
}

//=============================================================================
// TORTURE 16: Mixed types in CASE expression
//=============================================================================

func torture16_case_mixed_types() {
    Terminal.Say("--- Torture 16: CASE with mixed types ---");
    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE mixed (id INTEGER, val INTEGER)");
    exec.executeSql("INSERT INTO mixed VALUES (1, 100)");
    exec.executeSql("INSERT INTO mixed VALUES (2, 0)");
    exec.executeSql("INSERT INTO mixed VALUES (3, -50)");
    exec.executeSql("INSERT INTO mixed VALUES (4, NULL)");

    var r = exec.executeSql("SELECT id, CASE WHEN val > 50 THEN 'high' WHEN val > 0 THEN 'low' WHEN val = 0 THEN 'zero' WHEN val IS NULL THEN 'unknown' ELSE 'negative' END FROM mixed ORDER BY id ASC");
    assert(r.rowCount() == 4, "case-mixed: 4 rows");
    var row0 = r.getRow(0);
    if row0 != null {
        var rr = row0;
        assert(rr.getValue(1).toString() == "high", "case-mixed: 100=high");
    }
    var row1 = r.getRow(1);
    if row1 != null {
        var rr = row1;
        assert(rr.getValue(1).toString() == "zero", "case-mixed: 0=zero");
    }
    var row2 = r.getRow(2);
    if row2 != null {
        var rr = row2;
        assert(rr.getValue(1).toString() == "negative", "case-mixed: -50=negative");
    }
    var row3 = r.getRow(3);
    if row3 != null {
        var rr = row3;
        assert(rr.getValue(1).toString() == "unknown", "case-mixed: NULL=unknown");
    }
}

//=============================================================================
// MAIN
//=============================================================================

func main() {
    Terminal.Say("=== Native Torture Tests ===");

    torture1_order_by_expressions();
    torture2_groupby_having_orderby();
    torture3_multi_join();
    torture4_subquery_stress();
    torture5_update_delete_complex();
    torture6_string_pressure();
    torture7_multi_column_sort();
    torture8_null_arithmetic();
    torture9_schema_churn();
    torture10_copy_via_query();
    torture11_distinct_ordered();
    torture12_join_aggregate();
    torture13_case_in_orderby();
    torture14_large_groupby();
    torture15_update_verify();
    torture16_case_mixed_types();

    printResults();
}
