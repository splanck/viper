// test_phase21_pg_catalog.zia â€” Phase 21: pg_catalog Compatibility Tests
// Tests for PostgreSQL-compatible system catalog views.

module test_phase21_pg_catalog;

bind Terminal = Viper.Terminal;
bind String = Viper.String;
bind Fmt = Viper.Fmt;

bind "./test_common";
bind "../executor";
bind "../types";

func main() -> Integer {
    Terminal.Say("=== Phase 21: pg_catalog Compatibility Tests ===");

    var exec = new Executor();
    exec.init();

    // Setup test tables
    exec.executeSql("CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, email TEXT NOT NULL, active BOOLEAN DEFAULT TRUE)");
    exec.executeSql("CREATE TABLE posts (id INTEGER PRIMARY KEY, user_id INTEGER, title TEXT, body TEXT)");
    exec.executeSql("CREATE INDEX idx_email ON users (email)");
    exec.executeSql("CREATE UNIQUE INDEX idx_user_post ON posts (user_id, title)");
    exec.executeSql("INSERT INTO users VALUES (1, 'Alice', 'alice@test.com', TRUE)");
    exec.executeSql("INSERT INTO users VALUES (2, 'Bob', 'bob@test.com', FALSE)");
    exec.executeSql("INSERT INTO posts VALUES (1, 1, 'Hello', 'World')");

    //=========================================================================
    // 1. PG_CLASS
    //=========================================================================
    section("pg_class");

    // Test 1: pg_catalog.pg_class shows tables
    var r1 = exec.executeSql("SELECT * FROM pg_catalog.pg_class");
    assertSuccess(r1, "pg_class query succeeds");
    assert(r1.rows.count() >= 2, "pg_class has at least 2 entries (2 tables)");

    // Test 2: Verify column names
    assertEq(r1.columnNames.get(0), "oid", "Column 0 = oid");
    assertEq(r1.columnNames.get(1), "relname", "Column 1 = relname");
    assertEq(r1.columnNames.get(2), "relnamespace", "Column 2 = relnamespace");
    assertEq(r1.columnNames.get(3), "relkind", "Column 3 = relkind");

    // Test 3: Also accessible without pg_catalog prefix
    var r2 = exec.executeSql("SELECT * FROM pg_class");
    assertSuccess(r2, "pg_class without prefix succeeds");
    assertEqInt(r2.rows.count(), r1.rows.count(), "Same row count with/without prefix");

    // Test 4: Check relkind values
    // Should have 'r' for tables and 'i' for indexes
    var hasTable = false;
    var hasIndex = false;
    var ri = 0;
    while ri < r1.rows.count() {
        var row = r1.rows.get(ri);
        var relkind = row.values.get(3).textValue;
        if relkind == "r" { hasTable = true; }
        if relkind == "i" { hasIndex = true; }
        ri = ri + 1;
    }
    assert(hasTable == true, "pg_class contains table entries (relkind=r)");
    assert(hasIndex == true, "pg_class contains index entries (relkind=i)");

    //=========================================================================
    // 2. PG_ATTRIBUTE
    //=========================================================================
    section("pg_attribute");

    // Test 5: pg_attribute shows columns
    var r3 = exec.executeSql("SELECT * FROM pg_attribute");
    assertSuccess(r3, "pg_attribute query succeeds");
    assert(r3.rows.count() >= 7, "pg_attribute has at least 7 columns (4+3 across tables)");

    // Test 6: Verify column names
    assertEq(r3.columnNames.get(0), "attrelid", "Column 0 = attrelid");
    assertEq(r3.columnNames.get(1), "attname", "Column 1 = attname");
    assertEq(r3.columnNames.get(2), "atttypid", "Column 2 = atttypid");
    assertEq(r3.columnNames.get(3), "attnum", "Column 3 = attnum");
    assertEq(r3.columnNames.get(4), "attnotnull", "Column 4 = attnotnull");

    // Test 7: Check that NOT NULL columns show correctly
    var foundNotNull = false;
    var ai = 0;
    while ai < r3.rows.count() {
        var row = r3.rows.get(ai);
        if row.values.get(1).textValue == "email" && row.values.get(4).textValue == "t" {
            foundNotNull = true;
        }
        ai = ai + 1;
    }
    assert(foundNotNull == true, "email column shows attnotnull=t");

    //=========================================================================
    // 3. PG_TYPE
    //=========================================================================
    section("pg_type");

    // Test 8: pg_type shows data types
    var r4 = exec.executeSql("SELECT * FROM pg_type");
    assertSuccess(r4, "pg_type query succeeds");
    assert(r4.rows.count() >= 7, "pg_type has at least 7 type entries");

    // Test 9: Verify column names
    assertEq(r4.columnNames.get(0), "oid", "Column 0 = oid");
    assertEq(r4.columnNames.get(1), "typname", "Column 1 = typname");

    // Test 10: Check for known types
    var hasInt4 = false;
    var hasText = false;
    var hasBool = false;
    var tyi = 0;
    while tyi < r4.rows.count() {
        var typname = r4.rows.get(tyi).values.get(1).textValue;
        if typname == "int4" { hasInt4 = true; }
        if typname == "text" { hasText = true; }
        if typname == "bool" { hasBool = true; }
        tyi = tyi + 1;
    }
    assert(hasInt4 == true, "pg_type contains int4");
    assert(hasText == true, "pg_type contains text");
    assert(hasBool == true, "pg_type contains bool");

    //=========================================================================
    // 4. PG_NAMESPACE
    //=========================================================================
    section("pg_namespace");

    // Test 11: pg_namespace shows schemas
    var r5 = exec.executeSql("SELECT * FROM pg_namespace");
    assertSuccess(r5, "pg_namespace query succeeds");
    assert(r5.rows.count() >= 2, "pg_namespace has at least 2 schemas");

    // Test 12: Check for pg_catalog and public
    var hasPgCatalog = false;
    var hasPublic = false;
    var ni = 0;
    while ni < r5.rows.count() {
        var nspname = r5.rows.get(ni).values.get(1).textValue;
        if nspname == "pg_catalog" { hasPgCatalog = true; }
        if nspname == "public" { hasPublic = true; }
        ni = ni + 1;
    }
    assert(hasPgCatalog == true, "pg_namespace contains pg_catalog");
    assert(hasPublic == true, "pg_namespace contains public");

    //=========================================================================
    // 5. PG_INDEX
    //=========================================================================
    section("pg_index");

    // Test 13: pg_index shows indexes
    var r6 = exec.executeSql("SELECT * FROM pg_index");
    assertSuccess(r6, "pg_index query succeeds");
    assert(r6.rows.count() >= 2, "pg_index has at least 2 indexes");

    // Test 14: Verify column names
    assertEq(r6.columnNames.get(0), "indexrelid", "Column 0 = indexrelid");
    assertEq(r6.columnNames.get(1), "indrelid", "Column 1 = indrelid");
    assertEq(r6.columnNames.get(2), "indnatts", "Column 2 = indnatts");
    assertEq(r6.columnNames.get(3), "indisunique", "Column 3 = indisunique");

    // Test 15: Check unique index flag
    var hasUnique = false;
    var hasNonUnique = false;
    var ii = 0;
    while ii < r6.rows.count() {
        var row = r6.rows.get(ii);
        if row.values.get(3).textValue == "t" { hasUnique = true; }
        if row.values.get(3).textValue == "f" { hasNonUnique = true; }
        ii = ii + 1;
    }
    assert(hasUnique == true, "pg_index has unique index");
    assert(hasNonUnique == true, "pg_index has non-unique index");

    // Test 16: Check composite index column count
    var foundComposite = false;
    ii = 0;
    while ii < r6.rows.count() {
        var row = r6.rows.get(ii);
        if row.values.get(2).intValue == 2 {
            foundComposite = true;
        }
        ii = ii + 1;
    }
    assert(foundComposite == true, "pg_index shows composite index with indnatts=2");

    //=========================================================================
    // 6. PG_DATABASE
    //=========================================================================
    section("pg_database");

    // Test 17: pg_database shows databases
    var r7 = exec.executeSql("SELECT * FROM pg_database");
    assertSuccess(r7, "pg_database query succeeds");
    assert(r7.rows.count() >= 1, "pg_database has at least 1 database");

    // Test 18: Check for 'main' database
    var hasMain = false;
    var dbi = 0;
    while dbi < r7.rows.count() {
        if r7.rows.get(dbi).values.get(1).textValue == "main" {
            hasMain = true;
        }
        dbi = dbi + 1;
    }
    assert(hasMain == true, "pg_database contains 'main' database");

    // Test 19: Verify column names
    assertEq(r7.columnNames.get(0), "oid", "Column 0 = oid");
    assertEq(r7.columnNames.get(1), "datname", "Column 1 = datname");

    //=========================================================================
    // 7. PG_SETTINGS
    //=========================================================================
    section("pg_settings");

    // Test 20: pg_settings shows configuration
    var r8 = exec.executeSql("SELECT * FROM pg_settings");
    assertSuccess(r8, "pg_settings query succeeds");
    assert(r8.rows.count() >= 5, "pg_settings has at least 5 settings");

    // Test 21: Check for server_version
    var hasVersion = false;
    var si = 0;
    while si < r8.rows.count() {
        if r8.rows.get(si).values.get(0).textValue == "server_version" {
            hasVersion = true;
        }
        si = si + 1;
    }
    assert(hasVersion == true, "pg_settings has server_version");

    //=========================================================================
    // 8. PG_PROC (empty since functions are session-scoped)
    //=========================================================================
    section("pg_proc");

    // Test 22: pg_proc returns empty result
    var r9 = exec.executeSql("SELECT * FROM pg_proc");
    assertSuccess(r9, "pg_proc query succeeds");

    //=========================================================================
    // 9. OID STABILITY
    //=========================================================================
    section("OID Consistency");

    // Test 23: OIDs are consistent between views
    // pg_class table OID should match pg_attribute attrelid
    var classOids: List[Integer] = [];
    var ci2 = 0;
    while ci2 < r1.rows.count() {
        var row = r1.rows.get(ci2);
        if row.values.get(3).textValue == "r" {
            classOids.add(row.values.get(0).intValue);
        }
        ci2 = ci2 + 1;
    }
    // Check that pg_attribute attrelid values match pg_class oids
    var allMatch = true;
    var ati = 0;
    while ati < r3.rows.count() {
        var attrelid = r3.rows.get(ati).values.get(0).intValue;
        var found = false;
        var cli = 0;
        while cli < classOids.count() {
            if classOids.get(cli) == attrelid {
                found = true;
                cli = classOids.count();
            }
            cli = cli + 1;
        }
        if found == false {
            allMatch = false;
        }
        ati = ati + 1;
    }
    assert(allMatch == true, "pg_attribute attrelid values match pg_class OIDs");

    // Test 24: pg_index indexrelid matches pg_class index OIDs
    var indexOids: List[Integer] = [];
    ci2 = 0;
    while ci2 < r1.rows.count() {
        var row = r1.rows.get(ci2);
        if row.values.get(3).textValue == "i" {
            indexOids.add(row.values.get(0).intValue);
        }
        ci2 = ci2 + 1;
    }
    var indexMatch = true;
    var ixi = 0;
    while ixi < r6.rows.count() {
        var indexrelid = r6.rows.get(ixi).values.get(0).intValue;
        var found = false;
        var cli = 0;
        while cli < indexOids.count() {
            if indexOids.get(cli) == indexrelid {
                found = true;
                cli = indexOids.count();
            }
            cli = cli + 1;
        }
        if found == false {
            indexMatch = false;
        }
        ixi = ixi + 1;
    }
    assert(indexMatch == true, "pg_index indexrelid values match pg_class index OIDs");

    //=========================================================================
    // 10. VIEWS WITH ADDITIONAL DATABASES
    //=========================================================================
    section("Multi-database pg_catalog");

    exec.executeSql("CREATE DATABASE testdb");

    // Test 25: pg_database shows new database
    var r10 = exec.executeSql("SELECT * FROM pg_database");
    assertSuccess(r10, "pg_database with 2 databases succeeds");
    assert(r10.rows.count() >= 2, "pg_database now has 2+ databases");

    // Test 26: pg_namespace shows public for each database
    var r11 = exec.executeSql("SELECT * FROM pg_namespace");
    assertSuccess(r11, "pg_namespace with 2 databases succeeds");

    //=========================================================================
    // 11. VIEWS AFTER SCHEMA CHANGES
    //=========================================================================
    section("Schema Change Reflection");

    // Switch back to main and create a new table
    exec.executeSql("USE main");
    exec.executeSql("CREATE TABLE settings (skey TEXT PRIMARY KEY, svalue TEXT)");

    // Test 27: pg_class reflects new table
    var r12 = exec.executeSql("SELECT * FROM pg_class");
    assertSuccess(r12, "pg_class after CREATE TABLE succeeds");
    var foundSettings = false;
    var si2 = 0;
    while si2 < r12.rows.count() {
        if r12.rows.get(si2).values.get(1).textValue == "settings" {
            foundSettings = true;
        }
        si2 = si2 + 1;
    }
    assert(foundSettings == true, "pg_class shows new 'settings' table");

    // Test 28: pg_attribute reflects new columns
    var r13 = exec.executeSql("SELECT * FROM pg_attribute");
    assertSuccess(r13, "pg_attribute after CREATE TABLE succeeds");
    var foundSKey = false;
    var foundSValue = false;
    var ai2 = 0;
    while ai2 < r13.rows.count() {
        var attname = r13.rows.get(ai2).values.get(1).textValue;
        if attname == "skey" { foundSKey = true; }
        if attname == "svalue" { foundSValue = true; }
        ai2 = ai2 + 1;
    }
    assert(foundSKey == true, "pg_attribute shows 'skey' column");
    assert(foundSValue == true, "pg_attribute shows 'svalue' column");

    //=========================================================================
    // RESULTS
    //=========================================================================
    printResults();
    return 0;
}
