// test_multiuser.zia - Tests for Phase 7: Multi-User Concurrency Control
// Part of ViperSQL - Production Database Server
//
// Tests table-level locking (S/X), session isolation, and lock lifecycle.
// Uses multiple Executor instances sharing one DatabaseServer (simulating
// concurrent connections without requiring threads).

module test_multiuser;

bind Terminal = Viper.Terminal;
bind Fmt = Viper.Fmt;

bind "../executor";
bind "../server";
bind "../session";
bind "../storage/txn";
bind "./test_common";

//=============================================================================
// HELPER: create two sessions sharing a DatabaseServer
//=============================================================================

func makeSharedServer() -> DatabaseServer {
    var server = new DatabaseServer();
    server.init();
    return server;
}

func makeSession(server: DatabaseServer, id: Integer) -> Session {
    var s = new Session();
    s.initWithServer(id, "test-host", server);
    return s;
}

//=============================================================================
// TABLE LOCK MANAGER UNIT TESTS
//=============================================================================

func testLockManagerBasic() {
    Terminal.Say("Testing TableLockManager basic operations...");
    var lm = new TableLockManager();
    lm.init();

    // Session 1 acquires shared lock
    var ok = lm.tryAcquireTableLock(1, "users", LOCK_SHARED);
    assertTrue(ok, "Session 1 should acquire S lock on 'users'");
    assertTrue(lm.lockCount() == 1, "Lock count should be 1");
    assertTrue(lm.sessionLockCount(1) == 1, "Session 1 should hold 1 lock");

    // Session 2 acquires shared lock on same table (S+S compatible)
    ok = lm.tryAcquireTableLock(2, "users", LOCK_SHARED);
    assertTrue(ok, "Session 2 should acquire S lock on 'users' (S+S compatible)");
    assertTrue(lm.lockCount() == 2, "Lock count should be 2");

    // Release all session 1 locks
    lm.releaseAllLocks(1);
    assertTrue(lm.lockCount() == 1, "Lock count should be 1 after session 1 release");
    assertTrue(lm.sessionLockCount(1) == 0, "Session 1 should hold 0 locks");
    assertTrue(lm.sessionLockCount(2) == 1, "Session 2 should still hold 1 lock");

    // Release all session 2 locks
    lm.releaseAllLocks(2);
    assertTrue(lm.lockCount() == 0, "Lock count should be 0 after all releases");
}

func testLockConflicts() {
    Terminal.Say("Testing lock conflicts...");
    var lm = new TableLockManager();
    lm.init();

    // Session 1 acquires exclusive lock
    var ok = lm.tryAcquireTableLock(1, "orders", LOCK_EXCLUSIVE);
    assertTrue(ok, "Session 1 should acquire X lock on 'orders'");

    // Session 2 cannot acquire shared lock (X blocks S)
    ok = lm.tryAcquireTableLock(2, "orders", LOCK_SHARED);
    assertFalse(ok, "Session 2 S lock should be blocked by session 1 X lock");

    // Session 2 cannot acquire exclusive lock (X blocks X)
    ok = lm.tryAcquireTableLock(2, "orders", LOCK_EXCLUSIVE);
    assertFalse(ok, "Session 2 X lock should be blocked by session 1 X lock");

    // Session 2 can lock a different table
    ok = lm.tryAcquireTableLock(2, "products", LOCK_EXCLUSIVE);
    assertTrue(ok, "Session 2 should acquire X lock on different table 'products'");

    // Session 1 releases → Session 2 can now lock 'orders'
    lm.releaseAllLocks(1);
    ok = lm.tryAcquireTableLock(2, "orders", LOCK_SHARED);
    assertTrue(ok, "Session 2 should acquire S lock after session 1 release");

    lm.releaseAllLocks(2);
}

func testSharedExclusiveConflict() {
    Terminal.Say("Testing S blocks X...");
    var lm = new TableLockManager();
    lm.init();

    // Session 1 acquires shared lock
    lm.tryAcquireTableLock(1, "data", LOCK_SHARED);
    // Session 2 acquires shared lock (S+S compatible)
    var ok = lm.tryAcquireTableLock(2, "data", LOCK_SHARED);
    assertTrue(ok, "S+S should be compatible");

    // Session 3 cannot acquire exclusive lock (S blocks X)
    ok = lm.tryAcquireTableLock(3, "data", LOCK_EXCLUSIVE);
    assertFalse(ok, "X should be blocked by existing S locks");

    // Release all shared locks → X should succeed
    lm.releaseAllLocks(1);
    lm.releaseAllLocks(2);
    ok = lm.tryAcquireTableLock(3, "data", LOCK_EXCLUSIVE);
    assertTrue(ok, "X should succeed after S locks released");

    lm.releaseAllLocks(3);
}

func testLockReentry() {
    Terminal.Say("Testing lock re-entry (same session)...");
    var lm = new TableLockManager();
    lm.init();

    // Session 1 acquires S lock
    lm.tryAcquireTableLock(1, "t", LOCK_SHARED);

    // Same session acquires S lock again (should succeed — already held)
    var ok = lm.tryAcquireTableLock(1, "t", LOCK_SHARED);
    assertTrue(ok, "Same session S re-entry should succeed");

    // Same session acquires X lock (S already held, X > S so not "adequate")
    // This won't succeed because the existing S is mode 1, X is mode 2, and 1 < 2
    // Lock upgrade is not implemented — this will add a new lock entry
    // But since same session, it won't conflict with itself
    ok = lm.tryAcquireTableLock(1, "t", LOCK_EXCLUSIVE);
    assertTrue(ok, "Same session X after S should succeed (no self-conflict)");

    lm.releaseAllLocks(1);
}

func testReleaseSpecificLock() {
    Terminal.Say("Testing releaseTableLock...");
    var lm = new TableLockManager();
    lm.init();

    lm.tryAcquireTableLock(1, "a", LOCK_SHARED);
    lm.tryAcquireTableLock(1, "b", LOCK_EXCLUSIVE);
    lm.tryAcquireTableLock(1, "c", LOCK_SHARED);
    assertTrue(lm.sessionLockCount(1) == 3, "Should hold 3 locks");

    // Release only lock on 'b'
    lm.releaseTableLock(1, "b");
    assertTrue(lm.sessionLockCount(1) == 2, "Should hold 2 locks after releasing 'b'");

    // Another session should now be able to lock 'b'
    var ok = lm.tryAcquireTableLock(2, "b", LOCK_EXCLUSIVE);
    assertTrue(ok, "Session 2 should acquire X on 'b' after session 1 released it");

    lm.releaseAllLocks(1);
    lm.releaseAllLocks(2);
}

//=============================================================================
// SESSION-LEVEL INTEGRATION TESTS
//=============================================================================

func testTwoReadersNonTransactional() {
    Terminal.Say("Testing two sessions reading same table (no transactions)...");
    var server = makeSharedServer();
    var s1 = makeSession(server, 1);
    var s2 = makeSession(server, 2);

    // Setup: create a table with data
    s1.executeSql("CREATE TABLE employees (id INTEGER, name TEXT)");
    s1.executeSql("INSERT INTO employees VALUES (1, 'Alice')");
    s1.executeSql("INSERT INTO employees VALUES (2, 'Bob')");

    // Both sessions read (outside transactions — locks acquired and released per statement)
    var r1 = s1.executeSql("SELECT * FROM employees");
    assertTrue(r1.success, "Session 1 SELECT should succeed");
    assertTrue(r1.rowCount() == 2, "Session 1 should see 2 rows");

    var r2 = s2.executeSql("SELECT * FROM employees");
    assertTrue(r2.success, "Session 2 SELECT should succeed");
    assertTrue(r2.rowCount() == 2, "Session 2 should see 2 rows");
}

func testTwoWritersDifferentTables() {
    Terminal.Say("Testing two sessions writing different tables...");
    var server = makeSharedServer();
    var s1 = makeSession(server, 1);
    var s2 = makeSession(server, 2);

    s1.executeSql("CREATE TABLE t1 (id INTEGER)");
    s2.executeSql("CREATE TABLE t2 (id INTEGER)");

    // Both sessions write to different tables (no conflict)
    var r1 = s1.executeSql("INSERT INTO t1 VALUES (1)");
    assertTrue(r1.success, "Session 1 INSERT into t1 should succeed");

    var r2 = s2.executeSql("INSERT INTO t2 VALUES (2)");
    assertTrue(r2.success, "Session 2 INSERT into t2 should succeed");

    // Verify data isolation
    r1 = s1.executeSql("SELECT * FROM t1");
    assertTrue(r1.rowCount() == 1, "t1 should have 1 row");

    r2 = s2.executeSql("SELECT * FROM t2");
    assertTrue(r2.rowCount() == 1, "t2 should have 1 row");
}

func testTransactionHoldsLocks() {
    Terminal.Say("Testing that transactions hold locks until commit...");
    var server = makeSharedServer();
    var s1 = makeSession(server, 1);

    s1.executeSql("CREATE TABLE locked_tbl (id INTEGER)");

    // Start a transaction and INSERT (acquires X lock, held until COMMIT)
    s1.executeSql("BEGIN");
    s1.executeSql("INSERT INTO locked_tbl VALUES (1)");

    // Verify the lock is held
    var lockCount = server.tableLockMgr.sessionLockCount(1);
    assertTrue(lockCount > 0, "Session 1 should hold locks during transaction");

    // COMMIT releases locks
    s1.executeSql("COMMIT");
    lockCount = server.tableLockMgr.sessionLockCount(1);
    assertTrue(lockCount == 0, "Session 1 should hold 0 locks after COMMIT");
}

func testRollbackReleasesLocks() {
    Terminal.Say("Testing that ROLLBACK releases locks...");
    var server = makeSharedServer();
    var s1 = makeSession(server, 1);

    s1.executeSql("CREATE TABLE rollback_tbl (id INTEGER, val TEXT)");
    s1.executeSql("INSERT INTO rollback_tbl VALUES (1, 'original')");

    // Start transaction, modify data
    s1.executeSql("BEGIN");
    s1.executeSql("UPDATE rollback_tbl SET val = 'modified' WHERE id = 1");

    var lockCount = server.tableLockMgr.sessionLockCount(1);
    assertTrue(lockCount > 0, "Session 1 should hold locks during transaction");

    // ROLLBACK releases locks and undoes changes
    s1.executeSql("ROLLBACK");
    lockCount = server.tableLockMgr.sessionLockCount(1);
    assertTrue(lockCount == 0, "Session 1 should hold 0 locks after ROLLBACK");

    // Data should be unchanged
    var result = s1.executeSql("SELECT val FROM rollback_tbl WHERE id = 1");
    assertTrue(result.rowCount() == 1, "Should have 1 row");
    var row = result.getRow(0);
    if row != null {
        var r = row;
        assertTrue(r.getValue(0).textValue == "original", "Value should be 'original' after ROLLBACK");
    }
}

func testWriteConflictDetection() {
    Terminal.Say("Testing write conflict with TableLockManager directly...");
    var lm = new TableLockManager();
    lm.init();

    // Session 1 holds exclusive lock (simulating a transaction with INSERT)
    lm.tryAcquireTableLock(1, "conflict_tbl", LOCK_EXCLUSIVE);

    // Session 2 tries to read (S) — blocked by X
    var ok = lm.tryAcquireTableLock(2, "conflict_tbl", LOCK_SHARED);
    assertFalse(ok, "S lock should be blocked by X (write conflict)");

    // Session 2 tries to write (X) — blocked by X
    ok = lm.tryAcquireTableLock(2, "conflict_tbl", LOCK_EXCLUSIVE);
    assertFalse(ok, "X lock should be blocked by X (write conflict)");

    // Session 1 releases (simulating COMMIT)
    lm.releaseAllLocks(1);

    // Now session 2 succeeds
    ok = lm.tryAcquireTableLock(2, "conflict_tbl", LOCK_SHARED);
    assertTrue(ok, "S lock should succeed after X released");

    lm.releaseAllLocks(2);
}

func testNonTransactionalLockRelease() {
    Terminal.Say("Testing that non-transactional statements release locks...");
    var server = makeSharedServer();
    var s1 = makeSession(server, 1);

    s1.executeSql("CREATE TABLE auto_tbl (id INTEGER)");
    // After CREATE (non-transactional), locks should be released
    var lockCount = server.tableLockMgr.sessionLockCount(1);
    assertTrue(lockCount == 0, "Locks should be released after non-transactional CREATE");

    s1.executeSql("INSERT INTO auto_tbl VALUES (1)");
    lockCount = server.tableLockMgr.sessionLockCount(1);
    assertTrue(lockCount == 0, "Locks should be released after non-transactional INSERT");

    s1.executeSql("SELECT * FROM auto_tbl");
    lockCount = server.tableLockMgr.sessionLockCount(1);
    assertTrue(lockCount == 0, "Locks should be released after non-transactional SELECT");

    s1.executeSql("UPDATE auto_tbl SET id = 2 WHERE id = 1");
    lockCount = server.tableLockMgr.sessionLockCount(1);
    assertTrue(lockCount == 0, "Locks should be released after non-transactional UPDATE");

    s1.executeSql("DELETE FROM auto_tbl WHERE id = 2");
    lockCount = server.tableLockMgr.sessionLockCount(1);
    assertTrue(lockCount == 0, "Locks should be released after non-transactional DELETE");
}

func testSessionIsolation() {
    Terminal.Say("Testing per-session database context isolation...");
    var server = makeSharedServer();
    var s1 = makeSession(server, 1);
    var s2 = makeSession(server, 2);

    // Both start on 'main' database
    assertTrue(s1.executor.currentDbName == "main", "Session 1 should start on 'main'");
    assertTrue(s2.executor.currentDbName == "main", "Session 2 should start on 'main'");

    // Session 1 creates and switches to a new database
    s1.executeSql("CREATE DATABASE session_db");
    s1.executeSql("USE session_db");

    // Session 2 should still be on 'main'
    assertTrue(s1.executor.currentDbName == "session_db", "Session 1 should be on 'session_db'");
    assertTrue(s2.executor.currentDbName == "main", "Session 2 should still be on 'main'");
}

func testMultipleTablesLocking() {
    Terminal.Say("Testing locks on multiple tables (JOIN scenario)...");
    var server = makeSharedServer();
    var s1 = makeSession(server, 1);

    s1.executeSql("CREATE TABLE orders (id INTEGER, customer_id INTEGER)");
    s1.executeSql("CREATE TABLE customers (id INTEGER, name TEXT)");
    s1.executeSql("INSERT INTO customers VALUES (1, 'Alice')");
    s1.executeSql("INSERT INTO orders VALUES (100, 1)");

    // JOIN query acquires shared locks on both tables
    s1.executeSql("BEGIN");
    var result = s1.executeSql("SELECT orders.id, customers.name FROM orders INNER JOIN customers ON orders.customer_id = customers.id");
    assertTrue(result.success, "JOIN query should succeed");
    assertTrue(result.rowCount() == 1, "JOIN should return 1 row");

    // Both tables should be locked during transaction
    var lockCount = server.tableLockMgr.sessionLockCount(1);
    assertTrue(lockCount >= 2, "Session should hold locks on both joined tables");

    s1.executeSql("COMMIT");
    lockCount = server.tableLockMgr.sessionLockCount(1);
    assertTrue(lockCount == 0, "All locks released after COMMIT");
}

func testDDLExclusiveLocks() {
    Terminal.Say("Testing DDL operations acquire exclusive locks...");
    var lm = new TableLockManager();
    lm.init();

    // Simulate: session 1 holds S lock (reading), session 2 tries ALTER TABLE
    lm.tryAcquireTableLock(1, "schema_tbl", LOCK_SHARED);

    // ALTER TABLE needs X lock → should be blocked
    var ok = lm.tryAcquireTableLock(2, "schema_tbl", LOCK_EXCLUSIVE);
    assertFalse(ok, "DDL X lock should be blocked by reader S lock");

    lm.releaseAllLocks(1);

    // Now DDL succeeds
    ok = lm.tryAcquireTableLock(2, "schema_tbl", LOCK_EXCLUSIVE);
    assertTrue(ok, "DDL X lock should succeed after reader released");

    lm.releaseAllLocks(2);
}

func testConcurrentReadsAndWrites() {
    Terminal.Say("Testing sequential read/write with proper locking...");
    var server = makeSharedServer();
    var s1 = makeSession(server, 1);
    var s2 = makeSession(server, 2);

    // Setup
    s1.executeSql("CREATE TABLE counter (id INTEGER, val INTEGER)");
    s1.executeSql("INSERT INTO counter VALUES (1, 0)");

    // Session 1 increments (non-transactional: acquire X, execute, release)
    s1.executeSql("UPDATE counter SET val = 1 WHERE id = 1");

    // Session 2 reads (non-transactional: acquire S, execute, release)
    var result = s2.executeSql("SELECT val FROM counter WHERE id = 1");
    assertTrue(result.success, "Session 2 read should succeed");
    assertTrue(result.rowCount() == 1, "Should see 1 row");
    var row = result.getRow(0);
    if row != null {
        var r = row;
        assertTrue(r.getValue(0).intValue == 1, "Should see updated value 1");
    }

    // Session 2 increments
    s2.executeSql("UPDATE counter SET val = 2 WHERE id = 1");

    // Session 1 reads the latest
    result = s1.executeSql("SELECT val FROM counter WHERE id = 1");
    row = result.getRow(0);
    if row != null {
        var r = row;
        assertTrue(r.getValue(0).intValue == 2, "Session 1 should see value 2");
    }
}

//=============================================================================
// MAIN
//=============================================================================

func start() {
    Terminal.Say("=== Phase 7: Multi-User Concurrency Tests ===");
    Terminal.Say("");

    // TableLockManager unit tests
    testLockManagerBasic();
    testLockConflicts();
    testSharedExclusiveConflict();
    testLockReentry();
    testReleaseSpecificLock();
    testWriteConflictDetection();
    testDDLExclusiveLocks();

    // Session-level integration tests
    testTwoReadersNonTransactional();
    testTwoWritersDifferentTables();
    testTransactionHoldsLocks();
    testRollbackReleasesLocks();
    testNonTransactionalLockRelease();
    testSessionIsolation();
    testMultipleTablesLocking();
    testConcurrentReadsAndWrites();

    printResults();
}
