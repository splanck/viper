// test_phase32_cursors.zia — Phase 32: Cursors (DECLARE/FETCH/CLOSE)
// Tests for SQL cursor support.

module test_phase32_cursors;

bind Terminal = Viper.Terminal;
bind String = Viper.String;
bind Fmt = Viper.Fmt;

bind "./test_common";
bind "../executor";
bind "../types";

//=========================================================================
// DECLARE CURSOR
//=========================================================================

func testDeclareCursor() {
    section("DECLARE CURSOR");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE cur_t (id INTEGER, name TEXT, score INTEGER)");
    exec.executeSql("INSERT INTO cur_t VALUES (1, 'Alice', 80)");
    exec.executeSql("INSERT INTO cur_t VALUES (2, 'Bob', 90)");
    exec.executeSql("INSERT INTO cur_t VALUES (3, 'Carol', 70)");

    var r1 = exec.executeSql("DECLARE my_cur CURSOR FOR SELECT * FROM cur_t ORDER BY id");
    assertSuccess(r1, "DECLARE cursor succeeds");
    assertTrue(stringContains(r1.message, "DECLARE"), "DECLARE message");
}

func testDeclareDuplicate() {
    section("DECLARE duplicate cursor");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE dup_cur_t (id INTEGER)");

    exec.executeSql("DECLARE c1 CURSOR FOR SELECT * FROM dup_cur_t");
    var r1 = exec.executeSql("DECLARE c1 CURSOR FOR SELECT * FROM dup_cur_t");
    assertTrue(r1.success == false, "Duplicate cursor fails");
}

//=========================================================================
// FETCH
//=========================================================================

func testFetchNext() {
    section("FETCH NEXT");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE fetch_t (id INTEGER, name TEXT)");
    exec.executeSql("INSERT INTO fetch_t VALUES (1, 'Alice')");
    exec.executeSql("INSERT INTO fetch_t VALUES (2, 'Bob')");
    exec.executeSql("INSERT INTO fetch_t VALUES (3, 'Carol')");

    exec.executeSql("DECLARE fc CURSOR FOR SELECT * FROM fetch_t ORDER BY id");

    var r1 = exec.executeSql("FETCH NEXT FROM fc");
    assertEqInt(r1.rows.count(), 1, "FETCH NEXT returns 1 row");
    assertEq(val(r1, 0, 1), "Alice", "First row is Alice");

    var r2 = exec.executeSql("FETCH NEXT FROM fc");
    assertEq(val(r2, 0, 1), "Bob", "Second row is Bob");

    var r3 = exec.executeSql("FETCH NEXT FROM fc");
    assertEq(val(r3, 0, 1), "Carol", "Third row is Carol");

    // Past end — no rows
    var r4 = exec.executeSql("FETCH NEXT FROM fc");
    assertEqInt(r4.rows.count(), 0, "Past end returns 0 rows");
}

func testFetchForwardAll() {
    section("FETCH ALL");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE fall_t (id INTEGER, name TEXT)");
    exec.executeSql("INSERT INTO fall_t VALUES (1, 'Alice')");
    exec.executeSql("INSERT INTO fall_t VALUES (2, 'Bob')");
    exec.executeSql("INSERT INTO fall_t VALUES (3, 'Carol')");

    exec.executeSql("DECLARE fc2 CURSOR FOR SELECT * FROM fall_t ORDER BY id");

    var r1 = exec.executeSql("FETCH ALL FROM fc2");
    assertEqInt(r1.rows.count(), 3, "FETCH ALL returns all 3 rows");
    assertEq(val(r1, 0, 1), "Alice", "First row Alice");
    assertEq(val(r1, 2, 1), "Carol", "Last row Carol");
}

func testFetchForwardN() {
    section("FETCH FORWARD n");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE ffn_t (id INTEGER)");
    exec.executeSql("INSERT INTO ffn_t VALUES (1)");
    exec.executeSql("INSERT INTO ffn_t VALUES (2)");
    exec.executeSql("INSERT INTO ffn_t VALUES (3)");
    exec.executeSql("INSERT INTO ffn_t VALUES (4)");
    exec.executeSql("INSERT INTO ffn_t VALUES (5)");

    exec.executeSql("DECLARE fc3 CURSOR FOR SELECT * FROM ffn_t ORDER BY id");

    var r1 = exec.executeSql("FETCH FORWARD 2 FROM fc3");
    assertEqInt(r1.rows.count(), 2, "FETCH FORWARD 2 returns 2 rows");
    assertEq(val(r1, 0, 0), "1", "First row is 1");
    assertEq(val(r1, 1, 0), "2", "Second row is 2");

    var r2 = exec.executeSql("FETCH FORWARD 2 FROM fc3");
    assertEqInt(r2.rows.count(), 2, "Next 2 rows");
    assertEq(val(r2, 0, 0), "3", "Third row is 3");
    assertEq(val(r2, 1, 0), "4", "Fourth row is 4");
}

func testFetchFirstLast() {
    section("FETCH FIRST/LAST");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE ffl_t (id INTEGER, name TEXT)");
    exec.executeSql("INSERT INTO ffl_t VALUES (1, 'Alice')");
    exec.executeSql("INSERT INTO ffl_t VALUES (2, 'Bob')");
    exec.executeSql("INSERT INTO ffl_t VALUES (3, 'Carol')");

    exec.executeSql("DECLARE fc4 CURSOR FOR SELECT * FROM ffl_t ORDER BY id");

    var r1 = exec.executeSql("FETCH FIRST FROM fc4");
    assertEq(val(r1, 0, 1), "Alice", "FIRST returns Alice");

    var r2 = exec.executeSql("FETCH LAST FROM fc4");
    assertEq(val(r2, 0, 1), "Carol", "LAST returns Carol");

    // FIRST again should reset
    var r3 = exec.executeSql("FETCH FIRST FROM fc4");
    assertEq(val(r3, 0, 1), "Alice", "FIRST again returns Alice");
}

func testFetchAbsolute() {
    section("FETCH ABSOLUTE");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE fabs_t (id INTEGER, name TEXT)");
    exec.executeSql("INSERT INTO fabs_t VALUES (1, 'Alice')");
    exec.executeSql("INSERT INTO fabs_t VALUES (2, 'Bob')");
    exec.executeSql("INSERT INTO fabs_t VALUES (3, 'Carol')");

    exec.executeSql("DECLARE fc5 CURSOR FOR SELECT * FROM fabs_t ORDER BY id");

    var r1 = exec.executeSql("FETCH ABSOLUTE 2 FROM fc5");
    assertEqInt(r1.rows.count(), 1, "ABSOLUTE 2 returns 1 row");
    assertEq(val(r1, 0, 1), "Bob", "Row 2 is Bob");

    var r2 = exec.executeSql("FETCH ABSOLUTE 1 FROM fc5");
    assertEq(val(r2, 0, 1), "Alice", "Row 1 is Alice");
}

func testFetchPrior() {
    section("FETCH PRIOR");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE fprior_t (id INTEGER, name TEXT)");
    exec.executeSql("INSERT INTO fprior_t VALUES (1, 'Alice')");
    exec.executeSql("INSERT INTO fprior_t VALUES (2, 'Bob')");
    exec.executeSql("INSERT INTO fprior_t VALUES (3, 'Carol')");

    exec.executeSql("DECLARE fc6 CURSOR FOR SELECT * FROM fprior_t ORDER BY id");

    // Move to end
    exec.executeSql("FETCH LAST FROM fc6");
    // Now go backward
    var r1 = exec.executeSql("FETCH PRIOR FROM fc6");
    assertEq(val(r1, 0, 1), "Bob", "PRIOR from Carol is Bob");

    var r2 = exec.executeSql("FETCH PRIOR FROM fc6");
    assertEq(val(r2, 0, 1), "Alice", "PRIOR from Bob is Alice");
}

//=========================================================================
// CLOSE
//=========================================================================

func testCloseCursor() {
    section("CLOSE cursor");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE close_t (id INTEGER)");
    exec.executeSql("INSERT INTO close_t VALUES (1)");

    exec.executeSql("DECLARE cc CURSOR FOR SELECT * FROM close_t");
    var r1 = exec.executeSql("CLOSE cc");
    assertSuccess(r1, "CLOSE succeeds");

    // FETCH after CLOSE should fail
    var r2 = exec.executeSql("FETCH NEXT FROM cc");
    assertTrue(r2.success == false, "FETCH after CLOSE fails");
}

func testCloseAll() {
    section("CLOSE ALL");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE ca_t (id INTEGER)");
    exec.executeSql("INSERT INTO ca_t VALUES (1)");

    exec.executeSql("DECLARE ca1 CURSOR FOR SELECT * FROM ca_t");
    exec.executeSql("DECLARE ca2 CURSOR FOR SELECT * FROM ca_t");

    var r1 = exec.executeSql("CLOSE ALL");
    assertSuccess(r1, "CLOSE ALL succeeds");

    var r2 = exec.executeSql("FETCH NEXT FROM ca1");
    assertTrue(r2.success == false, "ca1 closed after CLOSE ALL");
}

//=========================================================================
// MOVE
//=========================================================================

func testMove() {
    section("MOVE");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE move_t (id INTEGER, name TEXT)");
    exec.executeSql("INSERT INTO move_t VALUES (1, 'Alice')");
    exec.executeSql("INSERT INTO move_t VALUES (2, 'Bob')");
    exec.executeSql("INSERT INTO move_t VALUES (3, 'Carol')");
    exec.executeSql("INSERT INTO move_t VALUES (4, 'Dave')");

    exec.executeSql("DECLARE mc CURSOR FOR SELECT * FROM move_t ORDER BY id");

    // Move forward 2 positions, then fetch
    exec.executeSql("MOVE FORWARD 2 IN mc");
    var r1 = exec.executeSql("FETCH NEXT FROM mc");
    assertEq(val(r1, 0, 1), "Carol", "After MOVE 2, next is Carol");
}

//=========================================================================
// CURSOR WITH WHERE CLAUSE
//=========================================================================

func testCursorWithWhere() {
    section("Cursor with WHERE");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE cw_t (id INTEGER, score INTEGER)");
    exec.executeSql("INSERT INTO cw_t VALUES (1, 80)");
    exec.executeSql("INSERT INTO cw_t VALUES (2, 90)");
    exec.executeSql("INSERT INTO cw_t VALUES (3, 70)");
    exec.executeSql("INSERT INTO cw_t VALUES (4, 95)");

    exec.executeSql("DECLARE wc CURSOR FOR SELECT * FROM cw_t WHERE score > 75 ORDER BY id");

    var r1 = exec.executeSql("FETCH ALL FROM wc");
    assertEqInt(r1.rows.count(), 3, "Cursor with WHERE returns 3 matching rows");
}

func main() -> Integer {
    Terminal.Say("=== Phase 32: Cursors (DECLARE/FETCH/CLOSE) ===");

    testDeclareCursor();
    testDeclareDuplicate();
    testFetchNext();
    testFetchForwardAll();
    testFetchForwardN();
    testFetchFirstLast();
    testFetchAbsolute();
    testFetchPrior();
    testCloseCursor();
    testCloseAll();
    testMove();
    testCursorWithWhere();

    printResults();
    return 0;
}
