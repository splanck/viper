// test_phase69_query_extras.zia — Phase 69: LIMIT PERCENT, SELECT INTO, Multi-table TRUNCATE
// Tests for percentage-based limits, SELECT INTO, and multi-table TRUNCATE.

module test_phase69_query_extras;

bind Terminal = Viper.Terminal;
bind Fmt = Viper.Fmt;

bind "./test_common";
bind "../executor";
bind "../types";

//=========================================================================
// LIMIT PERCENT — basic percentage
//=========================================================================

func testLimitPercent() {
    section("LIMIT PERCENT");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE numbers (n INTEGER)");
    var i = 1;
    while i <= 20 {
        exec.executeSql("INSERT INTO numbers VALUES (" + Fmt.Int(i) + ")");
        i = i + 1;
    }

    // 50% of 20 = 10 rows
    var r1 = exec.executeSql("SELECT * FROM numbers LIMIT 50 PERCENT");
    assertSuccess(r1, "LIMIT 50 PERCENT");
    assertRowCount(r1, 10, "50% of 20 = 10 rows");

    // 25% of 20 = 5 rows
    var r2 = exec.executeSql("SELECT * FROM numbers LIMIT 25 PERCENT");
    assertSuccess(r2, "LIMIT 25 PERCENT");
    assertRowCount(r2, 5, "25% of 20 = 5 rows");

    // 100% = all rows
    var r3 = exec.executeSql("SELECT * FROM numbers LIMIT 100 PERCENT");
    assertSuccess(r3, "LIMIT 100 PERCENT");
    assertRowCount(r3, 20, "100% = all 20 rows");

    // 10% of 20 = 2 rows
    var r4 = exec.executeSql("SELECT * FROM numbers LIMIT 10 PERCENT");
    assertSuccess(r4, "LIMIT 10 PERCENT");
    assertRowCount(r4, 2, "10% of 20 = 2 rows");
}

//=========================================================================
// LIMIT PERCENT with ORDER BY
//=========================================================================

func testLimitPercentOrdered() {
    section("LIMIT PERCENT with ORDER BY");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE scores (name TEXT, score INTEGER)");
    exec.executeSql("INSERT INTO scores VALUES ('Alice', 95)");
    exec.executeSql("INSERT INTO scores VALUES ('Bob', 88)");
    exec.executeSql("INSERT INTO scores VALUES ('Carol', 92)");
    exec.executeSql("INSERT INTO scores VALUES ('Dave', 78)");
    exec.executeSql("INSERT INTO scores VALUES ('Eve', 99)");

    // Top 40% by score = 2 rows
    var r1 = exec.executeSql("SELECT * FROM scores ORDER BY score DESC LIMIT 40 PERCENT");
    assertSuccess(r1, "Top 40% by score");
    assertRowCount(r1, 2, "40% of 5 = 2 rows");
    assertEq(val(r1, 0, 0), "Eve", "Top scorer is Eve");
}

//=========================================================================
// SELECT INTO — create table from query
//=========================================================================

func testSelectInto() {
    section("SELECT INTO");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE employees (id INTEGER, name TEXT, dept TEXT, salary INTEGER)");
    exec.executeSql("INSERT INTO employees VALUES (1, 'Alice', 'Engineering', 95000)");
    exec.executeSql("INSERT INTO employees VALUES (2, 'Bob', 'Sales', 75000)");
    exec.executeSql("INSERT INTO employees VALUES (3, 'Carol', 'Engineering', 88000)");
    exec.executeSql("INSERT INTO employees VALUES (4, 'Dave', 'Sales', 82000)");

    // SELECT INTO creates a new table
    var r1 = exec.executeSql("SELECT name, salary INTO engineers FROM employees WHERE dept = 'Engineering'");
    assertSuccess(r1, "SELECT INTO creates table");

    // Verify new table has the data
    var r2 = exec.executeSql("TABLE engineers");
    assertSuccess(r2, "TABLE engineers");
    assertRowCount(r2, 2, "2 engineering rows");
    assertEq(val(r2, 0, 0), "Alice", "First engineer");
    assertEq(val(r2, 1, 0), "Carol", "Second engineer");
}

//=========================================================================
// SELECT INTO — duplicate table error
//=========================================================================

func testSelectIntoDuplicate() {
    section("SELECT INTO duplicate");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE source (id INTEGER)");
    exec.executeSql("INSERT INTO source VALUES (1)");
    exec.executeSql("CREATE TABLE target (id INTEGER)");

    var r1 = exec.executeSql("SELECT * INTO target FROM source");
    assertFailure(r1, "SELECT INTO duplicate table errors");
}

//=========================================================================
// Multi-table TRUNCATE
//=========================================================================

func testMultiTruncate() {
    section("Multi-table TRUNCATE");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE t1 (id INTEGER, name TEXT)");
    exec.executeSql("CREATE TABLE t2 (id INTEGER, value TEXT)");
    exec.executeSql("CREATE TABLE t3 (id INTEGER, score INTEGER)");
    exec.executeSql("INSERT INTO t1 VALUES (1, 'a')");
    exec.executeSql("INSERT INTO t1 VALUES (2, 'b')");
    exec.executeSql("INSERT INTO t2 VALUES (1, 'x')");
    exec.executeSql("INSERT INTO t3 VALUES (1, 100)");

    // TRUNCATE multiple tables at once
    var r1 = exec.executeSql("TRUNCATE TABLE t1, t2, t3");
    assertSuccess(r1, "Multi-table TRUNCATE succeeds");

    // Verify all tables are empty
    var r2 = exec.executeSql("SELECT * FROM t1");
    assertRowCount(r2, 0, "t1 is empty");

    var r3 = exec.executeSql("SELECT * FROM t2");
    assertRowCount(r3, 0, "t2 is empty");

    var r4 = exec.executeSql("SELECT * FROM t3");
    assertRowCount(r4, 0, "t3 is empty");
}

//=========================================================================
// Single TRUNCATE still works
//=========================================================================

func testSingleTruncate() {
    section("Single TRUNCATE regression");

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE data (id INTEGER, val TEXT)");
    exec.executeSql("INSERT INTO data VALUES (1, 'a')");
    exec.executeSql("INSERT INTO data VALUES (2, 'b')");

    var r1 = exec.executeSql("TRUNCATE TABLE data");
    assertSuccess(r1, "Single TRUNCATE succeeds");

    var r2 = exec.executeSql("SELECT * FROM data");
    assertRowCount(r2, 0, "Table is empty after TRUNCATE");
}

//=========================================================================
// MAIN
//=========================================================================

func main() {
    Terminal.Say("=== Phase 69: LIMIT PERCENT, SELECT INTO, Multi-table TRUNCATE ===");

    testLimitPercent();
    testLimitPercentOrdered();
    testSelectInto();
    testSelectIntoDuplicate();
    testMultiTruncate();
    testSingleTruncate();

    printResults();
}
