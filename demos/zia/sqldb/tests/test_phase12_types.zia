// test_phase12_types.zia — Phase 12: BOOLEAN, DATE, TIMESTAMP Native Types
// Tests for native boolean/date/timestamp types, CAST, IS TRUE/FALSE,
// date arithmetic, type coercion on INSERT, and TYPEOF.

module test_phase12_types;

bind Terminal = Viper.Terminal;
bind String = Viper.String;
bind Fmt = Viper.Fmt;

bind "./test_common";
bind "../executor";
bind "../types";

func main() -> Integer {
    Terminal.Say("=== Phase 12: BOOLEAN, DATE, TIMESTAMP Native Types ===");

    var exec = new Executor();
    exec.init();

    //=========================================================================
    // BOOLEAN LITERALS
    //=========================================================================
    section("BOOLEAN literals");

    var r = exec.executeSql("SELECT TRUE");
    assertSuccess(r, "SELECT TRUE");
    assertEq(val(r, 0, 0), "true", "TRUE = true");

    r = exec.executeSql("SELECT FALSE");
    assertSuccess(r, "SELECT FALSE");
    assertEq(val(r, 0, 0), "false", "FALSE = false");

    r = exec.executeSql("SELECT TRUE = TRUE");
    assertSuccess(r, "TRUE = TRUE");
    assertEq(val(r, 0, 0), "1", "TRUE = TRUE yields 1");

    r = exec.executeSql("SELECT TRUE = FALSE");
    assertSuccess(r, "TRUE = FALSE");
    assertEq(val(r, 0, 0), "0", "TRUE = FALSE yields 0");

    //=========================================================================
    // BOOLEAN COLUMN
    //=========================================================================
    section("BOOLEAN column");

    r = exec.executeSql("CREATE TABLE btest(id INTEGER PRIMARY KEY, active BOOLEAN)");
    assertSuccess(r, "CREATE TABLE with BOOLEAN column");

    r = exec.executeSql("INSERT INTO btest VALUES (1, TRUE)");
    assertSuccess(r, "INSERT TRUE");

    r = exec.executeSql("INSERT INTO btest VALUES (2, FALSE)");
    assertSuccess(r, "INSERT FALSE");

    r = exec.executeSql("SELECT active FROM btest WHERE id = 1");
    assertSuccess(r, "SELECT boolean value");
    assertEq(val(r, 0, 0), "true", "active=true for id=1");

    r = exec.executeSql("SELECT active FROM btest WHERE id = 2");
    assertSuccess(r, "SELECT boolean value");
    assertEq(val(r, 0, 0), "false", "active=false for id=2");

    //=========================================================================
    // TYPEOF for new types
    //=========================================================================
    section("TYPEOF");

    r = exec.executeSql("SELECT TYPEOF(TRUE)");
    assertSuccess(r, "TYPEOF(TRUE)");
    assertEq(val(r, 0, 0), "boolean", "TYPEOF(TRUE) = boolean");

    r = exec.executeSql("SELECT TYPEOF(FALSE)");
    assertSuccess(r, "TYPEOF(FALSE)");
    assertEq(val(r, 0, 0), "boolean", "TYPEOF(FALSE) = boolean");

    r = exec.executeSql("SELECT TYPEOF(DATE('2025-06-15'))");
    assertSuccess(r, "TYPEOF(DATE)");
    assertEq(val(r, 0, 0), "date", "TYPEOF(DATE(...)) = date");

    r = exec.executeSql("SELECT TYPEOF(TIMESTAMP('2025-06-15T10:30:00'))");
    assertSuccess(r, "TYPEOF(TIMESTAMP)");
    assertEq(val(r, 0, 0), "timestamp", "TYPEOF(TIMESTAMP(...)) = timestamp");

    //=========================================================================
    // IS TRUE / IS FALSE
    //=========================================================================
    section("IS TRUE / IS FALSE");

    r = exec.executeSql("SELECT 1 IS TRUE");
    assertSuccess(r, "1 IS TRUE");
    assertEq(val(r, 0, 0), "1", "1 IS TRUE = 1");

    r = exec.executeSql("SELECT 0 IS TRUE");
    assertSuccess(r, "0 IS TRUE");
    assertEq(val(r, 0, 0), "0", "0 IS TRUE = 0");

    r = exec.executeSql("SELECT 0 IS FALSE");
    assertSuccess(r, "0 IS FALSE");
    assertEq(val(r, 0, 0), "1", "0 IS FALSE = 1");

    r = exec.executeSql("SELECT 1 IS FALSE");
    assertSuccess(r, "1 IS FALSE");
    assertEq(val(r, 0, 0), "0", "1 IS FALSE = 0");

    r = exec.executeSql("SELECT NULL IS NOT TRUE");
    assertSuccess(r, "NULL IS NOT TRUE");
    assertEq(val(r, 0, 0), "1", "NULL IS NOT TRUE = 1");

    r = exec.executeSql("SELECT NULL IS NOT FALSE");
    assertSuccess(r, "NULL IS NOT FALSE");
    assertEq(val(r, 0, 0), "1", "NULL IS NOT FALSE = 1");

    //=========================================================================
    // BOOLEAN CAST
    //=========================================================================
    section("BOOLEAN CAST");

    r = exec.executeSql("SELECT CAST(1 AS BOOLEAN)");
    assertSuccess(r, "CAST(1 AS BOOLEAN)");
    assertEq(val(r, 0, 0), "true", "CAST(1 AS BOOLEAN) = true");

    r = exec.executeSql("SELECT CAST(0 AS BOOLEAN)");
    assertSuccess(r, "CAST(0 AS BOOLEAN)");
    assertEq(val(r, 0, 0), "false", "CAST(0 AS BOOLEAN) = false");

    r = exec.executeSql("SELECT CAST(TRUE AS INTEGER)");
    assertSuccess(r, "CAST(TRUE AS INTEGER)");
    assertEq(val(r, 0, 0), "1", "CAST(TRUE AS INTEGER) = 1");

    r = exec.executeSql("SELECT CAST(FALSE AS INTEGER)");
    assertSuccess(r, "CAST(FALSE AS INTEGER)");
    assertEq(val(r, 0, 0), "0", "CAST(FALSE AS INTEGER) = 0");

    r = exec.executeSql("SELECT CAST('true' AS BOOLEAN)");
    assertSuccess(r, "CAST('true' AS BOOLEAN)");
    assertEq(val(r, 0, 0), "true", "CAST('true' AS BOOLEAN) = true");

    //=========================================================================
    // BOOLEAN DEFAULT
    //=========================================================================
    section("BOOLEAN DEFAULT");

    r = exec.executeSql("CREATE TABLE bdefault(id INTEGER PRIMARY KEY, flag BOOLEAN DEFAULT TRUE)");
    assertSuccess(r, "CREATE TABLE with BOOLEAN DEFAULT TRUE");

    r = exec.executeSql("INSERT INTO bdefault(id) VALUES (1)");
    assertSuccess(r, "INSERT with default boolean");

    r = exec.executeSql("SELECT flag FROM bdefault WHERE id = 1");
    assertSuccess(r, "SELECT default boolean");
    assertEq(val(r, 0, 0), "true", "DEFAULT TRUE applied");

    //=========================================================================
    // DATE column and construction
    //=========================================================================
    section("DATE column and construction");

    r = exec.executeSql("CREATE TABLE dtest(id INTEGER PRIMARY KEY, d DATE)");
    assertSuccess(r, "CREATE TABLE with DATE column");

    r = exec.executeSql("INSERT INTO dtest VALUES (1, DATE('2025-06-15'))");
    assertSuccess(r, "INSERT DATE value");

    r = exec.executeSql("SELECT d FROM dtest WHERE id = 1");
    assertSuccess(r, "SELECT DATE value");
    // DATE toString returns YYYY-MM-DD format
    assert(stringContains(val(r, 0, 0), "2025"), "DATE contains 2025: " + val(r, 0, 0));

    //=========================================================================
    // DATE arithmetic
    //=========================================================================
    section("DATE arithmetic");

    r = exec.executeSql("SELECT DATE('2025-01-15') + 10");
    assertSuccess(r, "DATE + INTEGER");
    var dateResult = val(r, 0, 0);
    assert(stringContains(dateResult, "2025"), "DATE + 10 contains 2025: " + dateResult);

    r = exec.executeSql("SELECT DATE('2025-01-20') - DATE('2025-01-10')");
    assertSuccess(r, "DATE - DATE");
    assertEq(val(r, 0, 0), "10", "DATE diff = 10 days");

    //=========================================================================
    // DATE CAST
    //=========================================================================
    section("DATE CAST");

    r = exec.executeSql("SELECT CAST('2025-06-15' AS DATE)");
    assertSuccess(r, "CAST(text AS DATE)");
    var castDateVal = val(r, 0, 0);
    assert(stringContains(castDateVal, "2025"), "CAST to DATE contains 2025: " + castDateVal);

    r = exec.executeSql("SELECT CAST(DATE('2025-06-15') AS TEXT)");
    assertSuccess(r, "CAST(DATE AS TEXT)");
    assert(stringContains(val(r, 0, 0), "2025"), "CAST DATE to TEXT: " + val(r, 0, 0));

    //=========================================================================
    // TIMESTAMP basics
    //=========================================================================
    section("TIMESTAMP basics");

    r = exec.executeSql("SELECT TIMESTAMP('2025-06-15T10:30:00')");
    assertSuccess(r, "TIMESTAMP constructor");
    var tsVal = val(r, 0, 0);
    assert(stringContains(tsVal, "2025"), "TIMESTAMP contains 2025: " + tsVal);

    r = exec.executeSql("SELECT TYPEOF(NOW())");
    assertSuccess(r, "TYPEOF(NOW())");
    assertEq(val(r, 0, 0), "timestamp", "TYPEOF(NOW()) = timestamp");

    r = exec.executeSql("SELECT TYPEOF(CURRENT_DATE)");
    assertSuccess(r, "TYPEOF(CURRENT_DATE)");
    assertEq(val(r, 0, 0), "date", "TYPEOF(CURRENT_DATE) = date");

    //=========================================================================
    // TIMESTAMP CAST — DATE↔TIMESTAMP
    //=========================================================================
    section("TIMESTAMP CAST");

    r = exec.executeSql("SELECT CAST(TIMESTAMP('2025-06-15T10:30:00') AS DATE)");
    assertSuccess(r, "CAST(TIMESTAMP AS DATE)");
    var tsToDate = val(r, 0, 0);
    assert(stringContains(tsToDate, "2025"), "TIMESTAMP→DATE: " + tsToDate);

    r = exec.executeSql("SELECT CAST(DATE('2025-06-15') AS TIMESTAMP)");
    assertSuccess(r, "CAST(DATE AS TIMESTAMP)");
    var dateToTs = val(r, 0, 0);
    assert(stringContains(dateToTs, "2025"), "DATE→TIMESTAMP: " + dateToTs);

    //=========================================================================
    // Auto-coercion on INSERT
    //=========================================================================
    section("Auto-coercion on INSERT");

    // Insert INTEGER into BOOLEAN column
    r = exec.executeSql("INSERT INTO btest VALUES (3, 1)");
    assertSuccess(r, "INSERT integer into BOOLEAN column");
    r = exec.executeSql("SELECT active FROM btest WHERE id = 3");
    assertSuccess(r, "SELECT coerced boolean");
    assertEq(val(r, 0, 0), "true", "Integer 1 coerced to true");

    // Insert text into DATE column
    r = exec.executeSql("INSERT INTO dtest VALUES (2, '2025-12-25')");
    assertSuccess(r, "INSERT text into DATE column");
    r = exec.executeSql("SELECT TYPEOF(d) FROM dtest WHERE id = 2");
    assertSuccess(r, "TYPEOF coerced date");
    assertEq(val(r, 0, 0), "date", "Text coerced to DATE type");

    //=========================================================================
    // TIMESTAMP column
    //=========================================================================
    section("TIMESTAMP column");

    r = exec.executeSql("CREATE TABLE tstest(id INTEGER PRIMARY KEY, ts TIMESTAMP)");
    assertSuccess(r, "CREATE TABLE with TIMESTAMP column");

    r = exec.executeSql("INSERT INTO tstest VALUES (1, TIMESTAMP('2025-06-15T10:30:00'))");
    assertSuccess(r, "INSERT TIMESTAMP value");

    r = exec.executeSql("SELECT TYPEOF(ts) FROM tstest WHERE id = 1");
    assertSuccess(r, "TYPEOF timestamp column");
    assertEq(val(r, 0, 0), "timestamp", "Stored TIMESTAMP has correct type");

    //=========================================================================
    // Cross-type comparisons
    //=========================================================================
    section("Cross-type comparisons");

    // BOOLEAN vs INTEGER
    r = exec.executeSql("SELECT TRUE = 1");
    assertSuccess(r, "TRUE = 1");
    assertEq(val(r, 0, 0), "1", "TRUE = 1");

    r = exec.executeSql("SELECT FALSE = 0");
    assertSuccess(r, "FALSE = 0");
    assertEq(val(r, 0, 0), "1", "FALSE = 0");

    //=========================================================================
    // Schema display
    //=========================================================================
    section("Schema display");

    r = exec.executeSql("DESCRIBE btest");
    assertSuccess(r, "DESCRIBE table with BOOLEAN");
    // Verify BOOLEAN appears in output
    var descStr = "";
    var di = 0;
    while di < r.rows.count() {
        descStr = descStr + val(r, di, 1) + " ";
        di = di + 1;
    }
    assert(stringContains(descStr, "BOOLEAN"), "DESCRIBE shows BOOLEAN type: " + descStr);

    //=========================================================================
    // Results
    //=========================================================================
    printResults();

    if failed > 0 {
        return 1;
    }
    return 0;
}
