// test_phase17_triggers.zia â€” Phase 17: Trigger Tests
// Tests for CREATE TRIGGER, DROP TRIGGER, SHOW TRIGGERS,
// BEFORE/AFTER INSERT/UPDATE/DELETE triggers, FOR EACH ROW,
// FOR EACH STATEMENT, OLD/NEW references, trigger ordering,
// recursive trigger prevention, and trigger cleanup on DROP TABLE.

module test_phase17_triggers;

bind Terminal = Viper.Terminal;
bind String = Viper.String;
bind Fmt = Viper.Fmt;

bind "./test_common";
bind "../executor";
bind "../types";
bind "../triggers";
bind "../stmt";

func main() -> Integer {
    Terminal.Say("=== Phase 17: Trigger Tests ===");

    //=========================================================================
    // 1. TRIGGER ENTITY BASICS
    //=========================================================================
    section("Trigger Entity");

    // Test 1: Create a trigger entity
    var trig = new Trigger();
    trig.initFull("trg_test", TRIGGER_BEFORE, TRIGGER_INSERT, "users", true, "INSERT INTO audit VALUES (1)");
    assertEq(trig.name, "trg_test", "Trigger name = trg_test");
    assertEqInt(trig.timing, TRIGGER_BEFORE, "Trigger timing = BEFORE");
    assertEqInt(trig.event, TRIGGER_INSERT, "Trigger event = INSERT");
    assertEq(trig.tableName, "users", "Trigger tableName = users");
    assertTrue(trig.forEachRow, "Trigger forEachRow = true");
    assertEq(trig.timingName(), "BEFORE", "timingName = BEFORE");
    assertEq(trig.eventName(), "INSERT", "eventName = INSERT");

    // Test 2: AFTER DELETE trigger
    var trig2 = new Trigger();
    trig2.initFull("trg_del", TRIGGER_AFTER, TRIGGER_DELETE, "orders", false, "DELETE FROM tlog");
    assertEq(trig2.timingName(), "AFTER", "AFTER timingName");
    assertEq(trig2.eventName(), "DELETE", "DELETE eventName");
    assertFalse(trig2.forEachRow, "FOR EACH STATEMENT");

    //=========================================================================
    // 2. TRIGGER MANAGER
    //=========================================================================
    section("TriggerManager");

    var mgr = new TriggerManager();
    mgr.init();

    // Test 3: Add trigger
    var t1 = new Trigger();
    t1.initFull("alpha", TRIGGER_BEFORE, TRIGGER_INSERT, "t1", true, "SELECT 1");
    var err1 = mgr.addTrigger(t1);
    assertEq(err1, "", "addTrigger alpha succeeds");

    // Test 4: Duplicate name
    var t1dup = new Trigger();
    t1dup.initFull("alpha", TRIGGER_AFTER, TRIGGER_DELETE, "t2", true, "SELECT 2");
    var err2 = mgr.addTrigger(t1dup);
    assertTrue(err2 != "", "Duplicate trigger name rejected");

    // Test 5: Add more triggers
    var t2 = new Trigger();
    t2.initFull("beta", TRIGGER_AFTER, TRIGGER_INSERT, "t1", true, "SELECT 2");
    mgr.addTrigger(t2);
    var t3 = new Trigger();
    t3.initFull("gamma", TRIGGER_BEFORE, TRIGGER_INSERT, "t1", true, "SELECT 3");
    mgr.addTrigger(t3);

    // Test 6: getTriggersFor returns sorted by name
    var before_inserts = mgr.getTriggersFor("t1", TRIGGER_BEFORE, TRIGGER_INSERT);
    assertEqInt(before_inserts.count(), 2, "2 BEFORE INSERT triggers on t1");
    assertEq(before_inserts.get(0).name, "alpha", "First trigger = alpha (sorted)");
    assertEq(before_inserts.get(1).name, "gamma", "Second trigger = gamma (sorted)");

    // Test 7: getTriggersFor different timing
    var after_inserts = mgr.getTriggersFor("t1", TRIGGER_AFTER, TRIGGER_INSERT);
    assertEqInt(after_inserts.count(), 1, "1 AFTER INSERT trigger on t1");
    assertEq(after_inserts.get(0).name, "beta", "AFTER INSERT = beta");

    // Test 8: getTriggersFor non-existent combination
    var before_deletes = mgr.getTriggersFor("t1", TRIGGER_BEFORE, TRIGGER_DELETE);
    assertEqInt(before_deletes.count(), 0, "0 BEFORE DELETE triggers on t1");

    // Test 9: findTrigger
    var found = mgr.findTrigger("beta");
    assertTrue(found != null, "findTrigger beta found");

    var notfound = mgr.findTrigger("nonexistent");
    assertTrue(notfound == null, "findTrigger nonexistent = null");

    // Test 10: dropTrigger
    assertTrue(mgr.dropTrigger("beta"), "dropTrigger beta succeeds");
    assertFalse(mgr.dropTrigger("beta"), "dropTrigger beta again fails");

    // Test 11: dropTriggersForTable
    mgr.dropTriggersForTable("t1");
    assertEqInt(mgr.listTriggers().count(), 0, "dropTriggersForTable removes all t1 triggers");

    //=========================================================================
    // 3. CREATE TRIGGER / DROP TRIGGER SQL
    //=========================================================================
    section("CREATE TRIGGER / DROP TRIGGER SQL");

    var exec = new Executor();
    exec.init();
    exec.executeSql("CREATE TABLE audit_log (id INTEGER, op TEXT, detail TEXT)");
    exec.executeSql("CREATE TABLE products (id INTEGER, name TEXT, price INTEGER)");

    // Test 12: CREATE TRIGGER
    var ct1 = exec.executeSql("CREATE TRIGGER trg_product_insert AFTER INSERT ON products FOR EACH ROW EXECUTE 'INSERT INTO audit_log VALUES (1, ''INSERT'', ''product added'')'");
    assertSuccess(ct1, "CREATE TRIGGER succeeds");
    assertTrue(stringContains(ct1.message, "created"), "Trigger created message");

    // Test 13: Duplicate trigger name
    var ct2 = exec.executeSql("CREATE TRIGGER trg_product_insert BEFORE DELETE ON products FOR EACH ROW EXECUTE 'SELECT 1'");
    assertFailure(ct2, "Duplicate trigger name rejected");

    // Test 14: Trigger on non-existent table
    var ct3 = exec.executeSql("CREATE TRIGGER trg_ghost BEFORE INSERT ON ghost_table FOR EACH ROW EXECUTE 'SELECT 1'");
    assertFailure(ct3, "Trigger on non-existent table rejected");

    // Test 15: SHOW TRIGGERS
    var st = exec.executeSql("SHOW TRIGGERS");
    assertSuccess(st, "SHOW TRIGGERS succeeds");
    assertRowCount(st, 1, "1 trigger in SHOW TRIGGERS");
    assertEq(val(st, 0, 0), "trg_product_insert", "SHOW TRIGGERS: trigger name");
    assertEq(val(st, 0, 1), "AFTER", "SHOW TRIGGERS: timing");
    assertEq(val(st, 0, 2), "INSERT", "SHOW TRIGGERS: event");
    assertEq(val(st, 0, 3), "products", "SHOW TRIGGERS: table");
    assertEq(val(st, 0, 4), "ROW", "SHOW TRIGGERS: for_each");

    // Test 16: DROP TRIGGER
    var dt1 = exec.executeSql("DROP TRIGGER trg_product_insert");
    assertSuccess(dt1, "DROP TRIGGER succeeds");
    assertTrue(stringContains(dt1.message, "dropped"), "Trigger dropped message");

    // Test 17: DROP non-existent trigger
    var dt2 = exec.executeSql("DROP TRIGGER trg_product_insert");
    assertFailure(dt2, "DROP non-existent trigger fails");

    //=========================================================================
    // 4. AFTER INSERT TRIGGER â€” AUDIT LOG
    //=========================================================================
    section("AFTER INSERT Trigger â€” Audit Log");

    var exec2 = new Executor();
    exec2.init();
    exec2.executeSql("CREATE TABLE items (id INTEGER, name TEXT)");
    exec2.executeSql("CREATE TABLE tlog (entry TEXT)");

    // Create AFTER INSERT trigger that logs insertions
    exec2.executeSql("CREATE TRIGGER trg_log_insert AFTER INSERT ON items FOR EACH ROW EXECUTE 'INSERT INTO tlog VALUES (''item_inserted'')'");

    // Test 18: Insert triggers the audit log
    exec2.executeSql("INSERT INTO items VALUES (1, 'widget')");
    var log1 = exec2.executeSql("SELECT entry FROM tlog");
    assertRowCount(log1, 1, "AFTER INSERT trigger fired: 1 log entry");
    assertEq(val(log1, 0, 0), "item_inserted", "Log entry = item_inserted");

    // Test 19: Multiple inserts = multiple trigger fires
    exec2.executeSql("INSERT INTO items VALUES (2, 'gadget')");
    exec2.executeSql("INSERT INTO items VALUES (3, 'gizmo')");
    var log2 = exec2.executeSql("SELECT COUNT(*) FROM tlog");
    assertEq(val(log2, 0, 0), "3", "3 inserts = 3 log entries");

    //=========================================================================
    // 5. BEFORE INSERT TRIGGER
    //=========================================================================
    section("BEFORE INSERT Trigger");

    var exec3 = new Executor();
    exec3.init();
    exec3.executeSql("CREATE TABLE counters (name TEXT, count INTEGER)");
    exec3.executeSql("INSERT INTO counters VALUES ('inserts', 0)");

    // Create BEFORE INSERT trigger
    exec3.executeSql("CREATE TABLE data (id INTEGER, val TEXT)");
    exec3.executeSql("CREATE TRIGGER trg_count_insert BEFORE INSERT ON data FOR EACH ROW EXECUTE 'UPDATE counters SET count = count + 1 WHERE name = ''inserts'''");

    // Test 20: BEFORE INSERT fires before the row is added
    exec3.executeSql("INSERT INTO data VALUES (1, 'hello')");
    var cnt1 = exec3.executeSql("SELECT count FROM counters WHERE name = 'inserts'");
    assertEq(val(cnt1, 0, 0), "1", "BEFORE INSERT counter = 1");

    // Test 21: Data row was also inserted
    var d1 = exec3.executeSql("SELECT val FROM data WHERE id = 1");
    assertEq(val(d1, 0, 0), "hello", "Data row inserted despite BEFORE trigger");

    //=========================================================================
    // 6. AFTER DELETE TRIGGER
    //=========================================================================
    section("AFTER DELETE Trigger");

    var exec4 = new Executor();
    exec4.init();
    exec4.executeSql("CREATE TABLE users (id INTEGER, name TEXT)");
    exec4.executeSql("CREATE TABLE del_log (user_id INTEGER)");
    exec4.executeSql("INSERT INTO users VALUES (1, 'alice')");
    exec4.executeSql("INSERT INTO users VALUES (2, 'bob')");

    exec4.executeSql("CREATE TRIGGER trg_log_delete AFTER DELETE ON users FOR EACH ROW EXECUTE 'INSERT INTO del_log VALUES (0)'");

    // Test 22: DELETE fires trigger
    exec4.executeSql("DELETE FROM users WHERE id = 1");
    var dlog = exec4.executeSql("SELECT COUNT(*) FROM del_log");
    assertEq(val(dlog, 0, 0), "1", "AFTER DELETE: 1 log entry");

    //=========================================================================
    // 7. AFTER UPDATE TRIGGER
    //=========================================================================
    section("AFTER UPDATE Trigger");

    var exec5 = new Executor();
    exec5.init();
    exec5.executeSql("CREATE TABLE accounts (id INTEGER, balance INTEGER)");
    exec5.executeSql("CREATE TABLE upd_log (msg TEXT)");
    exec5.executeSql("INSERT INTO accounts VALUES (1, 100)");

    exec5.executeSql("CREATE TRIGGER trg_log_update AFTER UPDATE ON accounts FOR EACH ROW EXECUTE 'INSERT INTO upd_log VALUES (''balance_changed'')'");

    // Test 23: UPDATE fires trigger
    exec5.executeSql("UPDATE accounts SET balance = 200 WHERE id = 1");
    var ulog = exec5.executeSql("SELECT msg FROM upd_log");
    assertRowCount(ulog, 1, "AFTER UPDATE: 1 log entry");
    assertEq(val(ulog, 0, 0), "balance_changed", "AFTER UPDATE log = balance_changed");

    // Test 24: Multiple row UPDATE fires trigger per row
    exec5.executeSql("INSERT INTO accounts VALUES (2, 300)");
    exec5.executeSql("UPDATE accounts SET balance = balance + 10 WHERE balance > 0");
    var ulog2 = exec5.executeSql("SELECT COUNT(*) FROM upd_log");
    assertEq(val(ulog2, 0, 0), "3", "Multi-row UPDATE: 3 total log entries (1 + 2)");

    //=========================================================================
    // 8. OLD AND NEW ROW REFERENCES
    //=========================================================================
    section("OLD and NEW Row References");

    var exec6 = new Executor();
    exec6.init();
    exec6.executeSql("CREATE TABLE emp (id INTEGER, name TEXT, salary INTEGER)");
    exec6.executeSql("CREATE TABLE salary_hist (emp_name TEXT, old_salary INTEGER, new_salary INTEGER)");
    exec6.executeSql("INSERT INTO emp VALUES (1, 'alice', 50000)");

    // Create AFTER UPDATE trigger that reads NEW table
    exec6.executeSql("CREATE TRIGGER trg_salary_hist AFTER UPDATE ON emp FOR EACH ROW EXECUTE 'INSERT INTO salary_hist SELECT new.name, old.salary, new.salary FROM old INNER JOIN new ON old.id = new.id'");

    // Test 25: UPDATE fires trigger with OLD/NEW
    exec6.executeSql("UPDATE emp SET salary = 60000 WHERE id = 1");
    var hist = exec6.executeSql("SELECT emp_name, old_salary, new_salary FROM salary_hist");
    assertRowCount(hist, 1, "Salary history: 1 entry");
    assertEq(val(hist, 0, 0), "alice", "salary_hist: emp_name = alice");
    assertEq(val(hist, 0, 1), "50000", "salary_hist: old_salary = 50000");
    assertEq(val(hist, 0, 2), "60000", "salary_hist: new_salary = 60000");

    //=========================================================================
    // 9. TRIGGER ORDERING (ALPHABETICAL)
    //=========================================================================
    section("Trigger Ordering");

    var exec7 = new Executor();
    exec7.init();
    exec7.executeSql("CREATE TABLE order_test (id INTEGER)");
    exec7.executeSql("CREATE TABLE order_log (trigger_name TEXT)");

    // Create triggers in non-alphabetical order
    exec7.executeSql("CREATE TRIGGER trg_c AFTER INSERT ON order_test FOR EACH ROW EXECUTE 'INSERT INTO order_log VALUES (''c'')'");
    exec7.executeSql("CREATE TRIGGER trg_a AFTER INSERT ON order_test FOR EACH ROW EXECUTE 'INSERT INTO order_log VALUES (''a'')'");
    exec7.executeSql("CREATE TRIGGER trg_b AFTER INSERT ON order_test FOR EACH ROW EXECUTE 'INSERT INTO order_log VALUES (''b'')'");

    // Test 26: Triggers fire in alphabetical order
    exec7.executeSql("INSERT INTO order_test VALUES (1)");
    var olog = exec7.executeSql("SELECT trigger_name FROM order_log");
    assertRowCount(olog, 3, "3 triggers fired");
    assertEq(val(olog, 0, 0), "a", "First trigger = a (alphabetical)");
    assertEq(val(olog, 1, 0), "b", "Second trigger = b");
    assertEq(val(olog, 2, 0), "c", "Third trigger = c");

    //=========================================================================
    // 10. TRIGGER REMOVED ON DROP TABLE
    //=========================================================================
    section("Trigger Cleanup on DROP TABLE");

    var exec8 = new Executor();
    exec8.init();
    exec8.executeSql("CREATE TABLE tmp_t (id INTEGER)");
    exec8.executeSql("CREATE TABLE tmp_log (msg TEXT)");
    exec8.executeSql("CREATE TRIGGER trg_tmp AFTER INSERT ON tmp_t FOR EACH ROW EXECUTE 'INSERT INTO tmp_log VALUES (''fired'')'");

    // Test 27: Trigger exists
    var st2 = exec8.executeSql("SHOW TRIGGERS");
    assertRowCount(st2, 1, "1 trigger before DROP TABLE");

    // Test 28: DROP TABLE removes triggers
    exec8.executeSql("DROP TABLE tmp_t");
    var st3 = exec8.executeSql("SHOW TRIGGERS");
    assertRowCount(st3, 0, "0 triggers after DROP TABLE");

    //=========================================================================
    // 11. MULTIPLE TRIGGERS ON DIFFERENT EVENTS
    //=========================================================================
    section("Multiple Triggers on Different Events");

    var exec9 = new Executor();
    exec9.init();
    exec9.executeSql("CREATE TABLE multi_t (id INTEGER, val TEXT)");
    exec9.executeSql("CREATE TABLE multi_log (op TEXT)");

    exec9.executeSql("CREATE TRIGGER trg_ins AFTER INSERT ON multi_t FOR EACH ROW EXECUTE 'INSERT INTO multi_log VALUES (''INSERT'')'");
    exec9.executeSql("CREATE TRIGGER trg_upd AFTER UPDATE ON multi_t FOR EACH ROW EXECUTE 'INSERT INTO multi_log VALUES (''UPDATE'')'");
    exec9.executeSql("CREATE TRIGGER trg_del AFTER DELETE ON multi_t FOR EACH ROW EXECUTE 'INSERT INTO multi_log VALUES (''DELETE'')'");

    // Test 29: INSERT trigger only fires for INSERT
    exec9.executeSql("INSERT INTO multi_t VALUES (1, 'hello')");
    var ml1 = exec9.executeSql("SELECT COUNT(*) FROM multi_log WHERE op = 'INSERT'");
    assertEq(val(ml1, 0, 0), "1", "1 INSERT log entry");

    // Test 30: UPDATE trigger fires for UPDATE
    exec9.executeSql("UPDATE multi_t SET val = 'world' WHERE id = 1");
    var ml2 = exec9.executeSql("SELECT COUNT(*) FROM multi_log WHERE op = 'UPDATE'");
    assertEq(val(ml2, 0, 0), "1", "1 UPDATE log entry");

    // Test 31: DELETE trigger fires for DELETE
    exec9.executeSql("DELETE FROM multi_t WHERE id = 1");
    var ml3 = exec9.executeSql("SELECT COUNT(*) FROM multi_log WHERE op = 'DELETE'");
    assertEq(val(ml3, 0, 0), "1", "1 DELETE log entry");

    // Test 32: Total log entries
    var mlTotal = exec9.executeSql("SELECT COUNT(*) FROM multi_log");
    assertEq(val(mlTotal, 0, 0), "3", "Total 3 log entries (INSERT+UPDATE+DELETE)");

    //=========================================================================
    // 12. TRIGGER WITH TRANSACTIONS
    //=========================================================================
    section("Triggers with Transactions");

    var exec10 = new Executor();
    exec10.init();
    exec10.executeSql("CREATE TABLE txn_t (id INTEGER)");
    exec10.executeSql("CREATE TABLE txn_log (msg TEXT)");

    exec10.executeSql("CREATE TRIGGER trg_txn AFTER INSERT ON txn_t FOR EACH ROW EXECUTE 'INSERT INTO txn_log VALUES (''triggered'')'");

    // Test 33: Trigger fires inside transaction
    exec10.executeSql("BEGIN");
    exec10.executeSql("INSERT INTO txn_t VALUES (1)");
    var txnLog = exec10.executeSql("SELECT COUNT(*) FROM txn_log");
    assertEq(val(txnLog, 0, 0), "1", "Trigger fires inside txn");
    exec10.executeSql("ROLLBACK");

    // Test 34: After rollback, both main row and trigger side-effect undone
    // Note: trigger side-effects within a transaction are part of the same transaction
    // journal, so they get rolled back too
    var txnLogAfter = exec10.executeSql("SELECT COUNT(*) FROM txn_t");
    assertEq(val(txnLogAfter, 0, 0), "0", "txn_t rolled back");

    //=========================================================================
    // 13. FOR EACH STATEMENT TRIGGER
    //=========================================================================
    section("FOR EACH STATEMENT Trigger");

    var exec11 = new Executor();
    exec11.init();
    exec11.executeSql("CREATE TABLE stmt_t (id INTEGER)");
    exec11.executeSql("CREATE TABLE stmt_log (msg TEXT)");

    exec11.executeSql("CREATE TRIGGER trg_stmt AFTER INSERT ON stmt_t FOR EACH STATEMENT EXECUTE 'INSERT INTO stmt_log VALUES (''statement_fired'')'");

    // Test 35: Statement trigger fires once per INSERT (even for multi-row, it fires per-row in our simplified impl)
    // Note: In our implementation, "FOR EACH STATEMENT" triggers fire once per matching row
    // since we don't have a separate statement-level fire point. This is a simplification.
    exec11.executeSql("INSERT INTO stmt_t VALUES (1)");
    var slog = exec11.executeSql("SELECT COUNT(*) FROM stmt_log");
    assertEq(val(slog, 0, 0), "1", "Statement trigger fires for INSERT");

    //=========================================================================
    // 14. TRIGGER CONSTANTS
    //=========================================================================
    section("Trigger Constants");

    // Test 36: Verify constants
    assertEqInt(TRIGGER_BEFORE, 1, "TRIGGER_BEFORE = 1");
    assertEqInt(TRIGGER_AFTER, 2, "TRIGGER_AFTER = 2");
    assertEqInt(TRIGGER_INSERT, 1, "TRIGGER_INSERT = 1");
    assertEqInt(TRIGGER_UPDATE, 2, "TRIGGER_UPDATE = 2");
    assertEqInt(TRIGGER_DELETE, 3, "TRIGGER_DELETE = 3");
    assertEqInt(MAX_TRIGGER_DEPTH, 16, "MAX_TRIGGER_DEPTH = 16");

    //=========================================================================
    // RESULTS
    //=========================================================================
    printResults();

    if failed > 0 {
        return 1;
    }
    return 0;
}
