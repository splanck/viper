// system_views.zia — System Views (INFORMATION_SCHEMA and sys.*)
// Part of ViperSQL - Phase 8.2
//
// Virtual views generated from live server state.
// Called by the executor when SELECT targets a system view name.

module system_views;

bind String = Viper.String;
bind Fmt = Viper.Fmt;

bind "./types";
bind "./schema";
bind "./table";
bind "./index";
bind "./database";
bind "./result";
bind "./server";

//=============================================================================
// SYSTEM VIEW DETECTION
//=============================================================================

// Check if a table name refers to a system view
func isSystemView(tableName: String) -> Boolean {
    var upper = String.ToUpper(tableName);
    if upper == "INFORMATION_SCHEMA.TABLES" { return true; }
    if upper == "INFORMATION_SCHEMA.COLUMNS" { return true; }
    if upper == "INFORMATION_SCHEMA.SCHEMATA" { return true; }
    if upper == "INFORMATION_SCHEMA.TABLE_PRIVILEGES" { return true; }
    if upper == "SYS.DATABASES" { return true; }
    if upper == "SYS.TABLES" { return true; }
    if upper == "SYS.COLUMNS" { return true; }
    if upper == "SYS.STATS" { return true; }
    if upper == "SYS.USERS" { return true; }
    if upper == "SYS.VACUUM_STATS" { return true; }
    // pg_stat views (Phase 27)
    if upper == "PG_STAT_ACTIVITY" || upper == "PG_CATALOG.PG_STAT_ACTIVITY" { return true; }
    if upper == "PG_STAT_USER_TABLES" || upper == "PG_CATALOG.PG_STAT_USER_TABLES" { return true; }
    if upper == "PG_STAT_USER_INDEXES" || upper == "PG_CATALOG.PG_STAT_USER_INDEXES" { return true; }
    // pg_catalog views (Phase 21)
    if upper == "PG_CATALOG.PG_CLASS" || upper == "PG_CLASS" { return true; }
    if upper == "PG_CATALOG.PG_ATTRIBUTE" || upper == "PG_ATTRIBUTE" { return true; }
    if upper == "PG_CATALOG.PG_TYPE" || upper == "PG_TYPE" { return true; }
    if upper == "PG_CATALOG.PG_NAMESPACE" || upper == "PG_NAMESPACE" { return true; }
    if upper == "PG_CATALOG.PG_INDEX" || upper == "PG_INDEX" { return true; }
    if upper == "PG_CATALOG.PG_DATABASE" || upper == "PG_DATABASE" { return true; }
    if upper == "PG_CATALOG.PG_PROC" || upper == "PG_PROC" { return true; }
    if upper == "PG_CATALOG.PG_SETTINGS" || upper == "PG_SETTINGS" { return true; }
    return false;
}

// Execute a system view query
func executeSystemView(tableName: String, server: DatabaseServer, currentDbName: String) -> QueryResult {
    var upper = String.ToUpper(tableName);

    if upper == "INFORMATION_SCHEMA.TABLES" {
        return viewInformationSchemaTables(server, currentDbName);
    }
    if upper == "INFORMATION_SCHEMA.COLUMNS" {
        return viewInformationSchemaColumns(server, currentDbName);
    }
    if upper == "INFORMATION_SCHEMA.SCHEMATA" {
        return viewInformationSchemaSchemata(server);
    }
    if upper == "SYS.DATABASES" {
        return viewSysDatabases(server);
    }
    if upper == "SYS.TABLES" {
        return viewSysTables(server, currentDbName);
    }
    if upper == "SYS.COLUMNS" {
        return viewSysColumns(server, currentDbName);
    }
    if upper == "SYS.STATS" {
        return viewSysStats(server);
    }
    if upper == "SYS.USERS" {
        return viewSysUsers(server);
    }
    if upper == "INFORMATION_SCHEMA.TABLE_PRIVILEGES" {
        return viewTablePrivileges(server);
    }
    // pg_catalog views (Phase 21)
    if upper == "PG_CATALOG.PG_CLASS" || upper == "PG_CLASS" {
        return viewPgClass(server, currentDbName);
    }
    if upper == "PG_CATALOG.PG_ATTRIBUTE" || upper == "PG_ATTRIBUTE" {
        return viewPgAttribute(server, currentDbName);
    }
    if upper == "PG_CATALOG.PG_TYPE" || upper == "PG_TYPE" {
        return viewPgType();
    }
    if upper == "PG_CATALOG.PG_NAMESPACE" || upper == "PG_NAMESPACE" {
        return viewPgNamespace(server);
    }
    if upper == "PG_CATALOG.PG_INDEX" || upper == "PG_INDEX" {
        return viewPgIndex(server, currentDbName);
    }
    if upper == "PG_CATALOG.PG_DATABASE" || upper == "PG_DATABASE" {
        return viewPgDatabase(server);
    }
    if upper == "PG_CATALOG.PG_PROC" || upper == "PG_PROC" {
        return viewPgProc(server);
    }
    if upper == "PG_CATALOG.PG_SETTINGS" || upper == "PG_SETTINGS" {
        return viewPgSettings();
    }

    var result = new QueryResult();
    result.init();
    result.setError("Unknown system view: " + tableName);
    return result;
}

//=============================================================================
// INFORMATION_SCHEMA.TABLES
//=============================================================================

func viewInformationSchemaTables(server: DatabaseServer, currentDbName: String) -> QueryResult {
    var result = new QueryResult();
    result.init();

    result.addColumnName("table_catalog");
    result.addColumnName("table_schema");
    result.addColumnName("table_name");
    result.addColumnName("table_type");

    var di = 0;
    while di < server.dbNames.count() {
        var dbName = server.dbNames.get(di);
        var db = server.dbList.get(di);
        var ti = 0;
        while ti < db.tableCount() {
            var maybeTable = db.getTable(ti);
            if maybeTable != null {
                var table = maybeTable;
                var row = new Row();
                row.init();
                row.addValue(sqlText(dbName));
                row.addValue(sqlText("public"));
                row.addValue(sqlText(table.name));
                row.addValue(sqlText("BASE TABLE"));
                result.addRow(row);
            }
            ti = ti + 1;
        }
        // Add views
        var vi = 0;
        while vi < db.viewNames.count() {
            var row = new Row();
            row.init();
            row.addValue(sqlText(dbName));
            row.addValue(sqlText("public"));
            row.addValue(sqlText(db.viewNames.get(vi)));
            row.addValue(sqlText("VIEW"));
            result.addRow(row);
            vi = vi + 1;
        }
        di = di + 1;
    }

    return result;
}

//=============================================================================
// INFORMATION_SCHEMA.COLUMNS
//=============================================================================

func viewInformationSchemaColumns(server: DatabaseServer, currentDbName: String) -> QueryResult {
    var result = new QueryResult();
    result.init();

    result.addColumnName("table_catalog");
    result.addColumnName("table_name");
    result.addColumnName("column_name");
    result.addColumnName("ordinal_position");
    result.addColumnName("data_type");
    result.addColumnName("is_nullable");

    var di = 0;
    while di < server.dbNames.count() {
        var dbName = server.dbNames.get(di);
        var db = server.dbList.get(di);
        var ti = 0;
        while ti < db.tableCount() {
            var maybeTable = db.getTable(ti);
            if maybeTable != null {
                var table = maybeTable;
                var ci = 0;
                while ci < table.columnCount() {
                    var col = table.getColumn(ci);
                    var row = new Row();
                    row.init();
                    row.addValue(sqlText(dbName));
                    row.addValue(sqlText(table.name));
                    row.addValue(sqlText(col.name));
                    row.addValue(sqlInteger(ci + 1));
                    row.addValue(sqlText(columnTypeName(col.typeCode)));
                    if col.notNull {
                        row.addValue(sqlText("NO"));
                    } else {
                        row.addValue(sqlText("YES"));
                    }
                    result.addRow(row);
                    ci = ci + 1;
                }
            }
            ti = ti + 1;
        }
        di = di + 1;
    }

    return result;
}

//=============================================================================
// INFORMATION_SCHEMA.SCHEMATA
//=============================================================================

func viewInformationSchemaSchemata(server: DatabaseServer) -> QueryResult {
    var result = new QueryResult();
    result.init();

    result.addColumnName("catalog_name");
    result.addColumnName("schema_name");

    var di = 0;
    while di < server.dbNames.count() {
        var row = new Row();
        row.init();
        row.addValue(sqlText(server.dbNames.get(di)));
        row.addValue(sqlText("public"));
        result.addRow(row);
        di = di + 1;
    }

    return result;
}

//=============================================================================
// SYS.DATABASES
//=============================================================================

func viewSysDatabases(server: DatabaseServer) -> QueryResult {
    var result = new QueryResult();
    result.init();

    result.addColumnName("name");
    result.addColumnName("table_count");
    result.addColumnName("is_persistent");
    result.addColumnName("file_path");

    var di = 0;
    while di < server.dbNames.count() {
        var dbName = server.dbNames.get(di);
        var db = server.dbList.get(di);

        var isPersistent = false;
        var filePath = "";
        if di < server.dbFilePaths.count() {
            filePath = server.dbFilePaths.get(di);
            if filePath != "" {
                isPersistent = true;
            }
        }

        var row = new Row();
        row.init();
        row.addValue(sqlText(dbName));
        row.addValue(sqlInteger(db.tableCount()));
        if isPersistent {
            row.addValue(sqlText("YES"));
        } else {
            row.addValue(sqlText("NO"));
        }
        row.addValue(sqlText(filePath));
        result.addRow(row);
        di = di + 1;
    }

    return result;
}

//=============================================================================
// SYS.TABLES — Tables in current database with row counts
//=============================================================================

func viewSysTables(server: DatabaseServer, currentDbName: String) -> QueryResult {
    var result = new QueryResult();
    result.init();

    result.addColumnName("database_name");
    result.addColumnName("table_name");
    result.addColumnName("row_count");
    result.addColumnName("column_count");

    var di = 0;
    while di < server.dbNames.count() {
        var dbName = server.dbNames.get(di);
        var db = server.dbList.get(di);
        var ti = 0;
        while ti < db.tableCount() {
            var maybeTable = db.getTable(ti);
            if maybeTable != null {
                var table = maybeTable;
                var row = new Row();
                row.init();
                row.addValue(sqlText(dbName));
                row.addValue(sqlText(table.name));
                row.addValue(sqlInteger(table.rowCount()));
                row.addValue(sqlInteger(table.columnCount()));
                result.addRow(row);
            }
            ti = ti + 1;
        }
        di = di + 1;
    }

    return result;
}

//=============================================================================
// SYS.COLUMNS — All columns across all tables
//=============================================================================

func viewSysColumns(server: DatabaseServer, currentDbName: String) -> QueryResult {
    var result = new QueryResult();
    result.init();

    result.addColumnName("table_name");
    result.addColumnName("column_name");
    result.addColumnName("data_type");
    result.addColumnName("is_primary_key");
    result.addColumnName("is_nullable");

    var di = 0;
    while di < server.dbNames.count() {
        var db = server.dbList.get(di);
        var ti = 0;
        while ti < db.tableCount() {
            var maybeTable = db.getTable(ti);
            if maybeTable != null {
                var table = maybeTable;
                var ci = 0;
                while ci < table.columnCount() {
                    var col = table.getColumn(ci);
                    var row = new Row();
                    row.init();
                    row.addValue(sqlText(table.name));
                    row.addValue(sqlText(col.name));
                    row.addValue(sqlText(columnTypeName(col.typeCode)));
                    if col.primaryKey {
                        row.addValue(sqlText("YES"));
                    } else {
                        row.addValue(sqlText("NO"));
                    }
                    if col.notNull {
                        row.addValue(sqlText("NO"));
                    } else {
                        row.addValue(sqlText("YES"));
                    }
                    result.addRow(row);
                    ci = ci + 1;
                }
            }
            ti = ti + 1;
        }
        di = di + 1;
    }

    return result;
}

//=============================================================================
// SYS.STATS — Server-wide statistics
//=============================================================================

func viewSysStats(server: DatabaseServer) -> QueryResult {
    var result = new QueryResult();
    result.init();

    result.addColumnName("stat_name");
    result.addColumnName("stat_value");

    // Database count
    var row1 = new Row();
    row1.init();
    row1.addValue(sqlText("database_count"));
    row1.addValue(sqlInteger(server.dbNames.count()));
    result.addRow(row1);

    // Total table count across all databases
    var totalTables = 0;
    var totalRows = 0;
    var di = 0;
    while di < server.dbList.count() {
        var db = server.dbList.get(di);
        totalTables = totalTables + db.tableCount();
        var ti = 0;
        while ti < db.tableCount() {
            var maybeTable = db.getTable(ti);
            if maybeTable != null {
                var table = maybeTable;
                totalRows = totalRows + table.rowCount();
            }
            ti = ti + 1;
        }
        di = di + 1;
    }

    var row2 = new Row();
    row2.init();
    row2.addValue(sqlText("total_tables"));
    row2.addValue(sqlInteger(totalTables));
    result.addRow(row2);

    var row3 = new Row();
    row3.init();
    row3.addValue(sqlText("total_rows"));
    row3.addValue(sqlInteger(totalRows));
    result.addRow(row3);

    return result;
}

//=============================================================================
// SYS.USERS — Registered database users
//=============================================================================

func viewSysUsers(server: DatabaseServer) -> QueryResult {
    var result = new QueryResult();
    result.init();

    result.addColumnName("username");
    result.addColumnName("is_superuser");

    var users = server.listUsers();
    var i = 0;
    while i < users.count() {
        var row = new Row();
        row.init();
        var username = users.get(i);
        row.addValue(sqlText(username));
        if username == "admin" {
            row.addValue(sqlText("YES"));
        } else {
            row.addValue(sqlText("NO"));
        }
        result.addRow(row);
        i = i + 1;
    }

    return result;
}

//=============================================================================
// HELPERS
//=============================================================================

// Convert a privilege bitmask to individual privilege name strings
func expandPrivileges(mask: Integer) -> List[String] {
    var privs: List[String] = [];
    // Use integer division to extract bits (Zia has no bitwise operators)
    var selectBit = (mask / 1) - ((mask / 2) * 2);
    var insertBit = (mask / 2) - ((mask / 4) * 2);
    var updateBit = (mask / 4) - ((mask / 8) * 2);
    var deleteBit = (mask / 8) - ((mask / 16) * 2);
    if selectBit != 0 { privs.add("SELECT"); }
    if insertBit != 0 { privs.add("INSERT"); }
    if updateBit != 0 { privs.add("UPDATE"); }
    if deleteBit != 0 { privs.add("DELETE"); }
    return privs;
}

//=============================================================================
// INFORMATION_SCHEMA.TABLE_PRIVILEGES
//=============================================================================

func viewTablePrivileges(server: DatabaseServer) -> QueryResult {
    var result = new QueryResult();
    result.init();

    result.addColumnName("grantor");
    result.addColumnName("grantee");
    result.addColumnName("table_name");
    result.addColumnName("privilege_type");

    var i = 0;
    while i < server.privGrantees.count() {
        var grantee = server.privGrantees.get(i);
        var tableName = server.privTableNames.get(i);
        var mask = server.privBitmasks.get(i);

        // Find the table owner as grantor
        var grantor = "";
        var oi = 0;
        while oi < server.ownedTableNames.count() {
            if server.ownedTableNames.get(oi) == tableName {
                grantor = server.tableOwners.get(oi);
                oi = server.ownedTableNames.count();
            }
            oi = oi + 1;
        }

        // Expand bitmask into individual privilege rows
        var privNames = expandPrivileges(mask);
        var pi = 0;
        while pi < privNames.count() {
            var row = new Row();
            row.init();
            row.addValue(sqlText(grantor));
            row.addValue(sqlText(grantee));
            row.addValue(sqlText(tableName));
            row.addValue(sqlText(privNames.get(pi)));
            result.addRow(row);
            pi = pi + 1;
        }
        i = i + 1;
    }

    return result;
}

func columnTypeName(dataType: Integer) -> String {
    if dataType == SQL_INTEGER { return "INTEGER"; }
    if dataType == SQL_REAL { return "REAL"; }
    if dataType == SQL_TEXT { return "TEXT"; }
    if dataType == SQL_BLOB { return "BLOB"; }
    if dataType == SQL_BOOLEAN { return "BOOLEAN"; }
    if dataType == SQL_DATE { return "DATE"; }
    if dataType == SQL_TIMESTAMP { return "TIMESTAMP"; }
    if dataType == SQL_JSON { return "JSON"; }
    return "UNKNOWN";
}

//=============================================================================
// OID GENERATION
//=============================================================================

// Simple OID generator: hash of object name for stable pseudo-OIDs
func generateOid(name: String) -> Integer {
    var h = Viper.Crypto.Hash.Fast(name);
    if h < 0 { h = 0 - h; }
    // Map to positive range (avoid collision with PG system OIDs < 16384)
    return 16384 + (h % 100000);
}

// Map SQL type code to PostgreSQL type OID
func sqlTypeToPgOid(typeCode: Integer) -> Integer {
    if typeCode == SQL_INTEGER { return 23; }      // int4
    if typeCode == SQL_REAL { return 701; }         // float8
    if typeCode == SQL_TEXT { return 25; }           // text
    if typeCode == SQL_BOOLEAN { return 16; }        // bool
    if typeCode == SQL_DATE { return 1082; }         // date
    if typeCode == SQL_TIMESTAMP { return 1114; }    // timestamp
    if typeCode == SQL_BLOB { return 17; }           // bytea
    if typeCode == SQL_JSON { return 114; }          // json
    return 25; // default to text
}

// Map SQL type code to PostgreSQL type name
func sqlTypeToPgName(typeCode: Integer) -> String {
    if typeCode == SQL_INTEGER { return "int4"; }
    if typeCode == SQL_REAL { return "float8"; }
    if typeCode == SQL_TEXT { return "text"; }
    if typeCode == SQL_BOOLEAN { return "bool"; }
    if typeCode == SQL_DATE { return "date"; }
    if typeCode == SQL_TIMESTAMP { return "timestamp"; }
    if typeCode == SQL_BLOB { return "bytea"; }
    if typeCode == SQL_JSON { return "json"; }
    return "text";
}

//=============================================================================
// PG_CATALOG.PG_CLASS  — tables, indexes, sequences, views
//=============================================================================

func viewPgClass(server: DatabaseServer, currentDbName: String) -> QueryResult {
    var result = new QueryResult();
    result.init();

    result.addColumnName("oid");
    result.addColumnName("relname");
    result.addColumnName("relnamespace");
    result.addColumnName("relkind");
    result.addColumnName("reltuples");
    result.addColumnName("relhasindex");

    var di = 0;
    while di < server.dbNames.count() {
        var dbName = server.dbNames.get(di);
        var db = server.dbList.get(di);
        var nsOid = generateOid("ns_" + dbName);

        // Tables (relkind = 'r')
        var ti = 0;
        while ti < db.tableCount() {
            var maybeTable = db.getTable(ti);
            if maybeTable != null {
                var table = maybeTable;
                var oid = generateOid(dbName + "." + table.name);
                var row = new Row();
                row.init();
                row.addValue(sqlInteger(oid));
                row.addValue(sqlText(table.name));
                row.addValue(sqlInteger(nsOid));
                row.addValue(sqlText("r"));
                row.addValue(sqlInteger(table.rowCount()));
                // Check if table has any indexes
                var hasIdx = false;
                if di < server.indexManagers.count() {
                    var im = server.indexManagers.get(di);
                    var ii = 0;
                    while ii < im.indexCount() {
                        var maybeIdx = im.getIndex(ii);
                        if maybeIdx != null {
                            var idx = maybeIdx;
                            if idx.tableName == table.name {
                                hasIdx = true;
                                ii = im.indexCount();  // break
                            }
                        }
                        ii = ii + 1;
                    }
                }
                if hasIdx {
                    row.addValue(sqlText("t"));
                } else {
                    row.addValue(sqlText("f"));
                }
                result.addRow(row);
            }
            ti = ti + 1;
        }

        // Views (relkind = 'v')
        var vi = 0;
        while vi < db.viewNames.count() {
            var viewName = db.viewNames.get(vi);
            var oid = generateOid(dbName + "." + viewName);
            var row = new Row();
            row.init();
            row.addValue(sqlInteger(oid));
            row.addValue(sqlText(viewName));
            row.addValue(sqlInteger(nsOid));
            row.addValue(sqlText("v"));
            row.addValue(sqlInteger(0));
            row.addValue(sqlText("f"));
            result.addRow(row);
            vi = vi + 1;
        }

        // Indexes (relkind = 'i')
        if di < server.indexManagers.count() {
            var im = server.indexManagers.get(di);
            var ii = 0;
            while ii < im.indexCount() {
                var maybeIdx = im.getIndex(ii);
                if maybeIdx != null {
                    var idx = maybeIdx;
                    var oid = generateOid(dbName + ".idx." + idx.name);
                    var row = new Row();
                    row.init();
                    row.addValue(sqlInteger(oid));
                    row.addValue(sqlText(idx.name));
                    row.addValue(sqlInteger(nsOid));
                    row.addValue(sqlText("i"));
                    row.addValue(sqlInteger(idx.entryCount()));
                    row.addValue(sqlText("f"));
                    result.addRow(row);
                }
                ii = ii + 1;
            }
        }

        di = di + 1;
    }

    return result;
}

//=============================================================================
// PG_CATALOG.PG_ATTRIBUTE  — columns of all relations
//=============================================================================

func viewPgAttribute(server: DatabaseServer, currentDbName: String) -> QueryResult {
    var result = new QueryResult();
    result.init();

    result.addColumnName("attrelid");
    result.addColumnName("attname");
    result.addColumnName("atttypid");
    result.addColumnName("attnum");
    result.addColumnName("attnotnull");
    result.addColumnName("atthasdef");

    var di = 0;
    while di < server.dbNames.count() {
        var dbName = server.dbNames.get(di);
        var db = server.dbList.get(di);
        var ti = 0;
        while ti < db.tableCount() {
            var maybeTable = db.getTable(ti);
            if maybeTable != null {
                var table = maybeTable;
                var relOid = generateOid(dbName + "." + table.name);
                var ci = 0;
                while ci < table.columnCount() {
                    var col = table.getColumn(ci);
                    var row = new Row();
                    row.init();
                    row.addValue(sqlInteger(relOid));
                    row.addValue(sqlText(col.name));
                    row.addValue(sqlInteger(sqlTypeToPgOid(col.typeCode)));
                    row.addValue(sqlInteger(ci + 1));
                    if col.notNull {
                        row.addValue(sqlText("t"));
                    } else {
                        row.addValue(sqlText("f"));
                    }
                    if col.hasDefault {
                        row.addValue(sqlText("t"));
                    } else {
                        row.addValue(sqlText("f"));
                    }
                    result.addRow(row);
                    ci = ci + 1;
                }
            }
            ti = ti + 1;
        }
        di = di + 1;
    }

    return result;
}

//=============================================================================
// PG_CATALOG.PG_TYPE  — data types
//=============================================================================

func viewPgType() -> QueryResult {
    var result = new QueryResult();
    result.init();

    result.addColumnName("oid");
    result.addColumnName("typname");
    result.addColumnName("typlen");
    result.addColumnName("typtype");
    result.addColumnName("typnamespace");

    // Standard types supported by ViperSQL
    addTypeRow(result, 16, "bool", 1, "b");
    addTypeRow(result, 17, "bytea", -1, "b");
    addTypeRow(result, 23, "int4", 4, "b");
    addTypeRow(result, 25, "text", -1, "b");
    addTypeRow(result, 701, "float8", 8, "b");
    addTypeRow(result, 1082, "date", 4, "b");
    addTypeRow(result, 1114, "timestamp", 8, "b");
    addTypeRow(result, 1043, "varchar", -1, "b");
    addTypeRow(result, 114, "json", -1, "b");
    addTypeRow(result, 3802, "jsonb", -1, "b");

    return result;
}

func addTypeRow(result: QueryResult, oid: Integer, name: String, len: Integer, typtype: String) {
    var row = new Row();
    row.init();
    row.addValue(sqlInteger(oid));
    row.addValue(sqlText(name));
    row.addValue(sqlInteger(len));
    row.addValue(sqlText(typtype));
    row.addValue(sqlInteger(11));  // pg_catalog namespace OID
    result.addRow(row);
}

//=============================================================================
// PG_CATALOG.PG_NAMESPACE  — schemas
//=============================================================================

func viewPgNamespace(server: DatabaseServer) -> QueryResult {
    var result = new QueryResult();
    result.init();

    result.addColumnName("oid");
    result.addColumnName("nspname");
    result.addColumnName("nspowner");

    // pg_catalog namespace
    var row1 = new Row();
    row1.init();
    row1.addValue(sqlInteger(11));
    row1.addValue(sqlText("pg_catalog"));
    row1.addValue(sqlInteger(10));
    result.addRow(row1);

    // public namespace (one per database)
    var di = 0;
    while di < server.dbNames.count() {
        var dbName = server.dbNames.get(di);
        var nsOid = generateOid("ns_" + dbName);
        var row = new Row();
        row.init();
        row.addValue(sqlInteger(nsOid));
        row.addValue(sqlText("public"));
        row.addValue(sqlInteger(10));
        result.addRow(row);
        di = di + 1;
    }

    // information_schema namespace
    var row2 = new Row();
    row2.init();
    row2.addValue(sqlInteger(12));
    row2.addValue(sqlText("information_schema"));
    row2.addValue(sqlInteger(10));
    result.addRow(row2);

    return result;
}

//=============================================================================
// PG_CATALOG.PG_INDEX  — index metadata
//=============================================================================

func viewPgIndex(server: DatabaseServer, currentDbName: String) -> QueryResult {
    var result = new QueryResult();
    result.init();

    result.addColumnName("indexrelid");
    result.addColumnName("indrelid");
    result.addColumnName("indnatts");
    result.addColumnName("indisunique");
    result.addColumnName("indisprimary");
    result.addColumnName("indkey");

    var di = 0;
    while di < server.dbNames.count() {
        var dbName = server.dbNames.get(di);
        var db = server.dbList.get(di);
        if di < server.indexManagers.count() {
            var im = server.indexManagers.get(di);
            var ii = 0;
            while ii < im.indexCount() {
                var maybeIdx = im.getIndex(ii);
                if maybeIdx != null {
                    var idx = maybeIdx;
                    var indexOid = generateOid(dbName + ".idx." + idx.name);
                    var tableOid = generateOid(dbName + "." + idx.tableName);

                    // Build indkey (column ordinal positions as space-separated string)
                    var indkey = "";
                    var table = db.findTable(idx.tableName);
                    var ci = 0;
                    while ci < idx.columnCount() {
                        if ci > 0 { indkey = indkey + " "; }
                        if table != null {
                            var t = table;
                            var colIdx = t.findColumnIndex(idx.getColumnName(ci));
                            indkey = indkey + Fmt.Int(colIdx + 1);
                        } else {
                            indkey = indkey + Fmt.Int(ci + 1);
                        }
                        ci = ci + 1;
                    }

                    var row = new Row();
                    row.init();
                    row.addValue(sqlInteger(indexOid));
                    row.addValue(sqlInteger(tableOid));
                    row.addValue(sqlInteger(idx.columnCount()));
                    if idx.isUnique {
                        row.addValue(sqlText("t"));
                    } else {
                        row.addValue(sqlText("f"));
                    }
                    row.addValue(sqlText("f"));  // indisprimary (no PK index tracking yet)
                    row.addValue(sqlText(indkey));
                    result.addRow(row);
                }
                ii = ii + 1;
            }
        }
        di = di + 1;
    }

    return result;
}

//=============================================================================
// PG_CATALOG.PG_DATABASE  — databases
//=============================================================================

func viewPgDatabase(server: DatabaseServer) -> QueryResult {
    var result = new QueryResult();
    result.init();

    result.addColumnName("oid");
    result.addColumnName("datname");
    result.addColumnName("datdba");
    result.addColumnName("encoding");
    result.addColumnName("datcollate");

    var di = 0;
    while di < server.dbNames.count() {
        var dbName = server.dbNames.get(di);
        var oid = generateOid("db_" + dbName);
        var row = new Row();
        row.init();
        row.addValue(sqlInteger(oid));
        row.addValue(sqlText(dbName));
        row.addValue(sqlInteger(10));       // owner = superuser (OID 10)
        row.addValue(sqlInteger(6));        // UTF-8 encoding
        row.addValue(sqlText("en_US.UTF-8"));
        result.addRow(row);
        di = di + 1;
    }

    return result;
}

//=============================================================================
// PG_CATALOG.PG_PROC  — functions/procedures
//=============================================================================

func viewPgProc(server: DatabaseServer) -> QueryResult {
    var result = new QueryResult();
    result.init();

    result.addColumnName("oid");
    result.addColumnName("proname");
    result.addColumnName("pronargs");
    result.addColumnName("prorettype");
    result.addColumnName("prolang");

    // No access to FunctionManager from here (it's per-executor, not server-level)
    // Return empty result for now — functions are session-scoped
    return result;
}

//=============================================================================
// PG_CATALOG.PG_SETTINGS  — server configuration
//=============================================================================

func viewPgSettings() -> QueryResult {
    var result = new QueryResult();
    result.init();

    result.addColumnName("name");
    result.addColumnName("setting");
    result.addColumnName("unit");
    result.addColumnName("category");
    result.addColumnName("description");

    addSettingRow(result, "server_version", "15.0", "", "Version", "ViperSQL (PostgreSQL-compatible)");
    addSettingRow(result, "server_encoding", "UTF8", "", "Client", "Server character set encoding");
    addSettingRow(result, "client_encoding", "UTF8", "", "Client", "Client character set encoding");
    addSettingRow(result, "max_connections", "100", "", "Connections", "Maximum number of connections");
    addSettingRow(result, "default_transaction_isolation", "read committed", "", "Transactions", "Default transaction isolation level");
    addSettingRow(result, "search_path", "public", "", "Client", "Schema search path");
    addSettingRow(result, "timezone", "UTC", "", "Client", "Time zone");
    addSettingRow(result, "standard_conforming_strings", "on", "", "Client", "Standard conforming strings");

    return result;
}

func addSettingRow(result: QueryResult, name: String, setting: String, unit: String, category: String, desc: String) {
    var row = new Row();
    row.init();
    row.addValue(sqlText(name));
    row.addValue(sqlText(setting));
    row.addValue(sqlText(unit));
    row.addValue(sqlText(category));
    row.addValue(sqlText(desc));
    result.addRow(row);
}
