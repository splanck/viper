// token.zia â€” Token Types and Token Entity
// Part of ViperSQL
//
// Defines the TK_* constants for every SQL token kind (keywords,
// operators, literals, punctuation) and the Token entity that carries
// the kind, text, and source location (line/column) for error reporting.
// Used by the Lexer to produce tokens and by the Parser to match them.

module token;

bind Fmt = Viper.Fmt;

//=============================================================================
// TOKEN TYPE CONSTANTS
//=============================================================================

// Token type constants
final TK_EOF = 0;
final TK_ERROR = 1;

// Literals
final TK_INTEGER = 10;
final TK_NUMBER = 11;
final TK_STRING = 12;
final TK_IDENTIFIER = 13;

// Keywords - DDL
final TK_CREATE = 20;
final TK_TABLE = 21;
final TK_DROP = 22;
final TK_ALTER = 23;
final TK_INDEX = 24;
final TK_VIEW = 25;
final TK_TRIGGER = 26;

// Keywords - DML
final TK_SELECT = 30;
final TK_INSERT = 31;
final TK_UPDATE = 32;
final TK_DELETE = 33;
final TK_INTO = 34;
final TK_FROM = 35;
final TK_WHERE = 36;
final TK_SET = 37;
final TK_VALUES = 38;

// Keywords - Clauses
final TK_ORDER = 40;
final TK_BY = 41;
final TK_ASC = 42;
final TK_DESC = 43;
final TK_LIMIT = 44;
final TK_OFFSET = 45;
final TK_GROUP = 46;
final TK_HAVING = 47;
final TK_DISTINCT = 48;

// Keywords - Joins
final TK_JOIN = 50;
final TK_INNER = 51;
final TK_LEFT = 52;
final TK_RIGHT = 53;
final TK_FULL = 54;
final TK_OUTER = 55;
final TK_CROSS = 56;
final TK_ON = 57;

// Keywords - Logical
final TK_AND = 60;
final TK_OR = 61;
final TK_NOT = 62;
final TK_IN = 63;
final TK_IS = 64;
final TK_LIKE = 65;
final TK_BETWEEN = 66;
final TK_EXISTS = 67;

// Keywords - Values
final TK_NULL = 70;
final TK_TRUE = 71;
final TK_FALSE = 72;
final TK_DEFAULT = 73;

// Keywords - Constraints
final TK_PRIMARY = 80;
final TK_FOREIGN = 81;
final TK_KEY = 82;
final TK_REFERENCES = 83;
final TK_UNIQUE = 84;
final TK_CHECK = 85;
final TK_CONSTRAINT = 86;
final TK_AUTOINCREMENT = 87;

// Keywords - Types
final TK_INT = 90;
final TK_INTEGER_TYPE = 91;
final TK_REAL = 92;
final TK_TEXT = 93;
final TK_BLOB = 94;
final TK_BOOLEAN = 95;
final TK_VARCHAR = 96;
final TK_DATE_TYPE = 97;
final TK_TIMESTAMP_TYPE = 98;

// Keywords - Transactions
final TK_BEGIN = 100;
final TK_COMMIT = 101;
final TK_ROLLBACK = 102;
final TK_TRANSACTION = 103;
final TK_SAVEPOINT = 104;
final TK_RELEASE = 105;

// Keywords - Other
final TK_AS = 110;
final TK_CASE = 111;
final TK_WHEN = 112;
final TK_THEN = 113;
final TK_ELSE = 114;
final TK_END = 115;
final TK_UNION = 116;
final TK_ALL = 117;
final TK_CAST = 118;
final TK_EXCEPT = 137;
final TK_INTERSECT = 138;

// Keywords - Utility
final TK_SHOW = 120;
final TK_DESCRIBE = 121;
final TK_EXPLAIN = 122;
final TK_VACUUM = 123;
final TK_SAVE = 124;
final TK_OPEN = 125;
final TK_EXPORT = 126;
final TK_IMPORT = 127;
final TK_HELP = 128;
final TK_TO = 129;
final TK_ADD = 130;
final TK_COLUMN = 131;
final TK_RENAME = 132;
final TK_IF = 133;

// Keywords - Multi-Database (Phase 1)
final TK_DATABASE = 134;
final TK_DATABASES = 135;
final TK_USE = 136;

// Keywords - Persistent Storage (Phase 2)
// NOTE: TK_CLOSE and TK_FILE were previously 137/138, colliding with TK_EXCEPT/TK_INTERSECT
final TK_CLOSE = 219;
final TK_FILE = 220;

// Keywords - FK Actions (Phase 3)
final TK_CASCADE = 139;
final TK_RESTRICT = 170;
final TK_ACTION = 171;

// Keywords - User Management (Phase 10)
final TK_USER = 213;
final TK_PASSWORD = 215;

// Keywords - Privileges (Phase 13)
final TK_GRANT = 216;
final TK_REVOKE = 217;
final TK_PRIVILEGES = 218;

// Keywords - Row Locking (Phase 14)
final TK_FOR = 221;
final TK_SHARE = 222;
final TK_NOWAIT = 223;
final TK_LOCKED = 224;
final TK_SKIP = 225;

// Keywords - Triggers (Phase 17)
final TK_BEFORE = 226;
final TK_AFTER = 227;
final TK_EACH = 228;
final TK_EXECUTE = 229;

// Keywords - Sequences (Phase 18)
final TK_SEQUENCE = 232;
final TK_START = 233;
final TK_INCREMENT = 234;
final TK_MINVALUE = 235;
final TK_MAXVALUE = 236;
final TK_CYCLE = 237;
final TK_NO = 238;

// Keywords - Stored Functions (Phase 19)
final TK_FUNCTION = 239;
final TK_RETURNS = 240;
final TK_LANGUAGE = 241;

// Keywords - JSON types (Phase 25)
final TK_JSON = 242;
final TK_JSONB = 243;
final TK_ANALYZE = 244;
final TK_VERBOSE = 245;

// Phase 29: Common SQL extensions
final TK_TRUNCATE = 246;
final TK_RETURNING = 247;
final TK_CONFLICT = 248;
final TK_DO = 249;
final TK_NOTHING = 250;

// Phase 30: Prepared statements
final TK_PREPARE = 251;
final TK_DEALLOCATE = 252;

// Phase 32: Cursors
final TK_DECLARE = 253;
final TK_CURSOR = 254;
final TK_FETCH = 255;
final TK_MOVE = 256;
final TK_FORWARD = 257;
final TK_BACKWARD = 258;
final TK_ABSOLUTE = 259;
final TK_RELATIVE = 260;
final TK_NEXT = 261;
final TK_PRIOR = 262;
final TK_FIRST = 263;
final TK_LAST = 264;

// Phase 34: COPY
final TK_COPY = 265;
final TK_STDIN = 266;
final TK_STDOUT = 267;
final TK_FORMAT = 268;
final TK_HEADER = 269;
final TK_DELIMITER = 270;
final TK_CALL = 271;

// Phase 36: Arrays
final TK_ARRAY = 272;
final TK_LBRACKET = 273;
final TK_RBRACKET = 274;

// Phase 37: Materialized Views
final TK_MATERIALIZED = 275;
final TK_REFRESH = 276;

// Phase 38: SQL Expression Enhancements
final TK_ILIKE = 277;
final TK_REPLACE = 278;

// Phase 43: COMMENT ON, SET/SHOW session variables
final TK_COMMENT = 279;
final TK_RESET = 280;

// Phase 51: Regular Expressions
final TK_SIMILAR = 281;
final TK_TILDE = 282;       // ~
final TK_TILDE_STAR = 283;  // ~*

// Phase 52: Table Inheritance
final TK_INHERITS = 284;
final TK_ONLY = 285;

// Phase 53: Generated Columns
final TK_GENERATED = 286;
final TK_ALWAYS = 287;
final TK_STORED = 288;

// Phase 54: FILTER clause
final TK_FILTER = 289;

// Phase 55: LATERAL joins
final TK_LATERAL = 290;

// Phase 56: NATURAL JOIN
final TK_NATURAL = 291;

// Phase 59: GROUPING SETS / ROLLUP / CUBE
final TK_ROLLUP = 292;
final TK_CUBE = 293;
final TK_GROUPING = 294;

// Phase 73: MERGE INTO
final TK_MERGE = 295;
final TK_MATCHED = 296;

// Keywords - Phase 4: CTEs, Window Functions, Multi-table DML
final TK_WITH = 200;
final TK_OVER = 201;
final TK_PARTITION = 202;
final TK_USING = 203;
final TK_ROWS = 204;
final TK_RANGE = 205;
final TK_UNBOUNDED = 206;
final TK_PRECEDING = 207;
final TK_FOLLOWING = 208;
final TK_CURRENT = 209;
final TK_ROW = 210;
final TK_RECURSIVE = 211;
final TK_TEMPORARY = 212;

// Operators
final TK_PLUS = 140;
final TK_MINUS = 141;
final TK_STAR = 142;
final TK_SLASH = 143;
final TK_PERCENT = 144;
final TK_EQ = 145;
final TK_NE = 146;
final TK_LT = 147;
final TK_LE = 148;
final TK_GT = 149;
final TK_GE = 150;
final TK_CONCAT = 151;

// Punctuation
final TK_LPAREN = 160;
final TK_RPAREN = 161;
final TK_COMMA = 162;
final TK_SEMICOLON = 163;
final TK_DOT = 164;

//=============================================================================
// TOKEN ENTITY
//=============================================================================

entity Token {
    expose Integer kind;
    expose String text;
    expose Integer line;
    expose Integer column;

    expose func init(k: Integer, t: String, ln: Integer, col: Integer) {
        kind = k;
        text = t;
        line = ln;
        column = col;
    }

    expose func getText() -> String {
        return text;
    }

    expose func isKeyword() -> Boolean {
        return kind >= 20 && kind < 140;
    }

    expose func isOperator() -> Boolean {
        return kind >= 140 && kind < 160;
    }

    expose func isPunctuation() -> Boolean {
        return kind >= 160;
    }

    expose func isLiteral() -> Boolean {
        return kind >= 10 && kind < 20;
    }

    expose func toString() -> String {
        return "Token(" + Fmt.Int(kind) + ", '" + text + "', " +
               Fmt.Int(line) + ":" + Fmt.Int(column) + ")";
    }
}

// Helper function to get token type name
func tokenTypeName(kind: Integer) -> String {
    if (kind == TK_EOF) { return "EOF"; }
    if (kind == TK_ERROR) { return "ERROR"; }
    if (kind == TK_INTEGER) { return "INTEGER"; }
    if (kind == TK_NUMBER) { return "NUMBER"; }
    if (kind == TK_STRING) { return "STRING"; }
    if (kind == TK_IDENTIFIER) { return "IDENTIFIER"; }
    if (kind == TK_SELECT) { return "SELECT"; }
    if (kind == TK_INSERT) { return "INSERT"; }
    if (kind == TK_UPDATE) { return "UPDATE"; }
    if (kind == TK_DELETE) { return "DELETE"; }
    if (kind == TK_CREATE) { return "CREATE"; }
    if (kind == TK_TABLE) { return "TABLE"; }
    if (kind == TK_DROP) { return "DROP"; }
    if (kind == TK_FROM) { return "FROM"; }
    if (kind == TK_WHERE) { return "WHERE"; }
    if (kind == TK_AND) { return "AND"; }
    if (kind == TK_OR) { return "OR"; }
    if (kind == TK_NOT) { return "NOT"; }
    if (kind == TK_NULL) { return "NULL"; }
    if (kind == TK_INTO) { return "INTO"; }
    if (kind == TK_VALUES) { return "VALUES"; }
    if (kind == TK_PLUS) { return "PLUS"; }
    if (kind == TK_MINUS) { return "MINUS"; }
    if (kind == TK_STAR) { return "STAR"; }
    if (kind == TK_SLASH) { return "SLASH"; }
    if (kind == TK_EQ) { return "EQ"; }
    if (kind == TK_NE) { return "NE"; }
    if (kind == TK_LT) { return "LT"; }
    if (kind == TK_GT) { return "GT"; }
    if (kind == TK_LE) { return "LE"; }
    if (kind == TK_GE) { return "GE"; }
    if (kind == TK_LPAREN) { return "LPAREN"; }
    if (kind == TK_RPAREN) { return "RPAREN"; }
    if (kind == TK_COMMA) { return "COMMA"; }
    if (kind == TK_SEMICOLON) { return "SEMICOLON"; }
    if (kind == TK_DOT) { return "DOT"; }
    if (kind == TK_TRUNCATE) { return "TRUNCATE"; }
    if (kind == TK_RETURNING) { return "RETURNING"; }
    if (kind == TK_CONFLICT) { return "CONFLICT"; }
    if (kind == TK_DO) { return "DO"; }
    if (kind == TK_NOTHING) { return "NOTHING"; }
    if (kind == TK_PREPARE) { return "PREPARE"; }
    if (kind == TK_DEALLOCATE) { return "DEALLOCATE"; }
    if (kind == TK_DECLARE) { return "DECLARE"; }
    if (kind == TK_CURSOR) { return "CURSOR"; }
    if (kind == TK_FETCH) { return "FETCH"; }
    if (kind == TK_MOVE) { return "MOVE"; }
    if (kind == TK_COPY) { return "COPY"; }
    if (kind == TK_CALL) { return "CALL"; }
    return "UNKNOWN(" + Fmt.Int(kind) + ")";
}
