// test_txn.zia - Transaction Manager Tests
// Part of ViperSQL - Phase 5 Testing

module test_txn;

bind "./storage/page";
bind "./storage/serializer";
bind "./storage/wal";
bind "./storage/txn";
bind "./types";

//=============================================================================
// TEST HARNESS
//=============================================================================

var testsPassed = 0;
var testsFailed = 0;

func assert(condition: Boolean, testName: String) {
    if condition {
        testsPassed = testsPassed + 1;
        Viper.Terminal.Say("[PASS] " + testName);
    } else {
        testsFailed = testsFailed + 1;
        Viper.Terminal.Say("[FAIL] " + testName);
    }
}

func printSummary() {
    Viper.Terminal.Say("");
    Viper.Terminal.Say("===========================================");
    Viper.Terminal.Say("TRANSACTION MANAGER TEST SUMMARY");
    Viper.Terminal.Say("===========================================");
    Viper.Terminal.Say("Passed: " + Viper.Fmt.Int(testsPassed));
    Viper.Terminal.Say("Failed: " + Viper.Fmt.Int(testsFailed));
    Viper.Terminal.Say("Total:  " + Viper.Fmt.Int(testsPassed + testsFailed));
    Viper.Terminal.Say("===========================================");
}

//=============================================================================
// TRANSACTION ENTITY TESTS
//=============================================================================

func testTransactionInit() {
    Viper.Terminal.Say("");
    Viper.Terminal.Say("--- Transaction Tests ---");

    var txn = new Transaction();
    txn.init();

    assert(txn.txnId == 0, "Transaction init sets txnId to 0");
    assert(txn.state == TXN_ACTIVE, "Transaction init sets state to ACTIVE");
    assert(txn.isActive() == true, "Transaction isActive returns true");
    assert(txn.isCommitted() == false, "Transaction isCommitted returns false");
    assert(txn.isAborted() == false, "Transaction isAborted returns false");
}

func testTransactionWithId() {
    var txn = new Transaction();
    txn.initWithId(42, 1000);

    assert(txn.txnId == 42, "Transaction stores txnId");
    assert(txn.startTimestamp == 1000, "Transaction stores startTimestamp");
}

func testTransactionModifiedPages() {
    var txn = new Transaction();
    txn.init();

    txn.addModifiedPage(10);
    txn.addModifiedPage(20);
    txn.addModifiedPage(10);  // Duplicate

    assert(txn.modifiedPages.count() == 2, "Transaction tracks unique modified pages");
    assert(txn.modifiedPages.get(0) == 10, "First modified page is 10");
    assert(txn.modifiedPages.get(1) == 20, "Second modified page is 20");
}

func testTransactionInsertedRows() {
    var txn = new Transaction();
    txn.init();

    txn.addInsertedRow(1, 100);
    txn.addInsertedRow(2, 200);

    assert(txn.insertedRows.count() == 2, "Transaction tracks inserted rows");
}

func testTransactionToString() {
    var txn = new Transaction();
    txn.initWithId(5, 100);

    var str = txn.toString();
    assert(Viper.String.Length(str) > 0, "Transaction has string representation");
}

//=============================================================================
// LOCK TESTS
//=============================================================================

func testLockInit() {
    Viper.Terminal.Say("");
    Viper.Terminal.Say("--- Lock Tests ---");

    var lock = new Lock();
    lock.init();

    assert(lock.resourceType == 0, "Lock init sets resourceType to 0");
    assert(lock.mode == LOCK_SHARED, "Lock init sets mode to SHARED");
}

func testLockTableInit() {
    var lock = new Lock();
    lock.initTableLock(10, LOCK_EXCLUSIVE, 1);

    assert(lock.resourceType == 0, "Table lock has resourceType 0");
    assert(lock.resourceId == 10, "Table lock stores resourceId");
    assert(lock.mode == LOCK_EXCLUSIVE, "Table lock stores mode");
    assert(lock.txnId == 1, "Table lock stores txnId");
}

func testLockRowInit() {
    var lock = new Lock();
    lock.initRowLock(5, 100, LOCK_SHARED, 2);

    assert(lock.resourceType == 2, "Row lock has resourceType 2");
    assert(lock.tableId == 5, "Row lock stores tableId");
    assert(lock.resourceId == 100, "Row lock stores rowId");
    assert(lock.mode == LOCK_SHARED, "Row lock stores mode");
}

func testLockCompatibility() {
    var lock1 = new Lock();
    lock1.initTableLock(1, LOCK_SHARED, 1);

    var lock2 = new Lock();
    lock2.initTableLock(1, LOCK_SHARED, 2);

    var lock3 = new Lock();
    lock3.initTableLock(1, LOCK_EXCLUSIVE, 3);

    var lock4 = new Lock();
    lock4.initTableLock(2, LOCK_EXCLUSIVE, 4);

    assert(lock1.isCompatible(lock2) == true, "S + S is compatible");
    assert(lock1.isCompatible(lock3) == false, "S + X is not compatible");
    assert(lock3.isCompatible(lock1) == false, "X + S is not compatible");
    assert(lock1.isCompatible(lock4) == true, "Different resources are compatible");
}

func testLockToString() {
    var lock = new Lock();
    lock.initTableLock(5, LOCK_EXCLUSIVE, 10);

    var str = lock.toString();
    assert(Viper.String.Length(str) > 0, "Lock has string representation");
}

//=============================================================================
// LOCK MANAGER TESTS
//=============================================================================

func testLockManagerInit() {
    Viper.Terminal.Say("");
    Viper.Terminal.Say("--- LockManager Tests ---");

    var mgr = new LockManager();
    mgr.init();

    assert(mgr.lockCount() == 0, "LockManager starts with 0 locks");
}

func testLockManagerAcquire() {
    var mgr = new LockManager();
    mgr.init();

    var lock = new Lock();
    lock.initTableLock(1, LOCK_SHARED, 1);

    var acquired = mgr.acquireLock(lock);
    assert(acquired == true, "Can acquire lock on free resource");
    assert(mgr.lockCount() == 1, "Lock count is 1 after acquire");
}

func testLockManagerConflict() {
    var mgr = new LockManager();
    mgr.init();

    var lock1 = new Lock();
    lock1.initTableLock(1, LOCK_EXCLUSIVE, 1);

    var lock2 = new Lock();
    lock2.initTableLock(1, LOCK_SHARED, 2);

    assert(mgr.acquireLock(lock1) == true, "First exclusive lock succeeds");
    assert(mgr.acquireLock(lock2) == false, "Conflicting shared lock fails");
}

func testLockManagerMultipleShared() {
    var mgr = new LockManager();
    mgr.init();

    var lock1 = new Lock();
    lock1.initTableLock(1, LOCK_SHARED, 1);

    var lock2 = new Lock();
    lock2.initTableLock(1, LOCK_SHARED, 2);

    assert(mgr.acquireLock(lock1) == true, "First shared lock succeeds");
    assert(mgr.acquireLock(lock2) == true, "Second shared lock succeeds");
    assert(mgr.lockCount() == 2, "Both shared locks acquired");
}

func testLockManagerRelease() {
    var mgr = new LockManager();
    mgr.init();

    var lock = new Lock();
    lock.initTableLock(1, LOCK_EXCLUSIVE, 1);

    mgr.acquireLock(lock);
    assert(mgr.lockCount() == 1, "Lock acquired");

    mgr.releaseLock(lock);
    assert(mgr.lockCount() == 0, "Lock released");
}

func testLockManagerReleaseAll() {
    var mgr = new LockManager();
    mgr.init();

    var lock1 = new Lock();
    lock1.initTableLock(1, LOCK_SHARED, 1);
    var lock2 = new Lock();
    lock2.initTableLock(2, LOCK_EXCLUSIVE, 1);
    var lock3 = new Lock();
    lock3.initTableLock(3, LOCK_SHARED, 2);

    mgr.acquireLock(lock1);
    mgr.acquireLock(lock2);
    mgr.acquireLock(lock3);
    assert(mgr.lockCount() == 3, "Three locks acquired");

    mgr.releaseAllLocks(1);
    assert(mgr.lockCount() == 1, "Only txn 2's lock remains");
}

func testLockManagerHoldsLock() {
    var mgr = new LockManager();
    mgr.init();

    var lock = new Lock();
    lock.initTableLock(5, LOCK_SHARED, 10);
    mgr.acquireLock(lock);

    assert(mgr.holdsLock(10, 0, 5) == true, "Txn 10 holds table lock 5");
    assert(mgr.holdsLock(10, 0, 6) == false, "Txn 10 does not hold table lock 6");
    assert(mgr.holdsLock(11, 0, 5) == false, "Txn 11 does not hold table lock 5");
}

//=============================================================================
// TRANSACTION MANAGER TESTS
//=============================================================================

func testTxnManagerInit() {
    Viper.Terminal.Say("");
    Viper.Terminal.Say("--- TransactionManager Tests ---");

    var tm = new TransactionManager();
    tm.init();

    assert(tm.nextTxnId == 1, "TxnManager starts with txnId 1");
    assert(tm.activeCount() == 0, "TxnManager starts with 0 active transactions");
    assert(tm.isAutoCommit() == true, "TxnManager default auto-commit is true");
}

func testTxnManagerBegin() {
    var tm = new TransactionManager();
    tm.init();

    var txn = tm.begin();
    assert(txn.txnId == 1, "First transaction has ID 1");
    assert(txn.isActive() == true, "New transaction is active");
    assert(tm.activeCount() == 1, "Active count is 1");

    var txn2 = tm.begin();
    assert(txn2.txnId == 2, "Second transaction has ID 2");
    assert(tm.activeCount() == 2, "Active count is 2");
}

func testTxnManagerCommit() {
    var tm = new TransactionManager();
    tm.init();

    var txn = tm.begin();
    assert(tm.activeCount() == 1, "Active count before commit");

    var committed = tm.commit(txn);
    assert(committed == true, "Commit returns true");
    assert(txn.isCommitted() == true, "Transaction is committed");
    assert(tm.activeCount() == 0, "Active count after commit is 0");
}

func testTxnManagerAbort() {
    var tm = new TransactionManager();
    tm.init();

    var txn = tm.begin();
    var aborted = tm.abort(txn);

    assert(aborted == true, "Abort returns true");
    assert(txn.isAborted() == true, "Transaction is aborted");
    assert(tm.activeCount() == 0, "Active count after abort is 0");
}

func testTxnManagerDoubleCommit() {
    var tm = new TransactionManager();
    tm.init();

    var txn = tm.begin();
    tm.commit(txn);

    var result = tm.commit(txn);
    assert(result == false, "Cannot commit already committed transaction");
}

func testTxnManagerLockTable() {
    var tm = new TransactionManager();
    tm.init();

    var txn = tm.begin();

    assert(tm.lockTableShared(txn, 1) == true, "Can acquire shared table lock");
    assert(txn.heldLocks.count() == 1, "Transaction holds 1 lock");
}

func testTxnManagerLockRow() {
    var tm = new TransactionManager();
    tm.init();

    var txn = tm.begin();

    assert(tm.lockRowExclusive(txn, 1, 100) == true, "Can acquire exclusive row lock");
    assert(txn.heldLocks.count() == 1, "Transaction holds 1 lock");
}

func testTxnManagerLocksReleasedOnCommit() {
    var tm = new TransactionManager();
    tm.init();

    var txn = tm.begin();
    tm.lockTableShared(txn, 1);
    tm.lockRowExclusive(txn, 1, 100);

    assert(tm.lockMgr.lockCount() == 2, "2 locks held before commit");

    tm.commit(txn);
    assert(tm.lockMgr.lockCount() == 0, "All locks released after commit");
}

func testTxnManagerLocksReleasedOnAbort() {
    var tm = new TransactionManager();
    tm.init();

    var txn = tm.begin();
    tm.lockTableExclusive(txn, 1);

    tm.abort(txn);
    assert(tm.lockMgr.lockCount() == 0, "All locks released after abort");
}

func testTxnManagerGetTransaction() {
    var tm = new TransactionManager();
    tm.init();

    var txn1 = tm.begin();
    var txn2 = tm.begin();

    var found = tm.getTransaction(txn1.txnId);
    assert(found != null, "Can find transaction by ID");
    if found != null {
        var f = found;
        assert(f.txnId == txn1.txnId, "Found transaction has correct ID");
    }

    var notFound = tm.getTransaction(999);
    assert(notFound == null, "Returns null for non-existent transaction");
}

func testTxnManagerGetActiveTxnIds() {
    var tm = new TransactionManager();
    tm.init();

    tm.begin();
    tm.begin();
    tm.begin();

    var ids = tm.getActiveTxnIds();
    assert(ids.count() == 3, "Returns 3 active transaction IDs");
    assert(ids.get(0) == 1, "First ID is 1");
    assert(ids.get(1) == 2, "Second ID is 2");
    assert(ids.get(2) == 3, "Third ID is 3");
}

func testTxnManagerAutoCommit() {
    var tm = new TransactionManager();
    tm.init();

    assert(tm.isAutoCommit() == true, "Default auto-commit is true");

    tm.setAutoCommit(false);
    assert(tm.isAutoCommit() == false, "Can disable auto-commit");

    tm.setAutoCommit(true);
    assert(tm.isAutoCommit() == true, "Can enable auto-commit");
}

func testTxnManagerLogging() {
    var tm = new TransactionManager();
    tm.init();

    var txn = tm.begin();

    // Log some operations
    var insertData = new BinaryBuffer();
    insertData.init();
    insertData.writeString("test row");

    tm.logInsert(txn, 1, 10, 0, insertData);
    assert(txn.modifiedPages.count() == 1, "Modified pages tracked after insert");

    var before = new BinaryBuffer();
    before.init();
    before.writeString("old");
    var after = new BinaryBuffer();
    after.init();
    after.writeString("new");

    tm.logUpdate(txn, 1, 10, 0, before, after);
    assert(txn.modifiedPages.count() == 1, "Same page not duplicated");

    tm.logDelete(txn, 1, 20, 1, before);
    assert(txn.modifiedPages.count() == 2, "New page added on delete");
}

func testTxnManagerConcurrentLocking() {
    Viper.Terminal.Say("");
    Viper.Terminal.Say("--- Concurrent Locking Tests ---");

    var tm = new TransactionManager();
    tm.init();

    var txn1 = tm.begin();
    var txn2 = tm.begin();

    // Both can get shared locks
    assert(tm.lockTableShared(txn1, 1) == true, "Txn1 gets shared lock");
    assert(tm.lockTableShared(txn2, 1) == true, "Txn2 gets shared lock (compatible)");

    tm.commit(txn1);
    tm.commit(txn2);
}

func testTxnManagerLockUpgrade() {
    var tm = new TransactionManager();
    tm.init();

    var txn1 = tm.begin();
    var txn2 = tm.begin();

    // Txn1 gets exclusive lock
    assert(tm.lockTableExclusive(txn1, 1) == true, "Txn1 gets exclusive lock");

    // Txn2 cannot get any lock on same table
    assert(tm.lockTableShared(txn2, 1) == false, "Txn2 cannot get shared lock");
    assert(tm.lockTableExclusive(txn2, 1) == false, "Txn2 cannot get exclusive lock");

    // After txn1 commits, txn2 can get lock
    tm.commit(txn1);
    assert(tm.lockTableExclusive(txn2, 1) == true, "Txn2 can get lock after txn1 commits");
}

//=============================================================================
// MAIN
//=============================================================================

func main() {
    Viper.Terminal.Say("===========================================");
    Viper.Terminal.Say("VIPERSQL TRANSACTION MANAGER TESTS");
    Viper.Terminal.Say("===========================================");

    // Transaction tests
    testTransactionInit();
    testTransactionWithId();
    testTransactionModifiedPages();
    testTransactionInsertedRows();
    testTransactionToString();

    // Lock tests
    testLockInit();
    testLockTableInit();
    testLockRowInit();
    testLockCompatibility();
    testLockToString();

    // LockManager tests
    testLockManagerInit();
    testLockManagerAcquire();
    testLockManagerConflict();
    testLockManagerMultipleShared();
    testLockManagerRelease();
    testLockManagerReleaseAll();
    testLockManagerHoldsLock();

    // TransactionManager tests
    testTxnManagerInit();
    testTxnManagerBegin();
    testTxnManagerCommit();
    testTxnManagerAbort();
    testTxnManagerDoubleCommit();
    testTxnManagerLockTable();
    testTxnManagerLockRow();
    testTxnManagerLocksReleasedOnCommit();
    testTxnManagerLocksReleasedOnAbort();
    testTxnManagerGetTransaction();
    testTxnManagerGetActiveTxnIds();
    testTxnManagerAutoCommit();
    testTxnManagerLogging();

    // Concurrent locking tests
    testTxnManagerConcurrentLocking();
    testTxnManagerLockUpgrade();

    printSummary();
}
