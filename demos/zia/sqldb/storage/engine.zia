// engine.zia - Storage Engine Adapter
// Bridges BufferPool/SchemaPage/DataPage to high-level database operations

module engine;

bind IO = Viper.IO;
bind String = Viper.String;
bind Terminal = Viper.Terminal;

bind "./page";
bind "./serializer";
bind "./pager";
bind "./buffer";
bind "./schema_page";
bind "./data_page";
bind "./wal";
bind "../types";
bind "../table";
bind "../schema";

//=============================================================================
// STORAGE ENGINE
//=============================================================================

entity StorageEngine {
    expose BufferPool pool;
    expose SchemaPageManager schemaMgr;
    expose DataPageManager dataMgr;
    expose String filename;
    expose Boolean isPersistent;

    // Cached table metadata (mirrors what's in the schema page)
    hide List[TableMeta] tableMetas;
    // Tracks the next table ID to assign
    hide Integer nextTableId;

    // Write-Ahead Log for crash recovery (Phase 4)
    expose WALManager wal;
    hide Integer nextTxnId;
    hide RowSerializer rowSerializer;
    hide Boolean walEnabled;

    // Last insert location for row tracking (Phase 5)
    expose Integer lastInsertPageId;
    expose Integer lastInsertSlotIdx;

    expose func init() {
        pool = new BufferPool();
        pool.init();
        schemaMgr = new SchemaPageManager();
        schemaMgr.init();
        dataMgr = new DataPageManager();
        dataMgr.init();
        filename = "";
        isPersistent = false;
        tableMetas = [];
        nextTableId = 1;
        wal = new WALManager();
        wal.init();
        nextTxnId = 1;
        rowSerializer = new RowSerializer();
        rowSerializer.init();
        walEnabled = false;
        lastInsertPageId = INVALID_PAGE_ID;
        lastInsertSlotIdx = -1;
        rowPageIds = [];
        rowSlotIdxs = [];
        rowTableNames = [];
    }

    //=========================================================================
    // DATABASE LIFECYCLE
    //=========================================================================

    // Create a new persistent database file
    expose func createDatabase(fname: String) -> Boolean {
        filename = fname;

        // Delete existing file if present
        if IO.File.Exists(fname) {
            IO.File.Delete(fname);
        }

        var ok = pool.createDatabase(fname);
        if ok == false {
            return false;
        }

        // Initialize schema page
        var schemaPage = pool.fetchPage(1);
        if schemaPage != null {
            var sp = schemaPage;
            schemaMgr.initSchemaPage(sp);
            pool.unpinPage(1, true);
        }

        pool.flushAll();
        isPersistent = true;
        tableMetas = [];
        nextTableId = 1;

        return true;
    }

    // Open an existing persistent database file
    expose func openDatabase(fname: String) -> Boolean {
        filename = fname;

        if IO.File.Exists(fname) == false {
            return false;
        }

        var ok = pool.openDatabase(fname);
        if ok == false {
            return false;
        }

        // Load schema metadata
        var schemaPage = pool.fetchPage(1);
        if schemaPage != null {
            var sp = schemaPage;
            tableMetas = schemaMgr.readAllTables(sp);
            pool.unpinPage(1, false);
        } else {
            tableMetas = [];
        }

        // Compute next table ID
        nextTableId = 1;
        var i = 0;
        while i < tableMetas.count() {
            var m = tableMetas.get(i);
            if m.tableId >= nextTableId {
                nextTableId = m.tableId + 1;
            }
            i = i + 1;
        }

        isPersistent = true;

        // Auto-enable WAL: check if WAL log files exist next to the database
        var walDir = fname + ".wal";
        var walFile0 = walDir + "/wal_0.log";
        if IO.File.Exists(walFile0) {
            enableWal(walDir);
            // Perform crash recovery if WAL files exist
            performRecovery();
        }

        return true;
    }

    // Perform WAL crash recovery (redo committed transactions)
    expose func performRecovery() -> RecoveryResult {
        if walEnabled == false {
            return createRecoveryResult(false);
        }

        // Phase 1: Analysis — read all WAL records, identify committed transactions
        var committedTxns: List[Integer] = [];
        var abortedTxns: List[Integer] = [];
        var activeTxns: List[Integer] = [];
        var allRecords: List[LogRecord] = [];

        var fileNum = 0;
        while fileNum <= wal.currentFile + 5 {
            var records = wal.readLogFile(fileNum);
            if records.count() == 0 && fileNum > wal.currentFile {
                fileNum = fileNum + 1;
                if fileNum > wal.currentFile + 5 {
                    // Stop scanning after 5 empty files past currentFile
                }
            } else {
                var ri = 0;
                while ri < records.count() {
                    var record = records.get(ri);
                    allRecords.add(record);

                    if record.recordType == LOG_BEGIN {
                        activeTxns.add(record.txnId);
                    } else if record.recordType == LOG_COMMIT {
                        committedTxns.add(record.txnId);
                        activeTxns = wal.removeTxnFromList(activeTxns, record.txnId);
                    } else if record.recordType == LOG_ABORT {
                        abortedTxns.add(record.txnId);
                        activeTxns = wal.removeTxnFromList(activeTxns, record.txnId);
                    }
                    ri = ri + 1;
                }
            }
            fileNum = fileNum + 1;
        }

        // Phase 2: Redo — replay committed INSERT operations
        var redoCount = 0;
        var ri = 0;
        while ri < allRecords.count() {
            var record = allRecords.get(ri);
            if record.recordType == LOG_INSERT {
                if wal.isTxnCommitted(committedTxns, record.txnId) {
                    // Check if this insert needs to be redone
                    // The row should be at (pageId, slotId) — verify it exists
                    if record.pageId != INVALID_PAGE_ID {
                        var page = pool.fetchPage(record.pageId);
                        if page != null {
                            var p = page;
                            // The page exists — check if slot is occupied
                            var slotCount = dataMgr.getRowCount(p);
                            if record.slotId >= slotCount {
                                // Slot doesn't exist yet — redo the insert
                                record.afterImage.seek(0);
                                var row = rowSerializer.deserializeRow(record.afterImage);
                                dataMgr.insertRow(p, row);
                                pool.unpinPage(record.pageId, true);
                                redoCount = redoCount + 1;
                            } else {
                                pool.unpinPage(record.pageId, false);
                            }
                        }
                    }
                }
            }
            ri = ri + 1;
        }

        // Phase 3: Flush recovered data and clean up WAL
        if redoCount > 0 {
            pool.flushAll();
        }
        wal.cleanupWalFiles();
        wal.resetState();

        // Build result
        var result = new RecoveryResult();
        result.init();
        result.recoveryComplete = true;
        result.committedTxns = committedTxns;
        result.abortedTxns = abortedTxns;
        result.activeTxnsAtCrash = activeTxns;
        result.redoCount = redoCount;
        return result;
    }

    // Close the database, flushing all dirty pages and WAL
    expose func closeDatabase() {
        if isPersistent {
            if walEnabled {
                // Checkpoint: flush WAL then data
                var activeTxns: List[Integer] = [];
                wal.checkpoint(activeTxns);
            }
            pool.flushAll();
            pool.closeDatabase();
            isPersistent = false;
        }
    }

    //=========================================================================
    // TABLE SCHEMA PERSISTENCE
    //=========================================================================

    // Persist a newly created table's schema to the database file
    // Returns the assigned table ID, or -1 on failure
    expose func persistTable(table: Table) -> Integer {
        if isPersistent == false {
            return -1;
        }

        // Create metadata for the table
        var meta = new TableMeta();
        meta.initFromTable(nextTableId, table);
        nextTableId = nextTableId + 1;

        // Allocate the first data page for this table
        var dataPage = pool.newPage(PAGE_TYPE_DATA);
        dataMgr.initDataPage(dataPage, meta.tableId);
        meta.firstDataPage = dataPage.pageId;
        pool.unpinPage(dataPage.pageId, true);

        // Write metadata to schema page
        var schemaPage = pool.fetchPage(1);
        if schemaPage != null {
            var sp = schemaPage;
            schemaMgr.addTable(sp, meta);
            pool.unpinPage(1, true);
        }

        tableMetas.add(meta);
        pool.flushAll();
        return meta.tableId;
    }

    // Remove a table's schema and data pages from storage
    expose func dropTableStorage(tableName: String) -> Boolean {
        if isPersistent == false {
            return false;
        }

        // Find the table metadata
        var meta = findMeta(tableName);
        if meta == null {
            return false;
        }
        var m = meta;

        // Free all data pages in the chain
        var pageId = m.firstDataPage;
        while pageId != INVALID_PAGE_ID {
            var page = pool.fetchPage(pageId);
            var nextPageId = INVALID_PAGE_ID;
            if page != null {
                var p = page;
                nextPageId = dataMgr.getNextPageId(p);
                pool.unpinPage(pageId, false);
            }
            pool.deletePage(pageId);
            pageId = nextPageId;
        }

        // Remove from schema page
        var schemaPage = pool.fetchPage(1);
        if schemaPage != null {
            var sp = schemaPage;
            schemaMgr.removeTable(sp, tableName);
            pool.unpinPage(1, true);
        }

        // Remove from cached metadata
        var newMetas: List[TableMeta] = [];
        var i = 0;
        while i < tableMetas.count() {
            var tm = tableMetas.get(i);
            if tm.tableName != tableName {
                newMetas.add(tm);
            }
            i = i + 1;
        }
        tableMetas = newMetas;

        pool.flushAll();
        return true;
    }

    //=========================================================================
    // TABLE DATA LOADING (Eager Load on Open)
    //=========================================================================

    // Load all tables from schema into in-memory Table entities
    expose func loadAllTables() -> List[Table] {
        var tables: List[Table] = [];

        var i = 0;
        while i < tableMetas.count() {
            var meta = tableMetas.get(i);
            var table = meta.toTable();

            // Load all rows for this table
            var rows = loadTableRows(meta);
            var j = 0;
            while j < rows.count() {
                table.addRow(rows.get(j));
                j = j + 1;
            }

            // Restore auto-increment value
            table.autoIncrementValue = meta.nextAutoIncrement;

            tables.add(table);
            i = i + 1;
        }

        return tables;
    }

    // Load all rows for a table by walking its data page chain
    // Also tracks row locations for Phase 5 incremental operations
    expose func loadTableRows(meta: TableMeta) -> List[Row] {
        var allRows: List[Row] = [];
        var pageId = meta.firstDataPage;

        while pageId != INVALID_PAGE_ID {
            var page = pool.fetchPage(pageId);
            if page != null {
                var p = page;
                var pageRows = dataMgr.forEachRow(p);
                var j = 0;
                while j < pageRows.count() {
                    allRows.add(pageRows.get(j));
                    // Track row location for incremental updates
                    trackRowLocation(meta.tableName, pageId, j);
                    j = j + 1;
                }
                var nextId = dataMgr.getNextPageId(p);
                pool.unpinPage(pageId, false);
                pageId = nextId;
            } else {
                pageId = INVALID_PAGE_ID;
            }
        }

        return allRows;
    }

    //=========================================================================
    // ROW PERSISTENCE (Write-Through on DML)
    //=========================================================================

    // Persist a single row insertion for a table
    expose func insertRowStorage(tableName: String, row: Row) -> Boolean {
        if isPersistent == false {
            return false;
        }

        var meta = findMeta(tableName);
        if meta == null {
            return false;
        }
        var m = meta;

        // WAL: begin implicit transaction
        var txnId = nextTxnId;
        nextTxnId = nextTxnId + 1;
        if walEnabled {
            wal.logBegin(txnId);
        }

        // Walk data page chain to find a page with space
        var pageId = m.firstDataPage;
        var lastPageId = INVALID_PAGE_ID;

        while pageId != INVALID_PAGE_ID {
            var page = pool.fetchPage(pageId);
            if page != null {
                var p = page;
                if dataMgr.canFitRow(p, row) {
                    // Insert here
                    var slot = dataMgr.insertRow(p, row);
                    pool.unpinPage(pageId, true);
                    if slot >= 0 {
                        // WAL: log the insert
                        if walEnabled {
                            var rowBuf = serializeRow(row);
                            wal.logInsert(txnId, m.tableId, pageId, slot, rowBuf);
                            wal.logCommit(txnId);
                        }
                        // Track insert location for Phase 5 row tracking
                        lastInsertPageId = pageId;
                        lastInsertSlotIdx = slot;
                        // Update row count in metadata
                        m.rowCount = m.rowCount + 1;
                        updateMetaInSchema(m);
                        pool.flushAll();
                        return true;
                    }
                }
                lastPageId = pageId;
                var nextId = dataMgr.getNextPageId(p);
                pool.unpinPage(pageId, false);
                pageId = nextId;
            } else {
                pageId = INVALID_PAGE_ID;
            }
        }

        // No page had space — allocate a new data page
        var newPage = pool.newPage(PAGE_TYPE_DATA);
        dataMgr.initDataPage(newPage, m.tableId);

        // Link the new page to the chain
        if lastPageId != INVALID_PAGE_ID {
            var lastPage = pool.fetchPage(lastPageId);
            if lastPage != null {
                var lp = lastPage;
                dataMgr.setNextPageId(lp, newPage.pageId);
                pool.unpinPage(lastPageId, true);
            }
        } else {
            // First data page was never set (shouldn't happen)
            m.firstDataPage = newPage.pageId;
        }

        var slot = dataMgr.insertRow(newPage, row);
        pool.unpinPage(newPage.pageId, true);

        if slot >= 0 {
            // WAL: log the insert
            if walEnabled {
                var rowBuf = serializeRow(row);
                wal.logInsert(txnId, m.tableId, newPage.pageId, slot, rowBuf);
                wal.logCommit(txnId);
            }
            // Track insert location for Phase 5 row tracking
            lastInsertPageId = newPage.pageId;
            lastInsertSlotIdx = slot;
            m.rowCount = m.rowCount + 1;
            updateMetaInSchema(m);
            pool.flushAll();
            return true;
        }

        // WAL: abort on failure
        if walEnabled {
            wal.logAbort(txnId);
        }
        return false;
    }

    // Rewrite all rows for a table (used after UPDATE/DELETE)
    // Drops all existing data pages and re-inserts the given rows
    expose func rewriteTableRows(tableName: String, rows: List[Row]) -> Boolean {
        if isPersistent == false {
            return false;
        }

        var meta = findMeta(tableName);
        if meta == null {
            return false;
        }
        var m = meta;

        // WAL: begin implicit transaction for the rewrite
        var txnId = nextTxnId;
        nextTxnId = nextTxnId + 1;
        if walEnabled {
            wal.logBegin(txnId);
        }

        // Clear existing row tracking for this table — will be rebuilt below
        clearRowLocations(tableName);

        // Free all existing data pages
        var pageId = m.firstDataPage;
        while pageId != INVALID_PAGE_ID {
            var page = pool.fetchPage(pageId);
            var nextPageId = INVALID_PAGE_ID;
            if page != null {
                var p = page;
                nextPageId = dataMgr.getNextPageId(p);
                pool.unpinPage(pageId, false);
            }
            pool.deletePage(pageId);
            pageId = nextPageId;
        }

        // Allocate a fresh first data page
        var firstPage = pool.newPage(PAGE_TYPE_DATA);
        dataMgr.initDataPage(firstPage, m.tableId);
        m.firstDataPage = firstPage.pageId;

        // Insert all rows, allocating new pages as needed
        var currentPageId = firstPage.pageId;
        pool.unpinPage(firstPage.pageId, true);

        var i = 0;
        while i < rows.count() {
            var row = rows.get(i);
            var curPage = pool.fetchPage(currentPageId);
            if curPage != null {
                var cp = curPage;
                if dataMgr.canFitRow(cp, row) {
                    var slot = dataMgr.insertRow(cp, row);
                    // Track new location for Phase 5 incremental operations
                    if slot >= 0 {
                        trackRowLocation(tableName, currentPageId, slot);
                    }
                    pool.unpinPage(currentPageId, true);
                    // WAL: log each re-inserted row
                    if walEnabled && slot >= 0 {
                        var rowBuf = serializeRow(row);
                        wal.logInsert(txnId, m.tableId, currentPageId, slot, rowBuf);
                    }
                } else {
                    // Current page full, allocate new page
                    var newPage = pool.newPage(PAGE_TYPE_DATA);
                    dataMgr.initDataPage(newPage, m.tableId);
                    dataMgr.setNextPageId(cp, newPage.pageId);
                    pool.unpinPage(currentPageId, true);

                    var slot = dataMgr.insertRow(newPage, row);
                    currentPageId = newPage.pageId;
                    // Track new location for Phase 5 incremental operations
                    if slot >= 0 {
                        trackRowLocation(tableName, currentPageId, slot);
                    }
                    pool.unpinPage(newPage.pageId, true);
                    // WAL: log each re-inserted row
                    if walEnabled && slot >= 0 {
                        var rowBuf = serializeRow(row);
                        wal.logInsert(txnId, m.tableId, currentPageId, slot, rowBuf);
                    }
                }
            }
            i = i + 1;
        }

        // WAL: commit the rewrite transaction
        if walEnabled {
            wal.logCommit(txnId);
        }

        // Update metadata
        m.rowCount = rows.count();
        updateMetaInSchema(m);
        pool.flushAll();
        return true;
    }

    //=========================================================================
    // UPDATE METADATA IN SCHEMA
    //=========================================================================

    // Update autoIncrement value for a table
    expose func updateAutoIncrement(tableName: String, nextVal: Integer) {
        var meta = findMeta(tableName);
        if meta != null {
            var m = meta;
            m.nextAutoIncrement = nextVal;
            updateMetaInSchema(m);
        }
    }

    // Flush all dirty pages to disk
    expose func flush() {
        if isPersistent {
            pool.flushAll();
        }
    }

    //=========================================================================
    // INTERNAL HELPERS
    //=========================================================================

    // Find table metadata by name
    hide func findMeta(tableName: String) -> TableMeta? {
        var i = 0;
        while i < tableMetas.count() {
            var m = tableMetas.get(i);
            if m.tableName == tableName {
                return m;
            }
            i = i + 1;
        }
        return null;
    }

    // Update a table's metadata in the schema page
    hide func updateMetaInSchema(meta: TableMeta) {
        var schemaPage = pool.fetchPage(1);
        if schemaPage != null {
            var sp = schemaPage;
            schemaMgr.updateTable(sp, meta);
            pool.unpinPage(1, true);
        }
    }

    // Update row count for a table in persistent metadata
    expose func updateRowCountInMeta(tableName: String, newCount: Integer) {
        var meta = findMeta(tableName);
        if meta != null {
            var m = meta;
            m.rowCount = newCount;
            updateMetaInSchema(m);
        }
    }

    // Serialize a row to a BinaryBuffer for WAL logging
    hide func serializeRow(row: Row) -> BinaryBuffer {
        var buf = new BinaryBuffer();
        buf.init();
        rowSerializer.serializeRow(row, buf);
        return buf;
    }

    // Enable WAL for crash recovery
    expose func enableWal(walDir: String) {
        wal = new WALManager();
        wal.initWithDir(walDir);
        walEnabled = true;
    }

    //=========================================================================
    // ROW LOCATION TRACKING (Phase 5)
    //=========================================================================

    // Per-row location: maps row index → (pageId, slotIdx) for in-place updates
    hide List[Integer] rowPageIds;
    hide List[Integer] rowSlotIdxs;
    hide List[String] rowTableNames;

    // Record a row's storage location after loading or inserting
    expose func trackRowLocation(tableName: String, pageId: Integer, slotIdx: Integer) {
        rowPageIds.add(pageId);
        rowSlotIdxs.add(slotIdx);
        rowTableNames.add(tableName);
    }

    // Find a row's location by table name and row index within that table
    expose func findRowLocation(tableName: String, rowIndex: Integer) -> List[Integer] {
        var result: List[Integer] = [];
        var matchCount = 0;
        var i = 0;
        while i < rowTableNames.count() {
            if rowTableNames.get(i) == tableName {
                if matchCount == rowIndex {
                    result.add(rowPageIds.get(i));
                    result.add(rowSlotIdxs.get(i));
                    return result;
                }
                matchCount = matchCount + 1;
            }
            i = i + 1;
        }
        // Not found
        result.add(INVALID_PAGE_ID);
        result.add(-1);
        return result;
    }

    // Clear row locations for a table (used before rewrite)
    expose func clearRowLocations(tableName: String) {
        var newPageIds: List[Integer] = [];
        var newSlotIdxs: List[Integer] = [];
        var newTableNames: List[String] = [];
        var i = 0;
        while i < rowTableNames.count() {
            if rowTableNames.get(i) != tableName {
                newPageIds.add(rowPageIds.get(i));
                newSlotIdxs.add(rowSlotIdxs.get(i));
                newTableNames.add(rowTableNames.get(i));
            }
            i = i + 1;
        }
        rowPageIds = newPageIds;
        rowSlotIdxs = newSlotIdxs;
        rowTableNames = newTableNames;
    }

    // Delete a specific row by its storage location
    expose func deleteRowByLocation(tableName: String, pageId: Integer, slotIdx: Integer) -> Boolean {
        if isPersistent == false || pageId == INVALID_PAGE_ID {
            return false;
        }

        var page = pool.fetchPage(pageId);
        if page != null {
            var p = page;
            dataMgr.deleteRow(p, slotIdx);
            pool.unpinPage(pageId, true);
            return true;
        }
        return false;
    }

    // Update a specific row by its storage location
    expose func updateRowByLocation(tableName: String, pageId: Integer, slotIdx: Integer, newRow: Row) -> Boolean {
        if isPersistent == false || pageId == INVALID_PAGE_ID {
            return false;
        }

        var page = pool.fetchPage(pageId);
        if page != null {
            var p = page;
            var ok = dataMgr.updateRow(p, slotIdx, newRow);
            pool.unpinPage(pageId, true);
            if ok {
                return true;
            }
            // If in-place update failed (row grew too large), fall through
        }
        return false;
    }
}
