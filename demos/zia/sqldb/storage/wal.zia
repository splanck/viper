// wal.zia - Write-Ahead Logging
// Part of ViperSQL - Phase 4: Durability

module wal;

bind IO = Viper.IO;
bind String = Viper.String;
bind Fmt = Viper.Fmt;
bind Threads = Viper.Threads;

bind "./page";
bind "./serializer";

//=============================================================================
// WAL CONSTANTS
//=============================================================================

// Log record types
final LOG_BEGIN = 1;       // Transaction begin
final LOG_COMMIT = 2;      // Transaction commit
final LOG_ABORT = 3;       // Transaction abort
final LOG_INSERT = 4;      // Row insert
final LOG_UPDATE = 5;      // Row update
final LOG_DELETE = 6;      // Row delete
final LOG_CHECKPOINT = 7;  // Checkpoint marker
final LOG_PAGE_WRITE = 8;  // Full page write (for redo)

// WAL configuration
final WAL_BUFFER_SIZE = 65536;  // 64KB log buffer
final WAL_MAX_FILE_SIZE = 10485760;  // 10MB before rotation

//=============================================================================
// LOG SEQUENCE NUMBER (LSN)
//=============================================================================

// LSN uniquely identifies a log record position
entity LSN {
    expose Integer fileNumber;  // Log file number
    expose Integer offset;      // Byte offset within file

    expose func init() {
        fileNumber = 0;
        offset = 0;
    }

    expose func initWith(file: Integer, off: Integer) {
        fileNumber = file;
        offset = off;
    }

    expose func compare(other: LSN) -> Integer {
        if fileNumber < other.fileNumber {
            return -1;
        }
        if fileNumber > other.fileNumber {
            return 1;
        }
        if offset < other.offset {
            return -1;
        }
        if offset > other.offset {
            return 1;
        }
        return 0;
    }

    expose func toString() -> String {
        return Fmt.Int(fileNumber) + ":" + Fmt.Int(offset);
    }
}

//=============================================================================
// LOG RECORD
//=============================================================================

// A single log record
entity LogRecord {
    expose LSN lsn;              // Position in log
    expose Integer recordType;   // LOG_* constant
    expose Integer txnId;        // Transaction ID
    expose Integer tableId;      // Table ID (for data operations)
    expose Integer pageId;       // Page ID (for page writes)
    expose Integer slotId;       // Slot ID (for row operations)

    // Data for undo/redo
    expose BinaryBuffer beforeImage;  // Data before change (for undo)
    expose BinaryBuffer afterImage;   // Data after change (for redo)

    expose func init() {
        lsn = new LSN();
        lsn.init();
        recordType = 0;
        txnId = 0;
        tableId = 0;
        pageId = INVALID_PAGE_ID;
        slotId = -1;
        beforeImage = new BinaryBuffer();
        beforeImage.init();
        afterImage = new BinaryBuffer();
        afterImage.init();
    }

    expose func initBegin(tid: Integer) {
        init();
        recordType = LOG_BEGIN;
        txnId = tid;
    }

    expose func initCommit(tid: Integer) {
        init();
        recordType = LOG_COMMIT;
        txnId = tid;
    }

    expose func initAbort(tid: Integer) {
        init();
        recordType = LOG_ABORT;
        txnId = tid;
    }

    expose func initInsert(tid: Integer, tblId: Integer, pid: Integer, slot: Integer, rowData: BinaryBuffer) {
        init();
        recordType = LOG_INSERT;
        txnId = tid;
        tableId = tblId;
        pageId = pid;
        slotId = slot;
        afterImage = rowData;
    }

    expose func initUpdate(tid: Integer, tblId: Integer, pid: Integer, slot: Integer, before: BinaryBuffer, after: BinaryBuffer) {
        init();
        recordType = LOG_UPDATE;
        txnId = tid;
        tableId = tblId;
        pageId = pid;
        slotId = slot;
        beforeImage = before;
        afterImage = after;
    }

    expose func initDelete(tid: Integer, tblId: Integer, pid: Integer, slot: Integer, rowData: BinaryBuffer) {
        init();
        recordType = LOG_DELETE;
        txnId = tid;
        tableId = tblId;
        pageId = pid;
        slotId = slot;
        beforeImage = rowData;
    }

    expose func initCheckpoint(activeTxns: List[Integer]) {
        init();
        recordType = LOG_CHECKPOINT;
        // Store active transaction IDs in afterImage
        afterImage = new BinaryBuffer();
        afterImage.init();
        afterImage.writeInt32(activeTxns.count());
        var i = 0;
        while i < activeTxns.count() {
            afterImage.writeInt64(activeTxns.get(i));
            i = i + 1;
        }
    }

    expose func recordTypeString() -> String {
        if recordType == LOG_BEGIN { return "BEGIN"; }
        if recordType == LOG_COMMIT { return "COMMIT"; }
        if recordType == LOG_ABORT { return "ABORT"; }
        if recordType == LOG_INSERT { return "INSERT"; }
        if recordType == LOG_UPDATE { return "UPDATE"; }
        if recordType == LOG_DELETE { return "DELETE"; }
        if recordType == LOG_CHECKPOINT { return "CHECKPOINT"; }
        if recordType == LOG_PAGE_WRITE { return "PAGE_WRITE"; }
        return "UNKNOWN";
    }

    expose func toString() -> String {
        return "[" + lsn.toString() + "] " + recordTypeString() + " txn=" + Fmt.Int(txnId);
    }
}

//=============================================================================
// LOG RECORD SERIALIZER
//=============================================================================

entity LogRecordSerializer {
    expose func init() {
        // No state needed
    }

    // Serialize a log record to binary
    expose func serialize(record: LogRecord, buf: BinaryBuffer) {
        // Record header
        buf.writeInt32(record.lsn.fileNumber);
        buf.writeInt64(record.lsn.offset);
        buf.writeByte(record.recordType);
        buf.writeInt64(record.txnId);
        buf.writeInt64(record.tableId);
        buf.writeInt64(record.pageId);
        buf.writeInt32(record.slotId);

        // Before image
        var beforeBytes = record.beforeImage.getBytes();
        buf.writeInt32(beforeBytes.count());
        var i = 0;
        while i < beforeBytes.count() {
            buf.writeByte(beforeBytes.get(i));
            i = i + 1;
        }

        // After image
        var afterBytes = record.afterImage.getBytes();
        buf.writeInt32(afterBytes.count());
        i = 0;
        while i < afterBytes.count() {
            buf.writeByte(afterBytes.get(i));
            i = i + 1;
        }
    }

    // Deserialize a log record from binary
    expose func deserialize(buf: BinaryBuffer) -> LogRecord {
        var record = new LogRecord();
        record.init();

        // Record header
        record.lsn.fileNumber = buf.readInt32();
        record.lsn.offset = buf.readInt64();
        record.recordType = buf.readByte();
        record.txnId = buf.readInt64();
        record.tableId = buf.readInt64();
        record.pageId = buf.readInt64();
        record.slotId = buf.readInt32();

        // Before image
        var beforeLen = buf.readInt32();
        record.beforeImage = new BinaryBuffer();
        record.beforeImage.init();
        var i = 0;
        while i < beforeLen {
            record.beforeImage.writeByte(buf.readByte());
            i = i + 1;
        }

        // After image
        var afterLen = buf.readInt32();
        record.afterImage = new BinaryBuffer();
        record.afterImage.init();
        i = 0;
        while i < afterLen {
            record.afterImage.writeByte(buf.readByte());
            i = i + 1;
        }

        return record;
    }

    // Calculate serialized size of a record
    expose func recordSize(record: LogRecord) -> Integer {
        // Header: 4 + 8 + 1 + 8 + 8 + 8 + 4 = 41 bytes
        // + 4 (beforeLen) + beforeImage bytes
        // + 4 (afterLen) + afterImage bytes
        return 41 + 4 + record.beforeImage.size() + 4 + record.afterImage.size();
    }
}

//=============================================================================
// WAL MANAGER
//=============================================================================

// Write-Ahead Log Manager
// Thread-safe: all log-writing methods are protected by a Monitor lock.
entity WALManager {
    expose String logDir;            // Directory for log files
    expose Integer currentFile;      // Current log file number
    expose Integer currentOffset;    // Current offset in file
    expose BinaryBuffer logBuffer;   // In-memory buffer
    expose Integer bufferPosition;   // Position in buffer
    expose LSN lastFlushedLSN;       // Last LSN written to disk
    expose Boolean enabled;          // WAL enabled flag

    hide LogRecordSerializer serializer;
    hide List[Integer] lock;         // Monitor object for thread safety

    expose func init() {
        logDir = "";
        currentFile = 0;
        currentOffset = 0;
        logBuffer = new BinaryBuffer();
        logBuffer.initWithCapacity(WAL_BUFFER_SIZE);
        bufferPosition = 0;
        lastFlushedLSN = new LSN();
        lastFlushedLSN.init();
        enabled = false;
        serializer = new LogRecordSerializer();
        serializer.init();
        lock = [];
    }

    expose func initWithDir(dir: String) {
        init();
        logDir = dir;
        enabled = true;
    }

    //=========================================================================
    // LOG WRITING
    //=========================================================================

    // Append a log record (public, thread-safe)
    expose func appendRecord(record: LogRecord) -> LSN {
        Threads.Monitor.Enter(lock);
        var lsn = appendRecordInternal(record);
        Threads.Monitor.Exit(lock);
        return lsn;
    }

    // Append a log record (internal, no locking)
    hide func appendRecordInternal(record: LogRecord) -> LSN {
        if enabled == false {
            var dummyLSN = new LSN();
            dummyLSN.init();
            return dummyLSN;
        }

        // Assign LSN
        record.lsn.fileNumber = currentFile;
        record.lsn.offset = currentOffset;

        // Serialize to buffer
        var recordBuf = new BinaryBuffer();
        recordBuf.init();
        serializer.serialize(record, recordBuf);

        // Check if we need to flush or rotate
        var recordSize = recordBuf.size();
        if bufferPosition + recordSize > WAL_BUFFER_SIZE {
            flushInternal();
        }

        // Check for log file rotation
        if currentOffset + recordSize > WAL_MAX_FILE_SIZE {
            rotateLogFile();
            record.lsn.fileNumber = currentFile;
            record.lsn.offset = currentOffset;
        }

        // Copy record to log buffer
        var bytes = recordBuf.getBytes();
        var i = 0;
        while i < bytes.count() {
            logBuffer.writeByte(bytes.get(i));
            i = i + 1;
        }
        bufferPosition = bufferPosition + recordSize;
        currentOffset = currentOffset + recordSize;

        return record.lsn;
    }

    // Log a BEGIN record
    expose func logBegin(txnId: Integer) -> LSN {
        Threads.Monitor.Enter(lock);
        var record = new LogRecord();
        record.initBegin(txnId);
        var lsn = appendRecordInternal(record);
        Threads.Monitor.Exit(lock);
        return lsn;
    }

    // Log a COMMIT record (forces flush)
    expose func logCommit(txnId: Integer) -> LSN {
        Threads.Monitor.Enter(lock);
        var record = new LogRecord();
        record.initCommit(txnId);
        var lsn = appendRecordInternal(record);
        flushInternal();  // Force write for durability
        Threads.Monitor.Exit(lock);
        return lsn;
    }

    // Log an ABORT record
    expose func logAbort(txnId: Integer) -> LSN {
        Threads.Monitor.Enter(lock);
        var record = new LogRecord();
        record.initAbort(txnId);
        var lsn = appendRecordInternal(record);
        Threads.Monitor.Exit(lock);
        return lsn;
    }

    // Log an INSERT record
    expose func logInsert(txnId: Integer, tableId: Integer, pageId: Integer, slotId: Integer, rowData: BinaryBuffer) -> LSN {
        Threads.Monitor.Enter(lock);
        var record = new LogRecord();
        record.initInsert(txnId, tableId, pageId, slotId, rowData);
        var lsn = appendRecordInternal(record);
        Threads.Monitor.Exit(lock);
        return lsn;
    }

    // Log an UPDATE record
    expose func logUpdate(txnId: Integer, tableId: Integer, pageId: Integer, slotId: Integer, before: BinaryBuffer, after: BinaryBuffer) -> LSN {
        Threads.Monitor.Enter(lock);
        var record = new LogRecord();
        record.initUpdate(txnId, tableId, pageId, slotId, before, after);
        var lsn = appendRecordInternal(record);
        Threads.Monitor.Exit(lock);
        return lsn;
    }

    // Log a DELETE record
    expose func logDelete(txnId: Integer, tableId: Integer, pageId: Integer, slotId: Integer, rowData: BinaryBuffer) -> LSN {
        Threads.Monitor.Enter(lock);
        var record = new LogRecord();
        record.initDelete(txnId, tableId, pageId, slotId, rowData);
        var lsn = appendRecordInternal(record);
        Threads.Monitor.Exit(lock);
        return lsn;
    }

    // Write a checkpoint
    expose func checkpoint(activeTxns: List[Integer]) -> LSN {
        Threads.Monitor.Enter(lock);
        var record = new LogRecord();
        record.initCheckpoint(activeTxns);
        var lsn = appendRecordInternal(record);
        flushInternal();
        Threads.Monitor.Exit(lock);
        return lsn;
    }

    //=========================================================================
    // LOG FILE MANAGEMENT
    //=========================================================================

    // Flush buffer to disk (public, thread-safe)
    expose func flush() {
        Threads.Monitor.Enter(lock);
        flushInternal();
        Threads.Monitor.Exit(lock);
    }

    // Flush buffer to disk (internal, no locking)
    hide func flushInternal() {
        if bufferPosition == 0 {
            return;
        }

        var filename = logFilePath(currentFile);

        // Read existing content
        var content = "";
        if IO.File.Exists(filename) {
            content = IO.File.ReadAllText(filename);
        }

        // Append buffer content with bounds checking
        var bytes = logBuffer.getBytes();
        var i = 0;
        while i < bufferPosition && i < bytes.count() {
            var b = bytes.get(i);
            // Ensure byte is in valid range for Chr
            if b < 0 {
                b = 0;
            }
            if b > 255 {
                b = b % 256;
            }
            content = content + String.Chr(b);
            i = i + 1;
        }

        IO.File.WriteAllText(filename, content);

        // Update last flushed LSN
        lastFlushedLSN.fileNumber = currentFile;
        lastFlushedLSN.offset = currentOffset;

        // Reset buffer
        logBuffer = new BinaryBuffer();
        logBuffer.initWithCapacity(WAL_BUFFER_SIZE);
        bufferPosition = 0;
    }

    // Rotate to a new log file (internal, called under lock)
    hide func rotateLogFile() {
        flushInternal();
        currentFile = currentFile + 1;
        currentOffset = 0;
    }

    // Get log file path
    hide func logFilePath(fileNum: Integer) -> String {
        return logDir + "/wal_" + Fmt.Int(fileNum) + ".log";
    }

    //=========================================================================
    // RECOVERY
    //=========================================================================

    // Read all records from a log file
    expose func readLogFile(fileNum: Integer) -> List[LogRecord] {
        var records: List[LogRecord] = [];
        var filename = logFilePath(fileNum);

        if IO.File.Exists(filename) == false {
            return records;
        }

        var content = IO.File.ReadAllText(filename);
        var buf = new BinaryBuffer();
        buf.init();

        // Convert string to buffer
        var i = 0;
        var len = String.Length(content);
        while i < len {
            var ch = String.Substring(content, i, 1);
            var code = String.Asc(ch);
            buf.writeByte(code);
            i = i + 1;
        }

        // Read records
        buf.seek(0);
        while buf.writePosition() > 0 && buf.position < buf.size() {
            var record = serializer.deserialize(buf);
            if record.recordType != 0 {
                records.add(record);
            }
        }

        return records;
    }

    // Perform basic recovery (analysis only â€” full redo done by StorageEngine)
    expose func recover() -> RecoveryResult {
        var result = createRecoveryResult(enabled);
        if enabled == false {
            return result;
        }

        // Analysis: identify committed transactions
        if checkWalFilesExist() {
            var committed: List[Integer] = [];
            var aborted: List[Integer] = [];
            var fileNum = 0;
            while fileNum <= currentFile + 5 {
                var records = readLogFile(fileNum);
                var ri = 0;
                while ri < records.count() {
                    var record = records.get(ri);
                    if record.recordType == LOG_COMMIT {
                        committed.add(record.txnId);
                    } else if record.recordType == LOG_ABORT {
                        aborted.add(record.txnId);
                    }
                    ri = ri + 1;
                }
                fileNum = fileNum + 1;
            }
            result.committedTxns = committed;
            result.abortedTxns = aborted;
            result.recoveryComplete = true;
        }

        return result;
    }

    // Check if any WAL files exist on disk
    hide func checkWalFilesExist() -> Boolean {
        var fileNum = 0;
        while fileNum <= currentFile {
            var path = logFilePath(fileNum);
            if IO.File.Exists(path) {
                return true;
            }
            fileNum = fileNum + 1;
        }
        return false;
    }

    // Count committed data operations across all WAL files
    hide func countCommittedOps(committedTxns: List[Integer]) -> Integer {
        var count = 0;
        var fileNum = 0;
        while fileNum <= currentFile {
            var records = readLogFile(fileNum);
            var ri = 0;
            while ri < records.count() {
                var record = records.get(ri);
                if record.recordType == LOG_INSERT || record.recordType == LOG_UPDATE || record.recordType == LOG_DELETE {
                    if isTxnCommitted(committedTxns, record.txnId) {
                        count = count + 1;
                    }
                }
                ri = ri + 1;
            }
            fileNum = fileNum + 1;
        }
        return count;
    }

    // Check if a transaction ID is in the committed list
    expose func isTxnCommitted(committed: List[Integer], txnId: Integer) -> Boolean {
        var i = 0;
        while i < committed.count() {
            if committed.get(i) == txnId {
                return true;
            }
            i = i + 1;
        }
        return false;
    }

    // Delete all WAL files from disk
    expose func cleanupWalFiles() {
        var fileNum = 0;
        while fileNum <= currentFile {
            var path = logFilePath(fileNum);
            if IO.File.Exists(path) {
                IO.File.Delete(path);
            }
            fileNum = fileNum + 1;
        }
    }


    // Reset WAL state after recovery
    expose func resetState() {
        currentFile = 0;
        currentOffset = 0;
        bufferPosition = 0;
        logBuffer = new BinaryBuffer();
        logBuffer.initWithCapacity(WAL_BUFFER_SIZE);
    }

    // Helper to remove transaction from list (returns new list)
    expose func removeTxnFromList(list: List[Integer], txnId: Integer) -> List[Integer] {
        // Workaround for BUG-002: List.remove() doesn't work
        var newList: List[Integer] = [];
        var i = 0;
        while i < list.count() {
            if list.get(i) != txnId {
                newList.add(list.get(i));
            }
            i = i + 1;
        }
        return newList;
    }

    //=========================================================================
    // STATUS
    //=========================================================================

    expose func isEnabled() -> Boolean {
        return enabled;
    }

    expose func getLastFlushedLSN() -> LSN {
        return lastFlushedLSN;
    }

    expose func getCurrentLSN() -> LSN {
        var lsn = new LSN();
        lsn.initWith(currentFile, currentOffset);
        return lsn;
    }
}

//=============================================================================
// RECOVERY RESULT
//=============================================================================

entity RecoveryResult {
    expose Boolean recoveryComplete;
    expose List[Integer] committedTxns;
    expose List[Integer] abortedTxns;
    expose List[Integer] activeTxnsAtCrash;
    expose Integer redoCount;
    expose Integer undoCount;

    expose func init() {
        recoveryComplete = false;
        committedTxns = [];
        abortedTxns = [];
        activeTxnsAtCrash = [];
        redoCount = 0;
        undoCount = 0;
    }

    expose func toString() -> String {
        var result = "Recovery Result:\n";
        result = result + "  Committed: " + Fmt.Int(committedTxns.count()) + "\n";
        result = result + "  Aborted: " + Fmt.Int(abortedTxns.count()) + "\n";
        result = result + "  Active at crash: " + Fmt.Int(activeTxnsAtCrash.count()) + "\n";
        result = result + "  Redo operations: " + Fmt.Int(redoCount) + "\n";
        result = result + "  Undo operations: " + Fmt.Int(undoCount);
        return result;
    }
}

// Helper function to create recovery result
func createRecoveryResult(walEnabled: Boolean) -> RecoveryResult {
    var result = new RecoveryResult();
    result.init();
    result.recoveryComplete = true;
    return result;
}
