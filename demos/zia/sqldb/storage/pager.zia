// pager.zia - Low-level Page I/O
// Part of ViperSQL - Binary Storage Engine (Phase 2)

module pager;

bind IO = Viper.IO;
bind String = Viper.String;
bind Collections = Viper.Collections;

bind "./page";
bind "./serializer";

//=============================================================================
// PAGE ENTITY
//=============================================================================

// Represents a single page in memory
entity Page {
    expose Integer pageId;
    expose Integer pageType;
    expose BinaryBuffer data;
    expose Boolean dirty;
    expose Integer pinCount;

    expose func init() {
        pageId = INVALID_PAGE_ID;
        pageType = PAGE_TYPE_DATA;
        data = new BinaryBuffer();
        data.initWithCapacity(PAGE_SIZE);
        dirty = false;
        pinCount = 0;
    }

    expose func initWithId(pid: Integer, ptype: Integer) {
        pageId = pid;
        pageType = ptype;
        data = new BinaryBuffer();
        data.initWithCapacity(PAGE_SIZE);
        dirty = false;
        pinCount = 0;
    }

    // Mark page as modified
    expose func markDirty() {
        dirty = true;
    }

    // Pin the page (prevent eviction)
    expose func pin() {
        pinCount = pinCount + 1;
    }

    // Unpin the page
    expose func unpin() {
        if pinCount > 0 {
            pinCount = pinCount - 1;
        }
    }

    // Check if page can be evicted
    expose func canEvict() -> Boolean {
        return pinCount == 0;
    }

    // Reset page for reuse
    expose func reset() {
        data = new BinaryBuffer();
        data.initWithCapacity(PAGE_SIZE);
        dirty = false;
        pinCount = 0;
    }
}

//=============================================================================
// PAGER ENTITY
//=============================================================================

// Manages page I/O for a database file
entity Pager {
    expose String filename;
    expose Integer pageCount;
    expose Integer freeListHead;
    expose Boolean isOpen;

    // File header info (cached)
    hide Integer fileVersion;
    hide Integer schemaPageId;

    expose func init() {
        filename = "";
        pageCount = 0;
        freeListHead = INVALID_PAGE_ID;
        isOpen = false;
        fileVersion = FILE_VERSION;
        schemaPageId = 1;
    }

    //=========================================================================
    // FILE OPERATIONS
    //=========================================================================

    // Create a new database file
    expose func createDatabase(fname: String) -> Boolean {
        filename = fname;

        // Write initial header page
        var header = new BinaryBuffer();
        header.initWithCapacity(PAGE_SIZE);

        // Magic string "VIPERSQL"
        writeHeaderMagic(header);

        // Version
        header.seek(HEADER_VERSION_OFFSET);
        header.writeInt32(FILE_VERSION);

        // Page size
        header.seek(HEADER_PAGE_SIZE_OFFSET);
        header.writeInt32(PAGE_SIZE);

        // Initial page count (header + schema page)
        header.seek(HEADER_PAGE_COUNT_OFFSET);
        header.writeInt64(2);

        // Schema page pointer
        header.seek(HEADER_SCHEMA_PAGE_OFFSET);
        header.writeInt64(1);

        // Free list head (none initially)
        header.seek(HEADER_FREELIST_HEAD_OFFSET);
        header.writeInt64(INVALID_PAGE_ID);

        // Write header to file
        writePageToFile(0, header);

        // Create empty schema page
        var schemaPage = new BinaryBuffer();
        schemaPage.initWithCapacity(PAGE_SIZE);
        schemaPage.writeByte(PAGE_TYPE_SCHEMA);
        schemaPage.writeInt32(0);  // Table count
        writePageToFile(1, schemaPage);

        pageCount = 2;
        freeListHead = INVALID_PAGE_ID;
        schemaPageId = 1;
        isOpen = true;

        return true;
    }

    // Open an existing database file
    expose func openDatabase(fname: String) -> Boolean {
        filename = fname;

        if IO.File.Exists(fname) == false {
            return false;
        }

        // Read header page
        var hdr = new BinaryBuffer();
        hdr.initWithCapacity(PAGE_SIZE);
        if readPageIntoBuffer(0, hdr) == false {
            return false;
        }

        // Verify magic
        hdr.seek(HEADER_MAGIC_OFFSET);
        if verifyHeaderMagic(hdr) == false {
            return false;
        }

        // Read version
        hdr.seek(HEADER_VERSION_OFFSET);
        fileVersion = hdr.readInt32();

        // Read page count
        hdr.seek(HEADER_PAGE_COUNT_OFFSET);
        pageCount = hdr.readInt64();

        // Read schema page pointer
        hdr.seek(HEADER_SCHEMA_PAGE_OFFSET);
        schemaPageId = hdr.readInt64();

        // Read free list head
        hdr.seek(HEADER_FREELIST_HEAD_OFFSET);
        freeListHead = hdr.readInt64();

        isOpen = true;
        return true;
    }

    // Close the database
    expose func closeDatabase() {
        if isOpen {
            // Update header with current state
            var header = new BinaryBuffer();
            header.initWithCapacity(PAGE_SIZE);

            writeHeaderMagic(header);

            header.seek(HEADER_VERSION_OFFSET);
            header.writeInt32(fileVersion);

            header.seek(HEADER_PAGE_SIZE_OFFSET);
            header.writeInt32(PAGE_SIZE);

            header.seek(HEADER_PAGE_COUNT_OFFSET);
            header.writeInt64(pageCount);

            header.seek(HEADER_SCHEMA_PAGE_OFFSET);
            header.writeInt64(schemaPageId);

            header.seek(HEADER_FREELIST_HEAD_OFFSET);
            header.writeInt64(freeListHead);

            writePageToFile(0, header);
        }
        isOpen = false;
    }

    //=========================================================================
    // PAGE ALLOCATION
    //=========================================================================

    // Allocate a new page
    expose func allocatePage() -> Integer {
        // Check free list first
        if freeListHead != INVALID_PAGE_ID {
            var pageId = freeListHead;
            // Read free page to get next in chain
            var fp = new BinaryBuffer();
            fp.initWithCapacity(PAGE_SIZE);
            if readPageIntoBuffer(pageId, fp) {
                fp.seek(1);  // Skip page type byte
                freeListHead = fp.readInt64();
            } else {
                freeListHead = INVALID_PAGE_ID;
            }
            return pageId;
        }

        // Allocate new page at end
        var newPageId = pageCount;
        pageCount = pageCount + 1;
        return newPageId;
    }

    // Free a page (add to free list)
    expose func freePage(pageId: Integer) {
        var page = new BinaryBuffer();
        page.initWithCapacity(PAGE_SIZE);
        page.writeByte(PAGE_TYPE_FREELIST);
        page.writeInt64(freeListHead);  // Link to previous head
        writePageToFile(pageId, page);
        freeListHead = pageId;
    }

    //=========================================================================
    // PAGE I/O
    //=========================================================================

    // Read a page from disk
    expose func readPage(pageId: Integer) -> Page? {
        if pageId < 0 || pageId >= pageCount {
            return null;
        }

        // Use readPageWithBuffer to avoid optional type issue
        var page = new Page();
        page.init();
        page.pageId = pageId;

        if readPageIntoBuffer(pageId, page.data) == false {
            return null;
        }

        page.data.seek(0);
        page.pageType = page.data.readByte();

        return page;
    }

    // Read page data into an existing buffer using BinFile (O(PAGE_SIZE) I/O)
    hide func readPageIntoBuffer(pageId: Integer, dest: BinaryBuffer) -> Boolean {
        if IO.File.Exists(filename) == false {
            return false;
        }

        var f = IO.BinFile.Open(filename, "r");
        var fileSize = f.Size;
        var startOffset = pageId * PAGE_SIZE;

        if startOffset + PAGE_SIZE > fileSize {
            f.Close();
            return false;
        }

        // Seek to page offset and read PAGE_SIZE bytes
        f.Seek(startOffset, 0);
        var raw = Collections.Bytes.New(PAGE_SIZE);
        var nread = f.Read(raw, 0, PAGE_SIZE);
        f.Close();

        if nread < PAGE_SIZE {
            return false;
        }

        // Copy Bytes into destination BinaryBuffer
        var bytes = dest.getBytes();
        while bytes.count() < PAGE_SIZE {
            bytes.add(0);
        }
        var i = 0;
        while i < PAGE_SIZE {
            bytes.set(i, Collections.Bytes.Get(raw, i));
            i = i + 1;
        }
        dest.seek(0);
        return true;
    }

    // Write a page to disk
    expose func writePage(page: Page) -> Boolean {
        if page.pageId == INVALID_PAGE_ID {
            return false;
        }

        // Ensure page type is at position 0
        page.data.seek(0);
        page.data.writeByte(page.pageType);

        writePageToFile(page.pageId, page.data);
        page.dirty = false;
        return true;
    }

    //=========================================================================
    // LOW-LEVEL FILE I/O (BinFile-based, O(PAGE_SIZE) per operation)
    //=========================================================================

    // Write a page to the file at the given page ID using BinFile
    hide func writePageToFile(pageId: Integer, buf: BinaryBuffer) {
        var startOffset = pageId * PAGE_SIZE;

        // Convert BinaryBuffer to Bytes
        var raw = Collections.Bytes.New(PAGE_SIZE);
        var bytes = buf.getBytes();
        var i = 0;
        while i < PAGE_SIZE {
            var b = 0;
            if i < bytes.count() {
                b = bytes.get(i);
            }
            Collections.Bytes.Set(raw, i, b);
            i = i + 1;
        }

        // If file doesn't exist, create it; otherwise open for read+write
        if IO.File.Exists(filename) == false {
            var f = IO.BinFile.Open(filename, "w");
            // Pad with zeros up to the page offset
            if startOffset > 0 {
                var zeros = Collections.Bytes.New(startOffset);
                f.Write(zeros, 0, startOffset);
            }
            f.Write(raw, 0, PAGE_SIZE);
            f.Flush();
            f.Close();
        } else {
            var f = IO.BinFile.Open(filename, "rw");
            var fileSize = f.Size;
            // Extend file if needed
            if startOffset > fileSize {
                f.Seek(fileSize, 0);
                var padLen = startOffset - fileSize;
                var zeros = Collections.Bytes.New(padLen);
                f.Write(zeros, 0, padLen);
            }
            f.Seek(startOffset, 0);
            f.Write(raw, 0, PAGE_SIZE);
            f.Flush();
            f.Close();
        }
    }

    //=========================================================================
    // HEADER HELPERS
    //=========================================================================

    hide func writeHeaderMagic(buf: BinaryBuffer) {
        buf.seek(HEADER_MAGIC_OFFSET);
        // "VIPERSQL" = 8 bytes
        buf.writeByte(86);   // V
        buf.writeByte(73);   // I
        buf.writeByte(80);   // P
        buf.writeByte(69);   // E
        buf.writeByte(82);   // R
        buf.writeByte(83);   // S
        buf.writeByte(81);   // Q
        buf.writeByte(76);   // L
    }

    hide func verifyHeaderMagic(buf: BinaryBuffer) -> Boolean {
        if buf.readByte() != 86 { return false; }   // V
        if buf.readByte() != 73 { return false; }   // I
        if buf.readByte() != 80 { return false; }   // P
        if buf.readByte() != 69 { return false; }   // E
        if buf.readByte() != 82 { return false; }   // R
        if buf.readByte() != 83 { return false; }   // S
        if buf.readByte() != 81 { return false; }   // Q
        if buf.readByte() != 76 { return false; }   // L
        return true;
    }

    // Get schema page ID
    expose func getSchemaPageId() -> Integer {
        return schemaPageId;
    }
}
