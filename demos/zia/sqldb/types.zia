// types.zia — SQL Value Types
// Part of ViperSQL
//
// Defines the SqlValue entity, the universal runtime representation of
// a SQL value. Each SqlValue has a kind (SQL_NULL, SQL_INTEGER, SQL_REAL,
// SQL_TEXT, SQL_BLOB) and carries the corresponding typed payload.
// Provides comparison, type coercion, arithmetic, and display formatting.
// Factory functions (sqlNull, sqlInteger, sqlReal, sqlText) create values
// concisely throughout the codebase.

module types;

bind String = Viper.String;
bind Fmt = Viper.Fmt;
bind DateTime = Viper.Time.DateTime;

//=============================================================================
// SQL TYPE CONSTANTS
//=============================================================================

final SQL_NULL = 0;
final SQL_INTEGER = 1;
final SQL_REAL = 2;
final SQL_TEXT = 3;
final SQL_BLOB = 4;
final SQL_BOOLEAN = 5;
final SQL_DATE = 6;       // intValue = days since Unix epoch (1970-01-01)
final SQL_TIMESTAMP = 7;  // intValue = epoch seconds
final SQL_JSON = 8;       // textValue = JSON string
final SQL_ARRAY = 9;      // textValue = PG-format array "{1,2,3}"

// Partition types (Phase 28)
final PARTITION_NONE = 0;
final PARTITION_RANGE = 1;
final PARTITION_LIST = 2;
final PARTITION_HASH = 3;

//=============================================================================
// HELPER FUNCTIONS
//=============================================================================

// Convert string to integer (delegates to runtime parser).
// Handles "123", "-5", and "3.14" (truncates to 3).
func stringToInt(text: String) -> Integer {
    var n = Viper.Core.Parse.IntOr(text, 0);
    if n != 0 { return n; }
    // IntOr rejects "3.14" — fall back to float parse + truncate
    var f = Viper.Core.Convert.ToDouble(text);
    return Viper.Core.Convert.NumToInt(f);
}

// Convert string to number (delegates to runtime parser).
func stringToNumber(text: String) -> Float {
    return Viper.Core.Convert.ToDouble(text);
}

//=============================================================================
// DATE/TIME HELPERS
//=============================================================================

func fmtDateParts(y: Integer, m: Integer, d: Integer) -> String {
    var result = Fmt.Int(y) + "-";
    if m < 10 { result = result + "0"; }
    result = result + Fmt.Int(m) + "-";
    if d < 10 { result = result + "0"; }
    result = result + Fmt.Int(d);
    return result;
}

func fmtTimeParts(h: Integer, m: Integer, s: Integer) -> String {
    var result = "";
    if h < 10 { result = result + "0"; }
    result = result + Fmt.Int(h) + ":";
    if m < 10 { result = result + "0"; }
    result = result + Fmt.Int(m) + ":";
    if s < 10 { result = result + "0"; }
    result = result + Fmt.Int(s);
    return result;
}

// Convert DATE epoch (noon local) to TIMESTAMP epoch (midnight local for same date)
func dateToTimestamp(dateEpoch: Integer) -> Integer {
    var y = DateTime.Year(dateEpoch);
    var m = DateTime.Month(dateEpoch);
    var d = DateTime.Day(dateEpoch);
    return DateTime.Create(y, m, d, 0, 0, 0);
}

// Convert TIMESTAMP epoch to DATE epoch (noon local for that date)
func timestampToDate(tsEpoch: Integer) -> Integer {
    var y = DateTime.Year(tsEpoch);
    var m = DateTime.Month(tsEpoch);
    var d = DateTime.Day(tsEpoch);
    return DateTime.Create(y, m, d, 12, 0, 0);
}

// Parse "YYYY-MM-DD" text to DATE epoch (noon local)
func parseDateText(text: String) -> Integer {
    var sLen = String.Length(text);
    if sLen < 10 { return 0; }
    var yr = stringToInt(String.Substring(text, 0, 4));
    var mo = stringToInt(String.Substring(text, 5, 2));
    var dy = stringToInt(String.Substring(text, 8, 2));
    return DateTime.Create(yr, mo, dy, 12, 0, 0);
}

// Parse "YYYY-MM-DD" or "YYYY-MM-DDTHH:MM:SS" to epoch seconds
func parseDateTimeText(text: String) -> Integer {
    return DateTime.TryParse(text);
}

//=============================================================================
// SQL VALUE ENTITY
//=============================================================================

entity SqlValue {
    expose Integer kind;       // SQL_NULL, SQL_INTEGER, SQL_REAL, SQL_TEXT, SQL_BLOB
    expose Integer intValue;   // Used when kind == SQL_INTEGER
    expose Float realValue;    // Used when kind == SQL_REAL
    expose String textValue;   // Used when kind == SQL_TEXT or SQL_BLOB

    expose func init() {
        kind = SQL_NULL;
        intValue = 0;
        realValue = 0.0;
        textValue = "";
    }

    expose func initNull() {
        kind = SQL_NULL;
        intValue = 0;
        realValue = 0.0;
        textValue = "";
    }

    expose func initInteger(val: Integer) {
        kind = SQL_INTEGER;
        intValue = val;
        realValue = 0.0;
        textValue = "";
    }

    expose func initReal(val: Float, text: String) {
        kind = SQL_REAL;
        intValue = 0;
        realValue = val;
        textValue = text;
    }

    expose func initText(val: String) {
        kind = SQL_TEXT;
        intValue = 0;
        realValue = 0.0;
        textValue = val;
    }

    expose func initBlob(val: String) {
        kind = SQL_BLOB;
        intValue = 0;
        realValue = 0.0;
        textValue = val;
    }

    expose func initBoolean(val: Boolean) {
        kind = SQL_BOOLEAN;
        if val { intValue = 1; } else { intValue = 0; }
        realValue = 0.0;
        textValue = "";
    }

    expose func initDate(daysSinceEpoch: Integer) {
        kind = SQL_DATE;
        intValue = daysSinceEpoch;
        realValue = 0.0;
        textValue = "";
    }

    expose func initTimestamp(epochSeconds: Integer) {
        kind = SQL_TIMESTAMP;
        intValue = epochSeconds;
        realValue = 0.0;
        textValue = "";
    }

    expose func initJson(val: String) {
        kind = SQL_JSON;
        intValue = 0;
        realValue = 0.0;
        textValue = val;
    }

    expose func initArray(val: String) {
        kind = SQL_ARRAY;
        intValue = 0;
        realValue = 0.0;
        textValue = val;
    }

    expose func isNull() -> Boolean { return kind == SQL_NULL; }
    expose func isInteger() -> Boolean { return kind == SQL_INTEGER; }
    expose func isReal() -> Boolean { return kind == SQL_REAL; }
    expose func isText() -> Boolean { return kind == SQL_TEXT; }
    expose func isBlob() -> Boolean { return kind == SQL_BLOB; }
    expose func isBoolean() -> Boolean { return kind == SQL_BOOLEAN; }
    expose func isDate() -> Boolean { return kind == SQL_DATE; }
    expose func isTimestamp() -> Boolean { return kind == SQL_TIMESTAMP; }
    expose func isJson() -> Boolean { return kind == SQL_JSON; }
    expose func isArray() -> Boolean { return kind == SQL_ARRAY; }

    expose func typeName() -> String {
        if (kind == SQL_NULL) { return "NULL"; }
        if (kind == SQL_INTEGER) { return "INTEGER"; }
        if (kind == SQL_REAL) { return "REAL"; }
        if (kind == SQL_TEXT) { return "TEXT"; }
        if (kind == SQL_BLOB) { return "BLOB"; }
        if (kind == SQL_BOOLEAN) { return "BOOLEAN"; }
        if (kind == SQL_DATE) { return "DATE"; }
        if (kind == SQL_TIMESTAMP) { return "TIMESTAMP"; }
        if (kind == SQL_JSON) { return "JSON"; }
        if (kind == SQL_ARRAY) { return "ARRAY"; }
        return "UNKNOWN";
    }

    expose func toString() -> String {
        if (kind == SQL_NULL) { return "NULL"; }
        if (kind == SQL_INTEGER) { return Fmt.Int(intValue); }
        if (kind == SQL_REAL) { return textValue; }
        if (kind == SQL_TEXT) { return textValue; }
        if (kind == SQL_BLOB) { return textValue; }
        if (kind == SQL_BOOLEAN) {
            if intValue != 0 { return "true"; }
            return "false";
        }
        if (kind == SQL_DATE) {
            var y = DateTime.Year(intValue);
            var m = DateTime.Month(intValue);
            var d = DateTime.Day(intValue);
            return fmtDateParts(y, m, d);
        }
        if (kind == SQL_TIMESTAMP) {
            return DateTime.ToLocal(intValue);
        }
        if (kind == SQL_JSON) { return textValue; }
        if (kind == SQL_ARRAY) { return textValue; }
        return "?";
    }

    // Format for SQL output (with quotes, escaping single quotes with '')
    expose func toSqlString() -> String {
        if (kind == SQL_NULL) { return "NULL"; }
        if (kind == SQL_INTEGER) { return Fmt.Int(intValue); }
        if (kind == SQL_REAL) { return textValue; }
        if (kind == SQL_TEXT) {
            // Escape single quotes by doubling them
            var escaped = "";
            var i = 0;
            var len = String.Length(textValue);
            while i < len {
                var ch = String.Substring(textValue, i, 1);
                if ch == "'" {
                    escaped = escaped + "''";
                } else {
                    escaped = escaped + ch;
                }
                i = i + 1;
            }
            return "'" + escaped + "'";
        }
        if (kind == SQL_BLOB) { return "X'" + textValue + "'"; }
        if (kind == SQL_BOOLEAN) {
            if intValue != 0 { return "TRUE"; }
            return "FALSE";
        }
        if (kind == SQL_DATE) {
            var y = DateTime.Year(intValue);
            var m = DateTime.Month(intValue);
            var d = DateTime.Day(intValue);
            return "'" + fmtDateParts(y, m, d) + "'";
        }
        if (kind == SQL_TIMESTAMP) {
            var s = DateTime.ToLocal(intValue);
            return "'" + s + "'";
        }
        if (kind == SQL_JSON) {
            // Escape single quotes by doubling them
            var escaped = "";
            var i = 0;
            var len = String.Length(textValue);
            while i < len {
                var ch = String.Substring(textValue, i, 1);
                if ch == "'" {
                    escaped = escaped + "''";
                } else {
                    escaped = escaped + ch;
                }
                i = i + 1;
            }
            return "'" + escaped + "'";
        }
        return "?";
    }

    // Compare two values. Returns -1, 0, 1 for ordering.
    // Returns 2 if either side is NULL (SQL three-valued logic).
    expose func compare(other: SqlValue) -> Integer {
        var result = 0;

        // NULL comparisons return 2 (NULL/unknown) per SQL spec
        if kind == SQL_NULL || other.kind == SQL_NULL {
            return 2;
        }

        if kind == SQL_INTEGER && other.kind == SQL_INTEGER {
            if intValue < other.intValue {
                result = -1;
            } else if intValue > other.intValue {
                result = 1;
            } else {
                result = 0;
            }
        } else if kind == SQL_REAL && other.kind == SQL_REAL {
            if realValue < other.realValue {
                result = -1;
            } else if realValue > other.realValue {
                result = 1;
            } else {
                result = 0;
            }
        } else if kind == SQL_TEXT && other.kind == SQL_TEXT {
            if textValue == other.textValue {
                result = 0;
            } else {
                var myLen = String.Length(textValue);
                var otherLen = String.Length(other.textValue);
                var minLen = myLen;
                if otherLen < minLen { minLen = otherLen; }
                var i = 0;
                var found = false;
                while i < minLen && found == false {
                    var myChar = String.Asc(String.Substring(textValue, i, 1));
                    var otherChar = String.Asc(String.Substring(other.textValue, i, 1));
                    if myChar < otherChar {
                        result = -1;
                        found = true;
                    } else if myChar > otherChar {
                        result = 1;
                        found = true;
                    }
                    i = i + 1;
                }
                if found == false {
                    if myLen < otherLen {
                        result = -1;
                    } else if myLen > otherLen {
                        result = 1;
                    } else {
                        result = 0;
                    }
                }
            }
        } else if kind == SQL_TEXT && other.kind == SQL_INTEGER {
            var myInt = stringToInt(textValue);
            if myInt < other.intValue {
                result = -1;
            } else if myInt > other.intValue {
                result = 1;
            } else {
                result = 0;
            }
        } else if kind == SQL_INTEGER && other.kind == SQL_TEXT {
            var otherInt = stringToInt(other.textValue);
            if intValue < otherInt {
                result = -1;
            } else if intValue > otherInt {
                result = 1;
            } else {
                result = 0;
            }
        } else if kind == SQL_REAL && other.kind == SQL_INTEGER {
            // Convert integer to float for comparison
            var otherReal = other.intValue * 1.0;
            if realValue < otherReal {
                result = -1;
            } else if realValue > otherReal {
                result = 1;
            } else {
                result = 0;
            }
        } else if kind == SQL_INTEGER && other.kind == SQL_REAL {
            var myReal = intValue * 1.0;
            if myReal < other.realValue {
                result = -1;
            } else if myReal > other.realValue {
                result = 1;
            } else {
                result = 0;
            }
        } else if kind == SQL_REAL && other.kind == SQL_TEXT {
            var otherReal = stringToNumber(other.textValue);
            if realValue < otherReal {
                result = -1;
            } else if realValue > otherReal {
                result = 1;
            } else {
                result = 0;
            }
        } else if kind == SQL_TEXT && other.kind == SQL_REAL {
            var myReal = stringToNumber(textValue);
            if myReal < other.realValue {
                result = -1;
            } else if myReal > other.realValue {
                result = 1;
            } else {
                result = 0;
            }
        // BOOLEAN comparisons
        } else if kind == SQL_BOOLEAN && other.kind == SQL_BOOLEAN {
            if intValue < other.intValue { result = -1; }
            else if intValue > other.intValue { result = 1; }
            else { result = 0; }
        } else if kind == SQL_BOOLEAN && other.kind == SQL_INTEGER {
            if intValue < other.intValue { result = -1; }
            else if intValue > other.intValue { result = 1; }
            else { result = 0; }
        } else if kind == SQL_INTEGER && other.kind == SQL_BOOLEAN {
            if intValue < other.intValue { result = -1; }
            else if intValue > other.intValue { result = 1; }
            else { result = 0; }
        // DATE comparisons
        } else if kind == SQL_DATE && other.kind == SQL_DATE {
            if intValue < other.intValue { result = -1; }
            else if intValue > other.intValue { result = 1; }
            else { result = 0; }
        // TIMESTAMP comparisons
        } else if kind == SQL_TIMESTAMP && other.kind == SQL_TIMESTAMP {
            if intValue < other.intValue { result = -1; }
            else if intValue > other.intValue { result = 1; }
            else { result = 0; }
        // DATE vs TIMESTAMP cross-type (both store epoch seconds)
        } else if kind == SQL_DATE && other.kind == SQL_TIMESTAMP {
            if intValue < other.intValue { result = -1; }
            else if intValue > other.intValue { result = 1; }
            else { result = 0; }
        } else if kind == SQL_TIMESTAMP && other.kind == SQL_DATE {
            if intValue < other.intValue { result = -1; }
            else if intValue > other.intValue { result = 1; }
            else { result = 0; }
        // DATE vs TEXT cross-type
        } else if kind == SQL_DATE && other.kind == SQL_TEXT {
            var otherDays = parseDateText(other.textValue);
            if intValue < otherDays { result = -1; }
            else if intValue > otherDays { result = 1; }
            else { result = 0; }
        } else if kind == SQL_TEXT && other.kind == SQL_DATE {
            var myDays = parseDateText(textValue);
            if myDays < other.intValue { result = -1; }
            else if myDays > other.intValue { result = 1; }
            else { result = 0; }
        // TIMESTAMP vs TEXT cross-type
        } else if kind == SQL_TIMESTAMP && other.kind == SQL_TEXT {
            var otherEpoch = parseDateTimeText(other.textValue);
            if intValue < otherEpoch { result = -1; }
            else if intValue > otherEpoch { result = 1; }
            else { result = 0; }
        } else if kind == SQL_TEXT && other.kind == SQL_TIMESTAMP {
            var myEpoch = parseDateTimeText(textValue);
            if myEpoch < other.intValue { result = -1; }
            else if myEpoch > other.intValue { result = 1; }
            else { result = 0; }
        // JSON comparisons (text-based)
        } else if kind == SQL_JSON && other.kind == SQL_JSON {
            if textValue == other.textValue { result = 0; }
            else { result = -1; }  // JSON equality only; no ordering
        } else if kind == SQL_JSON && other.kind == SQL_TEXT {
            if textValue == other.textValue { result = 0; }
            else { result = -1; }
        } else if kind == SQL_TEXT && other.kind == SQL_JSON {
            if textValue == other.textValue { result = 0; }
            else { result = -1; }
        } else if kind < other.kind {
            result = -1;
        } else if kind > other.kind {
            result = 1;
        }

        return result;
    }

    expose func equals(other: SqlValue) -> Boolean {
        return compare(other) == 0;
    }

    // NULL-safe equality for constraint checks (NULL == NULL is true)
    expose func nullSafeEquals(other: SqlValue) -> Boolean {
        if kind == SQL_NULL && other.kind == SQL_NULL { return true; }
        if kind == SQL_NULL || other.kind == SQL_NULL { return false; }
        return compare(other) == 0;
    }
}

//=============================================================================
// FACTORY FUNCTIONS
//=============================================================================

func sqlNull() -> SqlValue {
    var v = new SqlValue();
    v.initNull();
    return v;
}

func sqlInteger(val: Integer) -> SqlValue {
    var v = new SqlValue();
    v.initInteger(val);
    return v;
}

func sqlReal(val: Float, text: String) -> SqlValue {
    var v = new SqlValue();
    v.initReal(val, text);
    return v;
}

func sqlText(val: String) -> SqlValue {
    var v = new SqlValue();
    v.initText(val);
    return v;
}

func sqlBlob(val: String) -> SqlValue {
    var v = new SqlValue();
    v.initBlob(val);
    return v;
}

func sqlBoolean(val: Boolean) -> SqlValue {
    var v = new SqlValue();
    v.initBoolean(val);
    return v;
}

func sqlDate(daysSinceEpoch: Integer) -> SqlValue {
    var v = new SqlValue();
    v.initDate(daysSinceEpoch);
    return v;
}

func sqlTimestamp(epochSeconds: Integer) -> SqlValue {
    var v = new SqlValue();
    v.initTimestamp(epochSeconds);
    return v;
}

func sqlJson(val: String) -> SqlValue {
    var v = new SqlValue();
    v.initJson(val);
    return v;
}

func sqlArray(val: String) -> SqlValue {
    var v = new SqlValue();
    v.initArray(val);
    return v;
}

//=============================================================================
// ARRAY UTILITY FUNCTIONS
//=============================================================================

// Parse a PG-format array string "{1,2,3}" into a list of string elements
func parseArrayElements(arrayText: String) -> List[String] {
    var elements: List[String] = [];
    var len = String.Length(arrayText);
    if len < 2 { return elements; }

    // Strip outer braces
    var inner = String.Substring(arrayText, 1, len - 2);
    var innerLen = String.Length(inner);
    if innerLen == 0 { return elements; }

    // Split by comma, respecting quoted elements
    var current = "";
    var inQuotes = false;
    var i = 0;
    while i < innerLen {
        var ch = String.Substring(inner, i, 1);
        if inQuotes {
            if ch == "\"" {
                if i + 1 < innerLen && String.Substring(inner, i + 1, 1) == "\"" {
                    current = current + "\"";
                    i = i + 2;
                    continue;
                }
                inQuotes = false;
            } else {
                current = current + ch;
            }
        } else {
            if ch == "\"" {
                inQuotes = true;
            } else if ch == "," {
                elements.add(String.Trim(current));
                current = "";
            } else {
                current = current + ch;
            }
        }
        i = i + 1;
    }
    if String.Length(current) > 0 || innerLen > 0 {
        elements.add(String.Trim(current));
    }
    return elements;
}

// Build a PG-format array string from a list of string elements
func buildArrayString(elements: List[String]) -> String {
    var result = "{";
    var i = 0;
    while i < elements.count() {
        if i > 0 { result = result + ","; }
        result = result + elements.get(i);
        i = i + 1;
    }
    result = result + "}";
    return result;
}
