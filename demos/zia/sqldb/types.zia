// types.zia â€” SQL Value Types
// Part of ViperSQL
//
// Defines the SqlValue entity, the universal runtime representation of
// a SQL value. Each SqlValue has a kind (SQL_NULL, SQL_INTEGER, SQL_REAL,
// SQL_TEXT, SQL_BLOB) and carries the corresponding typed payload.
// Provides comparison, type coercion, arithmetic, and display formatting.
// Factory functions (sqlNull, sqlInteger, sqlReal, sqlText) create values
// concisely throughout the codebase.

module types;

bind String = Viper.String;
bind Fmt = Viper.Fmt;
bind DateTime = Viper.Time.DateTime;

//=============================================================================
// SQL TYPE CONSTANTS
//=============================================================================

final SQL_NULL = 0;
final SQL_INTEGER = 1;
final SQL_REAL = 2;
final SQL_TEXT = 3;
final SQL_BLOB = 4;
final SQL_BOOLEAN = 5;
final SQL_DATE = 6;       // intValue = days since Unix epoch (1970-01-01)
final SQL_TIMESTAMP = 7;  // intValue = epoch seconds

//=============================================================================
// HELPER FUNCTIONS
//=============================================================================

// Helper function to convert string to integer
func stringToInt(text: String) -> Integer {
    var result = 0;
    var i = 0;
    var len = String.Length(text);
    var negative = false;

    if len > 0 {
        if String.Substring(text, 0, 1) == "-" {
            negative = true;
            i = 1;
        }
    }

    while i < len {
        var ch = String.Substring(text, i, 1);
        if ch == "." {
            break;  // Stop at decimal point for integer truncation
        }
        var code = String.Asc(ch);
        if code >= 48 && code <= 57 {
            result = result * 10 + (code - 48);
        }
        i = i + 1;
    }

    if negative == true {
        return -result;
    }
    return result;
}

// Helper function to convert string to number
func stringToNumber(text: String) -> Float {
    var result = 0.0;
    var i = 0;
    var len = String.Length(text);
    var negative = false;
    var foundDecimal = false;
    var decimalPlace = 0.1;

    if len > 0 {
        if String.Substring(text, 0, 1) == "-" {
            negative = true;
            i = 1;
        }
    }

    while i < len {
        var ch = String.Substring(text, i, 1);
        if ch == "." {
            foundDecimal = true;
            i = i + 1;
            continue;
        }
        var code = String.Asc(ch);
        if code >= 48 && code <= 57 {
            var digit = code - 48;
            if foundDecimal {
                result = result + digit * decimalPlace;
                decimalPlace = decimalPlace * 0.1;
            } else {
                result = result * 10.0 + digit;
            }
        }
        i = i + 1;
    }

    if negative {
        return -result;
    }
    return result;
}

//=============================================================================
// DATE/TIME HELPERS
//=============================================================================

func fmtDateParts(y: Integer, m: Integer, d: Integer) -> String {
    var result = Fmt.Int(y) + "-";
    if m < 10 { result = result + "0"; }
    result = result + Fmt.Int(m) + "-";
    if d < 10 { result = result + "0"; }
    result = result + Fmt.Int(d);
    return result;
}

func fmtTimeParts(h: Integer, m: Integer, s: Integer) -> String {
    var result = "";
    if h < 10 { result = result + "0"; }
    result = result + Fmt.Int(h) + ":";
    if m < 10 { result = result + "0"; }
    result = result + Fmt.Int(m) + ":";
    if s < 10 { result = result + "0"; }
    result = result + Fmt.Int(s);
    return result;
}

// Convert DATE epoch (noon local) to TIMESTAMP epoch (midnight local for same date)
func dateToTimestamp(dateEpoch: Integer) -> Integer {
    var y = DateTime.Year(dateEpoch);
    var m = DateTime.Month(dateEpoch);
    var d = DateTime.Day(dateEpoch);
    return DateTime.Create(y, m, d, 0, 0, 0);
}

// Convert TIMESTAMP epoch to DATE epoch (noon local for that date)
func timestampToDate(tsEpoch: Integer) -> Integer {
    var y = DateTime.Year(tsEpoch);
    var m = DateTime.Month(tsEpoch);
    var d = DateTime.Day(tsEpoch);
    return DateTime.Create(y, m, d, 12, 0, 0);
}

// Parse "YYYY-MM-DD" text to DATE epoch (noon local)
func parseDateText(text: String) -> Integer {
    var sLen = String.Length(text);
    if sLen < 10 { return 0; }
    var yr = stringToInt(String.Substring(text, 0, 4));
    var mo = stringToInt(String.Substring(text, 5, 2));
    var dy = stringToInt(String.Substring(text, 8, 2));
    return DateTime.Create(yr, mo, dy, 12, 0, 0);
}

// Parse "YYYY-MM-DD" or "YYYY-MM-DDTHH:MM:SS" to epoch seconds
func parseDateTimeText(text: String) -> Integer {
    var sLen = String.Length(text);
    if sLen < 10 { return 0; }
    var yr = stringToInt(String.Substring(text, 0, 4));
    var mo = stringToInt(String.Substring(text, 5, 2));
    var dy = stringToInt(String.Substring(text, 8, 2));
    var hr = 0;
    var mn = 0;
    var sc = 0;
    if sLen >= 19 {
        var sep = String.Substring(text, 10, 1);
        if sep == "T" || sep == " " {
            hr = stringToInt(String.Substring(text, 11, 2));
            mn = stringToInt(String.Substring(text, 14, 2));
            sc = stringToInt(String.Substring(text, 17, 2));
        }
    }
    return DateTime.Create(yr, mo, dy, hr, mn, sc);
}

//=============================================================================
// SQL VALUE ENTITY
//=============================================================================

entity SqlValue {
    expose Integer kind;       // SQL_NULL, SQL_INTEGER, SQL_REAL, SQL_TEXT, SQL_BLOB
    expose Integer intValue;   // Used when kind == SQL_INTEGER
    expose Float realValue;    // Used when kind == SQL_REAL
    expose String textValue;   // Used when kind == SQL_TEXT or SQL_BLOB

    expose func init() {
        kind = SQL_NULL;
        intValue = 0;
        realValue = 0.0;
        textValue = "";
    }

    expose func initNull() {
        kind = SQL_NULL;
        intValue = 0;
        realValue = 0.0;
        textValue = "";
    }

    expose func initInteger(val: Integer) {
        kind = SQL_INTEGER;
        intValue = val;
        realValue = 0.0;
        textValue = "";
    }

    expose func initReal(val: Float, text: String) {
        kind = SQL_REAL;
        intValue = 0;
        realValue = val;
        textValue = text;
    }

    expose func initText(val: String) {
        kind = SQL_TEXT;
        intValue = 0;
        realValue = 0.0;
        textValue = val;
    }

    expose func initBlob(val: String) {
        kind = SQL_BLOB;
        intValue = 0;
        realValue = 0.0;
        textValue = val;
    }

    expose func initBoolean(val: Boolean) {
        kind = SQL_BOOLEAN;
        if val { intValue = 1; } else { intValue = 0; }
        realValue = 0.0;
        textValue = "";
    }

    expose func initDate(daysSinceEpoch: Integer) {
        kind = SQL_DATE;
        intValue = daysSinceEpoch;
        realValue = 0.0;
        textValue = "";
    }

    expose func initTimestamp(epochSeconds: Integer) {
        kind = SQL_TIMESTAMP;
        intValue = epochSeconds;
        realValue = 0.0;
        textValue = "";
    }

    expose func isNull() -> Boolean { return kind == SQL_NULL; }
    expose func isInteger() -> Boolean { return kind == SQL_INTEGER; }
    expose func isReal() -> Boolean { return kind == SQL_REAL; }
    expose func isText() -> Boolean { return kind == SQL_TEXT; }
    expose func isBlob() -> Boolean { return kind == SQL_BLOB; }
    expose func isBoolean() -> Boolean { return kind == SQL_BOOLEAN; }
    expose func isDate() -> Boolean { return kind == SQL_DATE; }
    expose func isTimestamp() -> Boolean { return kind == SQL_TIMESTAMP; }

    expose func typeName() -> String {
        if (kind == SQL_NULL) { return "NULL"; }
        if (kind == SQL_INTEGER) { return "INTEGER"; }
        if (kind == SQL_REAL) { return "REAL"; }
        if (kind == SQL_TEXT) { return "TEXT"; }
        if (kind == SQL_BLOB) { return "BLOB"; }
        if (kind == SQL_BOOLEAN) { return "BOOLEAN"; }
        if (kind == SQL_DATE) { return "DATE"; }
        if (kind == SQL_TIMESTAMP) { return "TIMESTAMP"; }
        return "UNKNOWN";
    }

    expose func toString() -> String {
        if (kind == SQL_NULL) { return "NULL"; }
        if (kind == SQL_INTEGER) { return Fmt.Int(intValue); }
        if (kind == SQL_REAL) { return textValue; }
        if (kind == SQL_TEXT) { return textValue; }
        if (kind == SQL_BLOB) { return textValue; }
        if (kind == SQL_BOOLEAN) {
            if intValue != 0 { return "true"; }
            return "false";
        }
        if (kind == SQL_DATE) {
            var y = DateTime.Year(intValue);
            var m = DateTime.Month(intValue);
            var d = DateTime.Day(intValue);
            return fmtDateParts(y, m, d);
        }
        if (kind == SQL_TIMESTAMP) {
            return DateTime.ToLocal(intValue);
        }
        return "?";
    }

    // Format for SQL output (with quotes, escaping single quotes with '')
    expose func toSqlString() -> String {
        if (kind == SQL_NULL) { return "NULL"; }
        if (kind == SQL_INTEGER) { return Fmt.Int(intValue); }
        if (kind == SQL_REAL) { return textValue; }
        if (kind == SQL_TEXT) {
            // Escape single quotes by doubling them
            var escaped = "";
            var i = 0;
            var len = String.Length(textValue);
            while i < len {
                var ch = String.Substring(textValue, i, 1);
                if ch == "'" {
                    escaped = escaped + "''";
                } else {
                    escaped = escaped + ch;
                }
                i = i + 1;
            }
            return "'" + escaped + "'";
        }
        if (kind == SQL_BLOB) { return "X'" + textValue + "'"; }
        if (kind == SQL_BOOLEAN) {
            if intValue != 0 { return "TRUE"; }
            return "FALSE";
        }
        if (kind == SQL_DATE) {
            var y = DateTime.Year(intValue);
            var m = DateTime.Month(intValue);
            var d = DateTime.Day(intValue);
            return "'" + fmtDateParts(y, m, d) + "'";
        }
        if (kind == SQL_TIMESTAMP) {
            var s = DateTime.ToLocal(intValue);
            return "'" + s + "'";
        }
        return "?";
    }

    // Compare two values. Returns -1, 0, 1 for ordering.
    // Returns 2 if either side is NULL (SQL three-valued logic).
    expose func compare(other: SqlValue) -> Integer {
        var result = 0;

        // NULL comparisons return 2 (NULL/unknown) per SQL spec
        if kind == SQL_NULL || other.kind == SQL_NULL {
            return 2;
        }

        if kind == SQL_INTEGER && other.kind == SQL_INTEGER {
            if intValue < other.intValue {
                result = -1;
            } else if intValue > other.intValue {
                result = 1;
            } else {
                result = 0;
            }
        } else if kind == SQL_REAL && other.kind == SQL_REAL {
            if realValue < other.realValue {
                result = -1;
            } else if realValue > other.realValue {
                result = 1;
            } else {
                result = 0;
            }
        } else if kind == SQL_TEXT && other.kind == SQL_TEXT {
            if textValue == other.textValue {
                result = 0;
            } else {
                var myLen = String.Length(textValue);
                var otherLen = String.Length(other.textValue);
                var minLen = myLen;
                if otherLen < minLen { minLen = otherLen; }
                var i = 0;
                var found = false;
                while i < minLen && found == false {
                    var myChar = String.Asc(String.Substring(textValue, i, 1));
                    var otherChar = String.Asc(String.Substring(other.textValue, i, 1));
                    if myChar < otherChar {
                        result = -1;
                        found = true;
                    } else if myChar > otherChar {
                        result = 1;
                        found = true;
                    }
                    i = i + 1;
                }
                if found == false {
                    if myLen < otherLen {
                        result = -1;
                    } else if myLen > otherLen {
                        result = 1;
                    } else {
                        result = 0;
                    }
                }
            }
        } else if kind == SQL_TEXT && other.kind == SQL_INTEGER {
            var myInt = stringToInt(textValue);
            if myInt < other.intValue {
                result = -1;
            } else if myInt > other.intValue {
                result = 1;
            } else {
                result = 0;
            }
        } else if kind == SQL_INTEGER && other.kind == SQL_TEXT {
            var otherInt = stringToInt(other.textValue);
            if intValue < otherInt {
                result = -1;
            } else if intValue > otherInt {
                result = 1;
            } else {
                result = 0;
            }
        } else if kind == SQL_REAL && other.kind == SQL_INTEGER {
            // Convert integer to float for comparison
            var otherReal = other.intValue * 1.0;
            if realValue < otherReal {
                result = -1;
            } else if realValue > otherReal {
                result = 1;
            } else {
                result = 0;
            }
        } else if kind == SQL_INTEGER && other.kind == SQL_REAL {
            var myReal = intValue * 1.0;
            if myReal < other.realValue {
                result = -1;
            } else if myReal > other.realValue {
                result = 1;
            } else {
                result = 0;
            }
        } else if kind == SQL_REAL && other.kind == SQL_TEXT {
            var otherReal = stringToNumber(other.textValue);
            if realValue < otherReal {
                result = -1;
            } else if realValue > otherReal {
                result = 1;
            } else {
                result = 0;
            }
        } else if kind == SQL_TEXT && other.kind == SQL_REAL {
            var myReal = stringToNumber(textValue);
            if myReal < other.realValue {
                result = -1;
            } else if myReal > other.realValue {
                result = 1;
            } else {
                result = 0;
            }
        // BOOLEAN comparisons
        } else if kind == SQL_BOOLEAN && other.kind == SQL_BOOLEAN {
            if intValue < other.intValue { result = -1; }
            else if intValue > other.intValue { result = 1; }
            else { result = 0; }
        } else if kind == SQL_BOOLEAN && other.kind == SQL_INTEGER {
            if intValue < other.intValue { result = -1; }
            else if intValue > other.intValue { result = 1; }
            else { result = 0; }
        } else if kind == SQL_INTEGER && other.kind == SQL_BOOLEAN {
            if intValue < other.intValue { result = -1; }
            else if intValue > other.intValue { result = 1; }
            else { result = 0; }
        // DATE comparisons
        } else if kind == SQL_DATE && other.kind == SQL_DATE {
            if intValue < other.intValue { result = -1; }
            else if intValue > other.intValue { result = 1; }
            else { result = 0; }
        // TIMESTAMP comparisons
        } else if kind == SQL_TIMESTAMP && other.kind == SQL_TIMESTAMP {
            if intValue < other.intValue { result = -1; }
            else if intValue > other.intValue { result = 1; }
            else { result = 0; }
        // DATE vs TIMESTAMP cross-type (both store epoch seconds)
        } else if kind == SQL_DATE && other.kind == SQL_TIMESTAMP {
            if intValue < other.intValue { result = -1; }
            else if intValue > other.intValue { result = 1; }
            else { result = 0; }
        } else if kind == SQL_TIMESTAMP && other.kind == SQL_DATE {
            if intValue < other.intValue { result = -1; }
            else if intValue > other.intValue { result = 1; }
            else { result = 0; }
        // DATE vs TEXT cross-type
        } else if kind == SQL_DATE && other.kind == SQL_TEXT {
            var otherDays = parseDateText(other.textValue);
            if intValue < otherDays { result = -1; }
            else if intValue > otherDays { result = 1; }
            else { result = 0; }
        } else if kind == SQL_TEXT && other.kind == SQL_DATE {
            var myDays = parseDateText(textValue);
            if myDays < other.intValue { result = -1; }
            else if myDays > other.intValue { result = 1; }
            else { result = 0; }
        // TIMESTAMP vs TEXT cross-type
        } else if kind == SQL_TIMESTAMP && other.kind == SQL_TEXT {
            var otherEpoch = parseDateTimeText(other.textValue);
            if intValue < otherEpoch { result = -1; }
            else if intValue > otherEpoch { result = 1; }
            else { result = 0; }
        } else if kind == SQL_TEXT && other.kind == SQL_TIMESTAMP {
            var myEpoch = parseDateTimeText(textValue);
            if myEpoch < other.intValue { result = -1; }
            else if myEpoch > other.intValue { result = 1; }
            else { result = 0; }
        } else if kind < other.kind {
            result = -1;
        } else if kind > other.kind {
            result = 1;
        }

        return result;
    }

    expose func equals(other: SqlValue) -> Boolean {
        return compare(other) == 0;
    }

    // NULL-safe equality for constraint checks (NULL == NULL is true)
    expose func nullSafeEquals(other: SqlValue) -> Boolean {
        if kind == SQL_NULL && other.kind == SQL_NULL { return true; }
        if kind == SQL_NULL || other.kind == SQL_NULL { return false; }
        return compare(other) == 0;
    }
}

//=============================================================================
// FACTORY FUNCTIONS
//=============================================================================

func sqlNull() -> SqlValue {
    var v = new SqlValue();
    v.initNull();
    return v;
}

func sqlInteger(val: Integer) -> SqlValue {
    var v = new SqlValue();
    v.initInteger(val);
    return v;
}

func sqlReal(val: Float, text: String) -> SqlValue {
    var v = new SqlValue();
    v.initReal(val, text);
    return v;
}

func sqlText(val: String) -> SqlValue {
    var v = new SqlValue();
    v.initText(val);
    return v;
}

func sqlBlob(val: String) -> SqlValue {
    var v = new SqlValue();
    v.initBlob(val);
    return v;
}

func sqlBoolean(val: Boolean) -> SqlValue {
    var v = new SqlValue();
    v.initBoolean(val);
    return v;
}

func sqlDate(daysSinceEpoch: Integer) -> SqlValue {
    var v = new SqlValue();
    v.initDate(daysSinceEpoch);
    return v;
}

func sqlTimestamp(epochSeconds: Integer) -> SqlValue {
    var v = new SqlValue();
    v.initTimestamp(epochSeconds);
    return v;
}
