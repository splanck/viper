// json.zia — JSON Parser and Functions
// Part of ViperSQL — Phase 25
//
// Provides a pure-Zia JSON parser for validation, type detection,
// value extraction, and construction. Used by sql_functions.zia
// for JSON_VALID, JSON_TYPE, JSON_EXTRACT, JSON_ARRAY_LENGTH,
// JSON_BUILD_OBJECT, JSON_BUILD_ARRAY, JSON_OBJECT_KEYS, etc.

module json;

bind String = Viper.String;
bind Fmt = Viper.Fmt;

bind "./types";

//=============================================================================
// JSON PARSER STATE
//=============================================================================

entity JsonParser {
    hide String src;
    hide Integer pos;
    hide Integer len;
    hide Boolean hasError;

    expose func init() {
        src = "";
        pos = 0;
        len = 0;
        hasError = false;
    }

    expose func initWithSource(s: String) {
        src = s;
        pos = 0;
        len = String.Length(s);
        hasError = false;
    }

    //-------------------------------------------------------------------------
    // Helpers
    //-------------------------------------------------------------------------

    hide func peek() -> String {
        if pos >= len { return ""; }
        return String.Substring(src, pos, 1);
    }

    hide func advance() {
        pos = pos + 1;
    }

    hide func skipWhitespace() {
        while pos < len {
            var ch = String.Substring(src, pos, 1);
            if ch == " " || ch == "\t" || ch == "\n" || ch == "\r" {
                pos = pos + 1;
            } else {
                return;
            }
        }
    }

    hide func expectChar(ch: String) -> Boolean {
        skipWhitespace();
        if pos < len && String.Substring(src, pos, 1) == ch {
            pos = pos + 1;
            return true;
        }
        hasError = true;
        return false;
    }

    hide func matchWord(word: String) -> Boolean {
        var wLen = String.Length(word);
        if pos + wLen <= len && String.Substring(src, pos, wLen) == word {
            pos = pos + wLen;
            return true;
        }
        hasError = true;
        return false;
    }

    //-------------------------------------------------------------------------
    // Skip a complete JSON value (for validation / navigation)
    //-------------------------------------------------------------------------

    hide func skipValue() {
        skipWhitespace();
        if pos >= len { hasError = true; return; }
        var ch = String.Substring(src, pos, 1);

        if ch == "\"" { skipString(); }
        else if ch == "{" { skipObject(); }
        else if ch == "[" { skipArray(); }
        else if ch == "t" { if matchWord("true") == false { hasError = true; } }
        else if ch == "f" { if matchWord("false") == false { hasError = true; } }
        else if ch == "n" { if matchWord("null") == false { hasError = true; } }
        else { skipNumber(); }
    }

    hide func skipString() {
        if pos >= len || String.Substring(src, pos, 1) != "\"" {
            hasError = true;
            return;
        }
        pos = pos + 1;  // skip opening quote
        while pos < len {
            var ch = String.Substring(src, pos, 1);
            if ch == "\\" {
                pos = pos + 2;  // skip escape sequence
            } else if ch == "\"" {
                pos = pos + 1;  // skip closing quote
                return;
            } else {
                pos = pos + 1;
            }
        }
        hasError = true;  // unterminated string
    }

    hide func skipNumber() {
        if pos >= len { hasError = true; return; }
        var ch = String.Substring(src, pos, 1);
        // Optional minus
        if ch == "-" { pos = pos + 1; }
        // Digits
        var gotDigit = false;
        while pos < len {
            ch = String.Substring(src, pos, 1);
            if ch >= "0" && ch <= "9" {
                gotDigit = true;
                pos = pos + 1;
            } else {
                // check for decimal or exponent break
                if ch == "." || ch == "e" || ch == "E" {
                    pos = pos + 1;
                    // optional sign after e/E
                    if pos < len {
                        var nc = String.Substring(src, pos, 1);
                        if nc == "+" || nc == "-" { pos = pos + 1; }
                    }
                } else {
                    if gotDigit == false { hasError = true; }
                    return;
                }
            }
        }
        if gotDigit == false { hasError = true; }
    }

    hide func skipObject() {
        if expectChar("{") == false { return; }
        skipWhitespace();
        if pos < len && String.Substring(src, pos, 1) == "}" {
            pos = pos + 1;
            return;
        }
        while hasError == false {
            skipWhitespace();
            skipString();  // key
            if hasError { return; }
            skipWhitespace();
            if expectChar(":") == false { return; }
            skipValue();
            if hasError { return; }
            skipWhitespace();
            if pos < len && String.Substring(src, pos, 1) == "," {
                pos = pos + 1;
            } else {
                if expectChar("}") == false { return; }
                return;
            }
        }
    }

    hide func skipArray() {
        if expectChar("[") == false { return; }
        skipWhitespace();
        if pos < len && String.Substring(src, pos, 1) == "]" {
            pos = pos + 1;
            return;
        }
        while hasError == false {
            skipValue();
            if hasError { return; }
            skipWhitespace();
            if pos < len && String.Substring(src, pos, 1) == "," {
                pos = pos + 1;
            } else {
                if expectChar("]") == false { return; }
                return;
            }
        }
    }

    //-------------------------------------------------------------------------
    // Public: Validate JSON
    //-------------------------------------------------------------------------

    expose func isValid() -> Boolean {
        pos = 0;
        hasError = false;
        skipValue();
        if hasError { return false; }
        skipWhitespace();
        return pos == len;  // must consume all input
    }

    //-------------------------------------------------------------------------
    // Public: Get top-level JSON type
    //-------------------------------------------------------------------------

    expose func getType() -> String {
        pos = 0;
        hasError = false;
        skipWhitespace();
        if pos >= len { return "null"; }
        var ch = String.Substring(src, pos, 1);
        if ch == "{" { return "object"; }
        if ch == "[" { return "array"; }
        if ch == "\"" { return "string"; }
        if ch == "t" { return "true"; }
        if ch == "f" { return "false"; }
        if ch == "n" { return "null"; }
        return "number";
    }

    //-------------------------------------------------------------------------
    // Read a string value (including quotes consumed)
    //-------------------------------------------------------------------------

    hide func readString() -> String {
        if pos >= len || String.Substring(src, pos, 1) != "\"" {
            hasError = true;
            return "";
        }
        pos = pos + 1;  // skip opening quote
        var result = "";
        while pos < len {
            var ch = String.Substring(src, pos, 1);
            if ch == "\\" {
                pos = pos + 1;
                if pos < len {
                    var esc = String.Substring(src, pos, 1);
                    if esc == "\"" { result = result + "\""; }
                    else if esc == "\\" { result = result + "\\"; }
                    else if esc == "/" { result = result + "/"; }
                    else if esc == "n" { result = result + "\n"; }
                    else if esc == "t" { result = result + "\t"; }
                    else if esc == "r" { result = result + "\r"; }
                    else { result = result + esc; }
                    pos = pos + 1;
                }
            } else if ch == "\"" {
                pos = pos + 1;
                return result;
            } else {
                result = result + ch;
                pos = pos + 1;
            }
        }
        hasError = true;
        return result;
    }

    //-------------------------------------------------------------------------
    // Read a raw JSON value (string including quotes, or number/bool/null literal)
    //-------------------------------------------------------------------------

    hide func readRawValue() -> String {
        skipWhitespace();
        if pos >= len { hasError = true; return ""; }
        var startPos = pos;
        skipValue();
        if hasError { return ""; }
        return String.Substring(src, startPos, pos - startPos);
    }

    //-------------------------------------------------------------------------
    // Public: Extract value by key from a JSON object
    // Returns the raw JSON substring for the value, or "" if not found.
    //-------------------------------------------------------------------------

    expose func extractKey(key: String) -> String {
        pos = 0;
        hasError = false;
        skipWhitespace();
        if pos >= len || String.Substring(src, pos, 1) != "{" {
            return "";
        }
        pos = pos + 1;  // skip {
        skipWhitespace();
        if pos < len && String.Substring(src, pos, 1) == "}" {
            return "";  // empty object
        }
        while hasError == false && pos < len {
            skipWhitespace();
            var k = readString();
            if hasError { return ""; }
            skipWhitespace();
            if expectChar(":") == false { return ""; }
            if k == key {
                // Found the key, read the raw value
                return readRawValue();
            }
            // Skip this value
            skipValue();
            if hasError { return ""; }
            skipWhitespace();
            if pos < len && String.Substring(src, pos, 1) == "," {
                pos = pos + 1;
            } else {
                return "";  // end of object, key not found
            }
        }
        return "";
    }

    //-------------------------------------------------------------------------
    // Public: Extract value by index from a JSON array
    //-------------------------------------------------------------------------

    expose func extractIndex(idx: Integer) -> String {
        pos = 0;
        hasError = false;
        skipWhitespace();
        if pos >= len || String.Substring(src, pos, 1) != "[" {
            return "";
        }
        pos = pos + 1;  // skip [
        skipWhitespace();
        if pos < len && String.Substring(src, pos, 1) == "]" {
            return "";  // empty array
        }
        var i = 0;
        while hasError == false && pos < len {
            if i == idx {
                return readRawValue();
            }
            skipValue();
            if hasError { return ""; }
            i = i + 1;
            skipWhitespace();
            if pos < len && String.Substring(src, pos, 1) == "," {
                pos = pos + 1;
            } else {
                return "";  // end of array, index not found
            }
        }
        return "";
    }

    //-------------------------------------------------------------------------
    // Public: Get array length
    //-------------------------------------------------------------------------

    expose func arrayLength() -> Integer {
        pos = 0;
        hasError = false;
        skipWhitespace();
        if pos >= len || String.Substring(src, pos, 1) != "[" {
            return -1;  // not an array
        }
        pos = pos + 1;  // skip [
        skipWhitespace();
        if pos < len && String.Substring(src, pos, 1) == "]" {
            return 0;  // empty array
        }
        var count = 0;
        while hasError == false && pos < len {
            skipValue();
            if hasError { return -1; }
            count = count + 1;
            skipWhitespace();
            if pos < len && String.Substring(src, pos, 1) == "," {
                pos = pos + 1;
            } else {
                return count;
            }
        }
        return count;
    }

    //-------------------------------------------------------------------------
    // Public: Get object keys as a JSON array string
    //-------------------------------------------------------------------------

    expose func objectKeys() -> String {
        pos = 0;
        hasError = false;
        skipWhitespace();
        if pos >= len || String.Substring(src, pos, 1) != "{" {
            return "[]";
        }
        pos = pos + 1;  // skip {
        skipWhitespace();
        if pos < len && String.Substring(src, pos, 1) == "}" {
            return "[]";  // empty object
        }
        var keys: List[String] = [];
        while hasError == false && pos < len {
            skipWhitespace();
            var k = readString();
            if hasError { return "[]"; }
            keys.add("\"" + escapeJsonString(k) + "\"");
            skipWhitespace();
            if expectChar(":") == false { return "[]"; }
            skipValue();
            if hasError { return "[]"; }
            skipWhitespace();
            if pos < len && String.Substring(src, pos, 1) == "," {
                pos = pos + 1;
            } else {
                // end of object
                var result = "[";
                var ki = 0;
                while ki < keys.count() {
                    if ki > 0 { result = result + ","; }
                    result = result + keys.get(ki);
                    ki = ki + 1;
                }
                result = result + "]";
                return result;
            }
        }
        return "[]";
    }

    //-------------------------------------------------------------------------
    // Public: Unwrap a JSON string value to a plain text string
    //   Input: "\"hello world\"" -> Output: "hello world"
    //   Non-string input returns the raw value
    //-------------------------------------------------------------------------

    expose func unwrapString(raw: String) -> String {
        var rLen = String.Length(raw);
        if rLen >= 2 && String.Substring(raw, 0, 1) == "\"" && String.Substring(raw, rLen - 1, 1) == "\"" {
            // Parse the string content (handles escape sequences)
            src = raw;
            pos = 0;
            len = rLen;
            hasError = false;
            return readString();
        }
        return raw;
    }
}

//=============================================================================
// JSON UTILITY FUNCTIONS
//=============================================================================

// Escape a string for JSON output (handle \ and " characters)
func escapeJsonString(s: String) -> String {
    var result = "";
    var i = 0;
    var sLen = String.Length(s);
    while i < sLen {
        var ch = String.Substring(s, i, 1);
        if ch == "\"" {
            result = result + "\\\"";
        } else if ch == "\\" {
            result = result + "\\\\";
        } else if ch == "\n" {
            result = result + "\\n";
        } else if ch == "\t" {
            result = result + "\\t";
        } else if ch == "\r" {
            result = result + "\\r";
        } else {
            result = result + ch;
        }
        i = i + 1;
    }
    return result;
}

// Convert a SqlValue to a JSON string representation
func sqlValueToJson(val: SqlValue) -> String {
    if val.kind == SQL_NULL { return "null"; }
    if val.kind == SQL_BOOLEAN {
        if val.intValue != 0 { return "true"; }
        return "false";
    }
    if val.kind == SQL_INTEGER { return Fmt.Int(val.intValue); }
    if val.kind == SQL_REAL { return val.textValue; }
    if val.kind == SQL_JSON { return val.textValue; }
    // Default: wrap as JSON string
    return "\"" + escapeJsonString(val.toString()) + "\"";
}

//=============================================================================
// JSON SQL FUNCTION EVALUATOR
//=============================================================================

// Evaluate JSON functions. Called from the sql_functions dispatch chain.
func evalJsonFunc(name: String, args: List[SqlValue]) -> SqlValue? {

    // JSON_VALID(text) -> BOOLEAN
    if name == "JSON_VALID" && args.count() > 0 {
        var arg = args.get(0);
        if arg.kind == SQL_NULL { return sqlNull(); }
        var text = arg.toString();
        var parser = new JsonParser();
        parser.initWithSource(text);
        return sqlBoolean(parser.isValid());
    }

    // JSON_TYPE(json) -> TEXT ('object', 'array', 'string', 'number', 'true', 'false', 'null')
    if name == "JSON_TYPE" && args.count() > 0 {
        var arg = args.get(0);
        if arg.kind == SQL_NULL { return sqlNull(); }
        var text = arg.toString();
        var parser = new JsonParser();
        parser.initWithSource(text);
        return sqlText(parser.getType());
    }

    // JSON_EXTRACT(json, path) -> JSON value
    // Path is a simple key name or $.key.subkey or $[0] notation
    if name == "JSON_EXTRACT" && args.count() >= 2 {
        var jsonArg = args.get(0);
        var pathArg = args.get(1);
        if jsonArg.kind == SQL_NULL || pathArg.kind == SQL_NULL { return sqlNull(); }
        var jsonStr = jsonArg.toString();
        var path = pathArg.toString();
        var result = jsonExtractPath(jsonStr, path);
        if String.Length(result) == 0 { return sqlNull(); }
        return sqlJson(result);
    }

    // JSON_EXTRACT_TEXT(json, key) -> TEXT (extracts and unwraps string values)
    if name == "JSON_EXTRACT_TEXT" && args.count() >= 2 {
        var jsonArg = args.get(0);
        var keyArg = args.get(1);
        if jsonArg.kind == SQL_NULL || keyArg.kind == SQL_NULL { return sqlNull(); }
        var jsonStr = jsonArg.toString();
        var key = keyArg.toString();
        var parser = new JsonParser();
        parser.initWithSource(jsonStr);
        var raw = parser.extractKey(key);
        if String.Length(raw) == 0 { return sqlNull(); }
        return sqlText(parser.unwrapString(raw));
    }

    // JSON_ARRAY_LENGTH(json) -> INTEGER
    if name == "JSON_ARRAY_LENGTH" && args.count() > 0 {
        var arg = args.get(0);
        if arg.kind == SQL_NULL { return sqlNull(); }
        var parser = new JsonParser();
        parser.initWithSource(arg.toString());
        var arrLen = parser.arrayLength();
        if arrLen < 0 { return sqlNull(); }
        return sqlInteger(arrLen);
    }

    // JSON_OBJECT_KEYS(json) -> JSON array of keys
    if name == "JSON_OBJECT_KEYS" && args.count() > 0 {
        var arg = args.get(0);
        if arg.kind == SQL_NULL { return sqlNull(); }
        var parser = new JsonParser();
        parser.initWithSource(arg.toString());
        return sqlJson(parser.objectKeys());
    }

    // JSON_BUILD_OBJECT(k1, v1, k2, v2, ...) -> JSON object
    if name == "JSON_BUILD_OBJECT" {
        if args.count() % 2 != 0 {
            return sqlNull();  // must have even number of args
        }
        var result = "{";
        var i = 0;
        while i < args.count() {
            if i > 0 { result = result + ","; }
            var key = args.get(i);
            var val = args.get(i + 1);
            result = result + "\"" + escapeJsonString(key.toString()) + "\":" + sqlValueToJson(val);
            i = i + 2;
        }
        result = result + "}";
        return sqlJson(result);
    }

    // JSON_BUILD_ARRAY(v1, v2, ...) -> JSON array
    if name == "JSON_BUILD_ARRAY" {
        var result = "[";
        var i = 0;
        while i < args.count() {
            if i > 0 { result = result + ","; }
            result = result + sqlValueToJson(args.get(i));
            i = i + 1;
        }
        result = result + "]";
        return sqlJson(result);
    }

    // JSON(text) -> JSON (parse and re-emit, validates JSON)
    if name == "JSON" && args.count() > 0 {
        var arg = args.get(0);
        if arg.kind == SQL_NULL { return sqlNull(); }
        if arg.kind == SQL_JSON { return arg; }
        var text = arg.toString();
        var parser = new JsonParser();
        parser.initWithSource(text);
        if parser.isValid() == false { return sqlNull(); }
        return sqlJson(text);
    }

    // JSON_QUOTE(value) -> JSON string
    if name == "JSON_QUOTE" && args.count() > 0 {
        var arg = args.get(0);
        if arg.kind == SQL_NULL { return sqlJson("null"); }
        return sqlJson(sqlValueToJson(arg));
    }

    // JSON_TYPEOF(json) -> TEXT (alias for JSON_TYPE, PostgreSQL name)
    if name == "JSON_TYPEOF" && args.count() > 0 {
        var arg = args.get(0);
        if arg.kind == SQL_NULL { return sqlNull(); }
        var parser = new JsonParser();
        parser.initWithSource(arg.toString());
        return sqlText(parser.getType());
    }

    return null;
}

//=============================================================================
// PATH EXTRACTION HELPER
//=============================================================================

// Extract a value from JSON using a simple path expression.
// Supports:
//   "key"           — top-level object key
//   "$.key"         — same with $ prefix
//   "$.key.subkey"  — nested object keys
//   "$[0]"          — array index
//   "$.arr[0]"      — key then array index
func jsonExtractPath(jsonStr: String, path: String) -> String {
    var current = jsonStr;
    var pathLen = String.Length(path);
    var pi = 0;

    // Skip leading $
    if pathLen > 0 && String.Substring(path, 0, 1) == "$" {
        pi = pi + 1;
    }
    // Skip leading .
    if pi < pathLen && String.Substring(path, pi, 1) == "." {
        pi = pi + 1;
    }

    // If path is empty or just "$", return the whole thing
    if pi >= pathLen { return current; }

    while pi < pathLen && String.Length(current) > 0 {
        var ch = String.Substring(path, pi, 1);

        if ch == "[" {
            // Array index: [N]
            pi = pi + 1;
            var idxStr = "";
            while pi < pathLen && String.Substring(path, pi, 1) != "]" {
                idxStr = idxStr + String.Substring(path, pi, 1);
                pi = pi + 1;
            }
            if pi < pathLen { pi = pi + 1; }  // skip ]
            // Skip trailing dot
            if pi < pathLen && String.Substring(path, pi, 1) == "." {
                pi = pi + 1;
            }
            var idx = stringToInt(idxStr);
            var parser = new JsonParser();
            parser.initWithSource(current);
            current = parser.extractIndex(idx);
        } else {
            // Object key: read until . or [ or end
            var key = "";
            var done = false;
            while pi < pathLen && done == false {
                var kc = String.Substring(path, pi, 1);
                if kc == "." || kc == "[" {
                    done = true;
                    if kc == "." { pi = pi + 1; }  // skip dot, leave [ for next iteration
                } else {
                    key = key + kc;
                    pi = pi + 1;
                }
            }
            if String.Length(key) > 0 {
                var parser = new JsonParser();
                parser.initWithSource(current);
                current = parser.extractKey(key);
            }
        }
    }

    return current;
}
