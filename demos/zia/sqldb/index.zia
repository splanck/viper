// index.zia â€” Index Entities
// Part of ViperSQL
//
// Hash-based in-memory index for accelerating WHERE clause lookups on
// indexed columns. Each HashIndex maps column values to lists of row
// indices using a configurable number of buckets with chaining. The
// IndexManager tracks all indexes per database and provides lookup,
// creation, and maintenance (insert/delete/rebuild) operations.
// Indexes are created via CREATE INDEX and used automatically by the
// executor when a WHERE clause filters on an indexed column.

module index;

bind String = Viper.String;
bind Fmt = Viper.Fmt;

bind "./types";
bind "./schema";
bind "./table";
bind "./expr";

//=============================================================================
// INDEX ENTRY
//=============================================================================

// Index entry - maps a key value to a row index
entity IndexEntry {
    expose Integer keyHash;      // Hash of the key value(s)
    expose String keyString;     // String representation of key for comparison
    expose Integer rowIndex;     // Index into table rows

    expose func init() {
        keyHash = 0;
        keyString = "";
        rowIndex = 0;
    }

    expose func initWith(hash: Integer, keyStr: String, rowIdx: Integer) {
        keyHash = hash;
        keyString = keyStr;
        rowIndex = rowIdx;
    }
}

//=============================================================================
// SQL INDEX
//=============================================================================

// SqlIndex - Hash-based index on one or more columns (with bucket acceleration)
entity SqlIndex {
    expose String name;
    expose String tableName;
    expose List[String] columnNames;
    expose Boolean isUnique;
    expose List[IndexEntry] entries;
    expose List[List[IndexEntry]] buckets;
    expose Integer bucketCount;
    expose Expr? whereExpr;      // Phase 74: partial index predicate
    expose Boolean isPartial;    // Phase 74: true if WHERE clause present

    expose func init() {
        name = "";
        tableName = "";
        columnNames = [];
        isUnique = false;
        entries = [];
        bucketCount = 64;
        buckets = [];
        whereExpr = null;
        isPartial = false;
        initBuckets();
    }

    expose func initWithNames(idxName: String, tblName: String) {
        name = idxName;
        tableName = tblName;
        columnNames = [];
        isUnique = false;
        entries = [];
        bucketCount = 64;
        buckets = [];
        whereExpr = null;
        isPartial = false;
        initBuckets();
    }

    // Initialize empty bucket lists
    expose func initBuckets() {
        buckets = [];
        var i = 0;
        while i < bucketCount {
            buckets.add(new List[IndexEntry]());
            i = i + 1;
        }
    }

    expose func addColumn(colName: String) {
        columnNames.add(colName);
    }

    expose func columnCount() -> Integer {
        return columnNames.count();
    }

    expose func getColumnName(index: Integer) -> String {
        if index >= 0 && index < columnNames.count() {
            return columnNames.get(index);
        }
        return "";
    }

    // Compute a hash for a string (FNV-1a via runtime)
    expose func hashString(s: String) -> Integer {
        var h = Viper.Crypto.Hash.Fast(s);
        if h < 0 { return 0 - h; }
        return h;
    }

    // Build key string from row values for indexed columns
    expose func buildKeyString(row: Row, tbl: Table) -> String {
        var result = "";
        var i = 0;
        while i < columnNames.count() {
            var colName = columnNames.get(i);
            var colIdx = tbl.findColumnIndex(colName);
            if colIdx >= 0 {
                var val = row.getValue(colIdx);
                if i > 0 {
                    result = result + "|";
                }
                result = result + val.toString();
            }
            i = i + 1;
        }
        return result;
    }

    // Add an entry to the index
    expose func addEntry(row: Row, rowIdx: Integer, tbl: Table) -> Boolean {
        var keyStr = buildKeyString(row, tbl);
        var hash = hashString(keyStr);
        var bIdx = hash % bucketCount;
        var bucket = buckets.get(bIdx);

        // Check for unique constraint violation (search only in bucket)
        if isUnique {
            var i = 0;
            while i < bucket.count() {
                if bucket.get(i).keyString == keyStr {
                    return false;  // Duplicate found
                }
                i = i + 1;
            }
        }

        // Add new entry to both flat list and bucket
        var entry = new IndexEntry();
        entry.init();
        entry.initWith(hash, keyStr, rowIdx);
        entries.add(entry);
        bucket.add(entry);
        return true;
    }

    // Remove an entry from the index (for DELETE operations)
    expose func removeEntry(rowIdx: Integer) {
        var i = 0;
        while i < entries.count() {
            if entries.get(i).rowIndex == rowIdx {
                // Also remove from bucket
                var hash = entries.get(i).keyHash;
                var bIdx = hash % bucketCount;
                var bucket = buckets.get(bIdx);
                var j = 0;
                while j < bucket.count() {
                    if bucket.get(j).rowIndex == rowIdx {
                        bucket.removeAt(j);
                        j = bucket.count();  // break
                    }
                    j = j + 1;
                }
                entries.removeAt(i);
                return;
            }
            i = i + 1;
        }
    }

    // Lookup entries matching a composite key (multiple column values)
    // Builds composite key string from values and looks up via hash bucket
    expose func lookupComposite(keyValues: List[SqlValue]) -> List[Integer] {
        var results: List[Integer] = [];
        // Build composite key string using same separator as buildKeyString
        var keyStr = "";
        var i = 0;
        while i < keyValues.count() {
            if i > 0 {
                keyStr = keyStr + "|";
            }
            keyStr = keyStr + keyValues.get(i).toString();
            i = i + 1;
        }
        var hash = hashString(keyStr);
        var bIdx = hash % bucketCount;
        var bucket = buckets.get(bIdx);

        i = 0;
        while i < bucket.count() {
            var entry = bucket.get(i);
            if entry.keyHash == hash && entry.keyString == keyStr {
                results.add(entry.rowIndex);
            }
            i = i + 1;
        }
        return results;
    }

    // Lookup entries matching a prefix of the composite key
    // For an index on (a, b, c), you can search just by a, or by a+b
    expose func lookupPrefix(keyValues: List[SqlValue]) -> List[Integer] {
        var results: List[Integer] = [];
        // Build prefix key string
        var prefix = "";
        var i = 0;
        while i < keyValues.count() {
            if i > 0 {
                prefix = prefix + "|";
            }
            prefix = prefix + keyValues.get(i).toString();
            i = i + 1;
        }
        var prefixLen = Viper.String.Length(prefix);

        // Scan all entries for prefix match (can't use hash for prefix)
        i = 0;
        while i < entries.count() {
            var entry = entries.get(i);
            var ks = entry.keyString;
            if Viper.String.Length(ks) >= prefixLen {
                var sub = Viper.String.Substring(ks, 0, prefixLen);
                if sub == prefix {
                    // Verify it's a complete prefix match (not partial value)
                    // Must end at string boundary or be followed by |
                    if Viper.String.Length(ks) == prefixLen || Viper.String.Substring(ks, prefixLen, 1) == "|" {
                        results.add(entry.rowIndex);
                    }
                }
            }
            i = i + 1;
        }
        return results;
    }

    // Lookup entries matching a single key value (bucket-accelerated)
    expose func lookupSingle(keyVal: SqlValue, tbl: Table) -> List[Integer] {
        var results: List[Integer] = [];
        var keyStr = keyVal.toString();
        var hash = hashString(keyStr);
        var bIdx = hash % bucketCount;
        var bucket = buckets.get(bIdx);

        // Search only within the matching bucket
        var i = 0;
        while i < bucket.count() {
            var entry = bucket.get(i);
            if entry.keyHash == hash {
                // Verify key matches (hash collision check)
                if entry.keyString == keyStr {
                    results.add(entry.rowIndex);
                }
            }
            i = i + 1;
        }

        return results;
    }

    // Range lookup: find all row indices where the indexed column satisfies a range predicate
    // rangeType: 1=GT(>), 2=GE(>=), 3=LT(<), 4=LE(<=), 5=BETWEEN
    // For BETWEEN, both boundVal and upperVal are used
    expose func lookupRange(boundVal: SqlValue, upperVal: SqlValue, rangeType: Integer, tbl: Table) -> List[Integer] {
        var results: List[Integer] = [];
        var i = 0;
        while i < entries.count() {
            var entry = entries.get(i);
            var rowIdx = entry.rowIndex;
            if rowIdx >= 0 && rowIdx < tbl.rowCount() {
                var maybeRow = tbl.getRow(rowIdx);
                if maybeRow != null {
                    var row = maybeRow;
                    if row.deleted == false {
                        var colIdx = tbl.findColumnIndex(columnNames.get(0));
                        if colIdx >= 0 {
                            var val = row.getValue(colIdx);
                            if checkRangeMatch(val, boundVal, upperVal, rangeType) {
                                results.add(rowIdx);
                            }
                        }
                    }
                }
            }
            i = i + 1;
        }
        return results;
    }

    // Check if a value matches a range predicate
    hide func checkRangeMatch(val: SqlValue, boundVal: SqlValue, upperVal: SqlValue, rangeType: Integer) -> Boolean {
        var cmp = val.compare(boundVal);
        if cmp == 2 { return false; }
        if rangeType == 1 { return cmp > 0; }
        if rangeType == 2 { return cmp >= 0; }
        if rangeType == 3 { return cmp < 0; }
        if rangeType == 4 { return cmp <= 0; }
        if rangeType == 5 {
            if cmp < 0 { return false; }
            var cmpUpper = val.compare(upperVal);
            if cmpUpper == 2 { return false; }
            return cmpUpper <= 0;
        }
        return false;
    }

    // Rebuild the entire index from table data
    expose func rebuild(tbl: Table) {
        entries = [];
        initBuckets();
        var i = 0;
        while i < tbl.rowCount() {
            var row = tbl.getRow(i);
            if row != null {
                // Workaround: copy to local var for deleted check
                var r = row;
                if r.deleted == false {
                    // Phase 74: Skip rows that don't match partial index predicate
                    if isPartial && matchesWhere(r, tbl) == false {
                        i = i + 1;
                        continue;
                    }
                    addEntry(r, i, tbl);
                }
            }
            i = i + 1;
        }
    }

    // Phase 74: Evaluate partial index WHERE predicate against a row.
    // Handles common patterns: comparisons, IS NOT NULL, AND/OR, NOT.
    expose func matchesWhere(row: Row, tbl: Table) -> Boolean {
        if whereExpr == null { return true; }
        var e = whereExpr;
        return evalPartialExpr(e!, row, tbl) != 0;
    }

    // Simple expression evaluator for partial index predicates.
    // Returns integer: 0 = false, nonzero = true, for logical ops.
    // For comparisons, returns the value itself (integer representation).
    hide func evalPartialExpr(expr: Expr, row: Row, tbl: Table) -> Integer {
        if expr.kind == EXPR_LITERAL {
            if expr.literalValue.kind == SQL_NULL { return 0; }
            return expr.literalValue.intValue;
        }
        if expr.kind == EXPR_COLUMN {
            var colIdx = tbl.findColumnIndex(expr.columnName);
            if colIdx < 0 { return 0; }
            var val = row.getValue(colIdx);
            if val.kind == SQL_NULL { return 0; }
            return val.intValue;
        }
        if expr.kind == EXPR_UNARY {
            if expr.op == OP_NOT {
                var operand = evalPartialExpr(expr.args.get(0), row, tbl);
                if operand == 0 { return 1; }
                return 0;
            }
            if expr.op == OP_NEG {
                return 0 - evalPartialExpr(expr.args.get(0), row, tbl);
            }
        }
        if expr.kind == EXPR_BINARY {
            // IS / IS NOT NULL
            if expr.op == OP_IS {
                var leftVal = getColumnValue(expr.args.get(0), row, tbl);
                var rightExpr = expr.args.get(1);
                // Check for IS NULL and IS NOT NULL patterns
                if rightExpr.kind == EXPR_LITERAL && rightExpr.literalValue.kind == SQL_NULL {
                    if leftVal.kind == SQL_NULL { return 1; }
                    return 0;
                }
                // IS NOT NULL: parser encodes NOT IS NULL as UNARY NOT around IS
                return 0;
            }
            // AND / OR
            if expr.op == OP_AND {
                var left = evalPartialExpr(expr.args.get(0), row, tbl);
                if left == 0 { return 0; }
                return evalPartialExpr(expr.args.get(1), row, tbl);
            }
            if expr.op == OP_OR {
                var left = evalPartialExpr(expr.args.get(0), row, tbl);
                if left != 0 { return 1; }
                return evalPartialExpr(expr.args.get(1), row, tbl);
            }
            // Comparison operators
            var leftVal = getColumnValue(expr.args.get(0), row, tbl);
            var rightVal = getColumnValue(expr.args.get(1), row, tbl);
            if leftVal.kind == SQL_NULL || rightVal.kind == SQL_NULL { return 0; }
            var cmp = leftVal.compare(rightVal);
            if cmp == 2 { return 0; } // incomparable
            if expr.op == OP_EQ { if cmp == 0 { return 1; } return 0; }
            if expr.op == OP_NE { if cmp != 0 { return 1; } return 0; }
            if expr.op == OP_LT { if cmp < 0 { return 1; } return 0; }
            if expr.op == OP_LE { if cmp <= 0 { return 1; } return 0; }
            if expr.op == OP_GT { if cmp > 0 { return 1; } return 0; }
            if expr.op == OP_GE { if cmp >= 0 { return 1; } return 0; }
        }
        return 0;
    }

    // Get SqlValue for an expression (literal or column reference)
    hide func getColumnValue(expr: Expr, row: Row, tbl: Table) -> SqlValue {
        if expr.kind == EXPR_LITERAL { return expr.literalValue; }
        if expr.kind == EXPR_COLUMN {
            var colIdx = tbl.findColumnIndex(expr.columnName);
            if colIdx >= 0 { return row.getValue(colIdx); }
        }
        return sqlNull();
    }

    expose func entryCount() -> Integer {
        return entries.count();
    }

    expose func toString() -> String {
        var result = "";
        if isUnique {
            result = "UNIQUE ";
        }
        result = result + "INDEX " + name + " ON " + tableName + " (";
        var i = 0;
        while i < columnNames.count() {
            if i > 0 {
                result = result + ", ";
            }
            result = result + columnNames.get(i);
            i = i + 1;
        }
        result = result + ") [" + Fmt.Int(entries.count()) + " entries]";
        if isPartial {
            result = result + " WHERE (partial)";
        }
        return result;
    }
}

// Factory function for creating indexes
func makeIndex(idxName: String, tblName: String) -> SqlIndex {
    var idx = new SqlIndex();
    idx.initWithNames(idxName, tblName);
    return idx;
}

//=============================================================================
// INDEX MANAGER
//=============================================================================

// Index Manager - Stores all indexes for the database
entity IndexManager {
    expose List[SqlIndex] indexes;
    expose List[String] indexNames;  // Parallel list of index names

    expose func init() {
        indexes = [];
        indexNames = [];
    }

    // Find an index by name
    expose func findIndex(idxName: String) -> SqlIndex? {
        var i = 0;
        while i < indexNames.count() {
            if indexNames.get(i) == idxName {
                return indexes.get(i);
            }
            i = i + 1;
        }
        return null;
    }

    // Find an index for a specific table and column combination
    // Matches single-column indexes or the leading column of composite indexes
    expose func findIndexForColumn(tblName: String, colName: String) -> SqlIndex? {
        // First, prefer an exact single-column index
        var i = 0;
        while i < indexes.count() {
            var idx = indexes.get(i);
            if idx.tableName == tblName && idx.columnCount() == 1 {
                if idx.columnNames.get(0) == colName {
                    return idx;
                }
            }
            i = i + 1;
        }
        // Fallback: leading column of a composite index
        i = 0;
        while i < indexes.count() {
            var idx = indexes.get(i);
            if idx.tableName == tblName && idx.columnCount() > 1 {
                if idx.columnNames.get(0) == colName {
                    return idx;
                }
            }
            i = i + 1;
        }
        return null;
    }

    // Find a composite index matching a set of column names (order matters)
    // The provided columns must match a prefix of the index columns
    expose func findIndexForColumns(tblName: String, colNames: List[String]) -> SqlIndex? {
        var i = 0;
        while i < indexes.count() {
            var idx = indexes.get(i);
            if idx.tableName == tblName && idx.columnCount() >= colNames.count() {
                // Check if colNames matches a prefix of idx.columnNames
                var isMatch = true;
                var j = 0;
                while j < colNames.count() {
                    if idx.columnNames.get(j) != colNames.get(j) {
                        isMatch = false;
                        j = colNames.count();  // break
                    }
                    j = j + 1;
                }
                if isMatch {
                    return idx;
                }
            }
            i = i + 1;
        }
        return null;
    }

    // Add an index
    expose func addIndex(idx: SqlIndex) {
        indexes.add(idx);
        indexNames.add(idx.name);
    }

    // Drop an index by name
    expose func dropIndex(idxName: String) -> Boolean {
        var i = 0;
        var count = indexNames.count();
        while i < count {
            var currentName = indexNames.get(i);
            if currentName == idxName {
                indexes.removeAt(i);
                indexNames.removeAt(i);
                return true;
            }
            i = i + 1;
        }
        return false;
    }

    // Phase 66: list all indexes for a specific table
    expose func listIndexesForTable(tableName: String) -> List[SqlIndex] {
        var result: List[SqlIndex] = [];
        var i = 0;
        while i < indexes.count() {
            var idx = indexes.get(i);
            if idx.tableName == tableName {
                result.add(idx);
            }
            i = i + 1;
        }
        return result;
    }

    expose func indexCount() -> Integer {
        return indexes.count();
    }

    expose func getIndex(index: Integer) -> SqlIndex? {
        if index >= 0 && index < indexes.count() {
            return indexes.get(index);
        }
        return null;
    }
}
