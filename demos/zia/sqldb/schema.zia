// schema.zia â€” Column and Row Entities
// Part of ViperSQL
//
// Defines the fundamental data structures for table metadata and row
// storage. Column carries schema information (name, type, constraints
// like PRIMARY KEY, NOT NULL, UNIQUE, FOREIGN KEY, CHECK, DEFAULT).
// Row holds an ordered list of SqlValues and a soft-delete flag.
// Both are used throughout the executor, storage, and join engines.

module schema;

bind "./types";

// Foreign key action constants
final FK_NO_ACTION = 0;   // Default: error if referenced
final FK_CASCADE = 1;     // Delete/update referencing rows
final FK_SET_NULL = 2;    // Set referencing columns to NULL
final FK_RESTRICT = 3;    // Prevent the operation (same as NO ACTION for us)

//=============================================================================
// COLUMN ENTITY
//=============================================================================

entity Column {
    expose String name;
    expose Integer typeCode;
    expose Boolean notNull;
    expose Boolean primaryKey;
    expose Boolean autoIncrement;
    expose Boolean unique;
    expose Boolean hasDefault;
    expose SqlValue defaultValue;
    expose Boolean isForeignKey;
    expose String refTableName;
    expose String refColumnName;
    expose Integer onDeleteAction;
    expose Integer onUpdateAction;
    expose String checkExprSQL;
    // Generated columns (Phase 53)
    expose Boolean isGenerated;       // GENERATED ALWAYS AS (expr) STORED
    expose String generatedExprSQL;   // SQL expression text for generation
    // Phase 68: named constraints
    expose String constraintName;     // Optional name for column constraint

    expose func init() {
        name = "";
        typeCode = SQL_TEXT;
        notNull = false;
        primaryKey = false;
        autoIncrement = false;
        unique = false;
        hasDefault = false;
        defaultValue = new SqlValue();
        defaultValue.initNull();
        isForeignKey = false;
        refTableName = "";
        refColumnName = "";
        onDeleteAction = FK_NO_ACTION;
        onUpdateAction = FK_NO_ACTION;
        checkExprSQL = "";
        isGenerated = false;
        generatedExprSQL = "";
        constraintName = "";
    }

    expose func initWithName(n: String, t: Integer) {
        name = n;
        typeCode = t;
        notNull = false;
        primaryKey = false;
        autoIncrement = false;
        unique = false;
        hasDefault = false;
        defaultValue = new SqlValue();
        defaultValue.initNull();
        isForeignKey = false;
        refTableName = "";
        refColumnName = "";
        onDeleteAction = FK_NO_ACTION;
        onUpdateAction = FK_NO_ACTION;
        checkExprSQL = "";
        isGenerated = false;
        generatedExprSQL = "";
        constraintName = "";
    }

    expose func typeName() -> String {
        if typeCode == SQL_NULL { return "NULL"; }
        if typeCode == SQL_INTEGER { return "INTEGER"; }
        if typeCode == SQL_REAL { return "REAL"; }
        if typeCode == SQL_TEXT { return "TEXT"; }
        if typeCode == SQL_BLOB { return "BLOB"; }
        if typeCode == SQL_BOOLEAN { return "BOOLEAN"; }
        if typeCode == SQL_DATE { return "DATE"; }
        if typeCode == SQL_TIMESTAMP { return "TIMESTAMP"; }
        if typeCode == SQL_JSON { return "JSON"; }
        return "UNKNOWN";
    }

    expose func setDefault(val: SqlValue) {
        hasDefault = true;
        defaultValue = val;
    }

    expose func toString() -> String {
        var result = name + " " + typeName();
        if primaryKey {
            result = result + " PRIMARY KEY";
        }
        if autoIncrement {
            result = result + " AUTOINCREMENT";
        }
        if notNull {
            result = result + " NOT NULL";
        }
        if unique {
            result = result + " UNIQUE";
        }
        if hasDefault {
            result = result + " DEFAULT " + defaultValue.toString();
        }
        if isForeignKey {
            result = result + " REFERENCES " + refTableName + "(" + refColumnName + ")";
        }
        if isGenerated {
            result = result + " GENERATED ALWAYS AS (" + generatedExprSQL + ") STORED";
        }
        return result;
    }
}

func makeColumn(name: String, typeCode: Integer) -> Column {
    var col = new Column();
    col.initWithName(name, typeCode);
    return col;
}

//=============================================================================
// ROW ENTITY
//=============================================================================

entity Row {
    expose List[SqlValue] values;
    expose Boolean deleted;

    // MVCC version tracking (Phase 16)
    expose Integer xmin;    // Transaction ID that created this row version
    expose Integer xmax;    // Transaction ID that deleted/updated this row (0 = live)

    expose func init() {
        values = [];
        deleted = false;
        xmin = 0;
        xmax = 0;
    }

    expose func initWithCount(count: Integer) {
        values = [];
        deleted = false;
        xmin = 0;
        xmax = 0;
        var i = 0;
        while i < count {
            var v = new SqlValue();
            v.initNull();
            values.add(v);
            i = i + 1;
        }
    }

    // MVCC visibility check.
    // A row is visible to a transaction with snapshotId if:
    //   1. xmin is committed (xmin < snapshotId) or created by current txn (xmin == currentTxnId)
    //   2. xmax is 0 (not deleted), or xmax is not yet committed (xmax >= snapshotId) and not current txn
    // When MVCC is not active (snapshotId == 0), falls back to deleted flag.
    expose func isVisible(snapshotId: Integer, currentTxnId: Integer) -> Boolean {
        // Fallback: non-MVCC mode (snapshotId == 0 means no active snapshot)
        if snapshotId == 0 {
            return deleted == false;
        }

        // Row was soft-deleted (legacy path)
        if deleted {
            return false;
        }

        // Check xmin: row must have been created before or by current txn
        if xmin > 0 {
            var xminVisible = false;
            if xmin == currentTxnId {
                xminVisible = true;  // Created by current transaction
            } else if xmin < snapshotId {
                xminVisible = true;  // Created by a committed transaction before snapshot
            }
            if xminVisible == false {
                return false;  // Created by a transaction not yet visible
            }
        }

        // Check xmax: row must not have been deleted before snapshot
        if xmax > 0 {
            if xmax == currentTxnId {
                return false;  // Deleted by current transaction
            }
            if xmax < snapshotId {
                return false;  // Deleted by a committed transaction before snapshot
            }
            // xmax >= snapshotId means delete not yet visible (row still visible)
        }

        return true;
    }

    expose func columnCount() -> Integer {
        return values.count();
    }

    expose func getValue(index: Integer) -> SqlValue {
        if index < 0 || index >= values.count() {
            var nullVal = new SqlValue();
            nullVal.initNull();
            return nullVal;
        }
        return values.get(index);
    }

    expose func setValue(index: Integer, val: SqlValue) {
        if index >= 0 && index < values.count() {
            values.set(index, val);
        }
    }

    expose func addValue(val: SqlValue) {
        values.add(val);
    }

    expose func clone() -> Row {
        var newRow = new Row();
        newRow.init();
        var i = 0;
        while i < values.count() {
            var v = values.get(i);
            var cloned = new SqlValue();
            cloned.kind = v.kind;
            cloned.intValue = v.intValue;
            cloned.realValue = v.realValue;
            cloned.textValue = v.textValue;
            newRow.addValue(cloned);
            i = i + 1;
        }
        newRow.deleted = deleted;
        newRow.xmin = xmin;
        newRow.xmax = xmax;
        return newRow;
    }

    expose func toString() -> String {
        var result = "(";
        var i = 0;
        while i < values.count() {
            if i > 0 {
                result = result + ", ";
            }
            result = result + values.get(i).toString();
            i = i + 1;
        }
        result = result + ")";
        return result;
    }
}

func makeRow(columnCount: Integer) -> Row {
    var row = new Row();
    row.initWithCount(columnCount);
    return row;
}
