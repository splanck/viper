// test_optimizer.zia - Query Optimizer Tests
// Part of ViperSQL - Phase 7 Testing

module test_optimizer;

bind "./optimizer/optimizer";
bind "./types";
bind "./executor";

//=============================================================================
// HELPER FUNCTIONS
//=============================================================================

func stringContains(s: String, sub: String) -> Boolean {
    var sLen = Viper.String.Length(s);
    var subLen = Viper.String.Length(sub);
    if subLen > sLen {
        return false;
    }
    var i = 0;
    while i <= sLen - subLen {
        var slice = Viper.String.Substring(s, i, subLen);
        if slice == sub {
            return true;
        }
        i = i + 1;
    }
    return false;
}

//=============================================================================
// TEST HARNESS
//=============================================================================

var testsPassed = 0;
var testsFailed = 0;

func assert(condition: Boolean, testName: String) {
    if condition {
        testsPassed = testsPassed + 1;
        Viper.Terminal.Say("[PASS] " + testName);
    } else {
        testsFailed = testsFailed + 1;
        Viper.Terminal.Say("[FAIL] " + testName);
    }
}

func printSummary() {
    Viper.Terminal.Say("");
    Viper.Terminal.Say("===========================================");
    Viper.Terminal.Say("QUERY OPTIMIZER TEST SUMMARY");
    Viper.Terminal.Say("===========================================");
    Viper.Terminal.Say("Passed: " + Viper.Fmt.Int(testsPassed));
    Viper.Terminal.Say("Failed: " + Viper.Fmt.Int(testsFailed));
    Viper.Terminal.Say("Total:  " + Viper.Fmt.Int(testsPassed + testsFailed));
    Viper.Terminal.Say("===========================================");
}

//=============================================================================
// TABLE STATS TESTS
//=============================================================================

func testTableStats() {
    Viper.Terminal.Say("");
    Viper.Terminal.Say("--- TableStats Tests ---");

    var stats = new TableStats();
    stats.initWithName("users");

    assert(stats.tableName == "users", "TableStats stores table name");
    assert(stats.rowCount == 0, "TableStats init has 0 rows");

    stats.setRowCount(1000);
    assert(stats.rowCount == 1000, "TableStats can set row count");
    assert(stats.distinctValues > 0, "TableStats estimates distinct values");
}

func testTableStatsSelectivity() {
    var stats = new TableStats();
    stats.initWithName("test");
    stats.setRowCount(100);

    var sel = stats.equalitySelectivityPct();
    assert(sel > 0, "Selectivity is positive");
    assert(sel <= 100, "Selectivity is <= 100");
}

//=============================================================================
// ACCESS PATH TESTS
//=============================================================================

func testAccessPathTableScan() {
    Viper.Terminal.Say("");
    Viper.Terminal.Say("--- AccessPath Tests ---");

    var path = new AccessPath();
    path.initTableScan("users", 1000);

    assert(path.pathType == ACCESS_TABLE_SCAN, "AccessPath is table scan");
    assert(path.tableName == "users", "AccessPath has table name");
    assert(path.estimatedRows == 1000, "AccessPath has estimated rows");
    assert(path.estimatedCost > 0, "AccessPath has positive cost");

    var str = path.toString();
    assert(stringContains(str, "TableScan"), "toString includes TableScan");
    assert(stringContains(str, "users"), "toString includes table name");
}

func testAccessPathIndexSeek() {
    var path = new AccessPath();
    path.initIndexSeek("users", "idx_users_id", 10);

    assert(path.pathType == ACCESS_INDEX_SEEK, "AccessPath is index seek");
    assert(path.indexName == "idx_users_id", "AccessPath has index name");
    assert(path.estimatedRows == 10, "AccessPath has estimated rows");
    assert(path.estimatedCost < 10000, "Index seek cost is low for few rows");

    var str = path.toString();
    assert(stringContains(str, "IndexSeek"), "toString includes IndexSeek");
}

func testAccessPathIndexScan() {
    var path = new AccessPath();
    path.initIndexScan("products", "idx_products_name", 500);

    assert(path.pathType == ACCESS_INDEX_SCAN, "AccessPath is index scan");
    assert(path.estimatedRows == 500, "AccessPath has estimated rows");

    var str = path.toString();
    assert(stringContains(str, "IndexScan"), "toString includes IndexScan");
}

//=============================================================================
// QUERY PLAN TESTS
//=============================================================================

func testQueryPlan() {
    Viper.Terminal.Say("");
    Viper.Terminal.Say("--- QueryPlan Tests ---");

    var plan = new QueryPlan();
    plan.init();

    assert(plan.totalCost == 0, "QueryPlan init has 0 cost");
    assert(plan.accessPaths.count() == 0, "QueryPlan init has no access paths");

    var path1 = new AccessPath();
    path1.initTableScan("users", 100);
    plan.addAccessPath(path1);

    assert(plan.accessPaths.count() == 1, "QueryPlan has 1 access path");
    assert(plan.totalCost > 0, "QueryPlan has positive cost after adding path");

    var path2 = new AccessPath();
    path2.initTableScan("orders", 500);
    plan.addAccessPath(path2);

    assert(plan.accessPaths.count() == 2, "QueryPlan has 2 access paths");
}

func testQueryPlanJoinOrder() {
    var plan = new QueryPlan();
    plan.init();

    var order: List[String] = [];
    order.add("users");
    order.add("orders");
    plan.setJoinOrder(order);

    assert(plan.joinOrder.count() == 2, "QueryPlan has join order");
    assert(plan.joinOrder.get(0) == "users", "First table in join order");
    assert(plan.joinOrder.get(1) == "orders", "Second table in join order");

    plan.setJoinType(JOIN_HASH);
    assert(plan.joinType == JOIN_HASH, "QueryPlan has join type");
}

func testQueryPlanToString() {
    var plan = new QueryPlan();
    plan.init();

    var path = new AccessPath();
    path.initTableScan("users", 100);
    plan.addAccessPath(path);

    var str = plan.toString();
    assert(stringContains(str, "QueryPlan"), "toString includes QueryPlan");
    assert(stringContains(str, "cost"), "toString includes cost");
    assert(stringContains(str, "TableScan"), "toString includes access path");
}

//=============================================================================
// STATS MANAGER TESTS
//=============================================================================

func testStatsManager() {
    Viper.Terminal.Say("");
    Viper.Terminal.Say("--- StatsManager Tests ---");

    var mgr = new StatsManager();
    mgr.init();

    mgr.setRowCount("users", 1000);
    var count = mgr.getRowCount("users");
    assert(count == 1000, "StatsManager stores row count");

    count = mgr.getRowCount("nonexistent");
    assert(count == 0, "StatsManager returns 0 for unknown table");
}

func testStatsManagerWithRealTable() {
    var mgr = new StatsManager();
    mgr.init();

    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE stat_test (id INTEGER, name TEXT)");
    exec.executeSql("INSERT INTO stat_test VALUES (1, 'Apple')");
    exec.executeSql("INSERT INTO stat_test VALUES (2, 'Banana')");
    exec.executeSql("INSERT INTO stat_test VALUES (3, 'Carrot')");

    var maybeTable = exec.db.findTable("stat_test");
    if maybeTable != null {
        var tbl = maybeTable;
        mgr.analyzeTable(tbl);

        var count = mgr.getRowCount("stat_test");
        assert(count == 3, "Stats has correct row count");
    }
}

//=============================================================================
// QUERY OPTIMIZER TESTS
//=============================================================================

func testQueryOptimizer() {
    Viper.Terminal.Say("");
    Viper.Terminal.Say("--- QueryOptimizer Tests ---");

    var optimizer = new QueryOptimizer();
    optimizer.init();

    assert(optimizer.stats != null, "Optimizer has stats manager");
}

func testOptimizerTableScan() {
    var optimizer = new QueryOptimizer();
    optimizer.init();

    optimizer.stats.setRowCount("products", 1000);

    var path = optimizer.createTableScan("products");
    assert(path.pathType == ACCESS_TABLE_SCAN, "Creates table scan");
    assert(path.tableName == "products", "Correct table name");
    assert(path.estimatedRows == 1000, "Correct row estimate");
}

func testOptimizerIndexSeek() {
    var optimizer = new QueryOptimizer();
    optimizer.init();

    optimizer.stats.setRowCount("products", 1000);

    var path = optimizer.createIndexSeek("products", "idx_price", 5);
    assert(path.pathType == ACCESS_INDEX_SEEK, "Creates index seek");
    assert(path.indexName == "idx_price", "Correct index name");
    assert(path.estimatedRows == 50, "Estimated 5% of 1000 = 50 rows");
}

func testOptimizerSimplePlan() {
    var optimizer = new QueryOptimizer();
    optimizer.init();

    optimizer.stats.setRowCount("users", 500);

    var plan = optimizer.createSimplePlan("users");
    assert(plan.accessPaths.count() == 1, "Simple plan has 1 access path");
    assert(plan.totalCost > 0, "Plan has positive cost");
}

func testOptimizerJoinPlan() {
    Viper.Terminal.Say("");
    Viper.Terminal.Say("--- Optimizer Join Tests ---");

    var optimizer = new QueryOptimizer();
    optimizer.init();

    optimizer.stats.setRowCount("users", 100);
    optimizer.stats.setRowCount("orders", 1000);

    var plan = optimizer.createJoinPlan("users", "orders");
    assert(plan.accessPaths.count() == 2, "Join plan has 2 access paths");
    assert(plan.joinOrder.count() == 2, "Join plan has join order");

    // Smaller table (users) should be first
    assert(plan.joinOrder.get(0) == "users", "Smaller table first in join order");
    assert(plan.joinOrder.get(1) == "orders", "Larger table second");

    // Total > 1000, should use hash join
    assert(plan.joinType == JOIN_HASH, "Large join uses hash join");
}

func testOptimizerSmallJoinPlan() {
    var optimizer = new QueryOptimizer();
    optimizer.init();

    optimizer.stats.setRowCount("a", 50);
    optimizer.stats.setRowCount("b", 100);

    var plan = optimizer.createJoinPlan("a", "b");
    // Total = 150, should use nested loop
    assert(plan.joinType == JOIN_NESTED_LOOP, "Small join uses nested loop");
}

func testOptimizerCostComparison() {
    Viper.Terminal.Say("");
    Viper.Terminal.Say("--- Optimizer Cost Comparison Tests ---");

    var tableScan = new AccessPath();
    tableScan.initTableScan("large_table", 10000);

    var indexSeek = new AccessPath();
    indexSeek.initIndexSeek("large_table", "idx_id", 10);

    assert(indexSeek.estimatedCost < tableScan.estimatedCost, "Index seek cheaper than table scan");
    assert(tableScan.estimatedCost > 100000, "Table scan cost is significant");
    assert(indexSeek.estimatedCost < 1000, "Index seek cost is low");
}

func testOptimizerSelectivity() {
    var optimizer = new QueryOptimizer();
    optimizer.init();

    var eqSel = optimizer.estimateSelectivityPct(true);
    assert(eqSel == EQUALITY_SELECTIVITY, "Equality selectivity correct");

    var defSel = optimizer.estimateSelectivityPct(false);
    assert(defSel == DEFAULT_SELECTIVITY, "Default selectivity correct");
}

func testOptimizerEstimateRows() {
    var optimizer = new QueryOptimizer();
    optimizer.init();

    optimizer.stats.setRowCount("products", 1000);

    var rows = optimizer.estimateRows("products", 10);
    assert(rows == 100, "10% of 1000 = 100 rows");

    rows = optimizer.estimateRows("products", 100);
    assert(rows == 1000, "100% = all rows");
}

//=============================================================================
// EXPLAIN PLAN TESTS
//=============================================================================

func testExplainPlan() {
    Viper.Terminal.Say("");
    Viper.Terminal.Say("--- Explain Plan Tests ---");

    var optimizer = new QueryOptimizer();
    optimizer.init();

    var plan = new QueryPlan();
    plan.init();

    var path = new AccessPath();
    path.initTableScan("users", 1000);
    plan.addAccessPath(path);
    plan.description = "Full table scan required";

    var explain = optimizer.explainPlan(plan);
    assert(stringContains(explain, "QueryPlan"), "Explain shows QueryPlan");
    assert(stringContains(explain, "TableScan"), "Explain shows TableScan");
    assert(stringContains(explain, "users"), "Explain shows table name");
}

func testExplainPlanWithJoin() {
    var optimizer = new QueryOptimizer();
    optimizer.init();

    optimizer.stats.setRowCount("customers", 100);
    optimizer.stats.setRowCount("orders", 1000);

    var plan = optimizer.createJoinPlan("customers", "orders");

    var explain = optimizer.explainPlan(plan);
    assert(stringContains(explain, "customers"), "Explain shows first table");
    assert(stringContains(explain, "orders"), "Explain shows second table");
}

//=============================================================================
// MAIN
//=============================================================================

func main() {
    Viper.Terminal.Say("===========================================");
    Viper.Terminal.Say("VIPERSQL QUERY OPTIMIZER TESTS");
    Viper.Terminal.Say("===========================================");

    // TableStats tests
    testTableStats();
    testTableStatsSelectivity();

    // AccessPath tests
    testAccessPathTableScan();
    testAccessPathIndexSeek();
    testAccessPathIndexScan();

    // QueryPlan tests
    testQueryPlan();
    testQueryPlanJoinOrder();
    testQueryPlanToString();

    // StatsManager tests
    testStatsManager();
    testStatsManagerWithRealTable();

    // QueryOptimizer tests
    testQueryOptimizer();
    testOptimizerTableScan();
    testOptimizerIndexSeek();
    testOptimizerSimplePlan();
    testOptimizerJoinPlan();
    testOptimizerSmallJoinPlan();
    testOptimizerCostComparison();
    testOptimizerSelectivity();
    testOptimizerEstimateRows();

    // Explain tests
    testExplainPlan();
    testExplainPlanWithJoin();

    printSummary();
}
