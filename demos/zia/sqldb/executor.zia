// executor.zia — SQL Executor (Core)
// Part of ViperSQL
//
// The Executor is the central query processing engine. It owns per-session
// state and coordinates statement execution through delegated handlers:
//   - DdlHandler (ddl.zia): CREATE/DROP/ALTER TABLE, INDEX, VIEW, DATABASE, USER
//   - DmlHandler (dml.zia): INSERT, UPDATE, DELETE with constraints and cascades
//   - QueryHandler (query.zia): SELECT, GROUP BY, sorting, subqueries, CTEs
//
// This file retains:
//   - Executor entity fields and initialization
//   - Expression evaluation (evalExpr, evalCondition, evalColumn, etc.)
//   - Index-based lookups (canUseIndex, indexLookup, indexRangeLookup)
//   - SQL dispatch (executeSqlDispatch → delegates to handlers)
//   - Transaction management (BEGIN/COMMIT/ROLLBACK, journal)
//   - Concurrency control (shared/exclusive locking)
//
// Each client connection gets its own Executor instance sharing the
// thread-safe DatabaseServer and StorageEngine. Per-connection state
// (transaction journal, subquery context, temp tables) is isolated.

module executor;

bind String = Viper.String;
bind Fmt = Viper.Fmt;
bind IO = Viper.IO;
bind Viper.Math;
bind DateTime = Viper.Time.DateTime;
bind Pattern = Viper.Text.Pattern;

bind "./types";
bind "./schema";
bind "./table";
bind "./index";
bind "./expr";
bind "./stmt";
bind "./parser";
bind "./database";
bind "./result";
bind "./server";
bind "./storage/page";
bind "./storage/serializer";
bind "./storage/pager";
bind "./storage/buffer";
bind "./storage/schema_page";
bind "./storage/data_page";
bind "./storage/engine";
bind "./storage/btree";
bind "./storage/btree_node";
bind "./setops";
bind "./join";
bind "./persistence";
bind "./csv";
bind "./optimizer/optimizer";
bind "./storage/txn";
bind "./sql_functions";
bind "./sql_window";
bind "./system_views";
bind "./ddl";
bind "./dml";
bind "./query";
bind "./triggers";
bind "./sequence";
bind "./procedures";

//=============================================================================
// TRANSACTION JOURNAL
//=============================================================================

// Journal entry types
final JOURNAL_INSERT = 1;   // Row inserted — undo: remove it
final JOURNAL_DELETE = 2;   // Row soft-deleted — undo: undelete it
final JOURNAL_UPDATE = 3;   // Row updated — undo: restore old values

entity JournalEntry {
    expose Integer entryType;
    expose String tableName;
    expose Integer rowIndex;     // Row index at time of operation
    expose Row beforeImage;      // Old row data (for UPDATE/DELETE undo)

    expose func init() {
        entryType = 0;
        tableName = "";
        rowIndex = -1;
    }

    expose func initInsert(tbl: String, idx: Integer) {
        entryType = JOURNAL_INSERT;
        tableName = tbl;
        rowIndex = idx;
    }

    expose func initDelete(tbl: String, idx: Integer, oldRow: Row) {
        entryType = JOURNAL_DELETE;
        tableName = tbl;
        rowIndex = idx;
        beforeImage = oldRow;
    }

    expose func initUpdate(tbl: String, idx: Integer, oldRow: Row) {
        entryType = JOURNAL_UPDATE;
        tableName = tbl;
        rowIndex = idx;
        beforeImage = oldRow;
    }
}

//=============================================================================
// EXECUTOR ENTITY
//=============================================================================

entity Executor {
    // Multi-database server (Phase 1)
    expose DatabaseServer server;

    // These point to server's current database/index manager
    // Using non-optional because server always has a current database
    expose Database db;
    expose IndexManager indexMgr;

    // Helper modules (initialized in init())
    expose JoinEngine joinEngine;
    expose PersistenceManager persistence;
    expose CsvHandler csvHandler;

    // Query optimizer (cost-based access path selection)
    expose QueryOptimizer optimizer;

    // Delegated statement handlers (see ddl.zia, dml.zia, query.zia)
    expose DdlHandler ddlHandler;
    expose DmlHandler dmlHandler;
    expose QueryHandler queryHandler;

    // Persistent storage engine (null when using in-memory mode)
    expose StorageEngine? storageEngine;

    // Transaction state
    expose Boolean inTransaction;
    expose List[JournalEntry] journal;
    expose List[String] txnDirtyTables;  // Tables modified during transaction

    // Context for correlated subqueries
    expose Row? outerRow;
    expose Table? outerTable;
    expose String outerTableAlias;
    expose String currentTableAlias;
    expose Integer subqueryDepth;

    // Per-executor current database context (for multi-user: each executor tracks its own)
    expose String currentDbName;
    expose Integer currentDbIndex;

    // Concurrency control: session ID and shared lock manager
    // In standalone mode (init()), sessionId=0 and tableLockMgr=null (no locking).
    // In multi-user mode (initWithServer()), uses shared lock manager from server.
    expose Integer sessionId;
    expose TableLockManager? tableLockMgr;
    expose RowLockManager? rowLockMgr;

    // Current authenticated user (Phase 13: privilege checking)
    // Defaults to "admin" for backward compatibility in standalone mode.
    expose String currentUser;

    // Per-session temporary tables (CREATE TEMP TABLE goes here)
    expose Database? tempDb;

    // MVCC snapshot state (Phase 16)
    // mvccTxnCounter: monotonically increasing counter for assigning txn IDs
    // mvccTxnId: current transaction's ID (0 when not in a transaction)
    // mvccSnapshotId: snapshot point — txn counter at BEGIN time (0 = no snapshot)
    expose Integer mvccTxnCounter;
    expose Integer mvccTxnId;
    expose Integer mvccSnapshotId;

    // Trigger manager (Phase 17)
    expose TriggerManager triggerMgr;
    expose Integer triggerDepth;    // Current trigger recursion depth (0 = not in trigger)

    // Sequence manager (Phase 18)
    expose SequenceManager seqMgr;

    // Function manager (Phase 19: Stored Procedures)
    expose FunctionManager funcMgr;

    // Random seed for RANDOM() function
    expose Integer randomSeed;

    // Subquery result cache to avoid re-executing the same subquery per row
    // This prevents native codegen string corruption from repeated recursive calls
    // Stores cloned scalar values (for scalar subqueries) and value lists (for IN subqueries)
    hide List[String] subqueryCacheKeys;
    hide List[SqlValue] subqueryCacheScalars;
    hide List[List[SqlValue]] subqueryCacheLists;

    // B-tree index tracking for persistent databases (Phase 10)
    // Parallel lists mapping index names to B-tree instances
    expose List[BTree] btrees;
    expose List[String] btreeIndexNames;

    // Vacuum/Analyze statistics tracking (Phase 26)
    // Parallel lists keyed by table name
    expose List[String] vacuumStatNames;
    expose List[Integer] vacuumStatDeadRemoved;     // Total dead rows removed by VACUUM
    expose List[Integer] vacuumStatLastVacuumTime;  // Epoch time of last VACUUM
    expose List[Integer] vacuumStatVacuumCount;     // Number of times vacuumed
    expose List[Integer] analyzeStatLiveRows;       // Live row count at last ANALYZE
    expose List[Integer] analyzeStatDeadRows;       // Dead row count at last ANALYZE
    expose List[Integer] analyzeStatLastAnalyzeTime; // Epoch time of last ANALYZE
    expose List[Integer] analyzeStatAnalyzeCount;    // Number of times analyzed

    // pg_stat tracking (Phase 27) — per-table statistics
    expose List[String] pgStatTableNames;
    expose List[Integer] pgStatSeqScan;       // Sequential scan count
    expose List[Integer] pgStatSeqTupRead;    // Rows read by sequential scans
    expose List[Integer] pgStatIdxScan;       // Index scan count
    expose List[Integer] pgStatIdxTupFetch;   // Rows fetched by index scans
    expose List[Integer] pgStatInsert;        // Rows inserted
    expose List[Integer] pgStatUpdate;        // Rows updated
    expose List[Integer] pgStatDelete;        // Rows deleted

    // pg_stat tracking — per-index statistics
    expose List[String] pgStatIndexNames;
    expose List[String] pgStatIndexTableNames;
    expose List[Integer] pgStatIndexIdxScan;
    expose List[Integer] pgStatIndexTupRead;
    expose List[Integer] pgStatIndexTupFetch;

    // Session tracking
    expose String pgStatLastQuery;
    expose Integer pgStatSessionStart;
    expose Integer pgStatQueryCount;
    // Prepared statements (Phase 30)
    expose List[String] preparedNames;
    expose List[String] preparedSqlTemplates;
    expose List[Integer] preparedParamCounts;

    // Cursors (Phase 32)
    expose List[String] cursorNames;
    expose List[QueryResult] cursorResults;   // Materialized result sets
    expose List[Integer] cursorPositions;      // Current fetch position (0-based, -1 = before first)

    // Savepoints (Phase 33)
    expose List[String] savepointNames;
    expose List[Integer] savepointJournalMarks;  // Journal index at savepoint creation

    // Session variables (Phase 43): key-value pairs
    expose List[String] sessionVarNames;
    expose List[String] sessionVarValues;

    // Object comments (Phase 43): COMMENT ON TABLE/COLUMN
    expose List[String] commentObjectKeys;   // "table:name" or "column:table.col"
    expose List[String] commentObjectValues;

    expose func init() {
        server = new DatabaseServer();
        server.init();
        // Initialize db and indexMgr - server always has 'main' database after init
        // Direct assignment from server lists (guaranteed non-null after server.init())
        db = server.dbList.get(0);
        indexMgr = server.indexManagers.get(0);
        storageEngine = null;
        currentDbName = "main";
        currentDbIndex = 0;
        sessionId = 0;
        tableLockMgr = null;
        rowLockMgr = null;
        currentUser = "admin";
        inTransaction = false;
        journal = [];
        txnDirtyTables = [];
        outerRow = null;
        outerTable = null;
        outerTableAlias = "";
        currentTableAlias = "";
        subqueryDepth = 0;
        randomSeed = 42;
        mvccTxnCounter = 1;
        mvccTxnId = 0;
        mvccSnapshotId = 0;
        triggerMgr = new TriggerManager();
        triggerMgr.init();
        triggerDepth = 0;
        seqMgr = new SequenceManager();
        seqMgr.init();
        funcMgr = new FunctionManager();
        funcMgr.init();
        var td = new Database();
        td.initWithName("tempdb");
        tempDb = td;
        subqueryCacheKeys = [];
        subqueryCacheScalars = [];
        subqueryCacheLists = [];
        btrees = [];
        btreeIndexNames = [];
        vacuumStatNames = [];
        vacuumStatDeadRemoved = [];
        vacuumStatLastVacuumTime = [];
        vacuumStatVacuumCount = [];
        analyzeStatLiveRows = [];
        analyzeStatDeadRows = [];
        analyzeStatLastAnalyzeTime = [];
        analyzeStatAnalyzeCount = [];
        pgStatTableNames = [];
        pgStatSeqScan = [];
        pgStatSeqTupRead = [];
        pgStatIdxScan = [];
        pgStatIdxTupFetch = [];
        pgStatInsert = [];
        pgStatUpdate = [];
        pgStatDelete = [];
        pgStatIndexNames = [];
        pgStatIndexTableNames = [];
        pgStatIndexIdxScan = [];
        pgStatIndexTupRead = [];
        pgStatIndexTupFetch = [];
        pgStatLastQuery = "";
        pgStatSessionStart = DateTime.Now();
        pgStatQueryCount = 0;
        preparedNames = [];
        preparedSqlTemplates = [];
        preparedParamCounts = [];
        cursorNames = [];
        cursorResults = [];
        cursorPositions = [];
        savepointNames = [];
        savepointJournalMarks = [];
        sessionVarNames = [];
        sessionVarValues = [];
        commentObjectKeys = [];
        commentObjectValues = [];
        initDefaultSessionVars();
        joinEngine = new JoinEngine(self);
        persistence = new PersistenceManager(self);
        csvHandler = new CsvHandler(self);
        optimizer = new QueryOptimizer();
        optimizer.init();
        ddlHandler = new DdlHandler(self);
        dmlHandler = new DmlHandler(self);
        queryHandler = new QueryHandler(self);
    }

    // Initialize with a shared DatabaseServer (for multi-user: multiple executors share one server)
    // sessId is the unique session identifier used for table-level lock ownership.
    expose func initWithServer(existingServer: DatabaseServer, sessId: Integer) {
        server = existingServer;
        // Start on the 'main' database (index 0)
        db = server.dbList.get(0);
        indexMgr = server.indexManagers.get(0);
        storageEngine = server.getStorageEngine("main");
        currentDbName = "main";
        currentDbIndex = 0;
        sessionId = sessId;
        tableLockMgr = server.tableLockMgr;
        rowLockMgr = server.rowLockMgr;
        currentUser = "admin";
        inTransaction = false;
        journal = [];
        txnDirtyTables = [];
        outerRow = null;
        outerTable = null;
        outerTableAlias = "";
        currentTableAlias = "";
        subqueryDepth = 0;
        randomSeed = 42;
        mvccTxnCounter = 1;
        mvccTxnId = 0;
        mvccSnapshotId = 0;
        triggerMgr = new TriggerManager();
        triggerMgr.init();
        triggerDepth = 0;
        seqMgr = new SequenceManager();
        seqMgr.init();
        funcMgr = new FunctionManager();
        funcMgr.init();
        var td = new Database();
        td.initWithName("tempdb");
        tempDb = td;
        subqueryCacheKeys = [];
        subqueryCacheScalars = [];
        subqueryCacheLists = [];
        btrees = [];
        btreeIndexNames = [];
        vacuumStatNames = [];
        vacuumStatDeadRemoved = [];
        vacuumStatLastVacuumTime = [];
        vacuumStatVacuumCount = [];
        analyzeStatLiveRows = [];
        analyzeStatDeadRows = [];
        analyzeStatLastAnalyzeTime = [];
        analyzeStatAnalyzeCount = [];
        pgStatTableNames = [];
        pgStatSeqScan = [];
        pgStatSeqTupRead = [];
        pgStatIdxScan = [];
        pgStatIdxTupFetch = [];
        pgStatInsert = [];
        pgStatUpdate = [];
        pgStatDelete = [];
        pgStatIndexNames = [];
        pgStatIndexTableNames = [];
        pgStatIndexIdxScan = [];
        pgStatIndexTupRead = [];
        pgStatIndexTupFetch = [];
        pgStatLastQuery = "";
        pgStatSessionStart = DateTime.Now();
        pgStatQueryCount = 0;
        preparedNames = [];
        preparedSqlTemplates = [];
        preparedParamCounts = [];
        cursorNames = [];
        cursorResults = [];
        cursorPositions = [];
        savepointNames = [];
        savepointJournalMarks = [];
        sessionVarNames = [];
        sessionVarValues = [];
        commentObjectKeys = [];
        commentObjectValues = [];
        initDefaultSessionVars();
        joinEngine = new JoinEngine(self);
        persistence = new PersistenceManager(self);
        csvHandler = new CsvHandler(self);
        optimizer = new QueryOptimizer();
        optimizer.init();
        ddlHandler = new DdlHandler(self);
        dmlHandler = new DmlHandler(self);
        queryHandler = new QueryHandler(self);
    }

    //=========================================================================
    // SESSION VARIABLES (Phase 43)
    //=========================================================================

    hide func initDefaultSessionVars() {
        setSessionVar("server_version", "16.0 (ViperSQL)");
        setSessionVar("server_encoding", "UTF8");
        setSessionVar("client_encoding", "UTF8");
        setSessionVar("search_path", "public");
        setSessionVar("timezone", "UTC");
        setSessionVar("datestyle", "ISO, MDY");
        setSessionVar("standard_conforming_strings", "on");
        setSessionVar("application_name", "");
        setSessionVar("statement_timeout", "0");
        setSessionVar("lock_timeout", "5000");
        setSessionVar("work_mem", "4MB");
        setSessionVar("max_connections", "100");
    }

    expose func getSessionVar(name: String) -> String {
        var key = String.ToLower(name);
        var i = 0;
        while i < sessionVarNames.count() {
            if sessionVarNames.get(i) == key {
                return sessionVarValues.get(i);
            }
            i = i + 1;
        }
        return "";
    }

    expose func setSessionVar(name: String, value: String) {
        var key = String.ToLower(name);
        var i = 0;
        while i < sessionVarNames.count() {
            if sessionVarNames.get(i) == key {
                sessionVarValues.set(i, value);
                return;
            }
            i = i + 1;
        }
        sessionVarNames.add(key);
        sessionVarValues.add(value);
    }

    expose func hasSessionVar(name: String) -> Boolean {
        var key = String.ToLower(name);
        var i = 0;
        while i < sessionVarNames.count() {
            if sessionVarNames.get(i) == key {
                return true;
            }
            i = i + 1;
        }
        return false;
    }

    //=========================================================================
    // COMMENT ON (Phase 43)
    //=========================================================================

    expose func setComment(objectKey: String, comment: String) {
        var i = 0;
        while i < commentObjectKeys.count() {
            if commentObjectKeys.get(i) == objectKey {
                commentObjectValues.set(i, comment);
                return;
            }
            i = i + 1;
        }
        commentObjectKeys.add(objectKey);
        commentObjectValues.add(comment);
    }

    expose func getComment(objectKey: String) -> String {
        var i = 0;
        while i < commentObjectKeys.count() {
            if commentObjectKeys.get(i) == objectKey {
                return commentObjectValues.get(i);
            }
            i = i + 1;
        }
        return "";
    }

    expose func removeComment(objectKey: String) {
        var i = 0;
        while i < commentObjectKeys.count() {
            if commentObjectKeys.get(i) == objectKey {
                commentObjectKeys.removeAt(i);
                commentObjectValues.removeAt(i);
                return;
            }
            i = i + 1;
        }
    }

    // Set the current user for privilege checking (called after authentication)
    expose func setCurrentUser(user: String) {
        currentUser = user;
    }

    // Check if current user is a superuser (admin bypasses all privilege checks)
    expose func isSuperuser() -> Boolean {
        return currentUser == "admin";
    }

    // Refresh db and indexMgr references from per-executor current database
    expose func refreshCurrentDatabase() {
        db = server.dbList.get(currentDbIndex);
        indexMgr = server.indexManagers.get(currentDbIndex);
    }

    // Look up a table by name, checking temp tables first, then current database.
    // This ensures temp tables shadow regular tables with the same name.
    expose func findTable(tableName: String) -> Table? {
        if tempDb != null {
            var tdb = tempDb;
            var tempTable = tdb.findTable(tableName);
            if tempTable != null {
                return tempTable;
            }
        }
        return db.findTable(tableName);
    }

    // Check if a table is a temp table
    expose func isTempTable(tableName: String) -> Boolean {
        if tempDb != null {
            var tdb = tempDb;
            return tdb.findTable(tableName) != null;
        }
        return false;
    }

    // Clean up all temp tables (called on session disconnect)
    expose func cleanupTempTables() {
        var td = new Database();
        td.initWithName("tempdb");
        tempDb = td;
    }

    // Check if currently in a transaction block (for PG wire protocol status)
    expose func isInTransaction() -> Boolean {
        return inTransaction;
    }

    //=========================================================================
    // TRIGGER FIRING (Phase 17)
    //=========================================================================

    // Fire all triggers for a table/timing/event combination.
    // oldRow and newRow may be null depending on the event:
    //   INSERT: oldRow=null, newRow=the inserted row
    //   DELETE: oldRow=the deleted row, newRow=null
    //   UPDATE: oldRow=before image, newRow=after image
    // Returns empty string on success, error message on failure.
    // For BEFORE triggers, newRow may be modified by the trigger body.
    expose func fireTriggers(tableName: String, timing: Integer, event: Integer,
                             oldRow: Row?, newRow: Row?, table: Table) -> String {
        if triggerDepth >= MAX_TRIGGER_DEPTH {
            return "Maximum trigger recursion depth exceeded";
        }
        var trigs = triggerMgr.getTriggersFor(tableName, timing, event);
        if trigs.count() == 0 {
            return "";
        }
        triggerDepth = triggerDepth + 1;
        var i = 0;
        while i < trigs.count() {
            var trig = trigs.get(i);
            if trig.forEachRow {
                // Set up OLD and NEW temp tables with a single row
                setupTriggerRow("old", oldRow, table);
                setupTriggerRow("new", newRow, table);
                // Execute the trigger body
                var bodyResult = executeSql(trig.bodySQL);
                // Clean up temp tables
                cleanupTriggerRow("old");
                cleanupTriggerRow("new");
                if bodyResult.success == false {
                    triggerDepth = triggerDepth - 1;
                    return "Trigger '" + trig.name + "' failed: " + bodyResult.message;
                }
            } else {
                // FOR EACH STATEMENT: fire once, no OLD/NEW row
                var bodyResult = executeSql(trig.bodySQL);
                if bodyResult.success == false {
                    triggerDepth = triggerDepth - 1;
                    return "Trigger '" + trig.name + "' failed: " + bodyResult.message;
                }
            }
            i = i + 1;
        }
        triggerDepth = triggerDepth - 1;
        return "";
    }

    // Create a temp table with a single row for OLD/NEW trigger references.
    hide func setupTriggerRow(name: String, row: Row?, table: Table) {
        if row == null { return; }
        var r = row;
        // Remove any existing temp table with this name
        if tempDb != null {
            var tdb = tempDb;
            tdb.dropTable(name);
            // Create temp table with same schema as the source table
            var tempTable = new Table();
            tempTable.initWithName(name);
            var ci = 0;
            while ci < table.columnCount() {
                tempTable.addColumn(table.getColumn(ci));
                ci = ci + 1;
            }
            tempTable.addRow(r.clone());
            tdb.addTable(tempTable);
        }
    }

    // Remove a trigger temp table.
    hide func cleanupTriggerRow(name: String) {
        if tempDb != null {
            var tdb = tempDb;
            tdb.dropTable(name);
        }
    }

    //=========================================================================
    // EXPRESSION EVALUATION
    //=========================================================================

    expose func evalExpr(expr: Expr, row: Row, table: Table) -> SqlValue {
        if expr.kind == EXPR_LITERAL {
            return expr.literalValue;
        }
        if expr.kind == EXPR_COLUMN {
            return evalColumn(expr, row, table);
        }
        if expr.kind == EXPR_BINARY {
            return evalBinary(expr, row, table);
        }
        if expr.kind == EXPR_UNARY {
            return evalUnary(expr, row, table);
        }
        if expr.kind == EXPR_FUNCTION {
            return evalFunction(expr, row, table);
        }
        if expr.kind == EXPR_SUBQUERY {
            return evalSubquery(expr, row, table);
        }
        if expr.kind == EXPR_EXISTS {
            return evalExists(expr, row, table);
        }
        if expr.kind == EXPR_CASE {
            return evalCase(expr, row, table);
        }
        // Phase 71: ANY/ALL/SOME quantified comparison
        if expr.kind == EXPR_QUANTIFIED {
            return evalQuantified(expr, row, table);
        }
        return sqlNull();
    }

    // Phase 76: Row value constructor comparison — (a, b) op (1, 2)
    hide func evalRowValueComparison(op: Integer, leftExpr: Expr, rightExpr: Expr, row: Row, table: Table) -> SqlValue {
        var count = leftExpr.args.count();
        if count != rightExpr.args.count() { return sqlInteger(0); }

        if op == OP_EQ {
            // All elements must be equal
            var i = 0;
            while i < count {
                var lv = evalExpr(leftExpr.args.get(i), row, table);
                var rv = evalExpr(rightExpr.args.get(i), row, table);
                var cmp = lv.compare(rv);
                if cmp != 0 { return sqlInteger(0); }
                i = i + 1;
            }
            return sqlInteger(1);
        }
        if op == OP_NE {
            // At least one element must differ
            var i = 0;
            while i < count {
                var lv = evalExpr(leftExpr.args.get(i), row, table);
                var rv = evalExpr(rightExpr.args.get(i), row, table);
                var cmp = lv.compare(rv);
                if cmp != 0 { return sqlInteger(1); }
                i = i + 1;
            }
            return sqlInteger(0);
        }
        // Lexicographic comparison for <, <=, >, >=
        var i = 0;
        while i < count {
            var lv = evalExpr(leftExpr.args.get(i), row, table);
            var rv = evalExpr(rightExpr.args.get(i), row, table);
            var cmp = lv.compare(rv);
            if cmp == 2 { return sqlInteger(0); } // null
            if cmp < 0 {
                if op == OP_LT || op == OP_LE { return sqlInteger(1); }
                return sqlInteger(0);
            }
            if cmp > 0 {
                if op == OP_GT || op == OP_GE { return sqlInteger(1); }
                return sqlInteger(0);
            }
            // Equal — continue to next element
            i = i + 1;
        }
        // All equal: LE and GE return true, LT and GT return false
        if op == OP_LE || op == OP_GE { return sqlInteger(1); }
        return sqlInteger(0);
    }

    // Phase 76: Row value IN — (a, b) IN ((1, 2), (3, 4))
    hide func evalRowValueIn(leftExpr: Expr, rightExpr: Expr, row: Row, table: Table) -> SqlValue {
        // rightExpr should contain the IN list; in the parser, IN (...) builds args
        // For row IN, the right side contains row value constructors in args list
        if rightExpr.kind == EXPR_ROW_VALUE {
            // Single tuple on right: (a, b) IN ((1, 2)) → just compare
            var cmpResult = evalRowValueComparison(OP_EQ, leftExpr, rightExpr, row, table);
            if cmpResult.intValue != 0 { return sqlInteger(1); }
            return sqlInteger(0);
        }
        // For IN list with multiple tuples, the parser builds args as a list
        var i = 0;
        while i < rightExpr.args.count() {
            var tupleExpr = rightExpr.args.get(i);
            if tupleExpr.kind == EXPR_ROW_VALUE {
                var cmpResult = evalRowValueComparison(OP_EQ, leftExpr, tupleExpr, row, table);
                if cmpResult.intValue != 0 { return sqlInteger(1); }
            }
            i = i + 1;
        }
        return sqlInteger(0);
    }

    // Evaluate a CASE expression
    expose func evalCase(expr: Expr, row: Row, table: Table) -> SqlValue {
        // Evaluate each WHEN condition until one is true
        var i = 0;
        while i < expr.caseConditions.count() {
            var condition = expr.caseConditions.get(i);
            var condResult = evalExpr(condition, row, table);

            // Condition is true if non-zero integer or non-empty string
            var isTrue = false;
            if condResult.kind == SQL_INTEGER && condResult.intValue != 0 {
                isTrue = true;
            } else if condResult.kind == SQL_TEXT && condResult.textValue != "" {
                isTrue = true;
            }

            if isTrue {
                // Return the corresponding THEN result
                var result = expr.caseResults.get(i);
                return evalExpr(result, row, table);
            }
            i = i + 1;
        }

        // No condition matched - return ELSE value or NULL
        if expr.caseElse != null {
            var elseExpr = expr.caseElse;
            return evalExpr(elseExpr, row, table);
        }
        return sqlNull();
    }

    // Evaluate EXISTS (SELECT ...) — returns 1 if subquery has rows, 0 otherwise
    hide func evalExists(expr: Expr, outerRowContext: Row, outerTableContext: Table) -> SqlValue {
        // Save outer context for correlated subqueries
        var savedOuterRow = outerRow;
        var savedOuterTable = outerTable;
        var savedOuterAlias = outerTableAlias;
        var savedCurrentAlias = currentTableAlias;

        outerRow = outerRowContext;
        outerTable = outerTableContext;
        // Use table alias if set, otherwise fall back to table name
        if currentTableAlias != "" {
            outerTableAlias = currentTableAlias;
        } else {
            outerTableAlias = outerTableContext.name;
        }

        var sql = flattenSubqueries(expr.subquerySQL);

        subqueryDepth = subqueryDepth + 1;
        var subResult = queryHandler.executeSubquerySelect(sql);
        subqueryDepth = subqueryDepth - 1;

        // Restore context
        outerRow = savedOuterRow;
        outerTable = savedOuterTable;
        outerTableAlias = savedOuterAlias;
        currentTableAlias = savedCurrentAlias;

        if subResult.success && subResult.rowCount() > 0 {
            return sqlInteger(1);
        }
        return sqlInteger(0);
    }

    // Phase 71: Evaluate col op ANY/ALL (subquery)
    hide func evalQuantified(expr: Expr, row: Row, table: Table) -> SqlValue {
        // Evaluate the left operand
        var leftVal = evalExpr(expr.args.get(0), row, table);
        if leftVal.kind == SQL_NULL { return sqlInteger(0); }

        // Build subquery expression to reuse evalInSubquery
        var subExpr = exprSubquery(expr.subquerySQL);
        var values = evalInSubquery(subExpr);

        var compOp = expr.op;
        var quantifier = expr.funcName;  // "ANY" or "ALL"

        if quantifier == "ANY" {
            // True if ANY value satisfies the comparison
            var i = 0;
            while i < values.count() {
                var val = values.get(i);
                if val.kind != SQL_NULL {
                    var cmp = leftVal.compare(val);
                    if cmp != 2 {
                        if compOp == OP_EQ && cmp == 0 { return sqlInteger(1); }
                        if compOp == OP_NE && cmp != 0 { return sqlInteger(1); }
                        if compOp == OP_LT && cmp < 0 { return sqlInteger(1); }
                        if compOp == OP_LE && cmp <= 0 { return sqlInteger(1); }
                        if compOp == OP_GT && cmp > 0 { return sqlInteger(1); }
                        if compOp == OP_GE && cmp >= 0 { return sqlInteger(1); }
                    }
                }
                i = i + 1;
            }
            return sqlInteger(0);
        }

        // ALL: True if ALL values satisfy the comparison (empty = true)
        if values.count() == 0 { return sqlInteger(1); }
        var j = 0;
        while j < values.count() {
            var val = values.get(j);
            if val.kind == SQL_NULL { return sqlInteger(0); }
            var cmp = leftVal.compare(val);
            if cmp == 2 { return sqlInteger(0); }
            if compOp == OP_EQ && cmp != 0 { return sqlInteger(0); }
            if compOp == OP_NE && cmp == 0 { return sqlInteger(0); }
            if compOp == OP_LT && cmp >= 0 { return sqlInteger(0); }
            if compOp == OP_LE && cmp > 0 { return sqlInteger(0); }
            if compOp == OP_GT && cmp <= 0 { return sqlInteger(0); }
            if compOp == OP_GE && cmp < 0 { return sqlInteger(0); }
            j = j + 1;
        }
        return sqlInteger(1);
    }

    // Flatten nested subqueries in a SQL string by pre-evaluating inner
    // (SELECT ...) expressions and substituting their results as literals.
    // This avoids deep recursion through executeSelect which causes
    // stack overflow in native codegen.
    expose func flattenSubqueries(sql: String) -> String {
        // Look for "( SELECT" or "(SELECT" pattern (parser adds space after paren)
        var result = sql;
        var maxPasses = 4;
        var pass = 0;
        while pass < maxPasses {
            // Find the LAST occurrence of a subquery pattern to flatten innermost first
            var idx = -1;
            var searchPos = 0;
            var len = String.Length(result);
            while searchPos < len - 9 {
                var ch = String.Substring(result, searchPos, 1);
                if ch == "(" {
                    // Check if followed by SELECT (with optional space)
                    var remaining = len - searchPos - 1;
                    if remaining >= 7 {
                        var after = String.Substring(result, searchPos + 1, 7);
                        var upperAfter = String.ToUpper(after);
                        if upperAfter == "SELECT " || upperAfter == " SELECT" {
                            idx = searchPos;
                        }
                    }
                }
                searchPos = searchPos + 1;
            }

            if idx < 0 {
                return result;
            }

            // Found inner subquery at idx. Extract it.
            // Find matching closing paren
            var depth = 1;
            var pos = idx + 1;
            while pos < len && depth > 0 {
                var ch = String.Substring(result, pos, 1);
                if ch == "(" {
                    depth = depth + 1;
                } else if ch == ")" {
                    depth = depth - 1;
                }
                if depth > 0 {
                    pos = pos + 1;
                }
            }
            if depth != 0 {
                return result;
            }

            // Extract the inner SQL (without outer parens)
            var innerSql = String.Substring(result, idx + 1, pos - idx - 1);

            // Execute the inner subquery
            var savedOuterRow2 = outerRow;
            var savedOuterTable2 = outerTable;
            var savedOuterAlias2 = outerTableAlias;
            var savedCurrentAlias2 = currentTableAlias;

            var innerResult = queryHandler.executeSubquerySelect(innerSql);

            outerRow = savedOuterRow2;
            outerTable = savedOuterTable2;
            outerTableAlias = savedOuterAlias2;
            currentTableAlias = savedCurrentAlias2;

            // Get scalar result
            var replacement = "NULL";
            if innerResult.success && innerResult.rowCount() > 0 {
                var firstRow = innerResult.getRow(0);
                if firstRow != null {
                    var fr = firstRow;
                    if fr.columnCount() > 0 {
                        var val = fr.getValue(0);
                        if val.kind == SQL_INTEGER {
                            replacement = Fmt.Int(val.intValue);
                        } else if val.kind == SQL_REAL {
                            replacement = val.textValue;
                        } else if val.kind == SQL_TEXT {
                            replacement = "'" + val.textValue + "'";
                        }
                    }
                }
            }

            // Substitute: before + replacement + after
            var before = String.Substring(result, 0, idx);
            var after = String.Substring(result, pos + 1, len - pos - 1);
            result = before + replacement + after;

            pass = pass + 1;
        }
        return result;
    }

    // Evaluate a scalar subquery (with caching for non-correlated subqueries)
    expose func evalSubquery(expr: Expr, outerRowContext: Row, outerTableContext: Table) -> SqlValue {
        // Guard against very deep nesting to prevent stack overflow
        if subqueryDepth >= 8 {
            return sqlNull();
        }

        // Check scalar subquery cache first (avoids repeated recursive calls
        // that cause string corruption in native codegen)
        var cacheKey = expr.subquerySQL;
        var ci = 0;
        while ci < subqueryCacheKeys.count() {
            if subqueryCacheKeys.get(ci) == cacheKey {
                return subqueryCacheScalars.get(ci);
            }
            ci = ci + 1;
        }

        // Set outer context for correlated subqueries
        var savedOuterRow = outerRow;
        var savedOuterTable = outerTable;
        var savedOuterAlias = outerTableAlias;
        var savedCurrentAlias = currentTableAlias;

        outerRow = outerRowContext;
        outerTable = outerTableContext;
        outerTableAlias = currentTableAlias;

        // Clone and flatten nested subqueries to avoid deep recursion stack overflow
        var sql = String.Substring(expr.subquerySQL, 0, String.Length(expr.subquerySQL));
        sql = flattenSubqueries(sql);

        // Execute the subquery via dedicated path to avoid full executeSql recursion
        subqueryDepth = subqueryDepth + 1;
        var result = queryHandler.executeSubquerySelect(sql);
        subqueryDepth = subqueryDepth - 1;

        // Restore ALL outer context including currentTableAlias
        outerRow = savedOuterRow;
        outerTable = savedOuterTable;
        outerTableAlias = savedOuterAlias;
        currentTableAlias = savedCurrentAlias;

        // Return scalar value from first row, first column
        // Clone the value to prevent string lifetime issues with nested subqueries
        if result.success && result.rowCount() > 0 {
            var firstRow = result.getRow(0);
            if firstRow != null {
                var r = firstRow;
                if r.columnCount() > 0 {
                    var val = cloneValue(r.getValue(0));
                    // Cache the cloned value for subsequent calls
                    subqueryCacheKeys.add(cacheKey);
                    subqueryCacheScalars.add(val);
                    // Add empty list to keep indices aligned
                    var emptyList: List[SqlValue] = [];
                    subqueryCacheLists.add(emptyList);
                    return val;
                }
            }
        }
        // Cache null result too
        var nullVal = sqlNull();
        subqueryCacheKeys.add(cacheKey);
        subqueryCacheScalars.add(nullVal);
        var emptyList2: List[SqlValue] = [];
        subqueryCacheLists.add(emptyList2);
        return nullVal;
    }

    // Evaluate an IN subquery: returns the list of cloned values from the subquery.
    // Uses same save/restore pattern as evalSubquery to avoid string corruption
    // in native codegen during recursive calls.
    expose func evalInSubquery(subqueryExpr: Expr) -> List[SqlValue] {
        // Check list cache first
        var cacheKey = subqueryExpr.subquerySQL;
        var ci = 0;
        while ci < subqueryCacheKeys.count() {
            if subqueryCacheKeys.get(ci) == cacheKey {
                return subqueryCacheLists.get(ci);
            }
            ci = ci + 1;
        }

        // Save ALL executor state
        var savedOuterRow = outerRow;
        var savedOuterTable = outerTable;
        var savedOuterAlias = outerTableAlias;
        var savedCurrentAlias = currentTableAlias;

        // Clone and flatten nested subqueries
        var sql = String.Substring(subqueryExpr.subquerySQL, 0, String.Length(subqueryExpr.subquerySQL));
        sql = flattenSubqueries(sql);

        subqueryDepth = subqueryDepth + 1;
        var subResult = queryHandler.executeSubquerySelect(sql);
        subqueryDepth = subqueryDepth - 1;

        // Restore ALL executor state
        outerRow = savedOuterRow;
        outerTable = savedOuterTable;
        outerTableAlias = savedOuterAlias;
        currentTableAlias = savedCurrentAlias;

        // Clone all result values
        var values = new List[SqlValue]();
        if subResult.success {
            var si = 0;
            while si < subResult.rowCount() {
                var subRow = subResult.getRow(si);
                if subRow != null {
                    var sr = subRow;
                    if sr.columnCount() > 0 {
                        values.add(cloneValue(sr.getValue(0)));
                    }
                }
                si = si + 1;
            }
        }

        // Cache the result
        subqueryCacheKeys.add(cacheKey);
        subqueryCacheScalars.add(sqlNull());
        subqueryCacheLists.add(values);
        return values;
    }

    expose func evalColumn(expr: Expr, row: Row, table: Table) -> SqlValue {
        // Check outer context for correlated subqueries
        if expr.tableName != "" && outerTableAlias != "" {
            if expr.tableName == outerTableAlias {
                if outerTable != null && outerRow != null {
                    var ot = outerTable;
                    var orow = outerRow;
                    var outerColIdx = ot.findColumnIndex(expr.columnName);
                    if outerColIdx >= 0 {
                        return orow.getValue(outerColIdx);
                    }
                }
                return sqlNull();
            }
        }

        var colIdx = table.findColumnIndex(expr.columnName);
        if colIdx < 0 {
            // Try outer context
            if expr.tableName == "" && outerTable != null && outerRow != null {
                var ot = outerTable;
                var orow = outerRow;
                var outerColIdx = ot.findColumnIndex(expr.columnName);
                if outerColIdx >= 0 {
                    return orow.getValue(outerColIdx);
                }
            }
            return sqlNull();
        }
        return row.getValue(colIdx);
    }

    expose func evalBinary(expr: Expr, row: Row, table: Table) -> SqlValue {
        var op = expr.op;

        // Phase 76: Row value constructor comparisons
        var leftExpr = expr.getLeft();
        var rightExpr = expr.getRight();
        if leftExpr.kind == EXPR_ROW_VALUE && rightExpr.kind == EXPR_ROW_VALUE {
            return evalRowValueComparison(op, leftExpr, rightExpr, row, table);
        }
        // Phase 76: Row value IN — (a, b) IN ((1, 2), (3, 4))
        if leftExpr.kind == EXPR_ROW_VALUE && op == OP_IN {
            return evalRowValueIn(leftExpr, rightExpr, row, table);
        }

        var left = evalExpr(leftExpr, row, table);

        // Short-circuit AND/OR: avoid evaluating right side when unnecessary
        if op == OP_AND {
            if left.intValue == 0 {
                return sqlInteger(0);
            }
            var rightVal = evalExpr(expr.getRight(), row, table);
            if rightVal.intValue != 0 {
                return sqlInteger(1);
            }
            return sqlInteger(0);
        }
        if op == OP_OR {
            if left.intValue != 0 {
                return sqlInteger(1);
            }
            var rightVal = evalExpr(expr.getRight(), row, table);
            if rightVal.intValue != 0 {
                return sqlInteger(1);
            }
            return sqlInteger(0);
        }

        // For IN with subqueries, don't evaluate right side through evalExpr
        // (which would call evalSubquery and cache a scalar). The IN handler
        // processes the subquery separately with its own list cache.
        var right = sqlNull();
        if op == OP_IN {
            var maybeSubquery = expr.getRight();
            if maybeSubquery.kind != EXPR_SUBQUERY {
                right = evalExpr(maybeSubquery, row, table);
            }
        } else {
            right = evalExpr(expr.getRight(), row, table);
        }

        // Arithmetic (supports INTEGER and REAL)
        if op == OP_ADD {
            if left.kind == SQL_INTEGER && right.kind == SQL_INTEGER {
                return sqlInteger(left.intValue + right.intValue);
            }
            // DATE + INTEGER = DATE (add days)
            if left.kind == SQL_DATE && right.kind == SQL_INTEGER {
                return sqlDate(DateTime.AddDays(left.intValue, right.intValue));
            }
            if left.kind == SQL_INTEGER && right.kind == SQL_DATE {
                return sqlDate(DateTime.AddDays(right.intValue, left.intValue));
            }
            if (left.kind == SQL_REAL || left.kind == SQL_INTEGER) && (right.kind == SQL_REAL || right.kind == SQL_INTEGER) {
                var lv = left.realValue;
                if left.kind == SQL_INTEGER { lv = left.intValue * 1.0; }
                var rv = right.realValue;
                if right.kind == SQL_INTEGER { rv = right.intValue * 1.0; }
                var res = lv + rv;
                return sqlReal(res, Fmt.Num(res));
            }
        }
        if op == OP_SUB {
            if left.kind == SQL_INTEGER && right.kind == SQL_INTEGER {
                return sqlInteger(left.intValue - right.intValue);
            }
            // DATE - INTEGER = DATE (subtract days)
            if left.kind == SQL_DATE && right.kind == SQL_INTEGER {
                return sqlDate(DateTime.AddDays(left.intValue, 0 - right.intValue));
            }
            // DATE - DATE = INTEGER (difference in days)
            if left.kind == SQL_DATE && right.kind == SQL_DATE {
                var diffSecs = DateTime.Diff(left.intValue, right.intValue);
                if diffSecs >= 0 {
                    return sqlInteger((diffSecs + 43200) / 86400);
                }
                return sqlInteger((diffSecs - 43200) / 86400);
            }
            // TIMESTAMP - TIMESTAMP = INTEGER (difference in seconds)
            if left.kind == SQL_TIMESTAMP && right.kind == SQL_TIMESTAMP {
                return sqlInteger(left.intValue - right.intValue);
            }
            if (left.kind == SQL_REAL || left.kind == SQL_INTEGER) && (right.kind == SQL_REAL || right.kind == SQL_INTEGER) {
                var lv = left.realValue;
                if left.kind == SQL_INTEGER { lv = left.intValue * 1.0; }
                var rv = right.realValue;
                if right.kind == SQL_INTEGER { rv = right.intValue * 1.0; }
                var res = lv - rv;
                return sqlReal(res, Fmt.Num(res));
            }
        }
        if op == OP_MUL {
            if left.kind == SQL_INTEGER && right.kind == SQL_INTEGER {
                return sqlInteger(left.intValue * right.intValue);
            }
            if (left.kind == SQL_REAL || left.kind == SQL_INTEGER) && (right.kind == SQL_REAL || right.kind == SQL_INTEGER) {
                var lv = left.realValue;
                if left.kind == SQL_INTEGER { lv = left.intValue * 1.0; }
                var rv = right.realValue;
                if right.kind == SQL_INTEGER { rv = right.intValue * 1.0; }
                var res = lv * rv;
                return sqlReal(res, Fmt.Num(res));
            }
        }
        if op == OP_DIV {
            if left.kind == SQL_INTEGER && right.kind == SQL_INTEGER {
                if right.intValue != 0 {
                    return sqlInteger(left.intValue / right.intValue);
                }
            }
            if (left.kind == SQL_REAL || left.kind == SQL_INTEGER) && (right.kind == SQL_REAL || right.kind == SQL_INTEGER) {
                var lv = left.realValue;
                if left.kind == SQL_INTEGER { lv = left.intValue * 1.0; }
                var rv = right.realValue;
                if right.kind == SQL_INTEGER { rv = right.intValue * 1.0; }
                if rv != 0.0 {
                    var res = lv / rv;
                    return sqlReal(res, Fmt.Num(res));
                }
            }
        }

        // Comparison - return 1 for true, 0 for false
        // compare() returns 2 for NULL comparisons (SQL three-valued logic)
        if op == OP_EQ {
            var cmp = left.compare(right);
            if cmp == 2 { return sqlInteger(0); }
            if cmp == 0 { return sqlInteger(1); }
            return sqlInteger(0);
        }
        if op == OP_NE {
            var cmp = left.compare(right);
            if cmp == 2 { return sqlInteger(0); }
            if cmp != 0 { return sqlInteger(1); }
            return sqlInteger(0);
        }
        if op == OP_LT {
            var cmp = left.compare(right);
            if cmp == 2 { return sqlInteger(0); }
            if cmp < 0 { return sqlInteger(1); }
            return sqlInteger(0);
        }
        if op == OP_LE {
            var cmp = left.compare(right);
            if cmp == 2 { return sqlInteger(0); }
            if cmp <= 0 { return sqlInteger(1); }
            return sqlInteger(0);
        }
        if op == OP_GT {
            var cmp = left.compare(right);
            if cmp == 2 { return sqlInteger(0); }
            if cmp > 0 { return sqlInteger(1); }
            return sqlInteger(0);
        }
        if op == OP_GE {
            var cmp = left.compare(right);
            if cmp == 2 { return sqlInteger(0); }
            if cmp >= 0 { return sqlInteger(1); }
            return sqlInteger(0);
        }

        // IS NULL / IS NOT NULL / IS TRUE / IS FALSE / IS NOT TRUE / IS NOT FALSE
        if op == OP_IS {
            if right.kind == SQL_NULL {
                // IS NULL
                if left.kind == SQL_NULL { return sqlInteger(1); }
                return sqlInteger(0);
            } else if right.intValue == 1 {
                // IS NOT NULL
                if left.kind != SQL_NULL { return sqlInteger(1); }
                return sqlInteger(0);
            } else if right.intValue == 5 {
                // IS TRUE
                if left.kind == SQL_NULL { return sqlInteger(0); }
                if left.intValue != 0 { return sqlInteger(1); }
                return sqlInteger(0);
            } else if right.intValue == 6 {
                // IS FALSE
                if left.kind == SQL_NULL { return sqlInteger(0); }
                if left.intValue == 0 { return sqlInteger(1); }
                return sqlInteger(0);
            } else if right.intValue == 3 {
                // IS NOT TRUE (true when NULL, false, or 0)
                if left.kind == SQL_NULL { return sqlInteger(1); }
                if left.intValue == 0 { return sqlInteger(1); }
                return sqlInteger(0);
            } else if right.intValue == 4 {
                // IS NOT FALSE (true when NULL, true, or non-zero)
                if left.kind == SQL_NULL { return sqlInteger(1); }
                if left.intValue != 0 { return sqlInteger(1); }
                return sqlInteger(0);
            }
        }

        // IS DISTINCT FROM: NULL-safe inequality (treats NULL = NULL as true)
        if op == OP_IS_DISTINCT {
            // Returns true when values are different, treating NULLs as equal
            if left.kind == SQL_NULL && right.kind == SQL_NULL { return sqlInteger(0); }
            if left.kind == SQL_NULL || right.kind == SQL_NULL { return sqlInteger(1); }
            var cmp = left.compare(right);
            if cmp == 0 { return sqlInteger(0); }
            return sqlInteger(1);
        }

        // IS NOT DISTINCT FROM: NULL-safe equality (treats NULL = NULL as true)
        if op == OP_IS_NOT_DISTINCT {
            if left.kind == SQL_NULL && right.kind == SQL_NULL { return sqlInteger(1); }
            if left.kind == SQL_NULL || right.kind == SQL_NULL { return sqlInteger(0); }
            var cmp = left.compare(right);
            if cmp == 0 { return sqlInteger(1); }
            return sqlInteger(0);
        }

        // LIKE pattern matching
        if op == OP_LIKE {
            if left.kind == SQL_NULL { return sqlInteger(0); }
            var leftStr = left.toString();
            var pattern = right.toString();
            if matchLike(leftStr, pattern) {
                return sqlInteger(1);
            }
            return sqlInteger(0);
        }

        // ~ regex match
        if op == OP_REGEX_MATCH {
            if left.kind == SQL_NULL || right.kind == SQL_NULL { return sqlNull(); }
            var text = left.toString();
            var pat = right.toString();
            if Pattern.IsMatch(text, pat) {
                return sqlInteger(1);
            }
            return sqlInteger(0);
        }

        // SIMILAR TO (SQL standard regex-like pattern)
        // Converts SQL SIMILAR TO pattern (% → .*, _ → .) to regex
        if op == OP_SIMILAR_TO {
            if left.kind == SQL_NULL || right.kind == SQL_NULL { return sqlNull(); }
            var text = left.toString();
            var pat = right.toString();
            // Convert SIMILAR TO pattern to regex: % → .*, _ → .
            var regex = "^";
            var pi = 0;
            while pi < String.Length(pat) {
                var ch = String.Substring(pat, pi, 1);
                if ch == "%" { regex = regex + ".*"; }
                else if ch == "_" { regex = regex + "."; }
                else if ch == "." || ch == "(" || ch == ")" || ch == "[" || ch == "]"
                     || ch == "{" || ch == "}" || ch == "^" || ch == "$" || ch == "+"
                     || ch == "?" || ch == "\\" { regex = regex + "\\" + ch; }
                else { regex = regex + ch; }
                pi = pi + 1;
            }
            regex = regex + "$";
            if Pattern.IsMatch(text, regex) {
                return sqlInteger(1);
            }
            return sqlInteger(0);
        }

        // AND/OR handled above with short-circuit evaluation

        // IN operator - right side is a subquery or value list
        if op == OP_IN {
            if left.kind == SQL_NULL { return sqlInteger(0); }
            var rightExpr = expr.getRight();
            if rightExpr.kind == EXPR_SUBQUERY {
                // Delegate to dedicated method that properly saves/restores
                // executor state (avoids string corruption in native codegen)
                var subValues = evalInSubquery(rightExpr);
                // Compare left value against subquery results
                var i = 0;
                while i < subValues.count() {
                    if left.compare(subValues.get(i)) == 0 {
                        return sqlInteger(1);
                    }
                    i = i + 1;
                }
            } else if rightExpr.kind == EXPR_FUNCTION {
                // IN value list (args contain the list values)
                var i = 0;
                while i < rightExpr.args.count() {
                    var listVal = evalExpr(rightExpr.args.get(i), row, table);
                    if left.compare(listVal) == 0 {
                        return sqlInteger(1);
                    }
                    i = i + 1;
                }
            }
            return sqlInteger(0);
        }

        // String concatenation
        if op == OP_CONCAT {
            var leftStr = left.toString();
            var rightStr = right.toString();
            if left.kind == SQL_NULL { leftStr = ""; }
            if right.kind == SQL_NULL { rightStr = ""; }
            return sqlText(leftStr + rightStr);
        }

        return sqlNull();
    }

    expose func evalUnary(expr: Expr, row: Row, table: Table) -> SqlValue {
        var operand = evalExpr(expr.getOperand(), row, table);

        if expr.op == OP_NEG {
            if operand.kind == SQL_INTEGER {
                return sqlInteger(-operand.intValue);
            }
            if operand.kind == SQL_REAL {
                var neg = -operand.realValue;
                return sqlReal(neg, Fmt.Num(neg));
            }
        }
        if expr.op == OP_NOT {
            if operand.kind == SQL_NULL {
                return sqlInteger(0);
            }
            if operand.intValue == 0 {
                return sqlInteger(1);
            }
            return sqlInteger(0);
        }

        return sqlNull();
    }

    // Deep-clone a SqlValue with fresh string allocation to avoid retain issues
    expose func cloneValue(v: SqlValue) -> SqlValue {
        var c = new SqlValue();
        c.kind = v.kind;
        c.intValue = v.intValue;
        c.realValue = v.realValue;
        if v.kind == SQL_TEXT || v.kind == SQL_BLOB || v.kind == SQL_REAL || v.kind == SQL_JSON {
            var len = String.Length(v.textValue);
            c.textValue = String.Substring(v.textValue, 0, len);
        } else {
            c.textValue = "";
        }
        return c;
    }

    // LIKE pattern matching: % matches any sequence, _ matches single char (case-insensitive)
    hide func matchLike(text: String, pattern: String) -> Boolean {
        return Viper.String.LikeCI(text, pattern);
    }

    expose func evalFunction(expr: Expr, row: Row, table: Table) -> SqlValue {
        var name = String.ToUpper(expr.funcName);

        // Short-circuit functions (need lazy argument evaluation)
        if name == "COALESCE" {
            var i = 0;
            while i < expr.args.count() {
                var arg = evalExpr(expr.args.get(i), row, table);
                if arg.kind != SQL_NULL { return arg; }
                i = i + 1;
            }
            return sqlNull();
        }
        if name == "IFNULL" && expr.args.count() >= 2 {
            var arg = evalExpr(expr.args.get(0), row, table);
            if arg.kind == SQL_NULL { return evalExpr(expr.args.get(1), row, table); }
            return arg;
        }
        if name == "NULLIF" && expr.args.count() >= 2 {
            var a = evalExpr(expr.args.get(0), row, table);
            var b = evalExpr(expr.args.get(1), row, table);
            if a.toString() == b.toString() { return sqlNull(); }
            return a;
        }
        if name == "IIF" && expr.args.count() >= 3 {
            var cond = evalExpr(expr.args.get(0), row, table);
            if cond.intValue != 0 { return evalExpr(expr.args.get(1), row, table); }
            return evalExpr(expr.args.get(2), row, table);
        }
        // RANDOM needs executor state (randomSeed)
        if name == "RANDOM" || name == "RAND" {
            randomSeed = (randomSeed * 1103515245 + 12345) % 2147483647;
            var rv = randomSeed;
            if rv < 0 { rv = -rv; }
            return sqlInteger(rv);
        }

        // Sequence functions need executor state (seqMgr) — Phase 18
        if name == "NEXTVAL" && expr.args.count() >= 1 {
            var seqNameVal = evalExpr(expr.args.get(0), row, table);
            var seqName = seqNameVal.toString();
            var maybeSeq = seqMgr.findSequence(seqName);
            if maybeSeq == null {
                return sqlNull();
            }
            var seq = maybeSeq;
            var nv = seq.nextVal();
            if nv <= 0 - 2147483646 {
                return sqlNull();
            }
            return sqlInteger(nv);
        }
        if name == "CURRVAL" && expr.args.count() >= 1 {
            var seqNameVal = evalExpr(expr.args.get(0), row, table);
            var seqName = seqNameVal.toString();
            var maybeSeq = seqMgr.findSequence(seqName);
            if maybeSeq == null {
                return sqlNull();
            }
            var seq = maybeSeq;
            var cv = seq.currVal();
            if cv <= 0 - 2147483646 {
                return sqlNull();
            }
            return sqlInteger(cv);
        }
        if name == "SETVAL" && expr.args.count() >= 2 {
            var seqNameVal = evalExpr(expr.args.get(0), row, table);
            var seqName = seqNameVal.toString();
            var newValExpr = evalExpr(expr.args.get(1), row, table);
            var newVal = newValExpr.intValue;
            var isCalled = true;
            if expr.args.count() >= 3 {
                var calledVal = evalExpr(expr.args.get(2), row, table);
                isCalled = calledVal.intValue != 0;
            }
            var maybeSeq = seqMgr.findSequence(seqName);
            if maybeSeq == null {
                return sqlNull();
            }
            var seq = maybeSeq;
            seq.setVal(newVal, isCalled);
            return sqlInteger(newVal);
        }

        // Session/system information functions (Phase 44)
        if name == "CURRENT_USER" || name == "USER" || name == "SESSION_USER" {
            return sqlText(currentUser);
        }
        if name == "CURRENT_DATABASE" || name == "CURRENT_CATALOG" {
            return sqlText(currentDbName);
        }
        if name == "CURRENT_SCHEMA" {
            return sqlText(getSessionVar("search_path"));
        }
        if name == "VERSION" {
            return sqlText(getSessionVar("server_version"));
        }
        if name == "CURRENT_SETTING" && expr.args.count() >= 1 {
            var settingName = evalExpr(expr.args.get(0), row, table);
            var key = settingName.textValue;
            if hasSessionVar(key) {
                return sqlText(getSessionVar(key));
            }
            return sqlNull();
        }
        if name == "SET_CONFIG" && expr.args.count() >= 2 {
            var cfgName = evalExpr(expr.args.get(0), row, table);
            var cfgValue = evalExpr(expr.args.get(1), row, table);
            setSessionVar(cfgName.textValue, cfgValue.toString());
            return sqlText(cfgValue.toString());
        }
        if name == "PG_BACKEND_PID" {
            return sqlInteger(sessionId);
        }
        if name == "INET_SERVER_PORT" {
            return sqlInteger(5433);
        }
        if name == "PG_IS_IN_RECOVERY" {
            return sqlBoolean(false);
        }
        if name == "TXID_CURRENT" {
            return sqlInteger(mvccTxnId);
        }
        if name == "OBJ_DESCRIPTION" && expr.args.count() >= 1 {
            var objIdVal = evalExpr(expr.args.get(0), row, table);
            // Look up by oid — we store by name, so return empty for now
            return sqlNull();
        }
        if name == "COL_DESCRIPTION" && expr.args.count() >= 2 {
            return sqlNull();
        }
        if name == "HAS_TABLE_PRIVILEGE" && expr.args.count() >= 2 {
            // Simplified: always return true for now
            return sqlBoolean(true);
        }
        if name == "HAS_SCHEMA_PRIVILEGE" && expr.args.count() >= 2 {
            return sqlBoolean(true);
        }

        // ARRAY constructor: ARRAY[1, 2, 3] -> sqlArray("{1,2,3}")
        if name == "ARRAY" {
            var elements: List[String] = [];
            var ei = 0;
            while ei < expr.args.count() {
                var elemVal = evalExpr(expr.args.get(ei), row, table);
                if elemVal.kind == SQL_NULL {
                    elements.add("NULL");
                } else if elemVal.kind == SQL_TEXT {
                    elements.add(elemVal.textValue);
                } else {
                    elements.add(elemVal.toString());
                }
                ei = ei + 1;
            }
            return sqlArray(buildArrayString(elements));
        }

        // Pre-evaluate all arguments for delegation to sql_functions module
        var evalArgs: List[SqlValue] = [];
        var ai = 0;
        while ai < expr.args.count() {
            evalArgs.add(evalExpr(expr.args.get(ai), row, table));
            ai = ai + 1;
        }

        // User-defined stored functions (Phase 19)
        var maybeFunc = funcMgr.findFunction(name, evalArgs.count());
        if maybeFunc != null {
            var storedFn = maybeFunc;
            var substitutedSql = storedFn.substituteParams(evalArgs);
            var fnResult = executeSql(substitutedSql);
            if fnResult.success && fnResult.rows.count() > 0 {
                var fnRow = fnResult.rows.get(0);
                if fnRow.values.count() > 0 {
                    return fnRow.values.get(0);
                }
            }
            if storedFn.returnType == SQL_NULL {
                return sqlNull();  // VOID function
            }
            return sqlNull();
        }

        // Delegate to sql_functions module
        return dispatchSqlFunctionOrNull(name, evalArgs);
    }

    // (CAST/conditional/string/math/date functions delegated to sql_functions module)

    expose func evalCondition(expr: Expr?, row: Row, table: Table) -> Boolean {
        if expr == null {
            return true;
        }
        var e = expr;
        var result = evalExpr(e, row, table);
        return result.intValue != 0;
    }

    //=========================================================================
    // INDEX-BASED LOOKUPS
    //=========================================================================

    // Check if WHERE clause is a simple equality that can use an index
    // Returns the column name and value if usable, null otherwise
    expose func canUseIndex(expr: Expr?, tableName: String) -> Boolean {
        if expr == null {
            return false;
        }
        var e = expr;

        // Check for AND chain of equality predicates (composite index)
        if e.kind == EXPR_BINARY && e.op == OP_AND {
            var eqCols = extractEqualityColumns(e);
            if eqCols.count() >= 2 {
                var maybeIdx = indexMgr.findIndexForColumns(tableName, eqCols);
                if maybeIdx != null {
                    return true;
                }
            }
            // Fall through: the left side of AND might be an indexable equality
            var left = e.getLeft();
            return canUseIndex(left, tableName);
        }

        // Must be a binary expression with OP_EQ
        if e.kind != EXPR_BINARY || e.op != OP_EQ {
            return false;
        }

        var left = e.getLeft();
        var right = e.getRight();

        // Check for column = literal pattern
        if left.kind == EXPR_COLUMN && right.kind == EXPR_LITERAL {
            var colName = left.columnName;
            var maybeIdx = indexMgr.findIndexForColumn(tableName, colName);
            return maybeIdx != null;
        }

        // Check for literal = column pattern
        if left.kind == EXPR_LITERAL && right.kind == EXPR_COLUMN {
            var colName = right.columnName;
            var maybeIdx = indexMgr.findIndexForColumn(tableName, colName);
            return maybeIdx != null;
        }

        return false;
    }

    // Extract column names from AND-chained equality predicates
    // Returns ordered list of column names for composite index matching
    expose func extractEqualityColumns(expr: Expr) -> List[String] {
        var cols: List[String] = [];
        collectEqualityColumns(expr, cols);
        return cols;
    }

    hide func collectEqualityColumns(expr: Expr, cols: List[String]) {
        if expr.kind != EXPR_BINARY { return; }
        if expr.op == OP_AND {
            collectEqualityColumns(expr.getLeft(), cols);
            collectEqualityColumns(expr.getRight(), cols);
            return;
        }
        if expr.op == OP_EQ {
            var left = expr.getLeft();
            var right = expr.getRight();
            if left.kind == EXPR_COLUMN && right.kind == EXPR_LITERAL {
                cols.add(left.columnName);
            } else if left.kind == EXPR_LITERAL && right.kind == EXPR_COLUMN {
                cols.add(right.columnName);
            }
        }
    }

    // Extract column-value pairs from AND-chained equality predicates
    hide func extractEqualityValues(expr: Expr, row: Row, table: Table) -> List[SqlValue] {
        var vals: List[SqlValue] = [];
        collectEqualityValues(expr, vals, row, table);
        return vals;
    }

    hide func collectEqualityValues(expr: Expr, vals: List[SqlValue], row: Row, table: Table) {
        if expr.kind != EXPR_BINARY { return; }
        if expr.op == OP_AND {
            collectEqualityValues(expr.getLeft(), vals, row, table);
            collectEqualityValues(expr.getRight(), vals, row, table);
            return;
        }
        if expr.op == OP_EQ {
            var left = expr.getLeft();
            var right = expr.getRight();
            if left.kind == EXPR_COLUMN && right.kind == EXPR_LITERAL {
                vals.add(right.literalValue);
            } else if left.kind == EXPR_LITERAL && right.kind == EXPR_COLUMN {
                vals.add(left.literalValue);
            }
        }
    }

    // Check if a range predicate (>, >=, <, <=) can use an index
    expose func canUseIndexRange(expr: Expr?, tableName: String) -> Boolean {
        if expr == null {
            return false;
        }
        var e = expr;
        if e.kind != EXPR_BINARY {
            return false;
        }

        // Check for range operators
        var isRange = e.op == OP_GT || e.op == OP_GE || e.op == OP_LT || e.op == OP_LE;
        if isRange == false {
            // Check for BETWEEN (AND of two range conditions on same column)
            if e.op == OP_AND {
                return canUseBetweenIndex(e, tableName);
            }
            return false;
        }

        var left = e.getLeft();
        var right = e.getRight();

        // column op literal
        if left.kind == EXPR_COLUMN && right.kind == EXPR_LITERAL {
            return indexMgr.findIndexForColumn(tableName, left.columnName) != null;
        }
        // literal op column
        if left.kind == EXPR_LITERAL && right.kind == EXPR_COLUMN {
            return indexMgr.findIndexForColumn(tableName, right.columnName) != null;
        }
        return false;
    }

    // Check if a BETWEEN-style AND expression can use an index
    hide func canUseBetweenIndex(expr: Expr, tableName: String) -> Boolean {
        var left = expr.getLeft();
        var right = expr.getRight();

        // Both sides must be range comparisons on the same column
        if left.kind != EXPR_BINARY || right.kind != EXPR_BINARY {
            return false;
        }

        var leftIsRange = left.op == OP_GE || left.op == OP_GT;
        var rightIsRange = right.op == OP_LE || right.op == OP_LT;
        if leftIsRange == false || rightIsRange == false {
            return false;
        }

        // Extract column names
        var leftCol = "";
        if left.getLeft().kind == EXPR_COLUMN {
            leftCol = left.getLeft().columnName;
        }
        var rightCol = "";
        if right.getLeft().kind == EXPR_COLUMN {
            rightCol = right.getLeft().columnName;
        }

        if leftCol == "" || leftCol != rightCol {
            return false;
        }

        return indexMgr.findIndexForColumn(tableName, leftCol) != null;
    }

    // Perform index range lookup
    expose func indexRangeLookup(expr: Expr, tableName: String, table: Table) -> List[Integer] {
        var left = expr.getLeft();
        var right = expr.getRight();

        // Handle BETWEEN (AND of two range conditions)
        if expr.op == OP_AND {
            return indexBetweenLookup(expr, tableName, table);
        }

        var colName = "";
        var boundVal = sqlNull();
        var rangeType = 0;

        // column op literal
        if left.kind == EXPR_COLUMN && right.kind == EXPR_LITERAL {
            colName = left.columnName;
            boundVal = right.literalValue;
            if expr.op == OP_GT { rangeType = 1; }
            else if expr.op == OP_GE { rangeType = 2; }
            else if expr.op == OP_LT { rangeType = 3; }
            else if expr.op == OP_LE { rangeType = 4; }
        }
        // literal op column — reverse the operator direction
        else if left.kind == EXPR_LITERAL && right.kind == EXPR_COLUMN {
            colName = right.columnName;
            boundVal = left.literalValue;
            if expr.op == OP_GT { rangeType = 3; }
            else if expr.op == OP_GE { rangeType = 4; }
            else if expr.op == OP_LT { rangeType = 1; }
            else if expr.op == OP_LE { rangeType = 2; }
        }

        if colName == "" || rangeType == 0 {
            return new List[Integer]();
        }

        var maybeIdx = indexMgr.findIndexForColumn(tableName, colName);
        if maybeIdx == null {
            return new List[Integer]();
        }
        var idx = maybeIdx;
        return idx.lookupRange(boundVal, sqlNull(), rangeType, table);
    }

    // Handle BETWEEN via AND of two range conditions
    hide func indexBetweenLookup(expr: Expr, tableName: String, table: Table) -> List[Integer] {
        var leftExpr = expr.getLeft();
        var rightExpr = expr.getRight();

        // Extract column and bounds
        var colName = "";
        var lowerVal = sqlNull();
        var upperVal = sqlNull();

        if leftExpr.getLeft().kind == EXPR_COLUMN {
            colName = leftExpr.getLeft().columnName;
        }
        if leftExpr.getRight().kind == EXPR_LITERAL {
            lowerVal = leftExpr.getRight().literalValue;
        }
        if rightExpr.getRight().kind == EXPR_LITERAL {
            upperVal = rightExpr.getRight().literalValue;
        }

        if colName == "" {
            return new List[Integer]();
        }

        var maybeIdx = indexMgr.findIndexForColumn(tableName, colName);
        if maybeIdx == null {
            return new List[Integer]();
        }
        var idx = maybeIdx;
        return idx.lookupRange(lowerVal, upperVal, 5, table);
    }

    // Get matching row indices using an index
    expose func indexLookup(expr: Expr, tableName: String, table: Table) -> List[Integer] {
        // Check for composite index lookup (AND chain)
        if expr.kind == EXPR_BINARY && expr.op == OP_AND {
            var eqCols = extractEqualityColumns(expr);
            if eqCols.count() >= 2 {
                var maybeIdx = indexMgr.findIndexForColumns(tableName, eqCols);
                if maybeIdx != null {
                    var idx = maybeIdx;
                    // Build dummy row for value extraction
                    var dummyRow = new Row();
                    dummyRow.init();
                    var vals = extractEqualityValues(expr, dummyRow, table);
                    if vals.count() == idx.columnCount() {
                        // Full composite key match
                        return idx.lookupComposite(vals);
                    } else {
                        // Prefix match
                        return idx.lookupPrefix(vals);
                    }
                }
            }
            // Fall back: try left side as simple equality
            var left = expr.getLeft();
            if left.kind == EXPR_BINARY && left.op == OP_EQ {
                return indexLookup(left, tableName, table);
            }
        }

        var left = expr.getLeft();
        var right = expr.getRight();

        var colName = "";
        var lookupValue = sqlNull();

        // Extract column name and lookup value
        if left.kind == EXPR_COLUMN && right.kind == EXPR_LITERAL {
            colName = left.columnName;
            lookupValue = right.literalValue;
        } else if left.kind == EXPR_LITERAL && right.kind == EXPR_COLUMN {
            colName = right.columnName;
            lookupValue = left.literalValue;
        }

        // Find the index
        var maybeIdx = indexMgr.findIndexForColumn(tableName, colName);
        if maybeIdx == null {
            // Fall back to empty list (caller should do linear scan)
            var empty: List[Integer] = [];
            return empty;
        }

        var idx = maybeIdx;
        // For single-column indexes, use lookupSingle
        if idx.columnCount() == 1 {
            return idx.lookupSingle(lookupValue, table);
        }
        // For composite index with single-value prefix lookup
        var prefixVals: List[SqlValue] = [];
        prefixVals.add(lookupValue);
        return idx.lookupPrefix(prefixVals);
    }

    //=========================================================================
    // AGGREGATE FUNCTIONS
    //=========================================================================

    // Check if expression is an aggregate function
    // Note: MIN/MAX with exactly 2 arguments are treated as scalar functions
    expose func isAggregateExpr(expr: Expr) -> Boolean {
        if expr.kind == EXPR_FUNCTION {
            var funcName = String.ToUpper(expr.funcName);
            if funcName == "COUNT" { return true; }
            if funcName == "COUNT_DISTINCT" { return true; }
            if funcName == "SUM" { return true; }
            if funcName == "AVG" { return true; }
            // MIN/MAX with 2 args = scalar, with 1 arg = aggregate
            if funcName == "MIN" && expr.args.count() != 2 { return true; }
            if funcName == "MAX" && expr.args.count() != 2 { return true; }
            if funcName == "STRING_AGG" { return true; }
            if funcName == "GROUP_CONCAT" { return true; }
            if funcName == "ARRAY_AGG" { return true; }
            if funcName == "BOOL_AND" { return true; }
            if funcName == "BOOL_OR" { return true; }
        }
        return false;
    }

    // Check if SELECT has any aggregate functions
    expose func hasAggregates(stmt: SelectStmt) -> Boolean {
        var c = 0;
        while c < stmt.columns.count() {
            var colExpr = stmt.columns.get(c);
            if isAggregateExpr(colExpr) {
                return true;
            }
            c = c + 1;
        }
        return false;
    }

    // Hash for GROUP BY and hash join bucketing (FNV-1a via runtime).
    expose func computeKeyHash(s: String) -> Integer {
        var h = Viper.Crypto.Hash.Fast(s);
        if h < 0 { return 0 - h; }
        return h;
    }

    // Rebuild all indexes for a table (after DELETE compaction changes row indices)
    expose func rebuildTableIndexes(tableName: String, table: Table) {
        var i = 0;
        while i < indexMgr.indexCount() {
            var idx = indexMgr.indexes.get(i);
            if idx.tableName == tableName {
                idx.rebuild(table);
            }
            i = i + 1;
        }
        // Also rebuild B-tree indexes for persistent databases
        if storageEngine != null {
            rebuildBTreeIndexes(tableName, table);
        }
    }

    //=========================================================================
    // B-TREE INDEX MANAGEMENT (Phase 10)
    //=========================================================================

    // Find a B-tree by index name
    expose func findBTreeForIndex(indexName: String) -> BTree? {
        var i = 0;
        while i < btreeIndexNames.count() {
            if btreeIndexNames.get(i) == indexName {
                return btrees.get(i);
            }
            i = i + 1;
        }
        return null;
    }

    // Register a B-tree for an index
    expose func addBTree(indexName: String, btree: BTree) {
        btreeIndexNames.add(indexName);
        btrees.add(btree);
    }

    // Remove a B-tree for an index
    expose func removeBTree(indexName: String) {
        var newNames: List[String] = [];
        var newTrees: List[BTree] = [];
        var i = 0;
        while i < btreeIndexNames.count() {
            if btreeIndexNames.get(i) != indexName {
                newNames.add(btreeIndexNames.get(i));
                newTrees.add(btrees.get(i));
            }
            i = i + 1;
        }
        btreeIndexNames = newNames;
        btrees = newTrees;
    }

    // Rebuild B-tree indexes for a table from current row data
    expose func rebuildBTreeIndexes(tableName: String, table: Table) {
        if storageEngine == null {
            return;
        }
        var se = storageEngine;

        var i = 0;
        while i < btreeIndexNames.count() {
            var idxName = btreeIndexNames.get(i);
            // Find the matching index in indexMgr to get column info
            var maybeIdx = indexMgr.findIndex(idxName);
            if maybeIdx != null {
                var sqlIdx = maybeIdx;
                if sqlIdx.tableName == tableName {
                    // Drop old B-tree, create new one
                    var oldBtree = btrees.get(i);
                    var colName = sqlIdx.getColumnName(0);
                    var newBtree = se.createBTree(idxName, 0, colName, sqlIdx.isUnique);

                    // Populate from current rows
                    var ri = 0;
                    while ri < table.rowCount() {
                        var maybeRow = table.getRow(ri);
                        if maybeRow != null {
                            var row = maybeRow;
                            if row.isVisible(mvccSnapshotId, mvccTxnId) {
                                var colIdx = table.findColumnIndex(colName);
                                if colIdx >= 0 {
                                    var keyVal = row.getValue(colIdx);
                                    // Get disk location for this row
                                    var loc = se.findRowLocation(tableName, ri);
                                    var pageId = loc.get(0);
                                    var slotId = loc.get(1);
                                    if pageId != INVALID_PAGE_ID {
                                        var btreeKey = new BTreeKey();
                                        btreeKey.initWithValue(keyVal, pageId, slotId);
                                        newBtree.insert(btreeKey);
                                    }
                                }
                            }
                        }
                        ri = ri + 1;
                    }

                    btrees.set(i, newBtree);

                    // Update the root page in index metadata
                    var si = 0;
                    while si < se.indexMetas.count() {
                        var im = se.indexMetas.get(si);
                        if im.indexName == idxName {
                            im.btreeRootPageId = newBtree.rootPageId;
                        }
                        si = si + 1;
                    }
                }
            }
            i = i + 1;
        }
    }

    expose func executeSql(sql: String) -> QueryResult {
        pgStatLastQuery = sql;
        pgStatQueryCount = pgStatQueryCount + 1;
        var result = executeSqlDispatch(sql);

        // For non-transactional statements, release locks after each statement.
        // During transactions, locks are held until COMMIT/ROLLBACK.
        if inTransaction == false {
            releaseSessionLocks();
        }

        return result;
    }

    hide func executeSqlDispatch(sql: String) -> QueryResult {
        // Clear subquery cache for each new top-level SQL statement
        subqueryCacheKeys = [];
        subqueryCacheScalars = [];
        subqueryCacheLists = [];

        var parser = new Parser(sql);

        var kind = parser.currentKind();

        //=====================================================================
        // WITH (Common Table Expressions)
        //=====================================================================
        if kind == TK_WITH {
            return queryHandler.executeWithCTE(sql, parser);
        }

        if kind == TK_CREATE {
            parser.advance();
            // CREATE TEMP TABLE / CREATE TEMPORARY TABLE
            var isTemp = false;
            if parser.currentKind() == TK_TEMPORARY {
                isTemp = true;
                parser.advance();
            }
            // Phase 65: CREATE OR REPLACE VIEW / FUNCTION
            var isOrReplace = false;
            if parser.currentKind() == TK_OR {
                parser.advance();
                if parser.currentKind() == TK_REPLACE {
                    isOrReplace = true;
                    parser.advance();
                }
            }
            if parser.currentKind() == TK_TABLE {
                // Check for CREATE TABLE name AS SELECT ... (CTAS)
                // Use a separate peek parser to test without consuming tokens
                var peekParser = new Parser(sql);
                peekParser.advance(); // skip CREATE
                if isTemp { peekParser.advance(); } // skip TEMPORARY
                peekParser.advance(); // skip TABLE
                // Phase 65: skip IF NOT EXISTS in peek
                if peekParser.currentKind() == TK_IF {
                    peekParser.advance(); // IF
                    peekParser.advance(); // NOT
                    peekParser.advance(); // EXISTS
                }
                var isCtas = false;
                var isLike = false;
                var ctasTableName = "";
                var likeSourceName = "";
                if peekParser.currentKind() == TK_IDENTIFIER {
                    ctasTableName = peekParser.currentText();
                    peekParser.advance();
                    if peekParser.currentKind() == TK_AS {
                        isCtas = true;
                    }
                    // Phase 67: CREATE TABLE name (LIKE source)
                    if peekParser.currentKind() == TK_LPAREN {
                        peekParser.advance();
                        if peekParser.currentKind() == TK_LIKE {
                            peekParser.advance();
                            if peekParser.currentKind() == TK_IDENTIFIER {
                                isLike = true;
                                likeSourceName = peekParser.currentText();
                            }
                        }
                    }
                }
                // Phase 67: CREATE TABLE name (LIKE source)
                if isLike {
                    parser.advance(); // TABLE
                    if parser.currentKind() == TK_IF {
                        parser.advance(); // IF
                        parser.advance(); // NOT
                        parser.advance(); // EXISTS
                    }
                    var likeNewName = "";
                    if parser.currentKind() == TK_IDENTIFIER {
                        likeNewName = parser.currentText();
                    }
                    return ddlHandler.executeCreateTableLike(likeNewName, likeSourceName, isTemp);
                }
                if isCtas {
                    // Advance main parser past TABLE, [IF NOT EXISTS], name, AS
                    parser.advance(); // TABLE
                    if parser.currentKind() == TK_IF {
                        parser.advance(); // IF
                        parser.advance(); // NOT
                        parser.advance(); // EXISTS
                    }
                    parser.advance(); // name
                    parser.advance(); // AS
                    var ctasSql = "";
                    while parser.currentKind() != TK_EOF && parser.currentKind() != TK_SEMICOLON {
                        if parser.currentKind() == TK_STRING {
                            ctasSql = ctasSql + " '" + parser.currentText() + "'";
                        } else {
                            if ctasSql != "" {
                                ctasSql = ctasSql + " ";
                            }
                            ctasSql = ctasSql + parser.currentText();
                        }
                        parser.advance();
                    }
                    return executeCreateTableAs(ctasTableName, ctasSql, isTemp);
                }
                // Normal CREATE TABLE
                var stmt = parser.parseCreateTableStmt();
                if parser.hasError {
                    var result = new QueryResult();
                    result.init();
                    result.setError(parser.error);
                    return result;
                }
                stmt.isTemporary = isTemp;
                return ddlHandler.executeCreateTable(stmt);
            }
            if parser.currentKind() == TK_INDEX || parser.currentKind() == TK_UNIQUE {
                var stmt = parser.parseCreateIndexStmt();
                if parser.hasError {
                    var result = new QueryResult();
                    result.init();
                    result.setError(parser.error);
                    return result;
                }
                return ddlHandler.executeCreateIndex(stmt);
            }
            // CREATE DATABASE [name] [FILE 'path']
            if parser.currentKind() == TK_DATABASE {
                parser.advance();
                if parser.currentKind() == TK_IDENTIFIER {
                    var dbName = parser.currentText();
                    parser.advance();
                    // Check for optional FILE 'path' clause
                    if parser.currentKind() == TK_FILE {
                        parser.advance();
                        if parser.currentKind() == TK_STRING {
                            var filePath = parser.currentText();
                            return ddlHandler.executeCreateDatabaseWithFile(dbName, filePath);
                        }
                        var result = new QueryResult();
                        result.init();
                        result.setError("FILE requires a file path string");
                        return result;
                    }
                    return ddlHandler.executeCreateDatabase(dbName);
                }
                var result = new QueryResult();
                result.init();
                result.setError("CREATE DATABASE requires a database name");
                return result;
            }
            // CREATE MATERIALIZED VIEW name AS SELECT ...
            if parser.currentKind() == TK_MATERIALIZED {
                parser.advance();
                if parser.currentKind() != TK_VIEW {
                    var result = new QueryResult();
                    result.init();
                    result.setError("Expected VIEW after MATERIALIZED");
                    return result;
                }
                parser.advance();
                if parser.currentKind() != TK_IDENTIFIER {
                    var result = new QueryResult();
                    result.init();
                    result.setError("CREATE MATERIALIZED VIEW requires a view name");
                    return result;
                }
                var matViewName = parser.currentText();
                parser.advance();
                if parser.currentKind() != TK_AS {
                    var result = new QueryResult();
                    result.init();
                    result.setError("Expected AS after materialized view name");
                    return result;
                }
                parser.advance();
                // Capture the rest as the view definition SQL
                var matViewSql = "";
                while parser.currentKind() != TK_EOF && parser.currentKind() != TK_SEMICOLON {
                    if parser.currentKind() == TK_STRING {
                        matViewSql = matViewSql + " '" + parser.currentText() + "'";
                    } else {
                        if matViewSql != "" {
                            matViewSql = matViewSql + " ";
                        }
                        matViewSql = matViewSql + parser.currentText();
                    }
                    parser.advance();
                }
                return executeCreateMatView(matViewName, matViewSql);
            }
            // CREATE [OR REPLACE] VIEW name AS SELECT ...
            if parser.currentKind() == TK_VIEW {
                parser.advance();
                if parser.currentKind() != TK_IDENTIFIER {
                    var result = new QueryResult();
                    result.init();
                    result.setError("CREATE VIEW requires a view name");
                    return result;
                }
                var viewName = parser.currentText();
                parser.advance();
                if parser.currentKind() != TK_AS {
                    var result = new QueryResult();
                    result.init();
                    result.setError("Expected AS after view name");
                    return result;
                }
                parser.advance();
                // Capture the rest as the view definition SQL
                var viewSql = "";
                while parser.currentKind() != TK_EOF && parser.currentKind() != TK_SEMICOLON {
                    if parser.currentKind() == TK_STRING {
                        viewSql = viewSql + " '" + parser.currentText() + "'";
                    } else {
                        if viewSql != "" {
                            viewSql = viewSql + " ";
                        }
                        viewSql = viewSql + parser.currentText();
                    }
                    parser.advance();
                }
                // Phase 65: CREATE OR REPLACE VIEW — drop existing view first
                if isOrReplace && db.isView(viewName) {
                    db.dropView(viewName);
                }
                return ddlHandler.executeCreateView(viewName, viewSql);
            }
            // CREATE TRIGGER name BEFORE|AFTER INSERT|UPDATE|DELETE ON table FOR EACH ROW EXECUTE 'sql'
            if parser.currentKind() == TK_TRIGGER {
                parser.advance();
                if parser.currentKind() != TK_IDENTIFIER {
                    var result = new QueryResult();
                    result.init();
                    result.setError("CREATE TRIGGER requires a trigger name");
                    return result;
                }
                var trigName = parser.currentText();
                parser.advance();
                // Parse timing: BEFORE or AFTER
                var timing = 0;
                if parser.currentKind() == TK_BEFORE {
                    timing = TRIGGER_BEFORE;
                    parser.advance();
                } else if parser.currentKind() == TK_AFTER {
                    timing = TRIGGER_AFTER;
                    parser.advance();
                } else {
                    var result = new QueryResult();
                    result.init();
                    result.setError("Expected BEFORE or AFTER");
                    return result;
                }
                // Parse event: INSERT, UPDATE, or DELETE
                var event = 0;
                if parser.currentKind() == TK_INSERT {
                    event = TRIGGER_INSERT;
                    parser.advance();
                } else if parser.currentKind() == TK_UPDATE {
                    event = TRIGGER_UPDATE;
                    parser.advance();
                } else if parser.currentKind() == TK_DELETE {
                    event = TRIGGER_DELETE;
                    parser.advance();
                } else {
                    var result = new QueryResult();
                    result.init();
                    result.setError("Expected INSERT, UPDATE, or DELETE");
                    return result;
                }
                // Parse ON table_name
                if parser.currentKind() != TK_ON {
                    var result = new QueryResult();
                    result.init();
                    result.setError("Expected ON after event type");
                    return result;
                }
                parser.advance();
                if parser.currentKind() != TK_IDENTIFIER {
                    var result = new QueryResult();
                    result.init();
                    result.setError("Expected table name after ON");
                    return result;
                }
                var tblName = parser.currentText();
                parser.advance();
                // Optional: FOR EACH ROW (default) or FOR EACH STATEMENT
                var forEachRow = true;
                if parser.currentKind() == TK_FOR {
                    parser.advance();
                    if parser.currentKind() == TK_EACH {
                        parser.advance();
                        if parser.currentKind() == TK_ROW {
                            forEachRow = true;
                            parser.advance();
                        } else if parser.currentKind() == TK_IDENTIFIER && String.ToUpper(parser.currentText()) == "STATEMENT" {
                            forEachRow = false;
                            parser.advance();
                        }
                    }
                }
                // Parse EXECUTE 'body_sql'
                if parser.currentKind() != TK_EXECUTE {
                    var result = new QueryResult();
                    result.init();
                    result.setError("Expected EXECUTE after trigger definition");
                    return result;
                }
                parser.advance();
                if parser.currentKind() != TK_STRING {
                    var result = new QueryResult();
                    result.init();
                    result.setError("Expected SQL string after EXECUTE");
                    return result;
                }
                var bodySql = parser.currentText();
                return ddlHandler.executeCreateTrigger(trigName, timing, event, tblName, forEachRow, bodySql);
            }
            // CREATE USER name PASSWORD 'password'
            if parser.currentKind() == TK_USER {
                parser.advance();
                if parser.currentKind() != TK_IDENTIFIER {
                    var result = new QueryResult();
                    result.init();
                    result.setError("CREATE USER requires a username");
                    return result;
                }
                var userName = parser.currentText();
                parser.advance();
                if parser.currentKind() != TK_PASSWORD {
                    var result = new QueryResult();
                    result.init();
                    result.setError("Expected PASSWORD after username: CREATE USER name PASSWORD 'pass'");
                    return result;
                }
                parser.advance();
                if parser.currentKind() != TK_STRING {
                    var result = new QueryResult();
                    result.init();
                    result.setError("Expected password string");
                    return result;
                }
                var password = parser.currentText();
                return ddlHandler.executeCreateUser(userName, password);
            }
            // CREATE SEQUENCE name [START [WITH] n] [INCREMENT [BY] n] [MINVALUE n | NO MINVALUE]
            //                      [MAXVALUE n | NO MAXVALUE] [CYCLE | NO CYCLE]
            if parser.currentKind() == TK_SEQUENCE {
                parser.advance();
                if parser.currentKind() != TK_IDENTIFIER {
                    var result = new QueryResult();
                    result.init();
                    result.setError("CREATE SEQUENCE requires a sequence name");
                    return result;
                }
                var seqName = parser.currentText();
                parser.advance();
                // Parse optional clauses
                var startVal = 1;
                var incrVal = 1;
                var minVal = 1;
                var maxVal = 2147483647;
                var doCycle = false;
                var hasStart = false;
                var hasMin = false;
                var hasMax = false;
                while parser.currentKind() != TK_EOF && parser.currentKind() != TK_SEMICOLON {
                    if parser.currentKind() == TK_START {
                        parser.advance();
                        // Optional WITH keyword
                        if parser.currentKind() == TK_WITH || (parser.currentKind() == TK_IDENTIFIER && String.ToUpper(parser.currentText()) == "WITH") {
                            parser.advance();
                        }
                        if parser.currentKind() == TK_INTEGER || parser.currentKind() == TK_MINUS {
                            var neg = false;
                            if parser.currentKind() == TK_MINUS {
                                neg = true;
                                parser.advance();
                            }
                            startVal = stringToInt(parser.currentText());
                            if neg { startVal = 0 - startVal; }
                            hasStart = true;
                            parser.advance();
                        }
                    } else if parser.currentKind() == TK_INCREMENT {
                        parser.advance();
                        // Optional BY keyword
                        if parser.currentKind() == TK_BY {
                            parser.advance();
                        }
                        if parser.currentKind() == TK_INTEGER || parser.currentKind() == TK_MINUS {
                            var neg = false;
                            if parser.currentKind() == TK_MINUS {
                                neg = true;
                                parser.advance();
                            }
                            incrVal = stringToInt(parser.currentText());
                            if neg { incrVal = 0 - incrVal; }
                            parser.advance();
                        }
                    } else if parser.currentKind() == TK_MINVALUE {
                        parser.advance();
                        if parser.currentKind() == TK_INTEGER || parser.currentKind() == TK_MINUS {
                            var neg = false;
                            if parser.currentKind() == TK_MINUS {
                                neg = true;
                                parser.advance();
                            }
                            minVal = stringToInt(parser.currentText());
                            if neg { minVal = 0 - minVal; }
                            hasMin = true;
                            parser.advance();
                        }
                    } else if parser.currentKind() == TK_MAXVALUE {
                        parser.advance();
                        if parser.currentKind() == TK_INTEGER || parser.currentKind() == TK_MINUS {
                            var neg = false;
                            if parser.currentKind() == TK_MINUS {
                                neg = true;
                                parser.advance();
                            }
                            maxVal = stringToInt(parser.currentText());
                            if neg { maxVal = 0 - maxVal; }
                            hasMax = true;
                            parser.advance();
                        }
                    } else if parser.currentKind() == TK_CYCLE {
                        doCycle = true;
                        parser.advance();
                    } else if parser.currentKind() == TK_NO {
                        parser.advance();
                        if parser.currentKind() == TK_CYCLE {
                            doCycle = false;
                            parser.advance();
                        } else if parser.currentKind() == TK_MINVALUE {
                            hasMin = true;
                            minVal = 1;
                            parser.advance();
                        } else if parser.currentKind() == TK_MAXVALUE {
                            hasMax = true;
                            maxVal = 2147483647;
                            parser.advance();
                        }
                    } else {
                        parser.advance();
                    }
                }
                // If descending sequence and no explicit min, default min to -2147483647
                if incrVal < 0 && hasMin == false {
                    minVal = 0 - 2147483646;
                }
                // If descending sequence and no explicit start, start at maxValue
                if incrVal < 0 && hasStart == false {
                    startVal = maxVal;
                }
                return ddlHandler.executeCreateSequence(seqName, startVal, incrVal, minVal, maxVal, doCycle);
            }
            // CREATE FUNCTION name(param1 type, ...) RETURNS type [LANGUAGE SQL] AS 'body'
            if parser.currentKind() == TK_FUNCTION {
                parser.advance();
                if parser.currentKind() != TK_IDENTIFIER {
                    var result = new QueryResult();
                    result.init();
                    result.setError("CREATE FUNCTION requires a function name");
                    return result;
                }
                var funcName = String.ToUpper(parser.currentText());
                parser.advance();
                // Parse parameter list: (name type, name type, ...)
                var funcParams: List[FuncParam] = [];
                if parser.currentKind() == TK_LPAREN {
                    parser.advance();
                    while parser.currentKind() != TK_RPAREN && parser.currentKind() != TK_EOF {
                        if parser.currentKind() == TK_COMMA {
                            parser.advance();
                        }
                        if parser.currentKind() == TK_IDENTIFIER {
                            var paramName = parser.currentText();
                            parser.advance();
                            // Parse type
                            var paramType = SQL_TEXT;
                            if parser.currentKind() == TK_INT || parser.currentKind() == TK_INTEGER_TYPE {
                                paramType = SQL_INTEGER;
                                parser.advance();
                            } else if parser.currentKind() == TK_REAL {
                                paramType = SQL_REAL;
                                parser.advance();
                            } else if parser.currentKind() == TK_TEXT || parser.currentKind() == TK_VARCHAR {
                                paramType = SQL_TEXT;
                                parser.advance();
                            } else if parser.currentKind() == TK_BOOLEAN {
                                paramType = SQL_BOOLEAN;
                                parser.advance();
                            } else if parser.currentKind() == TK_DATE_TYPE {
                                paramType = SQL_DATE;
                                parser.advance();
                            } else if parser.currentKind() == TK_TIMESTAMP_TYPE {
                                paramType = SQL_TIMESTAMP;
                                parser.advance();
                            } else {
                                // Default to TEXT for unknown types
                                parser.advance();
                            }
                            var fp = new FuncParam();
                            fp.initFull(paramName, paramType);
                            funcParams.add(fp);
                        } else {
                            parser.advance();
                        }
                    }
                    if parser.currentKind() == TK_RPAREN {
                        parser.advance();
                    }
                }
                // Parse RETURNS type
                var retType = SQL_TEXT;
                if parser.currentKind() == TK_RETURNS {
                    parser.advance();
                    if parser.currentKind() == TK_INT || parser.currentKind() == TK_INTEGER_TYPE {
                        retType = SQL_INTEGER;
                        parser.advance();
                    } else if parser.currentKind() == TK_REAL {
                        retType = SQL_REAL;
                        parser.advance();
                    } else if parser.currentKind() == TK_TEXT || parser.currentKind() == TK_VARCHAR {
                        retType = SQL_TEXT;
                        parser.advance();
                    } else if parser.currentKind() == TK_BOOLEAN {
                        retType = SQL_BOOLEAN;
                        parser.advance();
                    } else if parser.currentKind() == TK_IDENTIFIER && String.ToUpper(parser.currentText()) == "VOID" {
                        retType = SQL_NULL;
                        parser.advance();
                    } else {
                        parser.advance();
                    }
                }
                // Optional LANGUAGE SQL
                if parser.currentKind() == TK_LANGUAGE {
                    parser.advance();
                    parser.advance();  // skip language name (e.g., SQL)
                }
                // Parse AS 'sql_body'
                var bodySQL = "";
                if parser.currentKind() == TK_AS {
                    parser.advance();
                    if parser.currentKind() == TK_STRING {
                        bodySQL = parser.currentText();
                    }
                }
                // Phase 65: CREATE OR REPLACE FUNCTION — drop existing first
                if isOrReplace {
                    funcMgr.dropFunction(funcName);
                }
                return ddlHandler.executeCreateFunction(funcName, funcParams, retType, bodySQL);
            }
        }

        if kind == TK_INSERT {
            parser.advance();
            var stmt = parser.parseInsertStmt();
            if parser.hasError {
                var result = new QueryResult();
                result.init();
                result.setError(parser.error);
                return result;
            }
            return dmlHandler.executeInsert(stmt);
        }

        if kind == TK_SELECT {
            parser.advance();
            var stmt = parser.parseSelectStmt();
            if parser.hasError {
                var result = new QueryResult();
                result.init();
                result.setError(parser.error);
                return result;
            }
            var firstResult = queryHandler.executeSelect(stmt);
            if firstResult.success == false {
                return firstResult;
            }

            // Chained set operations: UNION [ALL] / EXCEPT [ALL] / INTERSECT [ALL]
            // Supports multiple chained operations: SELECT ... UNION ... EXCEPT ... INTERSECT ...
            var currentResult = firstResult;
            while parser.currentKind() == TK_UNION || parser.currentKind() == TK_EXCEPT || parser.currentKind() == TK_INTERSECT {
                var setOpKind = parser.currentKind();
                parser.advance();
                var setOpAll = false;
                if parser.currentKind() == TK_ALL {
                    setOpAll = true;
                    parser.advance();
                }
                if parser.currentKind() != TK_SELECT {
                    break;
                }
                parser.advance();
                var stmt2 = parser.parseSelectStmt();
                if parser.hasError {
                    var result = new QueryResult();
                    result.init();
                    result.setError(parser.error);
                    return result;
                }
                var secondResult = queryHandler.executeSelect(stmt2);
                if secondResult.success == false {
                    return secondResult;
                }
                if setOpKind == TK_UNION {
                    currentResult = executeUnion(currentResult, secondResult, setOpAll);
                } else if setOpKind == TK_EXCEPT {
                    if setOpAll {
                        currentResult = executeExceptAll(currentResult, secondResult);
                    } else {
                        currentResult = executeExcept(currentResult, secondResult);
                    }
                } else if setOpKind == TK_INTERSECT {
                    if setOpAll {
                        currentResult = executeIntersectAll(currentResult, secondResult);
                    } else {
                        currentResult = executeIntersect(currentResult, secondResult);
                    }
                }
            }

            // Phase 69: SELECT INTO — create table from query results
            if stmt.selectIntoTable != "" && currentResult.success {
                var intoResult = createTableFromResult(stmt.selectIntoTable, currentResult);
                return intoResult;
            }

            return currentResult;
        }

        if kind == TK_UPDATE {
            parser.advance();
            var stmt = parser.parseUpdateStmt();
            if parser.hasError {
                var result = new QueryResult();
                result.init();
                result.setError(parser.error);
                return result;
            }
            return dmlHandler.executeUpdate(stmt);
        }

        if kind == TK_DELETE {
            parser.advance();
            var stmt = parser.parseDeleteStmt();
            if parser.hasError {
                var result = new QueryResult();
                result.init();
                result.setError(parser.error);
                return result;
            }
            return dmlHandler.executeDelete(stmt);
        }

        // Phase 73: MERGE INTO
        if kind == TK_MERGE {
            parser.advance();
            var stmt = parser.parseMergeStmt();
            if parser.hasError {
                var result = new QueryResult();
                result.init();
                result.setError(parser.error);
                return result;
            }
            return dmlHandler.executeMerge(stmt);
        }

        if kind == TK_DROP {
            parser.advance();
            if parser.currentKind() == TK_TABLE {
                parser.advance();
                // Phase 65: DROP TABLE IF EXISTS
                var ifExists = false;
                if parser.currentKind() == TK_IF {
                    parser.advance();
                    if parser.currentKind() == TK_EXISTS {
                        ifExists = true;
                        parser.advance();
                    }
                }
                if parser.currentKind() == TK_IDENTIFIER {
                    var tableName = parser.currentText();
                    if ifExists && findTable(tableName) == null {
                        var result = new QueryResult();
                        result.init();
                        result.message = "Table '" + tableName + "' does not exist, skipping";
                        return result;
                    }
                    return ddlHandler.executeDropTable(tableName);
                }
            }
            if parser.currentKind() == TK_INDEX {
                parser.advance(); // consume INDEX
                // Phase 65: DROP INDEX IF EXISTS
                var ifExists = false;
                if parser.currentKind() == TK_IF {
                    parser.advance();
                    if parser.currentKind() == TK_EXISTS {
                        ifExists = true;
                        parser.advance();
                    }
                }
                if parser.currentKind() == TK_IDENTIFIER {
                    var idxName = parser.currentText();
                    var stmt = new DropIndexStmt();
                    stmt.init();
                    stmt.indexName = idxName;
                    if ifExists && indexMgr.findIndex(idxName) == null {
                        var result = new QueryResult();
                        result.init();
                        result.message = "Index '" + idxName + "' does not exist, skipping";
                        return result;
                    }
                    return ddlHandler.executeDropIndex(stmt);
                }
            }
            // DROP DATABASE [IF EXISTS]
            if parser.currentKind() == TK_DATABASE {
                parser.advance();
                // Phase 65: DROP DATABASE IF EXISTS
                var ifExists = false;
                if parser.currentKind() == TK_IF {
                    parser.advance();
                    if parser.currentKind() == TK_EXISTS {
                        ifExists = true;
                        parser.advance();
                    }
                }
                if parser.currentKind() == TK_IDENTIFIER {
                    var dbName = parser.currentText();
                    if ifExists && server.databaseExists(dbName) == false {
                        var result = new QueryResult();
                        result.init();
                        result.message = "Database '" + dbName + "' does not exist, skipping";
                        return result;
                    }
                    return ddlHandler.executeDropDatabase(dbName);
                }
                var result = new QueryResult();
                result.init();
                result.setError("DROP DATABASE requires a database name");
                return result;
            }
            // DROP MATERIALIZED VIEW [IF EXISTS]
            if parser.currentKind() == TK_MATERIALIZED {
                parser.advance();
                if parser.currentKind() == TK_VIEW {
                    parser.advance();
                    // Phase 65: IF EXISTS
                    var ifExists = false;
                    if parser.currentKind() == TK_IF {
                        parser.advance();
                        if parser.currentKind() == TK_EXISTS {
                            ifExists = true;
                            parser.advance();
                        }
                    }
                    if parser.currentKind() == TK_IDENTIFIER {
                        var mvName = parser.currentText();
                        if ifExists && db.isView("__matview_" + mvName) == false {
                            var result = new QueryResult();
                            result.init();
                            result.message = "Materialized view '" + mvName + "' does not exist, skipping";
                            return result;
                        }
                        return executeDropMatView(mvName);
                    }
                }
                var result = new QueryResult();
                result.init();
                result.setError("DROP MATERIALIZED VIEW requires a view name");
                return result;
            }
            // DROP VIEW [IF EXISTS]
            if parser.currentKind() == TK_VIEW {
                parser.advance();
                // Phase 65: DROP VIEW IF EXISTS
                var ifExists = false;
                if parser.currentKind() == TK_IF {
                    parser.advance();
                    if parser.currentKind() == TK_EXISTS {
                        ifExists = true;
                        parser.advance();
                    }
                }
                if parser.currentKind() == TK_IDENTIFIER {
                    var viewName = parser.currentText();
                    if ifExists && db.isView(viewName) == false {
                        var result = new QueryResult();
                        result.init();
                        result.message = "View '" + viewName + "' does not exist, skipping";
                        return result;
                    }
                    return ddlHandler.executeDropView(viewName);
                }
                var result = new QueryResult();
                result.init();
                result.setError("DROP VIEW requires a view name");
                return result;
            }
            // DROP TRIGGER [IF EXISTS] name
            if parser.currentKind() == TK_TRIGGER {
                parser.advance();
                // Phase 65: DROP TRIGGER IF EXISTS
                var ifExists = false;
                if parser.currentKind() == TK_IF {
                    parser.advance();
                    if parser.currentKind() == TK_EXISTS {
                        ifExists = true;
                        parser.advance();
                    }
                }
                if parser.currentKind() == TK_IDENTIFIER {
                    var trigName = parser.currentText();
                    var dropResult = ddlHandler.executeDropTrigger(trigName);
                    if ifExists && dropResult.success == false {
                        dropResult.success = true;
                        dropResult.message = "Trigger '" + trigName + "' does not exist, skipping";
                        return dropResult;
                    }
                    return dropResult;
                }
                var result = new QueryResult();
                result.init();
                result.setError("DROP TRIGGER requires a trigger name");
                return result;
            }
            // DROP SEQUENCE [IF EXISTS] name
            if parser.currentKind() == TK_SEQUENCE {
                parser.advance();
                // Phase 65: DROP SEQUENCE IF EXISTS
                var ifExists = false;
                if parser.currentKind() == TK_IF {
                    parser.advance();
                    if parser.currentKind() == TK_EXISTS {
                        ifExists = true;
                        parser.advance();
                    }
                }
                if parser.currentKind() == TK_IDENTIFIER {
                    var seqName = parser.currentText();
                    var dropResult = ddlHandler.executeDropSequence(seqName);
                    if ifExists && dropResult.success == false {
                        dropResult.success = true;
                        dropResult.message = "Sequence '" + seqName + "' does not exist, skipping";
                        return dropResult;
                    }
                    return dropResult;
                }
                var result = new QueryResult();
                result.init();
                result.setError("DROP SEQUENCE requires a sequence name");
                return result;
            }
            // DROP FUNCTION [IF EXISTS] name
            if parser.currentKind() == TK_FUNCTION {
                parser.advance();
                // Phase 65: DROP FUNCTION IF EXISTS
                var ifExists = false;
                if parser.currentKind() == TK_IF {
                    parser.advance();
                    if parser.currentKind() == TK_EXISTS {
                        ifExists = true;
                        parser.advance();
                    }
                }
                if parser.currentKind() == TK_IDENTIFIER {
                    var funcName = String.ToUpper(parser.currentText());
                    var dropResult = ddlHandler.executeDropFunction(funcName);
                    if ifExists && dropResult.success == false {
                        dropResult.success = true;
                        dropResult.message = "Function '" + funcName + "' does not exist, skipping";
                        return dropResult;
                    }
                    return dropResult;
                }
                var result = new QueryResult();
                result.init();
                result.setError("DROP FUNCTION requires a function name");
                return result;
            }
            // DROP USER [IF EXISTS] name
            if parser.currentKind() == TK_USER {
                parser.advance();
                // Phase 65: DROP USER IF EXISTS
                var ifExists = false;
                if parser.currentKind() == TK_IF {
                    parser.advance();
                    if parser.currentKind() == TK_EXISTS {
                        ifExists = true;
                        parser.advance();
                    }
                }
                if parser.currentKind() == TK_IDENTIFIER {
                    var userName = parser.currentText();
                    if ifExists && server.userExists(userName) == false {
                        var result = new QueryResult();
                        result.init();
                        result.message = "User '" + userName + "' does not exist, skipping";
                        return result;
                    }
                    return ddlHandler.executeDropUser(userName);
                }
                var result = new QueryResult();
                result.init();
                result.setError("DROP USER requires a username");
                return result;
            }
        }

        // USE command: USE database_name
        if kind == TK_USE {
            parser.advance();
            if parser.currentKind() == TK_IDENTIFIER || parser.currentKind() == TK_DATABASE {
                var dbName = parser.currentText();
                parser.advance();
                // Handle "USE DATABASE name" syntax
                if parser.currentKind() == TK_IDENTIFIER {
                    dbName = parser.currentText();
                }
                return ddlHandler.executeUseDatabase(dbName);
            }
            var result = new QueryResult();
            result.init();
            result.setError("USE requires a database name: USE database_name");
            return result;
        }

        if kind == TK_SHOW {
            parser.advance();
            // Phase 66: SHOW CREATE TABLE tablename
            if parser.currentKind() == TK_CREATE {
                parser.advance();
                if parser.currentKind() == TK_TABLE {
                    parser.advance();
                    if parser.currentKind() == TK_IDENTIFIER {
                        var showTableName = parser.currentText();
                        return ddlHandler.executeShowCreateTable(showTableName);
                    }
                    var result = new QueryResult();
                    result.init();
                    result.setError("SHOW CREATE TABLE requires a table name");
                    return result;
                }
            }
            if parser.currentKind() == TK_DATABASES {
                return ddlHandler.executeShowDatabases();
            }
            // Phase 67: SHOW INDEXES [FROM tablename]
            if parser.currentKind() == TK_INDEX || (parser.currentKind() == TK_IDENTIFIER && String.ToUpper(parser.currentText()) == "INDEXES") {
                parser.advance();
                var idxTableName = "";
                // SHOW INDEXES FROM tablename
                if parser.currentKind() == TK_FROM || (parser.currentKind() == TK_IDENTIFIER && String.ToUpper(parser.currentText()) == "FROM") {
                    parser.advance();
                    if parser.currentKind() == TK_IDENTIFIER {
                        idxTableName = parser.currentText();
                    }
                } else if parser.currentKind() == TK_IDENTIFIER {
                    // SHOW INDEXES tablename (without FROM)
                    idxTableName = parser.currentText();
                }
                return ddlHandler.executeShowIndexes(idxTableName);
            }
            // Phase 67: SHOW COLUMNS FROM tablename
            if parser.currentKind() == TK_IDENTIFIER && String.ToUpper(parser.currentText()) == "COLUMNS" {
                parser.advance();
                if parser.currentKind() == TK_FROM || (parser.currentKind() == TK_IDENTIFIER && String.ToUpper(parser.currentText()) == "FROM") {
                    parser.advance();
                }
                if parser.currentKind() == TK_IDENTIFIER {
                    var colTableName = parser.currentText();
                    return ddlHandler.executeShowColumns(colTableName);
                }
                var result = new QueryResult();
                result.init();
                result.setError("SHOW COLUMNS requires a table name");
                return result;
            }
            if parser.currentKind() == TK_IDENTIFIER && String.ToUpper(parser.currentText()) == "USERS" {
                return ddlHandler.executeShowUsers();
            }
            if parser.currentKind() == TK_TRIGGER || (parser.currentKind() == TK_IDENTIFIER && String.ToUpper(parser.currentText()) == "TRIGGERS") {
                return ddlHandler.executeShowTriggers();
            }
            if parser.currentKind() == TK_SEQUENCE || (parser.currentKind() == TK_IDENTIFIER && String.ToUpper(parser.currentText()) == "SEQUENCES") {
                return ddlHandler.executeShowSequences();
            }
            if parser.currentKind() == TK_FUNCTION || (parser.currentKind() == TK_IDENTIFIER && String.ToUpper(parser.currentText()) == "FUNCTIONS") {
                return ddlHandler.executeShowFunctions();
            }
            if parser.currentKind() == TK_GRANT || (parser.currentKind() == TK_IDENTIFIER && String.ToUpper(parser.currentText()) == "GRANTS") {
                // SHOW GRANTS [FOR username]
                parser.advance();
                var forUser = currentUser;
                if parser.currentKind() == TK_IDENTIFIER {
                    var maybeFor = String.ToUpper(parser.currentText());
                    if maybeFor == "FOR" {
                        parser.advance();
                        if parser.currentKind() == TK_IDENTIFIER {
                            forUser = parser.currentText();
                        }
                    }
                }
                return ddlHandler.executeShowGrants(forUser);
            }
            // SHOW ALL — show all session variables
            if parser.currentKind() == TK_ALL {
                return executeShowAllVars();
            }
            // SHOW TABLES (default for TK_TABLE or just SHOW)
            if parser.currentKind() == TK_TABLE || parser.currentKind() == TK_EOF || parser.currentKind() == TK_SEMICOLON {
                return ddlHandler.executeShowTables();
            }
            // SHOW variable_name — show a session variable (supports dotted names)
            if parser.currentKind() == TK_IDENTIFIER {
                var varName = parser.currentText();
                parser.advance();
                while parser.currentKind() == TK_DOT {
                    varName = varName + ".";
                    parser.advance();
                    if parser.currentKind() == TK_IDENTIFIER {
                        varName = varName + parser.currentText();
                        parser.advance();
                    }
                }
                return executeShowVar(varName);
            }
            return ddlHandler.executeShowTables();
        }

        // SET variable = value / SET variable TO value
        if kind == TK_SET {
            parser.advance();
            // SET LOCAL / SET SESSION — skip optional keyword
            var upperText = String.ToUpper(parser.currentText());
            if upperText == "LOCAL" || upperText == "SESSION" {
                parser.advance();
            }
            if parser.currentKind() == TK_IDENTIFIER || parser.currentKind() == TK_INTEGER {
                var varName = parser.currentText();
                parser.advance();
                // Handle dotted names like my_app.debug
                while parser.currentKind() == TK_DOT {
                    varName = varName + ".";
                    parser.advance();
                    if parser.currentKind() == TK_IDENTIFIER {
                        varName = varName + parser.currentText();
                        parser.advance();
                    }
                }
                // Accept = or TO
                if parser.currentKind() == TK_EQ || parser.currentKind() == TK_TO {
                    parser.advance();
                }
                // Collect value (may be string, identifier, integer, or composite like 'ISO, MDY')
                var varValue = "";
                if parser.currentKind() == TK_STRING {
                    varValue = parser.currentText();
                } else {
                    while parser.currentKind() != TK_EOF && parser.currentKind() != TK_SEMICOLON {
                        if varValue != "" { varValue = varValue + " "; }
                        varValue = varValue + parser.currentText();
                        parser.advance();
                    }
                }
                return executeSetVar(varName, varValue);
            }
            var result = new QueryResult();
            result.init();
            result.setError("SET requires a variable name");
            return result;
        }

        // RESET variable / RESET ALL
        if kind == TK_RESET {
            parser.advance();
            if parser.currentKind() == TK_ALL {
                return executeResetAllVars();
            }
            if parser.currentKind() == TK_IDENTIFIER {
                var varName = parser.currentText();
                return executeResetVar(varName);
            }
            var result = new QueryResult();
            result.init();
            result.setError("RESET requires a variable name or ALL");
            return result;
        }

        // COMMENT ON TABLE/COLUMN ... IS 'text'
        if kind == TK_COMMENT {
            parser.advance();
            if parser.currentKind() == TK_ON {
                parser.advance();
                return executeCommentOn(parser);
            }
            var result = new QueryResult();
            result.init();
            result.setError("Expected ON after COMMENT");
            return result;
        }

        // SAVE command: SAVE 'filename' or SAVE TO 'filename'
        if kind == TK_SAVE {
            parser.advance();
            // Optional TO keyword
            if parser.currentKind() == TK_TO {
                parser.advance();
            }
            if parser.currentKind() == TK_STRING {
                var filename = parser.currentText();
                return persistence.executeSave(filename);
            }
            var result = new QueryResult();
            result.init();
            result.setError("SAVE requires a filename: SAVE 'filename'");
            return result;
        }

        // OPEN command: OPEN 'filename' or OPEN FROM 'filename'
        if kind == TK_OPEN {
            parser.advance();
            // Optional FROM keyword
            if parser.currentKind() == TK_FROM {
                parser.advance();
            }
            if parser.currentKind() == TK_STRING {
                var filename = parser.currentText();
                return persistence.executeOpen(filename);
            }
            var result = new QueryResult();
            result.init();
            result.setError("OPEN requires a filename: OPEN 'filename'");
            return result;
        }

        // CLOSE command: CLOSE cursor_name, CLOSE ALL (cursors), or CLOSE (database)
        if kind == TK_CLOSE {
            parser.advance();
            // If followed by identifier or ALL, it's a cursor close
            if parser.currentKind() == TK_IDENTIFIER || parser.currentKind() == TK_ALL {
                return executeCloseCursor(parser);
            }
            // Otherwise it's the database close command
            return persistence.executeClose();
        }

        // EXPORT command: EXPORT table TO 'filename'
        if kind == TK_EXPORT {
            parser.advance();
            if parser.currentKind() == TK_IDENTIFIER {
                var tableName = parser.currentText();
                parser.advance();
                if parser.currentKind() == TK_TO {
                    parser.advance();
                    if parser.currentKind() == TK_STRING {
                        var filename = parser.currentText();
                        return csvHandler.executeExport(tableName, filename);
                    }
                }
            }
            var result = new QueryResult();
            result.init();
            result.setError("EXPORT syntax: EXPORT tablename TO 'filename.csv'");
            return result;
        }

        // IMPORT command: IMPORT INTO table FROM 'filename'
        if kind == TK_IMPORT {
            parser.advance();
            if parser.currentKind() == TK_INTO {
                parser.advance();
            }
            if parser.currentKind() == TK_IDENTIFIER {
                var tableName = parser.currentText();
                parser.advance();
                if parser.currentKind() == TK_FROM {
                    parser.advance();
                    if parser.currentKind() == TK_STRING {
                        var filename = parser.currentText();
                        return csvHandler.executeImport(tableName, filename);
                    }
                }
            }
            var result = new QueryResult();
            result.init();
            result.setError("IMPORT syntax: IMPORT INTO tablename FROM 'filename.csv'");
            return result;
        }

        // TRUNCATE TABLE tablename [, tablename, ...]
        if kind == TK_TRUNCATE {
            parser.advance();
            // Optional TABLE keyword
            if parser.currentKind() == TK_TABLE {
                parser.advance();
            }
            if parser.currentKind() == TK_IDENTIFIER {
                var tblName = parser.currentText();
                parser.advance();
                // Phase 69: multi-table TRUNCATE
                if parser.currentKind() == TK_COMMA {
                    // Multiple tables
                    var tables: List[String] = [];
                    tables.add(tblName);
                    while parser.currentKind() == TK_COMMA {
                        parser.advance();
                        if parser.currentKind() == TK_IDENTIFIER {
                            tables.add(parser.currentText());
                            parser.advance();
                        }
                    }
                    var ti = 0;
                    while ti < tables.count() {
                        var truncResult = executeTruncate(tables.get(ti));
                        if truncResult.success == false {
                            return truncResult;
                        }
                        ti = ti + 1;
                    }
                    var result = new QueryResult();
                    result.init();
                    result.message = "TRUNCATE TABLE (" + Fmt.Int(tables.count()) + " tables)";
                    return result;
                }
                return executeTruncate(tblName);
            }
            var result = new QueryResult();
            result.init();
            result.setError("Expected table name after TRUNCATE");
            return result;
        }

        // VACUUM command: VACUUM [FULL] [ANALYZE] [tablename]
        if kind == TK_VACUUM {
            parser.advance();
            var vacFull = false;
            var vacAnalyze = false;
            // Check for FULL or ANALYZE modifiers
            if parser.currentKind() == TK_FULL {
                vacFull = true;
                parser.advance();
            }
            if parser.currentKind() == TK_ANALYZE {
                vacAnalyze = true;
                parser.advance();
            }
            // Check for optional table name
            if parser.currentKind() == TK_IDENTIFIER {
                var tableName = parser.currentText();
                if vacAnalyze {
                    var vr = ddlHandler.executeVacuumTable(tableName);
                    var ar = ddlHandler.executeAnalyzeTable(tableName);
                    var result = new QueryResult();
                    result.init();
                    result.message = vr.message + "; " + ar.message;
                    return result;
                }
                return ddlHandler.executeVacuumTable(tableName);
            }
            if vacFull {
                if vacAnalyze {
                    var vr = ddlHandler.executeVacuumFull();
                    var ar = ddlHandler.executeAnalyze();
                    var result = new QueryResult();
                    result.init();
                    result.message = vr.message + "; " + ar.message;
                    return result;
                }
                return ddlHandler.executeVacuumFull();
            }
            if vacAnalyze {
                return ddlHandler.executeVacuumAnalyze();
            }
            return ddlHandler.executeVacuum();
        }

        // ANALYZE command: ANALYZE [tablename]
        if kind == TK_ANALYZE {
            parser.advance();
            if parser.currentKind() == TK_IDENTIFIER {
                var tableName = parser.currentText();
                return ddlHandler.executeAnalyzeTable(tableName);
            }
            return ddlHandler.executeAnalyze();
        }

        // HELP command
        if kind == TK_HELP {
            return ddlHandler.executeHelp();
        }

        // DESCRIBE command: DESCRIBE tablename
        if kind == TK_DESCRIBE {
            parser.advance();
            if parser.currentKind() == TK_IDENTIFIER {
                var tableName = parser.currentText();
                return ddlHandler.executeDescribe(tableName);
            }
            var result = new QueryResult();
            result.init();
            result.setError("DESCRIBE requires a table name");
            return result;
        }

        // ALTER TABLE / ALTER USER command
        if kind == TK_ALTER {
            parser.advance();
            if parser.currentKind() == TK_TABLE {
                parser.advance();
                if parser.currentKind() == TK_IDENTIFIER {
                    var tableName = parser.currentText();
                    // Acquire exclusive lock on table being altered
                    if acquireExclusiveLock(tableName) == false {
                        return lockTimeoutError(tableName);
                    }
                    parser.advance();
                    return ddlHandler.executeAlterTable(parser, tableName);
                }
            }
            // ALTER USER name [SET] PASSWORD 'newpass'
            if parser.currentKind() == TK_USER {
                parser.advance();
                if parser.currentKind() != TK_IDENTIFIER {
                    var result = new QueryResult();
                    result.init();
                    result.setError("ALTER USER requires a username");
                    return result;
                }
                var userName = parser.currentText();
                parser.advance();
                // Optional SET keyword
                if parser.currentKind() == TK_SET {
                    parser.advance();
                }
                if parser.currentKind() != TK_PASSWORD {
                    var result = new QueryResult();
                    result.init();
                    result.setError("ALTER USER: expected PASSWORD");
                    return result;
                }
                parser.advance();
                if parser.currentKind() != TK_STRING {
                    var result = new QueryResult();
                    result.init();
                    result.setError("ALTER USER: expected password string");
                    return result;
                }
                var newPassword = parser.currentText();
                return ddlHandler.executeAlterUser(userName, newPassword);
            }
            // ALTER SEQUENCE name [RESTART [WITH n]] [INCREMENT [BY] n] [MINVALUE n] [MAXVALUE n] [CYCLE|NO CYCLE]
            if parser.currentKind() == TK_SEQUENCE {
                parser.advance();
                if parser.currentKind() != TK_IDENTIFIER {
                    var result = new QueryResult();
                    result.init();
                    result.setError("ALTER SEQUENCE requires a sequence name");
                    return result;
                }
                var seqName = parser.currentText();
                parser.advance();
                // Parse optional clauses
                var restartVal = 0 - 2147483647;  // sentinel: no restart
                var newIncr = 0 - 2147483647;
                var newMin = 0 - 2147483647;
                var newMax = 0 - 2147483647;
                var setCycle = -1;  // -1 = unchanged, 0 = no cycle, 1 = cycle
                while parser.currentKind() != TK_EOF && parser.currentKind() != TK_SEMICOLON {
                    if parser.currentKind() == TK_IDENTIFIER && String.ToUpper(parser.currentText()) == "RESTART" {
                        parser.advance();
                        // Optional WITH keyword
                        if parser.currentKind() == TK_WITH || (parser.currentKind() == TK_IDENTIFIER && String.ToUpper(parser.currentText()) == "WITH") {
                            parser.advance();
                        }
                        if parser.currentKind() == TK_INTEGER || parser.currentKind() == TK_MINUS {
                            var neg = false;
                            if parser.currentKind() == TK_MINUS {
                                neg = true;
                                parser.advance();
                            }
                            restartVal = stringToInt(parser.currentText());
                            if neg { restartVal = 0 - restartVal; }
                            parser.advance();
                        } else {
                            // RESTART without value means restart with original startValue
                            restartVal = 0 - 2147483646;  // special sentinel: use startValue
                        }
                    } else if parser.currentKind() == TK_INCREMENT {
                        parser.advance();
                        if parser.currentKind() == TK_BY { parser.advance(); }
                        if parser.currentKind() == TK_INTEGER || parser.currentKind() == TK_MINUS {
                            var neg = false;
                            if parser.currentKind() == TK_MINUS { neg = true; parser.advance(); }
                            newIncr = stringToInt(parser.currentText());
                            if neg { newIncr = 0 - newIncr; }
                            parser.advance();
                        }
                    } else if parser.currentKind() == TK_MINVALUE {
                        parser.advance();
                        if parser.currentKind() == TK_INTEGER || parser.currentKind() == TK_MINUS {
                            var neg = false;
                            if parser.currentKind() == TK_MINUS { neg = true; parser.advance(); }
                            newMin = stringToInt(parser.currentText());
                            if neg { newMin = 0 - newMin; }
                            parser.advance();
                        }
                    } else if parser.currentKind() == TK_MAXVALUE {
                        parser.advance();
                        if parser.currentKind() == TK_INTEGER || parser.currentKind() == TK_MINUS {
                            var neg = false;
                            if parser.currentKind() == TK_MINUS { neg = true; parser.advance(); }
                            newMax = stringToInt(parser.currentText());
                            if neg { newMax = 0 - newMax; }
                            parser.advance();
                        }
                    } else if parser.currentKind() == TK_CYCLE {
                        setCycle = 1;
                        parser.advance();
                    } else if parser.currentKind() == TK_NO {
                        parser.advance();
                        if parser.currentKind() == TK_CYCLE {
                            setCycle = 0;
                            parser.advance();
                        }
                    } else {
                        parser.advance();
                    }
                }
                return ddlHandler.executeAlterSequence(seqName, restartVal, newIncr, newMin, newMax, setCycle);
            }
            var result = new QueryResult();
            result.init();
            result.setError("ALTER TABLE syntax: ALTER TABLE tablename ADD/DROP/RENAME ...");
            return result;
        }

        // EXPLAIN [ANALYZE] command: EXPLAIN [ANALYZE] SELECT ...
        if kind == TK_EXPLAIN {
            parser.advance();
            var explainAnalyze = false;
            if parser.currentKind() == TK_ANALYZE {
                explainAnalyze = true;
                parser.advance();
            }
            if parser.currentKind() == TK_SELECT {
                parser.advance();
                var stmt = parser.parseSelectStmt();
                if parser.hasError {
                    var result = new QueryResult();
                    result.init();
                    result.setError(parser.error);
                    return result;
                }
                if explainAnalyze {
                    return executeExplainAnalyze(stmt);
                }
                return ddlHandler.executeExplain(stmt);
            }
            var result = new QueryResult();
            result.init();
            result.setError("EXPLAIN currently supports SELECT statements only");
            return result;
        }

        // PREPARE name AS sql
        if kind == TK_PREPARE {
            parser.advance();
            return executePrepare(parser);
        }

        // EXECUTE name [(param, ...)]
        if kind == TK_EXECUTE {
            parser.advance();
            return executeExecute(parser);
        }

        // DEALLOCATE [PREPARE] name
        if kind == TK_DEALLOCATE {
            parser.advance();
            return executeDeallocate(parser);
        }

        // GRANT privileges ON table TO user
        if kind == TK_GRANT {
            parser.advance();
            var privMask = parsePrivilegeList(parser);
            if privMask < 0 {
                var result = new QueryResult();
                result.init();
                result.setError("Invalid privilege name. Use SELECT, INSERT, UPDATE, DELETE, or ALL");
                return result;
            }
            if parser.currentKind() != TK_ON {
                var result = new QueryResult();
                result.init();
                result.setError("Expected ON after privilege list: GRANT ... ON tablename TO user");
                return result;
            }
            parser.advance();
            if parser.currentKind() != TK_IDENTIFIER {
                var result = new QueryResult();
                result.init();
                result.setError("Expected table name after ON");
                return result;
            }
            var tableName = parser.currentText();
            parser.advance();
            if parser.currentKind() != TK_TO {
                var result = new QueryResult();
                result.init();
                result.setError("Expected TO after table name: GRANT ... ON tablename TO user");
                return result;
            }
            parser.advance();
            var grantee = "";
            if parser.currentKind() == TK_IDENTIFIER {
                grantee = parser.currentText();
            } else {
                var result = new QueryResult();
                result.init();
                result.setError("Expected username or PUBLIC after TO");
                return result;
            }
            return ddlHandler.executeGrant(privMask, tableName, grantee);
        }

        // REVOKE privileges ON table FROM user
        if kind == TK_REVOKE {
            parser.advance();
            var privMask = parsePrivilegeList(parser);
            if privMask < 0 {
                var result = new QueryResult();
                result.init();
                result.setError("Invalid privilege name. Use SELECT, INSERT, UPDATE, DELETE, or ALL");
                return result;
            }
            if parser.currentKind() != TK_ON {
                var result = new QueryResult();
                result.init();
                result.setError("Expected ON after privilege list: REVOKE ... ON tablename FROM user");
                return result;
            }
            parser.advance();
            if parser.currentKind() != TK_IDENTIFIER {
                var result = new QueryResult();
                result.init();
                result.setError("Expected table name after ON");
                return result;
            }
            var tableName = parser.currentText();
            parser.advance();
            if parser.currentKind() != TK_FROM {
                var result = new QueryResult();
                result.init();
                result.setError("Expected FROM after table name: REVOKE ... ON tablename FROM user");
                return result;
            }
            parser.advance();
            var grantee = "";
            if parser.currentKind() == TK_IDENTIFIER {
                grantee = parser.currentText();
            } else {
                var result = new QueryResult();
                result.init();
                result.setError("Expected username or PUBLIC after FROM");
                return result;
            }
            return ddlHandler.executeRevoke(privMask, tableName, grantee);
        }

        // DECLARE cursor_name CURSOR FOR select_query
        if kind == TK_DECLARE {
            parser.advance();
            return executeDeclareCursor(parser);
        }

        // FETCH [direction] FROM cursor_name
        if kind == TK_FETCH {
            parser.advance();
            return executeFetchCursor(parser);
        }

        // MOVE [direction] IN cursor_name
        if kind == TK_MOVE {
            parser.advance();
            return executeMoveCursor(parser);
        }

        // COPY table TO/FROM 'file'
        if kind == TK_COPY {
            parser.advance();
            return executeCopy(parser, sql);
        }

        // CALL function_name(args)
        if kind == TK_CALL {
            parser.advance();
            return executeCall(parser);
        }

        // DO $$ ... $$ or DO 'sql; sql; ...'
        if kind == TK_DO {
            parser.advance();
            var doBody = "";
            if parser.currentKind() == TK_STRING {
                doBody = parser.currentText();
            } else {
                // Try to capture everything as raw text until EOF
                while parser.currentKind() != TK_EOF {
                    if parser.currentKind() == TK_STRING {
                        doBody = doBody + " '" + parser.currentText() + "'";
                    } else {
                        if doBody != "" { doBody = doBody + " "; }
                        doBody = doBody + parser.currentText();
                    }
                    parser.advance();
                }
            }
            return executeDoBlock(doBody);
        }

        // REFRESH MATERIALIZED VIEW name
        if kind == TK_REFRESH {
            parser.advance();
            if parser.currentKind() == TK_MATERIALIZED {
                parser.advance();
                if parser.currentKind() == TK_VIEW {
                    parser.advance();
                    if parser.currentKind() == TK_IDENTIFIER {
                        var mvName = parser.currentText();
                        return executeRefreshMatView(mvName);
                    }
                }
            }
            var result = new QueryResult();
            result.init();
            result.setError("Expected MATERIALIZED VIEW name after REFRESH");
            return result;
        }

        // Transaction commands
        if kind == TK_BEGIN {
            return executeBegin();
        }
        if kind == TK_COMMIT {
            return executeCommit();
        }
        if kind == TK_ROLLBACK {
            parser.advance();
            // Check for ROLLBACK TO [SAVEPOINT] name
            if parser.currentKind() == TK_TO {
                parser.advance();
                // Optional SAVEPOINT keyword
                if parser.currentKind() == TK_SAVEPOINT {
                    parser.advance();
                }
                if parser.currentKind() == TK_IDENTIFIER {
                    var spName = parser.currentText();
                    return executeRollbackToSavepoint(spName);
                }
                var result = new QueryResult();
                result.init();
                result.setError("Expected savepoint name after ROLLBACK TO");
                return result;
            }
            return executeRollback();
        }

        // SAVEPOINT name
        if kind == TK_SAVEPOINT {
            parser.advance();
            if parser.currentKind() == TK_IDENTIFIER {
                var spName = parser.currentText();
                return executeSavepoint(spName);
            }
            var result = new QueryResult();
            result.init();
            result.setError("SAVEPOINT requires a name");
            return result;
        }

        // RELEASE [SAVEPOINT] name
        if kind == TK_RELEASE {
            parser.advance();
            // Optional SAVEPOINT keyword
            if parser.currentKind() == TK_SAVEPOINT {
                parser.advance();
            }
            if parser.currentKind() == TK_IDENTIFIER {
                var spName = parser.currentText();
                return executeReleaseSavepoint(spName);
            }
            var result = new QueryResult();
            result.init();
            result.setError("RELEASE requires a savepoint name");
            return result;
        }

        // VALUES (...), (...) as standalone query
        if kind == TK_VALUES {
            return executeStandaloneValues(parser);
        }

        // Phase 68: TABLE tablename — shorthand for SELECT * FROM tablename
        if kind == TK_TABLE {
            parser.advance();
            if parser.currentKind() == TK_IDENTIFIER {
                var tblExprName = parser.currentText();
                return executeSql("SELECT * FROM " + tblExprName);
            }
        }

        var result = new QueryResult();
        result.init();
        result.setError("Unknown SQL statement");
        return result;
    }

    //=========================================================================
    // STANDALONE VALUES QUERY
    //=========================================================================

    hide func executeStandaloneValues(parser: Parser) -> QueryResult {
        var result = new QueryResult();
        result.init();

        parser.advance(); // skip VALUES

        // Create dummy row/table for expression evaluation
        var dummyRow = new Row();
        dummyRow.init();
        var dummyTable = new Table();
        dummyTable.initWithName("_values");

        var allRows: List[List[Expr]] = [];

        // Parse value rows: (expr, expr, ...), (expr, expr, ...), ...
        while true {
            if parser.currentKind() != TK_LPAREN {
                result.setError("Expected '(' after VALUES");
                return result;
            }
            parser.advance();

            var rowExprs: List[Expr] = [];
            while true {
                var expr = parser.parseExpr();
                if parser.hasError {
                    result.setError(parser.error);
                    return result;
                }
                rowExprs.add(expr);
                if parser.currentKind() == TK_COMMA {
                    parser.advance();
                } else {
                    break;
                }
            }
            if parser.currentKind() != TK_RPAREN {
                result.setError("Expected ')' after VALUES row");
                return result;
            }
            parser.advance();

            allRows.add(rowExprs);

            if parser.currentKind() == TK_COMMA {
                parser.advance();
            } else {
                break;
            }
        }

        if allRows.count() == 0 {
            result.setError("VALUES requires at least one row");
            return result;
        }

        // Build column names: column1, column2, ...
        var numCols = allRows.get(0).count();
        var ci = 0;
        while ci < numCols {
            result.addColumnName("column" + Fmt.Int(ci + 1));
            ci = ci + 1;
        }

        // Evaluate expressions and build result rows
        var ri = 0;
        while ri < allRows.count() {
            var rowExprs = allRows.get(ri);
            var outRow = new Row();
            outRow.init();
            var ei = 0;
            while ei < rowExprs.count() {
                var val = evalExpr(rowExprs.get(ei), dummyRow, dummyTable);
                outRow.addValue(val);
                ei = ei + 1;
            }
            result.addRow(outRow);
            ri = ri + 1;
        }

        return result;
    }

    //=========================================================================
    // SET/SHOW/RESET/COMMENT HANDLERS (Phase 43)
    //=========================================================================

    hide func executeSetVar(name: String, value: String) -> QueryResult {
        var result = new QueryResult();
        result.init();
        setSessionVar(name, value);
        result.message = "SET";
        return result;
    }

    hide func executeShowVar(name: String) -> QueryResult {
        var result = new QueryResult();
        result.init();
        var key = String.ToLower(name);
        if hasSessionVar(key) == false {
            result.setError("Unrecognized configuration parameter '" + name + "'");
            return result;
        }
        result.addColumnName(key);
        var row = new Row();
        row.init();
        row.addValue(sqlText(getSessionVar(key)));
        result.addRow(row);
        return result;
    }

    hide func executeShowAllVars() -> QueryResult {
        var result = new QueryResult();
        result.init();
        result.addColumnName("name");
        result.addColumnName("setting");
        var i = 0;
        while i < sessionVarNames.count() {
            var row = new Row();
            row.init();
            row.addValue(sqlText(sessionVarNames.get(i)));
            row.addValue(sqlText(sessionVarValues.get(i)));
            result.addRow(row);
            i = i + 1;
        }
        return result;
    }

    hide func executeResetVar(name: String) -> QueryResult {
        var result = new QueryResult();
        result.init();
        // Reset to default by re-initializing defaults and looking up
        var key = String.ToLower(name);
        if hasSessionVar(key) == false {
            result.setError("Unrecognized configuration parameter '" + name + "'");
            return result;
        }
        // Reset known defaults
        if key == "search_path" { setSessionVar(key, "public"); }
        else if key == "client_encoding" { setSessionVar(key, "UTF8"); }
        else if key == "timezone" { setSessionVar(key, "UTC"); }
        else if key == "datestyle" { setSessionVar(key, "ISO, MDY"); }
        else if key == "application_name" { setSessionVar(key, ""); }
        else if key == "statement_timeout" { setSessionVar(key, "0"); }
        else if key == "lock_timeout" { setSessionVar(key, "5000"); }
        else if key == "work_mem" { setSessionVar(key, "4MB"); }
        else { setSessionVar(key, ""); }
        result.message = "RESET";
        return result;
    }

    hide func executeResetAllVars() -> QueryResult {
        sessionVarNames = [];
        sessionVarValues = [];
        initDefaultSessionVars();
        var result = new QueryResult();
        result.init();
        result.message = "RESET";
        return result;
    }

    hide func executeCommentOn(parser: Parser) -> QueryResult {
        var result = new QueryResult();
        result.init();

        if parser.currentKind() == TK_TABLE {
            parser.advance();
            if parser.currentKind() != TK_IDENTIFIER {
                result.setError("COMMENT ON TABLE requires a table name");
                return result;
            }
            var tableName = parser.currentText();
            parser.advance();
            // Verify table exists
            var table = findTable(tableName);
            if table == null {
                result.setError("Table '" + tableName + "' not found");
                return result;
            }
            if parser.currentKind() != TK_IS {
                result.setError("Expected IS after table name");
                return result;
            }
            parser.advance();
            if parser.currentKind() == TK_NULL {
                // COMMENT ON TABLE t IS NULL — remove comment
                removeComment("table:" + tableName);
                result.message = "COMMENT";
                return result;
            }
            if parser.currentKind() != TK_STRING {
                result.setError("Expected string after IS");
                return result;
            }
            var comment = parser.currentText();
            setComment("table:" + tableName, comment);
            result.message = "COMMENT";
            return result;
        }

        if parser.currentKind() == TK_COLUMN {
            parser.advance();
            if parser.currentKind() != TK_IDENTIFIER {
                result.setError("COMMENT ON COLUMN requires table.column");
                return result;
            }
            var firstPart = parser.currentText();
            parser.advance();
            if parser.currentKind() != TK_DOT {
                result.setError("COMMENT ON COLUMN requires table.column format");
                return result;
            }
            parser.advance();
            if parser.currentKind() != TK_IDENTIFIER {
                result.setError("COMMENT ON COLUMN requires table.column format");
                return result;
            }
            var colPart = parser.currentText();
            parser.advance();
            // Verify table and column exist
            var table = findTable(firstPart);
            if table == null {
                result.setError("Table '" + firstPart + "' not found");
                return result;
            }
            var t = table;
            var colIdx = t.findColumnIndex(colPart);
            if colIdx < 0 {
                result.setError("Column '" + colPart + "' not found in table '" + firstPart + "'");
                return result;
            }
            if parser.currentKind() != TK_IS {
                result.setError("Expected IS after column name");
                return result;
            }
            parser.advance();
            if parser.currentKind() == TK_NULL {
                removeComment("column:" + firstPart + "." + colPart);
                result.message = "COMMENT";
                return result;
            }
            if parser.currentKind() != TK_STRING {
                result.setError("Expected string after IS");
                return result;
            }
            var comment = parser.currentText();
            setComment("column:" + firstPart + "." + colPart, comment);
            result.message = "COMMENT";
            return result;
        }

        result.setError("COMMENT ON requires TABLE or COLUMN");
        return result;
    }

    //=========================================================================
    // PRIVILEGE HELPERS (Phase 13)
    //=========================================================================

    // Parse a comma-separated list of privilege names into a bitmask.
    // Returns -1 on error.
    hide func parsePrivilegeList(parser: Parser) -> Integer {
        var mask = 0;
        var first = true;
        while true {
            if first == false {
                if parser.currentKind() == TK_COMMA {
                    parser.advance();
                } else {
                    return mask;
                }
            }
            first = false;
            var text = String.ToUpper(parser.currentText());
            if text == "ALL" {
                parser.advance();
                // Optional PRIVILEGES keyword
                if parser.currentKind() == TK_PRIVILEGES {
                    parser.advance();
                }
                mask = PRIV_ALL;
                return mask;
            }
            if parser.currentKind() == TK_SELECT {
                mask = mask + PRIV_SELECT;
                parser.advance();
            } else if parser.currentKind() == TK_INSERT {
                mask = mask + PRIV_INSERT;
                parser.advance();
            } else if parser.currentKind() == TK_UPDATE {
                mask = mask + PRIV_UPDATE;
                parser.advance();
            } else if parser.currentKind() == TK_DELETE {
                mask = mask + PRIV_DELETE;
                parser.advance();
            } else {
                if mask == 0 { return -1; }
                return mask;
            }
        }
        return mask;
    }

    // Check if the current user has a privilege on a table.
    // Returns null if allowed, or an error QueryResult if denied.
    expose func checkPrivilege(tableName: String, privMask: Integer) -> QueryResult? {
        // Skip for temp tables and system views
        if isTempTable(tableName) { return null; }
        if isSystemView(tableName) { return null; }
        // Superuser bypasses all checks
        if isSuperuser() { return null; }
        // Check privilege via server
        if server.hasPrivilege(currentUser, tableName, privMask) {
            return null;
        }
        var result = new QueryResult();
        result.init();
        var privName = "access";
        if privMask == PRIV_SELECT { privName = "SELECT"; }
        if privMask == PRIV_INSERT { privName = "INSERT"; }
        if privMask == PRIV_UPDATE { privName = "UPDATE"; }
        if privMask == PRIV_DELETE { privName = "DELETE"; }
        result.setError("Permission denied: " + privName + " on '" + tableName + "' for user '" + currentUser + "'");
        return result;
    }

    // Check if the current user is the owner of a table (or superuser).
    // Returns null if allowed, or an error QueryResult if denied.
    expose func checkOwnership(tableName: String) -> QueryResult? {
        if isSuperuser() { return null; }
        var owner = server.getTableOwner(tableName);
        if owner == currentUser { return null; }
        var result = new QueryResult();
        result.init();
        result.setError("Permission denied: must be owner of table '" + tableName + "'");
        return result;
    }

    //=========================================================================
    // CONCURRENCY CONTROL HELPERS
    //=========================================================================

    // Acquire a shared (read) lock on a table. No-op in standalone mode.
    expose func acquireSharedLock(tableName: String) -> Boolean {
        if tableLockMgr == null { return true; }
        var lm = tableLockMgr;
        return lm.acquireTableLock(sessionId, tableName, LOCK_SHARED);
    }

    // Acquire an exclusive (write) lock on a table. No-op in standalone mode.
    expose func acquireExclusiveLock(tableName: String) -> Boolean {
        if tableLockMgr == null { return true; }
        var lm = tableLockMgr;
        return lm.acquireTableLock(sessionId, tableName, LOCK_EXCLUSIVE);
    }

    // Release all locks held by this session. No-op in standalone mode.
    expose func releaseSessionLocks() {
        if tableLockMgr != null {
            var lm = tableLockMgr;
            lm.releaseAllLocks(sessionId);
        }
        if rowLockMgr != null {
            var rlm = rowLockMgr;
            rlm.releaseAllRowLocks(sessionId);
        }
    }

    // Return a lock timeout error result for the given table
    expose func lockTimeoutError(tableName: String) -> QueryResult {
        var result = new QueryResult();
        result.init();
        result.setError("Lock timeout: could not acquire lock on '" + tableName + "'");
        return result;
    }

    // Acquire a row-level lock for SELECT ... FOR UPDATE/SHARE.
    // Returns: 0 = acquired, 1 = conflict (skip), 2 = conflict (error for NOWAIT)
    expose func acquireRowLockForSelect(tableName: String, rowIndex: Integer, mode: Integer, nowait: Boolean) -> Integer {
        if rowLockMgr == null { return 0; }
        var rlm = rowLockMgr;
        if nowait {
            // Non-blocking: return error immediately on conflict
            if rlm.tryAcquireRowLock(sessionId, tableName, rowIndex, mode) {
                return 0;
            }
            return 2;
        }
        // Try non-blocking first for SKIP LOCKED path
        if rlm.tryAcquireRowLock(sessionId, tableName, rowIndex, mode) {
            return 0;
        }
        return 1;  // Conflict — caller decides to skip or block
    }

    // Return a row lock conflict error
    expose func rowLockError(tableName: String, rowIndex: Integer) -> QueryResult {
        var result = new QueryResult();
        result.init();
        result.setError("could not obtain lock on row " + Fmt.Int(rowIndex) + " in table '" + tableName + "'");
        return result;
    }

    //=========================================================================
    // TRUNCATE TABLE (Phase 29)
    //=========================================================================

    hide func executeTruncate(tableName: String) -> QueryResult {
        var result = new QueryResult();
        result.init();
        var table = findTable(tableName);
        if table == null {
            result.setError("Table '" + tableName + "' not found");
            return result;
        }
        var t = table;
        // Cannot truncate partitioned parent directly — truncate children too
        if t.isPartitioned && t.partitionChildren.count() > 0 {
            var ci = 0;
            while ci < t.partitionChildren.count() {
                var childName = t.partitionChildren.get(ci);
                var childTable = findTable(childName);
                if childTable != null {
                    var ct = childTable;
                    ct.clearAllRows();
                }
                ci = ci + 1;
            }
            result.message = "TRUNCATE TABLE (partitioned, " + Fmt.Int(t.partitionChildren.count()) + " partitions cleared)";
            return result;
        }
        t.clearAllRows();
        result.message = "TRUNCATE TABLE";
        return result;
    }

    //=========================================================================
    // PREPARED STATEMENTS (Phase 30)
    //=========================================================================

    hide func executePrepare(parser: Parser) -> QueryResult {
        var result = new QueryResult();
        result.init();

        if parser.currentKind() != TK_IDENTIFIER {
            result.setError("Expected prepared statement name after PREPARE");
            return result;
        }
        var name = String.ToUpper(parser.currentText());
        parser.advance();

        // Check for duplicate
        var i = 0;
        while i < preparedNames.count() {
            if preparedNames.get(i) == name {
                result.setError("Prepared statement '" + name + "' already exists");
                return result;
            }
            i = i + 1;
        }

        // Expect AS keyword
        if parser.currentKind() != TK_AS {
            result.setError("Expected AS after prepared statement name");
            return result;
        }
        parser.advance();

        // Collect remaining SQL as the template (everything until semicolon/EOF)
        var sqlTemplate = "";
        var paramCount = 0;
        while parser.currentKind() != TK_EOF && parser.currentKind() != TK_SEMICOLON {
            var tok = parser.currentText();
            // Detect $N parameter placeholders ($=TK_ERROR, N=TK_INTEGER)
            if tok == "$" {
                parser.advance();
                if parser.currentKind() == TK_INTEGER {
                    var pnum = stringToInt(parser.currentText());
                    if pnum > paramCount { paramCount = pnum; }
                    sqlTemplate = sqlTemplate + " $" + parser.currentText();
                    parser.advance();
                    continue;
                }
                sqlTemplate = sqlTemplate + " $";
                continue;
            }
            if parser.currentKind() == TK_STRING {
                sqlTemplate = sqlTemplate + " '" + tok + "'";
            } else {
                sqlTemplate = sqlTemplate + " " + tok;
            }
            parser.advance();
        }
        sqlTemplate = String.Trim(sqlTemplate);

        preparedNames.add(name);
        preparedSqlTemplates.add(sqlTemplate);
        preparedParamCounts.add(paramCount);
        result.message = "PREPARE";
        return result;
    }

    hide func executeExecute(parser: Parser) -> QueryResult {
        var result = new QueryResult();
        result.init();

        if parser.currentKind() != TK_IDENTIFIER {
            result.setError("Expected prepared statement name after EXECUTE");
            return result;
        }
        var name = String.ToUpper(parser.currentText());
        parser.advance();

        // Find the prepared statement
        var idx = -1;
        var i = 0;
        while i < preparedNames.count() {
            if preparedNames.get(i) == name {
                idx = i;
                i = preparedNames.count();
            }
            i = i + 1;
        }
        if idx < 0 {
            result.setError("Prepared statement '" + name + "' not found");
            return result;
        }

        var sqlTemplate = preparedSqlTemplates.get(idx);

        // Parse optional parameter list: (val1, val2, ...)
        if parser.currentKind() == TK_LPAREN {
            parser.advance();
            var paramIdx = 1;
            while parser.currentKind() != TK_RPAREN && parser.currentKind() != TK_EOF {
                var paramText = "";
                if parser.currentKind() == TK_STRING {
                    paramText = "'" + parser.currentText() + "'";
                } else {
                    paramText = parser.currentText();
                }
                // Replace $N in template with actual value
                sqlTemplate = String.Replace(sqlTemplate, "$" + Fmt.Int(paramIdx), paramText);
                parser.advance();
                paramIdx = paramIdx + 1;
                if parser.currentKind() == TK_COMMA {
                    parser.advance();
                }
            }
            if parser.currentKind() == TK_RPAREN {
                parser.advance();
            }
        }

        // Execute the substituted SQL
        return executeSql(sqlTemplate);
    }

    hide func executeDeallocate(parser: Parser) -> QueryResult {
        var result = new QueryResult();
        result.init();

        // Optional PREPARE keyword after DEALLOCATE
        if parser.currentKind() == TK_PREPARE {
            parser.advance();
        }

        if parser.currentKind() != TK_IDENTIFIER {
            // DEALLOCATE ALL
            if String.ToUpper(parser.currentText()) == "ALL" {
                preparedNames = [];
                preparedSqlTemplates = [];
                preparedParamCounts = [];
                result.message = "DEALLOCATE ALL";
                return result;
            }
            result.setError("Expected prepared statement name after DEALLOCATE");
            return result;
        }
        var name = String.ToUpper(parser.currentText());

        var idx = -1;
        var i = 0;
        while i < preparedNames.count() {
            if preparedNames.get(i) == name {
                idx = i;
                i = preparedNames.count();
            }
            i = i + 1;
        }
        if idx < 0 {
            result.setError("Prepared statement '" + name + "' not found");
            return result;
        }

        preparedNames.removeAt(idx);
        preparedSqlTemplates.removeAt(idx);
        preparedParamCounts.removeAt(idx);
        result.message = "DEALLOCATE";
        return result;
    }

    //=========================================================================
    // EXPLAIN ANALYZE (Phase 30)
    //=========================================================================

    hide func executeExplainAnalyze(stmt: SelectStmt) -> QueryResult {
        var startTime = DateTime.Now();

        // Execute the actual query
        var actualResult = queryHandler.executeSelect(stmt);

        var elapsed = DateTime.Now() - startTime;

        // Build EXPLAIN ANALYZE output
        var result = new QueryResult();
        result.init();
        result.addColumnName("QUERY PLAN");

        // Get the base EXPLAIN plan
        var planResult = ddlHandler.executeExplain(stmt);

        // Add plan rows with actual stats
        var pi = 0;
        while pi < planResult.rows.count() {
            result.addRow(planResult.rows.get(pi));
            pi = pi + 1;
        }

        // Add execution statistics
        var statsRow = new Row();
        statsRow.init();
        statsRow.addValue(sqlText("Execution Time: " + Fmt.Int(elapsed) + " ms"));
        result.addRow(statsRow);

        var rowsRow = new Row();
        rowsRow.init();
        rowsRow.addValue(sqlText("Rows Returned: " + Fmt.Int(actualResult.rows.count())));
        result.addRow(rowsRow);

        return result;
    }

    //=========================================================================
    // VACUUM / ANALYZE STATISTICS (Phase 26)
    //=========================================================================

    // Record vacuum statistics for a table
    expose func recordVacuumStats(tableName: String, deadRemoved: Integer) {
        var idx = findVacuumStatIndex(tableName);
        if idx < 0 {
            vacuumStatNames.add(tableName);
            vacuumStatDeadRemoved.add(deadRemoved);
            vacuumStatLastVacuumTime.add(DateTime.Now());
            vacuumStatVacuumCount.add(1);
            analyzeStatLiveRows.add(0);
            analyzeStatDeadRows.add(0);
            analyzeStatLastAnalyzeTime.add(0);
            analyzeStatAnalyzeCount.add(0);
        } else {
            vacuumStatDeadRemoved.set(idx, vacuumStatDeadRemoved.get(idx) + deadRemoved);
            vacuumStatLastVacuumTime.set(idx, DateTime.Now());
            vacuumStatVacuumCount.set(idx, vacuumStatVacuumCount.get(idx) + 1);
        }
    }

    // Record analyze statistics for a table
    expose func recordAnalyzeStats(tableName: String, liveRows: Integer, deadRows: Integer) {
        var idx = findVacuumStatIndex(tableName);
        if idx < 0 {
            vacuumStatNames.add(tableName);
            vacuumStatDeadRemoved.add(0);
            vacuumStatLastVacuumTime.add(0);
            vacuumStatVacuumCount.add(0);
            analyzeStatLiveRows.add(liveRows);
            analyzeStatDeadRows.add(deadRows);
            analyzeStatLastAnalyzeTime.add(DateTime.Now());
            analyzeStatAnalyzeCount.add(1);
        } else {
            analyzeStatLiveRows.set(idx, liveRows);
            analyzeStatDeadRows.set(idx, deadRows);
            analyzeStatLastAnalyzeTime.set(idx, DateTime.Now());
            analyzeStatAnalyzeCount.set(idx, analyzeStatAnalyzeCount.get(idx) + 1);
        }
    }

    hide func findVacuumStatIndex(tableName: String) -> Integer {
        var i = 0;
        while i < vacuumStatNames.count() {
            if vacuumStatNames.get(i) == tableName {
                return i;
            }
            i = i + 1;
        }
        return -1;
    }

    //=========================================================================
    // PG_STAT TRACKING (Phase 27)
    //=========================================================================

    hide func findPgStatTableIndex(tableName: String) -> Integer {
        var i = 0;
        while i < pgStatTableNames.count() {
            if pgStatTableNames.get(i) == tableName {
                return i;
            }
            i = i + 1;
        }
        return -1;
    }

    hide func ensurePgStatTable(tableName: String) -> Integer {
        var idx = findPgStatTableIndex(tableName);
        if idx < 0 {
            pgStatTableNames.add(tableName);
            pgStatSeqScan.add(0);
            pgStatSeqTupRead.add(0);
            pgStatIdxScan.add(0);
            pgStatIdxTupFetch.add(0);
            pgStatInsert.add(0);
            pgStatUpdate.add(0);
            pgStatDelete.add(0);
            return pgStatTableNames.count() - 1;
        }
        return idx;
    }

    expose func recordSeqScan(tableName: String, tuplesRead: Integer) {
        var idx = ensurePgStatTable(tableName);
        pgStatSeqScan.set(idx, pgStatSeqScan.get(idx) + 1);
        pgStatSeqTupRead.set(idx, pgStatSeqTupRead.get(idx) + tuplesRead);
    }

    expose func recordIdxScan(tableName: String, tuplesFetched: Integer) {
        var idx = ensurePgStatTable(tableName);
        pgStatIdxScan.set(idx, pgStatIdxScan.get(idx) + 1);
        pgStatIdxTupFetch.set(idx, pgStatIdxTupFetch.get(idx) + tuplesFetched);
    }

    expose func recordInsert(tableName: String, count: Integer) {
        var idx = ensurePgStatTable(tableName);
        pgStatInsert.set(idx, pgStatInsert.get(idx) + count);
    }

    expose func recordUpdate(tableName: String, count: Integer) {
        var idx = ensurePgStatTable(tableName);
        pgStatUpdate.set(idx, pgStatUpdate.get(idx) + count);
    }

    expose func recordDelete(tableName: String, count: Integer) {
        var idx = ensurePgStatTable(tableName);
        pgStatDelete.set(idx, pgStatDelete.get(idx) + count);
    }

    hide func findPgStatIndexIndex(indexName: String) -> Integer {
        var i = 0;
        while i < pgStatIndexNames.count() {
            if pgStatIndexNames.get(i) == indexName {
                return i;
            }
            i = i + 1;
        }
        return -1;
    }

    expose func recordIndexScan(indexName: String, tableName: String, tuplesRead: Integer, tuplesFetched: Integer) {
        var idx = findPgStatIndexIndex(indexName);
        if idx < 0 {
            pgStatIndexNames.add(indexName);
            pgStatIndexTableNames.add(tableName);
            pgStatIndexIdxScan.add(1);
            pgStatIndexTupRead.add(tuplesRead);
            pgStatIndexTupFetch.add(tuplesFetched);
        } else {
            pgStatIndexIdxScan.set(idx, pgStatIndexIdxScan.get(idx) + 1);
            pgStatIndexTupRead.set(idx, pgStatIndexTupRead.get(idx) + tuplesRead);
            pgStatIndexTupFetch.set(idx, pgStatIndexTupFetch.get(idx) + tuplesFetched);
        }
    }

    //=========================================================================
    // TRANSACTION MANAGEMENT
    //=========================================================================

    hide func executeBegin() -> QueryResult {
        var result = new QueryResult();
        result.init();
        if inTransaction {
            result.setError("Already in a transaction");
            return result;
        }
        inTransaction = true;
        journal = [];
        txnDirtyTables = [];

        // MVCC: assign transaction ID and take snapshot
        mvccTxnId = mvccTxnCounter;
        mvccSnapshotId = mvccTxnCounter;
        mvccTxnCounter = mvccTxnCounter + 1;

        result.message = "BEGIN";
        return result;
    }

    hide func executeCommit() -> QueryResult {
        var result = new QueryResult();
        result.init();
        if inTransaction == false {
            result.setError("No active transaction");
            return result;
        }

        // Compact any tables with soft-deleted rows
        var i = 0;
        while i < txnDirtyTables.count() {
            var tblName = txnDirtyTables.get(i);
            var table = findTable(tblName);
            if table != null {
                var t = table;
                compactTable(t);
                rebuildTableIndexes(tblName, t);
            }
            i = i + 1;
        }

        // Flush storage engine
        if storageEngine != null {
            var se = storageEngine;
            se.flush();
        }

        inTransaction = false;
        journal = [];
        txnDirtyTables = [];

        // Clear savepoints
        savepointNames = [];
        savepointJournalMarks = [];

        // MVCC: clear transaction state (snapshot becomes committed)
        mvccTxnId = 0;
        mvccSnapshotId = 0;

        // Release all table locks held during the transaction
        releaseSessionLocks();

        result.message = "COMMIT";
        return result;
    }

    hide func executeRollback() -> QueryResult {
        var result = new QueryResult();
        result.init();
        if inTransaction == false {
            result.setError("No active transaction");
            return result;
        }

        // Undo journal entries in reverse order
        var i = journal.count() - 1;
        while i >= 0 {
            var entry = journal.get(i);
            undoJournalEntry(entry);
            i = i - 1;
        }

        // Rebuild indexes for all affected tables
        var t = 0;
        while t < txnDirtyTables.count() {
            var tblName = txnDirtyTables.get(t);
            var table = findTable(tblName);
            if table != null {
                var tbl = table;
                rebuildTableIndexes(tblName, tbl);
            }
            t = t + 1;
        }

        inTransaction = false;
        journal = [];
        txnDirtyTables = [];

        // Clear savepoints
        savepointNames = [];
        savepointJournalMarks = [];

        // MVCC: clear transaction state
        mvccTxnId = 0;
        mvccSnapshotId = 0;

        // Release all table locks held during the transaction
        releaseSessionLocks();

        result.message = "ROLLBACK";
        return result;
    }

    // Undo a single journal entry
    hide func undoJournalEntry(entry: JournalEntry) {
        var table = findTable(entry.tableName);
        if table == null { return; }
        var t = table;

        if entry.entryType == JOURNAL_INSERT {
            // Undo INSERT: remove the inserted row
            if entry.rowIndex < t.rowCount() {
                t.rows.removeAt(entry.rowIndex);
            }
        } else if entry.entryType == JOURNAL_DELETE {
            // Undo DELETE: unmark the soft-deleted row
            if entry.rowIndex < t.rowCount() {
                var row = t.getRow(entry.rowIndex);
                if row != null {
                    var r = row;
                    r.deleted = false;
                }
            }
        } else if entry.entryType == JOURNAL_UPDATE {
            // Undo UPDATE: restore old values from before image
            if entry.rowIndex < t.rowCount() {
                var row = t.getRow(entry.rowIndex);
                if row != null {
                    var r = row;
                    var c = 0;
                    while c < entry.beforeImage.columnCount() {
                        r.setValue(c, entry.beforeImage.getValue(c));
                        c = c + 1;
                    }
                }
            }
        }
    }

    //=========================================================================
    // CURSOR HANDLERS (Phase 32)
    //=========================================================================

    hide func executeDeclareCursor(parser: Parser) -> QueryResult {
        var result = new QueryResult();
        result.init();

        // DECLARE cursor_name CURSOR FOR select_query
        if parser.currentKind() != TK_IDENTIFIER {
            result.setError("DECLARE requires a cursor name");
            return result;
        }
        var cursorName = String.ToUpper(parser.currentText());
        parser.advance();

        // Check for duplicate cursor
        var ci = 0;
        while ci < cursorNames.count() {
            if cursorNames.get(ci) == cursorName {
                result.setError("Cursor \"" + cursorName + "\" already exists");
                return result;
            }
            ci = ci + 1;
        }

        // Expect CURSOR keyword
        if parser.currentKind() != TK_CURSOR {
            result.setError("Expected CURSOR after cursor name");
            return result;
        }
        parser.advance();

        // Expect FOR keyword
        if parser.currentKind() != TK_FOR {
            result.setError("Expected FOR after CURSOR");
            return result;
        }
        parser.advance();

        // Capture the rest as the SELECT query
        var selectSql = "";
        while parser.currentKind() != TK_EOF && parser.currentKind() != TK_SEMICOLON {
            if parser.currentKind() == TK_STRING {
                selectSql = selectSql + " '" + parser.currentText() + "'";
            } else {
                if selectSql != "" {
                    selectSql = selectSql + " ";
                }
                selectSql = selectSql + parser.currentText();
            }
            parser.advance();
        }

        // Execute the query to materialize the result set
        var qr = executeSql(selectSql);
        if qr.success == false {
            result.setError("Cursor query failed: " + qr.message);
            return result;
        }

        // Store cursor
        cursorNames.add(cursorName);
        cursorResults.add(qr);
        cursorPositions.add(-1);  // Before first row

        result.message = "DECLARE CURSOR";
        return result;
    }

    hide func executeFetchCursor(parser: Parser) -> QueryResult {
        var result = new QueryResult();
        result.init();

        // Parse direction: NEXT, PRIOR, FIRST, LAST, FORWARD n, BACKWARD n, ABSOLUTE n, RELATIVE n, ALL, or number
        var direction = "NEXT";
        var fetchCount = 1;

        if parser.currentKind() == TK_NEXT {
            direction = "NEXT";
            fetchCount = 1;
            parser.advance();
        } else if parser.currentKind() == TK_PRIOR {
            direction = "PRIOR";
            fetchCount = 1;
            parser.advance();
        } else if parser.currentKind() == TK_FIRST {
            direction = "FIRST";
            fetchCount = 1;
            parser.advance();
        } else if parser.currentKind() == TK_LAST {
            direction = "LAST";
            fetchCount = 1;
            parser.advance();
        } else if parser.currentKind() == TK_FORWARD {
            direction = "FORWARD";
            parser.advance();
            if parser.currentKind() == TK_ALL {
                fetchCount = -1;  // sentinel for ALL
                parser.advance();
            } else if parser.currentKind() == TK_INTEGER {
                fetchCount = stringToInt(parser.currentText());
                parser.advance();
            }
        } else if parser.currentKind() == TK_BACKWARD {
            direction = "BACKWARD";
            parser.advance();
            if parser.currentKind() == TK_ALL {
                fetchCount = -1;
                parser.advance();
            } else if parser.currentKind() == TK_INTEGER {
                fetchCount = stringToInt(parser.currentText());
                parser.advance();
            }
        } else if parser.currentKind() == TK_ABSOLUTE {
            direction = "ABSOLUTE";
            parser.advance();
            if parser.currentKind() == TK_INTEGER {
                fetchCount = stringToInt(parser.currentText());
                parser.advance();
            }
        } else if parser.currentKind() == TK_RELATIVE {
            direction = "RELATIVE";
            parser.advance();
            if parser.currentKind() == TK_INTEGER {
                fetchCount = stringToInt(parser.currentText());
                parser.advance();
            } else if parser.currentKind() == TK_MINUS {
                parser.advance();
                if parser.currentKind() == TK_INTEGER {
                    fetchCount = 0 - stringToInt(parser.currentText());
                    parser.advance();
                }
            }
        } else if parser.currentKind() == TK_ALL {
            direction = "FORWARD";
            fetchCount = -1;
            parser.advance();
        } else if parser.currentKind() == TK_INTEGER {
            direction = "FORWARD";
            fetchCount = stringToInt(parser.currentText());
            parser.advance();
        }

        // Expect FROM or IN
        if parser.currentKind() == TK_FROM || parser.currentKind() == TK_IN {
            parser.advance();
        }

        // Get cursor name
        if parser.currentKind() != TK_IDENTIFIER {
            result.setError("Expected cursor name");
            return result;
        }
        var cursorName = String.ToUpper(parser.currentText());

        // Find cursor
        var idx = -1;
        var fi = 0;
        while fi < cursorNames.count() {
            if cursorNames.get(fi) == cursorName {
                idx = fi;
            }
            fi = fi + 1;
        }
        if idx < 0 {
            result.setError("Cursor \"" + cursorName + "\" does not exist");
            return result;
        }

        var cursorResult = cursorResults.get(idx);
        var curPos = cursorPositions.get(idx);
        var totalRows = cursorResult.rows.count();

        // Copy column names from cursor result
        var ci = 0;
        while ci < cursorResult.columnNames.count() {
            result.addColumnName(cursorResult.columnNames.get(ci));
            ci = ci + 1;
        }

        // Compute new position and fetch rows based on direction
        if direction == "FIRST" {
            curPos = 0;
            if totalRows > 0 {
                result.addRow(cursorResult.rows.get(0));
            }
            cursorPositions.set(idx, curPos);
            return result;
        }

        if direction == "LAST" {
            curPos = totalRows - 1;
            if totalRows > 0 {
                result.addRow(cursorResult.rows.get(curPos));
            }
            cursorPositions.set(idx, curPos);
            return result;
        }

        if direction == "ABSOLUTE" {
            // ABSOLUTE n: position to row n (1-based)
            curPos = fetchCount - 1;
            if curPos >= 0 && curPos < totalRows {
                result.addRow(cursorResult.rows.get(curPos));
            }
            cursorPositions.set(idx, curPos);
            return result;
        }

        if direction == "RELATIVE" {
            curPos = curPos + fetchCount;
            if curPos >= 0 && curPos < totalRows {
                result.addRow(cursorResult.rows.get(curPos));
            }
            cursorPositions.set(idx, curPos);
            return result;
        }

        if direction == "PRIOR" {
            curPos = curPos - 1;
            if curPos >= 0 && curPos < totalRows {
                result.addRow(cursorResult.rows.get(curPos));
            }
            cursorPositions.set(idx, curPos);
            return result;
        }

        if direction == "BACKWARD" {
            if fetchCount == -1 {
                // BACKWARD ALL: fetch from current position to the beginning
                while curPos >= 0 {
                    if curPos < totalRows {
                        result.addRow(cursorResult.rows.get(curPos));
                    }
                    curPos = curPos - 1;
                }
            } else {
                var fc = 0;
                while fc < fetchCount && curPos >= 0 {
                    if curPos < totalRows {
                        result.addRow(cursorResult.rows.get(curPos));
                    }
                    curPos = curPos - 1;
                    fc = fc + 1;
                }
            }
            cursorPositions.set(idx, curPos);
            return result;
        }

        // Default: FORWARD (NEXT is FORWARD 1)
        if direction == "NEXT" {
            curPos = curPos + 1;
            if curPos >= 0 && curPos < totalRows {
                result.addRow(cursorResult.rows.get(curPos));
            }
            cursorPositions.set(idx, curPos);
            return result;
        }

        // FORWARD n or FORWARD ALL
        if fetchCount == -1 {
            // FORWARD ALL: fetch remaining rows
            curPos = curPos + 1;
            while curPos < totalRows {
                result.addRow(cursorResult.rows.get(curPos));
                curPos = curPos + 1;
            }
            curPos = totalRows;  // past end
        } else {
            var fc = 0;
            while fc < fetchCount {
                curPos = curPos + 1;
                if curPos >= 0 && curPos < totalRows {
                    result.addRow(cursorResult.rows.get(curPos));
                }
                fc = fc + 1;
            }
        }
        cursorPositions.set(idx, curPos);
        return result;
    }

    hide func executeCloseCursor(parser: Parser) -> QueryResult {
        var result = new QueryResult();
        result.init();

        // CLOSE ALL
        if parser.currentKind() == TK_ALL {
            cursorNames = [];
            cursorResults = [];
            cursorPositions = [];
            result.message = "CLOSE ALL";
            return result;
        }

        if parser.currentKind() != TK_IDENTIFIER {
            result.setError("CLOSE requires a cursor name or ALL");
            return result;
        }
        var cursorName = String.ToUpper(parser.currentText());

        var idx = -1;
        var fi = 0;
        while fi < cursorNames.count() {
            if cursorNames.get(fi) == cursorName {
                idx = fi;
            }
            fi = fi + 1;
        }
        if idx < 0 {
            result.setError("Cursor \"" + cursorName + "\" does not exist");
            return result;
        }

        cursorNames.removeAt(idx);
        cursorResults.removeAt(idx);
        cursorPositions.removeAt(idx);

        result.message = "CLOSE CURSOR";
        return result;
    }

    hide func executeMoveCursor(parser: Parser) -> QueryResult {
        var result = new QueryResult();
        result.init();

        // Parse direction (same as FETCH but doesn't return rows)
        var direction = "NEXT";
        var moveCount = 1;

        if parser.currentKind() == TK_NEXT {
            direction = "NEXT";
            parser.advance();
        } else if parser.currentKind() == TK_PRIOR {
            direction = "PRIOR";
            parser.advance();
        } else if parser.currentKind() == TK_FIRST {
            direction = "FIRST";
            parser.advance();
        } else if parser.currentKind() == TK_LAST {
            direction = "LAST";
            parser.advance();
        } else if parser.currentKind() == TK_FORWARD {
            direction = "FORWARD";
            parser.advance();
            if parser.currentKind() == TK_ALL {
                moveCount = -1;
                parser.advance();
            } else if parser.currentKind() == TK_INTEGER {
                moveCount = stringToInt(parser.currentText());
                parser.advance();
            }
        } else if parser.currentKind() == TK_ABSOLUTE {
            direction = "ABSOLUTE";
            parser.advance();
            if parser.currentKind() == TK_INTEGER {
                moveCount = stringToInt(parser.currentText());
                parser.advance();
            }
        } else if parser.currentKind() == TK_INTEGER {
            direction = "FORWARD";
            moveCount = stringToInt(parser.currentText());
            parser.advance();
        }

        // Expect IN or FROM
        if parser.currentKind() == TK_IN || parser.currentKind() == TK_FROM {
            parser.advance();
        }

        if parser.currentKind() != TK_IDENTIFIER {
            result.setError("Expected cursor name");
            return result;
        }
        var cursorName = String.ToUpper(parser.currentText());

        var idx = -1;
        var fi = 0;
        while fi < cursorNames.count() {
            if cursorNames.get(fi) == cursorName {
                idx = fi;
            }
            fi = fi + 1;
        }
        if idx < 0 {
            result.setError("Cursor \"" + cursorName + "\" does not exist");
            return result;
        }

        var curPos = cursorPositions.get(idx);
        var totalRows = cursorResults.get(idx).rows.count();

        if direction == "NEXT" {
            curPos = curPos + 1;
        } else if direction == "PRIOR" {
            curPos = curPos - 1;
        } else if direction == "FIRST" {
            curPos = 0;
        } else if direction == "LAST" {
            curPos = totalRows - 1;
        } else if direction == "ABSOLUTE" {
            curPos = moveCount - 1;
        } else if direction == "FORWARD" {
            if moveCount == -1 {
                curPos = totalRows;
            } else {
                curPos = curPos + moveCount;
            }
        }

        cursorPositions.set(idx, curPos);
        result.message = "MOVE";
        return result;
    }

    //=========================================================================
    // SAVEPOINT HANDLERS (Phase 33)
    //=========================================================================

    hide func executeSavepoint(name: String) -> QueryResult {
        var result = new QueryResult();
        result.init();

        if inTransaction == false {
            result.setError("SAVEPOINT can only be used within a transaction");
            return result;
        }

        // Check for duplicate savepoint — overwrite if exists (PG behavior)
        var fi = 0;
        var found = false;
        while fi < savepointNames.count() {
            if savepointNames.get(fi) == name {
                savepointJournalMarks.set(fi, journal.count());
                found = true;
            }
            fi = fi + 1;
        }

        if found == false {
            savepointNames.add(name);
            savepointJournalMarks.add(journal.count());
        }

        result.message = "SAVEPOINT";
        return result;
    }

    hide func executeReleaseSavepoint(name: String) -> QueryResult {
        var result = new QueryResult();
        result.init();

        if inTransaction == false {
            result.setError("RELEASE SAVEPOINT can only be used within a transaction");
            return result;
        }

        // Find the savepoint
        var idx = -1;
        var fi = 0;
        while fi < savepointNames.count() {
            if savepointNames.get(fi) == name {
                idx = fi;
            }
            fi = fi + 1;
        }

        if idx < 0 {
            result.setError("Savepoint \"" + name + "\" does not exist");
            return result;
        }

        // Release this savepoint and all savepoints created after it
        while savepointNames.count() > idx {
            savepointNames.removeAt(savepointNames.count() - 1);
            savepointJournalMarks.removeAt(savepointJournalMarks.count() - 1);
        }

        result.message = "RELEASE";
        return result;
    }

    hide func executeRollbackToSavepoint(name: String) -> QueryResult {
        var result = new QueryResult();
        result.init();

        if inTransaction == false {
            result.setError("ROLLBACK TO SAVEPOINT can only be used within a transaction");
            return result;
        }

        // Find the savepoint
        var idx = -1;
        var fi = 0;
        while fi < savepointNames.count() {
            if savepointNames.get(fi) == name {
                idx = fi;
            }
            fi = fi + 1;
        }

        if idx < 0 {
            result.setError("Savepoint \"" + name + "\" does not exist");
            return result;
        }

        var journalMark = savepointJournalMarks.get(idx);

        // Undo journal entries in reverse order from current position back to mark
        var i = journal.count() - 1;
        while i >= journalMark {
            var entry = journal.get(i);
            undoJournalEntry(entry);
            i = i - 1;
        }

        // Trim journal to savepoint mark
        while journal.count() > journalMark {
            journal.removeAt(journal.count() - 1);
        }

        // Rebuild indexes for affected tables
        var t = 0;
        while t < txnDirtyTables.count() {
            var tblName = txnDirtyTables.get(t);
            var table = findTable(tblName);
            if table != null {
                var tbl = table;
                rebuildTableIndexes(tblName, tbl);
            }
            t = t + 1;
        }

        // Remove savepoints created after this one, but keep this savepoint
        while savepointNames.count() > idx + 1 {
            savepointNames.removeAt(savepointNames.count() - 1);
            savepointJournalMarks.removeAt(savepointJournalMarks.count() - 1);
        }

        result.message = "ROLLBACK";
        return result;
    }

    //=========================================================================
    // COPY HANDLER (Phase 34)
    //=========================================================================

    hide func executeCopy(parser: Parser, fullSql: String) -> QueryResult {
        var result = new QueryResult();
        result.init();

        // COPY table_name TO/FROM 'filename' [WITH (FORMAT CSV, HEADER, DELIMITER 'x')]
        // COPY (query) TO 'filename'

        var isQuery = false;
        var tableName = "";
        var querySql = "";

        // Check for COPY (subquery)
        if parser.currentKind() == TK_LPAREN {
            isQuery = true;
            parser.advance();
            // Capture query until matching )
            var depth = 1;
            while parser.currentKind() != TK_EOF && depth > 0 {
                if parser.currentKind() == TK_LPAREN {
                    depth = depth + 1;
                }
                if parser.currentKind() == TK_RPAREN {
                    depth = depth - 1;
                    if depth == 0 {
                        parser.advance();
                        break;
                    }
                }
                if parser.currentKind() == TK_STRING {
                    querySql = querySql + " '" + parser.currentText() + "'";
                } else {
                    if querySql != "" { querySql = querySql + " "; }
                    querySql = querySql + parser.currentText();
                }
                parser.advance();
            }
        } else if parser.currentKind() == TK_IDENTIFIER {
            tableName = parser.currentText();
            parser.advance();
        } else {
            result.setError("COPY requires a table name or (query)");
            return result;
        }

        // Parse TO or FROM
        var isTo = false;
        var isFrom = false;
        if parser.currentKind() == TK_TO {
            isTo = true;
            parser.advance();
        } else if parser.currentKind() == TK_FROM {
            isFrom = true;
            parser.advance();
        } else {
            result.setError("Expected TO or FROM after table name");
            return result;
        }

        // Parse filename or STDOUT/STDIN
        var fileName = "";
        var useStdout = false;
        var useStdin = false;
        if parser.currentKind() == TK_STRING {
            fileName = parser.currentText();
            parser.advance();
        } else if parser.currentKind() == TK_STDOUT {
            useStdout = true;
            parser.advance();
        } else if parser.currentKind() == TK_STDIN {
            useStdin = true;
            parser.advance();
        } else {
            result.setError("Expected filename, STDOUT, or STDIN");
            return result;
        }

        // Parse optional WITH (FORMAT CSV, HEADER, DELIMITER 'x')
        var formatCsv = false;
        var includeHeader = true;  // default: include header
        var delimiter = ",";

        if parser.currentKind() == TK_WITH {
            parser.advance();
            if parser.currentKind() == TK_LPAREN {
                parser.advance();
                while parser.currentKind() != TK_RPAREN && parser.currentKind() != TK_EOF {
                    if parser.currentKind() == TK_FORMAT {
                        parser.advance();
                        if parser.currentKind() == TK_IDENTIFIER && String.ToUpper(parser.currentText()) == "CSV" {
                            formatCsv = true;
                            parser.advance();
                        }
                    } else if parser.currentKind() == TK_HEADER {
                        includeHeader = true;
                        parser.advance();
                    } else if parser.currentKind() == TK_DELIMITER {
                        parser.advance();
                        if parser.currentKind() == TK_STRING {
                            delimiter = parser.currentText();
                            parser.advance();
                        }
                    } else if parser.currentKind() == TK_COMMA {
                        parser.advance();
                    } else {
                        parser.advance();
                    }
                }
            }
        }

        if isTo {
            // COPY TO: export data
            var qr: QueryResult;
            if isQuery {
                qr = executeSql(querySql);
            } else {
                qr = executeSql("SELECT * FROM " + tableName);
            }
            if qr.success == false {
                result.setError("COPY TO failed: " + qr.message);
                return result;
            }

            // Build CSV output
            var output = "";
            if includeHeader {
                var hi = 0;
                while hi < qr.columnNames.count() {
                    if hi > 0 { output = output + delimiter; }
                    output = output + qr.columnNames.get(hi);
                    hi = hi + 1;
                }
                output = output + "\n";
            }

            var ri = 0;
            while ri < qr.rows.count() {
                var row = qr.rows.get(ri);
                var vi = 0;
                while vi < row.columnCount() {
                    if vi > 0 { output = output + delimiter; }
                    var v = row.getValue(vi);
                    if v.kind == SQL_NULL {
                        // empty for NULL
                    } else if v.kind == SQL_TEXT || v.kind == SQL_JSON {
                        // Quote text values
                        output = output + "\"" + String.Replace(v.textValue, "\"", "\"\"") + "\"";
                    } else {
                        output = output + v.toString();
                    }
                    vi = vi + 1;
                }
                output = output + "\n";
                ri = ri + 1;
            }

            if useStdout {
                // Return as result rows with single 'line' column
                result.addColumnName("COPY");
                var lines = splitByNewline(output);
                var li = 0;
                while li < lines.count() {
                    var line = lines.get(li);
                    if String.Length(line) > 0 {
                        var r = new Row();
                        r.initWithCount(1);
                        r.setValue(0, sqlText(line));
                        result.addRow(r);
                    }
                    li = li + 1;
                }
            } else {
                // Write to file
                IO.File.WriteAllText(fileName, output);
                result.message = "COPY " + Fmt.Int(qr.rows.count());
            }
            return result;
        }

        // COPY FROM: import data
        if isFrom {
            if isQuery {
                result.setError("COPY FROM does not support subqueries");
                return result;
            }

            var table = findTable(tableName);
            if table == null {
                result.setError("Table \"" + tableName + "\" does not exist");
                return result;
            }
            var t = table;

            var content = IO.File.ReadAllText(fileName);
            var lines = splitByNewline(content);

            var startLine = 0;
            if includeHeader && lines.count() > 0 {
                startLine = 1;  // Skip header line
            }

            var rowsImported = 0;
            var li = startLine;
            while li < lines.count() {
                var line = lines.get(li);
                if String.Length(line) == 0 {
                    li = li + 1;
                    continue;
                }

                // Parse CSV line into values
                var vals = splitCsvLine(line, delimiter);
                var colCount = t.columnCount();

                if vals.count() >= colCount {
                    var newRow = new Row();
                    newRow.initWithCount(colCount);
                    var vi = 0;
                    while vi < colCount {
                        var rawVal = vals.get(vi);
                        var colOpt = t.getColumn(vi);
                        if colOpt == null {
                            vi = vi + 1;
                            continue;
                        }
                        var col = colOpt;
                        if String.Length(rawVal) == 0 {
                            newRow.setValue(vi, sqlNull());
                        } else if col.typeCode == SQL_INTEGER {
                            newRow.setValue(vi, sqlInteger(stringToInt(rawVal)));
                        } else if col.typeCode == SQL_REAL {
                            newRow.setValue(vi, sqlReal(stringToNumber(rawVal), rawVal));
                        } else {
                            // Remove surrounding quotes if present
                            var vLen = String.Length(rawVal);
                            if vLen >= 2 && String.Substring(rawVal, 0, 1) == "\"" && String.Substring(rawVal, vLen - 1, 1) == "\"" {
                                rawVal = String.Substring(rawVal, 1, vLen - 2);
                                rawVal = String.Replace(rawVal, "\"\"", "\"");
                            }
                            newRow.setValue(vi, sqlText(rawVal));
                        }
                        vi = vi + 1;
                    }
                    t.addRow(newRow);
                    rowsImported = rowsImported + 1;
                }
                li = li + 1;
            }

            result.message = "COPY " + Fmt.Int(rowsImported);
            return result;
        }

        result.setError("COPY requires TO or FROM");
        return result;
    }

    // Split a string by newline characters
    hide func splitByNewline(s: String) -> List[String] {
        var parts: List[String] = [];
        var current = "";
        var i = 0;
        var len = String.Length(s);
        while i < len {
            var ch = String.Substring(s, i, 1);
            if ch == "\n" {
                parts.add(current);
                current = "";
            } else if ch == "\r" {
                // skip CR
            } else {
                current = current + ch;
            }
            i = i + 1;
        }
        if String.Length(current) > 0 {
            parts.add(current);
        }
        return parts;
    }

    // Split a CSV line by delimiter, respecting quoted fields
    hide func splitCsvLine(line: String, delim: String) -> List[String] {
        var parts: List[String] = [];
        var current = "";
        var inQuotes = false;
        var i = 0;
        var len = String.Length(line);
        while i < len {
            var ch = String.Substring(line, i, 1);
            if inQuotes {
                if ch == "\"" {
                    if i + 1 < len && String.Substring(line, i + 1, 1) == "\"" {
                        current = current + "\"";
                        i = i + 2;
                        continue;
                    }
                    inQuotes = false;
                } else {
                    current = current + ch;
                }
            } else {
                if ch == "\"" {
                    inQuotes = true;
                } else if ch == delim {
                    parts.add(current);
                    current = "";
                } else {
                    current = current + ch;
                }
            }
            i = i + 1;
        }
        parts.add(current);
        return parts;
    }

    //=========================================================================
    // CALL HANDLER (Phase 35)
    //=========================================================================

    hide func executeCall(parser: Parser) -> QueryResult {
        var result = new QueryResult();
        result.init();

        // CALL function_name(args, ...)
        if parser.currentKind() != TK_IDENTIFIER {
            result.setError("CALL requires a function name");
            return result;
        }
        var funcName = String.ToUpper(parser.currentText());
        parser.advance();

        // Collect argument expressions as SQL text
        var argSqls: List[String] = [];
        if parser.currentKind() == TK_LPAREN {
            parser.advance();
            if parser.currentKind() != TK_RPAREN {
                // Collect each arg as text until comma or rparen
                var argText = "";
                var depth = 0;
                while parser.currentKind() != TK_EOF {
                    if parser.currentKind() == TK_LPAREN {
                        depth = depth + 1;
                        argText = argText + "(";
                        parser.advance();
                    } else if parser.currentKind() == TK_RPAREN {
                        if depth == 0 {
                            if String.Length(String.Trim(argText)) > 0 {
                                argSqls.add(String.Trim(argText));
                            }
                            parser.advance();
                            break;
                        }
                        depth = depth - 1;
                        argText = argText + ")";
                        parser.advance();
                    } else if parser.currentKind() == TK_COMMA && depth == 0 {
                        argSqls.add(String.Trim(argText));
                        argText = "";
                        parser.advance();
                    } else {
                        if parser.currentKind() == TK_STRING {
                            argText = argText + "'" + parser.currentText() + "'";
                        } else {
                            if String.Length(argText) > 0 { argText = argText + " "; }
                            argText = argText + parser.currentText();
                        }
                        parser.advance();
                    }
                }
            } else {
                parser.advance();
            }
        }

        // Look up function in FunctionManager
        var fn = funcMgr.findFunction(funcName, argSqls.count());
        if fn == null {
            result.setError("Function " + funcName + "(" + Fmt.Int(argSqls.count()) + " args) does not exist");
            return result;
        }
        var userFn = fn;

        // Build the SQL body with parameter substitution
        var bodySqlStr = userFn.bodySQL;
        var pi = 0;
        while pi < argSqls.count() {
            var paramPlaceholder = "$" + Fmt.Int(pi + 1);
            bodySqlStr = String.Replace(bodySqlStr, paramPlaceholder, argSqls.get(pi));
            pi = pi + 1;
        }

        // Execute the function body
        var fnResult = executeSql(bodySqlStr);

        // For VOID functions, just return success message
        if userFn.returnType == SQL_NULL {
            result.message = "CALL";
            return result;
        }

        // Return function result
        return fnResult;
    }

    //=========================================================================
    // MATERIALIZED VIEWS (Phase 37)
    //=========================================================================

    hide func executeCreateMatView(viewName: String, viewSql: String) -> QueryResult {
        var result = new QueryResult();
        result.init();

        // Check for existing materialized view
        if db.isMatView(viewName) {
            result.setError("Materialized view '" + viewName + "' already exists");
            return result;
        }
        // Check for table or view with same name
        if findTable(viewName) != null {
            result.setError("A table with name '" + viewName + "' already exists");
            return result;
        }
        if db.isView(viewName) {
            result.setError("A view with name '" + viewName + "' already exists");
            return result;
        }

        // Execute the query to materialize the data
        var queryResult = executeSql(viewSql);
        if queryResult.success == false {
            result.setError("Failed to materialize view: " + queryResult.message);
            return result;
        }

        // Create the backing table with columns from the query result
        var matTable = new Table();
        matTable.initWithName(viewName);
        var ci = 0;
        while ci < queryResult.columnNames.count() {
            var col = new Column();
            col.initWithName(queryResult.columnNames.get(ci), SQL_TEXT);
            matTable.addColumn(col);
            ci = ci + 1;
        }

        // Copy rows into the backing table
        var ri = 0;
        while ri < queryResult.rows.count() {
            var srcRow = queryResult.rows.get(ri);
            var newRow = new Row();
            newRow.initWithCount(matTable.columnCount());
            var vi = 0;
            while vi < srcRow.values.count() {
                newRow.setValue(vi, srcRow.values.get(vi));
                vi = vi + 1;
            }
            matTable.addRow(newRow);
            ri = ri + 1;
        }

        // Store the backing table and register the materialized view
        db.addTable(matTable);
        db.addMatView(viewName, viewSql);

        result.message = "Materialized view '" + viewName + "' created with " + Fmt.Int(queryResult.rows.count()) + " rows";
        return result;
    }

    hide func executeRefreshMatView(viewName: String) -> QueryResult {
        var result = new QueryResult();
        result.init();

        // Check that the materialized view exists
        var viewSql = db.findMatView(viewName);
        if viewSql == "" {
            result.setError("Materialized view '" + viewName + "' does not exist");
            return result;
        }

        // Execute the query to get fresh data
        var queryResult = executeSql(viewSql);
        if queryResult.success == false {
            result.setError("Failed to refresh materialized view: " + queryResult.message);
            return result;
        }

        // Find the backing table and replace its data
        var matTable = findTable(viewName);
        if matTable == null {
            result.setError("Backing table for materialized view '" + viewName + "' not found");
            return result;
        }
        var t = matTable;

        // Clear existing rows
        t.clearAllRows();

        // Rebuild columns if needed (query result shape may change)
        t.columns = [];
        var ci = 0;
        while ci < queryResult.columnNames.count() {
            var col = new Column();
            col.initWithName(queryResult.columnNames.get(ci), SQL_TEXT);
            t.addColumn(col);
            ci = ci + 1;
        }

        // Copy fresh rows
        var ri = 0;
        while ri < queryResult.rows.count() {
            var srcRow = queryResult.rows.get(ri);
            var newRow = new Row();
            newRow.initWithCount(t.columnCount());
            var vi = 0;
            while vi < srcRow.values.count() {
                newRow.setValue(vi, srcRow.values.get(vi));
                vi = vi + 1;
            }
            t.addRow(newRow);
            ri = ri + 1;
        }

        result.message = "Materialized view '" + viewName + "' refreshed with " + Fmt.Int(queryResult.rows.count()) + " rows";
        return result;
    }

    hide func executeDropMatView(viewName: String) -> QueryResult {
        var result = new QueryResult();
        result.init();

        if db.isMatView(viewName) == false {
            result.setError("Materialized view '" + viewName + "' does not exist");
            return result;
        }

        // Drop the backing table
        db.dropTable(viewName);
        // Remove the materialized view definition
        db.dropMatView(viewName);

        result.message = "Materialized view '" + viewName + "' dropped";
        return result;
    }

    //=========================================================================
    // DO BLOCKS (Phase 41)
    //=========================================================================

    hide func executeDoBlock(body: String) -> QueryResult {
        var result = new QueryResult();
        result.init();

        if String.Length(String.Trim(body)) == 0 {
            result.setError("DO block is empty");
            return result;
        }

        // Split body by semicolons and execute each statement
        var stmtCount = 0;
        var lastResult = result;
        var current = "";
        var inString = false;
        var i = 0;
        var bodyLen = String.Length(body);
        while i < bodyLen {
            var ch = String.Substring(body, i, 1);
            if ch == "'" {
                inString = !inString;
                current = current + ch;
            } else if ch == ";" && inString == false {
                var trimmed = String.Trim(current);
                if String.Length(trimmed) > 0 {
                    lastResult = executeSql(trimmed);
                    stmtCount = stmtCount + 1;
                    if lastResult.success == false {
                        return lastResult;
                    }
                }
                current = "";
            } else {
                current = current + ch;
            }
            i = i + 1;
        }
        // Execute any remaining statement
        var trimmedLast = String.Trim(current);
        if String.Length(trimmedLast) > 0 {
            lastResult = executeSql(trimmedLast);
            stmtCount = stmtCount + 1;
            if lastResult.success == false {
                return lastResult;
            }
        }

        result.message = "DO (" + Fmt.Int(stmtCount) + " statements)";
        return result;
    }

    //=========================================================================
    // CREATE TABLE AS SELECT (Phase 39)
    //=========================================================================

    hide func executeCreateTableAs(tableName: String, querySql: String, isTemp: Boolean) -> QueryResult {
        var result = new QueryResult();
        result.init();

        // Check for existing table
        if findTable(tableName) != null {
            result.setError("Table '" + tableName + "' already exists");
            return result;
        }
        if db.isView(tableName) {
            result.setError("A view with name '" + tableName + "' already exists");
            return result;
        }

        // Execute the query
        var queryResult = executeSql(querySql);
        if queryResult.success == false {
            result.setError("Failed to execute query: " + queryResult.message);
            return result;
        }

        // Create the table with columns from the query result
        var newTable = new Table();
        newTable.initWithName(tableName);
        var ci = 0;
        while ci < queryResult.columnNames.count() {
            var col = new Column();
            col.initWithName(queryResult.columnNames.get(ci), SQL_TEXT);
            newTable.addColumn(col);
            ci = ci + 1;
        }

        // Copy rows into the new table
        var ri = 0;
        while ri < queryResult.rows.count() {
            var srcRow = queryResult.rows.get(ri);
            var newRow = new Row();
            newRow.initWithCount(newTable.columnCount());
            var vi = 0;
            while vi < srcRow.values.count() {
                newRow.setValue(vi, srcRow.values.get(vi));
                vi = vi + 1;
            }
            newTable.addRow(newRow);
            ri = ri + 1;
        }

        // Add to database
        db.addTable(newTable);

        result.message = "SELECT " + Fmt.Int(queryResult.rows.count());
        return result;
    }

    // Phase 69: SELECT INTO — create table from query result
    hide func createTableFromResult(tableName: String, queryResult: QueryResult) -> QueryResult {
        var result = new QueryResult();
        result.init();

        if findTable(tableName) != null {
            result.setError("Table '" + tableName + "' already exists");
            return result;
        }

        var newTable = new Table();
        newTable.initWithName(tableName);
        var ci = 0;
        while ci < queryResult.columnNames.count() {
            var col = new Column();
            col.initWithName(queryResult.columnNames.get(ci), SQL_TEXT);
            newTable.addColumn(col);
            ci = ci + 1;
        }

        var ri = 0;
        while ri < queryResult.rows.count() {
            var srcRow = queryResult.rows.get(ri);
            var newRow = new Row();
            newRow.initWithCount(newTable.columnCount());
            var vi = 0;
            while vi < srcRow.values.count() {
                newRow.setValue(vi, srcRow.values.get(vi));
                vi = vi + 1;
            }
            newTable.addRow(newRow);
            ri = ri + 1;
        }

        db.addTable(newTable);
        result.message = "SELECT INTO " + Fmt.Int(queryResult.rows.count());
        return result;
    }

    // Compact a table by removing soft-deleted rows
    expose func compactTable(t: Table) {
        var compacted: List[Row] = [];
        var cr = 0;
        while cr < t.rowCount() {
            var checkRow = t.getRow(cr);
            if checkRow != null {
                var checkData = checkRow;
                if checkData.deleted == false {
                    compacted.add(checkData);
                }
            }
            cr = cr + 1;
        }
        t.rows = compacted;
    }

    // Undo journal entries back to a savepoint (for statement-level atomicity)
    expose func undoToSavepoint(savepoint: Integer) {
        var i = journal.count() - 1;
        while i >= savepoint {
            var entry = journal.get(i);
            undoJournalEntry(entry);
            i = i - 1;
        }
        // Remove undone entries from journal
        while journal.count() > savepoint {
            journal.removeAt(journal.count() - 1);
        }
        // Rebuild indexes for affected tables
        var t = 0;
        while t < txnDirtyTables.count() {
            var tblName = txnDirtyTables.get(t);
            var table = findTable(tblName);
            if table != null {
                var tbl = table;
                rebuildTableIndexes(tblName, tbl);
            }
            t = t + 1;
        }
    }

    // Track a table as modified (for transaction rollback and statement atomicity)
    expose func markTableDirty(tableName: String) {
        // Check if already tracked
        var i = 0;
        while i < txnDirtyTables.count() {
            if txnDirtyTables.get(i) == tableName {
                return;
            }
            i = i + 1;
        }
        txnDirtyTables.add(tableName);
    }

    // Record a journal entry for INSERT (always records for statement-level atomicity)
    expose func journalInsert(tableName: String, rowIndex: Integer) {
        var entry = new JournalEntry();
        entry.init();
        entry.initInsert(tableName, rowIndex);
        journal.add(entry);
        markTableDirty(tableName);
    }

    // Record a journal entry for DELETE (always records for statement-level atomicity)
    expose func journalDelete(tableName: String, rowIndex: Integer, row: Row) {
        var entry = new JournalEntry();
        entry.init();
        entry.initDelete(tableName, rowIndex, row);
        journal.add(entry);
        markTableDirty(tableName);
    }

    // Record a journal entry for UPDATE (deep-copy before image)
    expose func journalUpdate(tableName: String, rowIndex: Integer, row: Row) {
        // Deep-copy the row as before image
        var copy = new Row();
        copy.initWithCount(row.columnCount());
        var c = 0;
        while c < row.columnCount() {
            var val = row.getValue(c);
            copy.setValue(c, val);
            c = c + 1;
        }
        var entry = new JournalEntry();
        entry.init();
        entry.initUpdate(tableName, rowIndex, copy);
        journal.add(entry);
        markTableDirty(tableName);
    }

    // Clear the journal after a successful non-transactional statement
    expose func clearStatementJournal() {
        if inTransaction == false {
            journal = [];
            txnDirtyTables = [];
        }
    }

    // DDL, DML, and query functions are delegated to handler entities.
    // See ddl.zia (DdlHandler), dml.zia (DmlHandler), query.zia (QueryHandler).

}
