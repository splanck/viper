// executor.viper - SQL Executor with proper OOP design
// Part of SQLite Clone - ViperLang Implementation

module executor;

bind String = Viper.String;
bind Fmt = Viper.Fmt;
bind IO = Viper.IO;

bind "./types";
bind "./schema";
bind "./table";
bind "./index";
bind "./expr";
bind "./stmt";
bind "./parser";
bind "./database";
bind "./result";
bind "./server";
bind "./storage/page";
bind "./storage/serializer";
bind "./storage/pager";
bind "./storage/buffer";
bind "./storage/schema_page";
bind "./storage/data_page";
bind "./storage/engine";

//=============================================================================
// EXECUTOR ENTITY
//=============================================================================

entity Executor {
    // Multi-database server (Phase 1)
    expose DatabaseServer server;

    // These point to server's current database/index manager
    // Using non-optional because server always has a current database
    expose Database db;
    expose IndexManager indexMgr;

    // Persistent storage engine (null when using in-memory mode)
    hide StorageEngine? storageEngine;

    // Context for correlated subqueries
    hide Row? outerRow;
    hide Table? outerTable;
    hide String outerTableAlias;
    hide String currentTableAlias;
    hide Integer subqueryDepth;

    // Subquery result cache to avoid re-executing the same subquery per row
    // This prevents native codegen string corruption from repeated recursive calls
    // Stores cloned scalar values (for scalar subqueries) and value lists (for IN subqueries)
    hide List[String] subqueryCacheKeys;
    hide List[SqlValue] subqueryCacheScalars;
    hide List[List[SqlValue]] subqueryCacheLists;

    expose func init() {
        server = new DatabaseServer();
        server.init();
        // Initialize db and indexMgr - server always has 'main' database after init
        // Direct assignment from server lists (guaranteed non-null after server.init())
        db = server.dbList.get(0);
        indexMgr = server.indexManagers.get(0);
        storageEngine = null;
        outerRow = null;
        outerTable = null;
        outerTableAlias = "";
        currentTableAlias = "";
        subqueryDepth = 0;
        subqueryCacheKeys = [];
        subqueryCacheScalars = [];
        subqueryCacheLists = [];
    }

    // Refresh db and indexMgr references from server's current database
    hide func refreshCurrentDatabase() {
        // Server's currentDbIndex is always valid after init
        db = server.dbList.get(server.currentDbIndex);
        indexMgr = server.indexManagers.get(server.currentDbIndex);
    }

    //=========================================================================
    // EXPRESSION EVALUATION
    //=========================================================================

    expose func evalExpr(expr: Expr, row: Row, table: Table) -> SqlValue {
        if expr.kind == EXPR_LITERAL {
            return expr.literalValue;
        }
        if expr.kind == EXPR_COLUMN {
            return evalColumn(expr, row, table);
        }
        if expr.kind == EXPR_BINARY {
            return evalBinary(expr, row, table);
        }
        if expr.kind == EXPR_UNARY {
            return evalUnary(expr, row, table);
        }
        if expr.kind == EXPR_FUNCTION {
            return evalFunction(expr, row, table);
        }
        if expr.kind == EXPR_SUBQUERY {
            return evalSubquery(expr, row, table);
        }
        if expr.kind == EXPR_CASE {
            return evalCase(expr, row, table);
        }
        return sqlNull();
    }

    // Evaluate a CASE expression
    expose func evalCase(expr: Expr, row: Row, table: Table) -> SqlValue {
        // Evaluate each WHEN condition until one is true
        var i = 0;
        while i < expr.caseConditions.count() {
            var condition = expr.caseConditions.get(i);
            var condResult = evalExpr(condition, row, table);

            // Condition is true if non-zero integer or non-empty string
            var isTrue = false;
            if condResult.kind == SQL_INTEGER && condResult.intValue != 0 {
                isTrue = true;
            } else if condResult.kind == SQL_TEXT && condResult.textValue != "" {
                isTrue = true;
            }

            if isTrue {
                // Return the corresponding THEN result
                var result = expr.caseResults.get(i);
                return evalExpr(result, row, table);
            }
            i = i + 1;
        }

        // No condition matched - return ELSE value or NULL
        if expr.caseElse != null {
            var elseExpr = expr.caseElse;
            return evalExpr(elseExpr, row, table);
        }
        return sqlNull();
    }

    // Flatten nested subqueries in a SQL string by pre-evaluating inner
    // (SELECT ...) expressions and substituting their results as literals.
    // This avoids deep recursion through executeSelect which causes
    // stack overflow in native codegen.
    expose func flattenSubqueries(sql: String) -> String {
        // Look for "( SELECT" or "(SELECT" pattern (parser adds space after paren)
        var result = sql;
        var maxPasses = 4;
        var pass = 0;
        while pass < maxPasses {
            // Find the LAST occurrence of a subquery pattern to flatten innermost first
            var idx = -1;
            var searchPos = 0;
            var len = String.Length(result);
            while searchPos < len - 9 {
                var ch = String.Substring(result, searchPos, 1);
                if ch == "(" {
                    // Check if followed by SELECT (with optional space)
                    var remaining = len - searchPos - 1;
                    if remaining >= 7 {
                        var after = String.Substring(result, searchPos + 1, 7);
                        var upperAfter = String.ToUpper(after);
                        if upperAfter == "SELECT " || upperAfter == " SELECT" {
                            idx = searchPos;
                        }
                    }
                }
                searchPos = searchPos + 1;
            }

            if idx < 0 {
                return result;
            }

            // Found inner subquery at idx. Extract it.
            // Find matching closing paren
            var depth = 1;
            var pos = idx + 1;
            while pos < len && depth > 0 {
                var ch = String.Substring(result, pos, 1);
                if ch == "(" {
                    depth = depth + 1;
                } else if ch == ")" {
                    depth = depth - 1;
                }
                if depth > 0 {
                    pos = pos + 1;
                }
            }
            if depth != 0 {
                return result;
            }

            // Extract the inner SQL (without outer parens)
            var innerSql = String.Substring(result, idx + 1, pos - idx - 1);

            // Execute the inner subquery
            var savedOuterRow2 = outerRow;
            var savedOuterTable2 = outerTable;
            var savedOuterAlias2 = outerTableAlias;
            var savedCurrentAlias2 = currentTableAlias;

            var innerResult = executeSubquerySelect(innerSql);

            outerRow = savedOuterRow2;
            outerTable = savedOuterTable2;
            outerTableAlias = savedOuterAlias2;
            currentTableAlias = savedCurrentAlias2;

            // Get scalar result
            var replacement = "NULL";
            if innerResult.success && innerResult.rowCount() > 0 {
                var firstRow = innerResult.getRow(0);
                if firstRow != null {
                    var fr = firstRow;
                    if fr.columnCount() > 0 {
                        var val = fr.getValue(0);
                        if val.kind == SQL_INTEGER {
                            replacement = Fmt.Int(val.intValue);
                        } else if val.kind == SQL_REAL {
                            replacement = val.textValue;
                        } else if val.kind == SQL_TEXT {
                            replacement = "'" + val.textValue + "'";
                        }
                    }
                }
            }

            // Substitute: before + replacement + after
            var before = String.Substring(result, 0, idx);
            var after = String.Substring(result, pos + 1, len - pos - 1);
            result = before + replacement + after;

            pass = pass + 1;
        }
        return result;
    }

    // Evaluate a scalar subquery (with caching for non-correlated subqueries)
    expose func evalSubquery(expr: Expr, outerRowContext: Row, outerTableContext: Table) -> SqlValue {
        // Guard against very deep nesting to prevent stack overflow
        if subqueryDepth >= 8 {
            return sqlNull();
        }

        // Check scalar subquery cache first (avoids repeated recursive calls
        // that cause string corruption in native codegen)
        var cacheKey = expr.subquerySQL;
        var ci = 0;
        while ci < subqueryCacheKeys.count() {
            if subqueryCacheKeys.get(ci) == cacheKey {
                return subqueryCacheScalars.get(ci);
            }
            ci = ci + 1;
        }

        // Set outer context for correlated subqueries
        var savedOuterRow = outerRow;
        var savedOuterTable = outerTable;
        var savedOuterAlias = outerTableAlias;
        var savedCurrentAlias = currentTableAlias;

        outerRow = outerRowContext;
        outerTable = outerTableContext;
        outerTableAlias = currentTableAlias;

        // Clone and flatten nested subqueries to avoid deep recursion stack overflow
        var sql = String.Substring(expr.subquerySQL, 0, String.Length(expr.subquerySQL));
        sql = flattenSubqueries(sql);

        // Execute the subquery via dedicated path to avoid full executeSql recursion
        subqueryDepth = subqueryDepth + 1;
        var result = executeSubquerySelect(sql);
        subqueryDepth = subqueryDepth - 1;

        // Restore ALL outer context including currentTableAlias
        outerRow = savedOuterRow;
        outerTable = savedOuterTable;
        outerTableAlias = savedOuterAlias;
        currentTableAlias = savedCurrentAlias;

        // Return scalar value from first row, first column
        // Clone the value to prevent string lifetime issues with nested subqueries
        if result.success && result.rowCount() > 0 {
            var firstRow = result.getRow(0);
            if firstRow != null {
                var r = firstRow;
                if r.columnCount() > 0 {
                    var val = cloneValue(r.getValue(0));
                    // Cache the cloned value for subsequent calls
                    subqueryCacheKeys.add(cacheKey);
                    subqueryCacheScalars.add(val);
                    // Add empty list to keep indices aligned
                    var emptyList: List[SqlValue] = [];
                    subqueryCacheLists.add(emptyList);
                    return val;
                }
            }
        }
        // Cache null result too
        var nullVal = sqlNull();
        subqueryCacheKeys.add(cacheKey);
        subqueryCacheScalars.add(nullVal);
        var emptyList2: List[SqlValue] = [];
        subqueryCacheLists.add(emptyList2);
        return nullVal;
    }

    // Evaluate an IN subquery: returns the list of cloned values from the subquery.
    // Uses same save/restore pattern as evalSubquery to avoid string corruption
    // in native codegen during recursive calls.
    expose func evalInSubquery(subqueryExpr: Expr) -> List[SqlValue] {
        // Check list cache first
        var cacheKey = subqueryExpr.subquerySQL;
        var ci = 0;
        while ci < subqueryCacheKeys.count() {
            if subqueryCacheKeys.get(ci) == cacheKey {
                return subqueryCacheLists.get(ci);
            }
            ci = ci + 1;
        }

        // Save ALL executor state
        var savedOuterRow = outerRow;
        var savedOuterTable = outerTable;
        var savedOuterAlias = outerTableAlias;
        var savedCurrentAlias = currentTableAlias;

        // Clone and flatten nested subqueries
        var sql = String.Substring(subqueryExpr.subquerySQL, 0, String.Length(subqueryExpr.subquerySQL));
        sql = flattenSubqueries(sql);

        subqueryDepth = subqueryDepth + 1;
        var subResult = executeSubquerySelect(sql);
        subqueryDepth = subqueryDepth - 1;

        // Restore ALL executor state
        outerRow = savedOuterRow;
        outerTable = savedOuterTable;
        outerTableAlias = savedOuterAlias;
        currentTableAlias = savedCurrentAlias;

        // Clone all result values
        var values = new List[SqlValue]();
        if subResult.success {
            var si = 0;
            while si < subResult.rowCount() {
                var subRow = subResult.getRow(si);
                if subRow != null {
                    var sr = subRow;
                    if sr.columnCount() > 0 {
                        values.add(cloneValue(sr.getValue(0)));
                    }
                }
                si = si + 1;
            }
        }

        // Cache the result
        subqueryCacheKeys.add(cacheKey);
        subqueryCacheScalars.add(sqlNull());
        subqueryCacheLists.add(values);
        return values;
    }

    expose func evalColumn(expr: Expr, row: Row, table: Table) -> SqlValue {
        // Check outer context for correlated subqueries
        if expr.tableName != "" && outerTableAlias != "" {
            if expr.tableName == outerTableAlias {
                if outerTable != null && outerRow != null {
                    var ot = outerTable;
                    var orow = outerRow;
                    var outerColIdx = ot.findColumnIndex(expr.columnName);
                    if outerColIdx >= 0 {
                        return orow.getValue(outerColIdx);
                    }
                }
                return sqlNull();
            }
        }

        var colIdx = table.findColumnIndex(expr.columnName);
        if colIdx < 0 {
            // Try outer context
            if expr.tableName == "" && outerTable != null && outerRow != null {
                var ot = outerTable;
                var orow = outerRow;
                var outerColIdx = ot.findColumnIndex(expr.columnName);
                if outerColIdx >= 0 {
                    return orow.getValue(outerColIdx);
                }
            }
            return sqlNull();
        }
        return row.getValue(colIdx);
    }

    expose func evalBinary(expr: Expr, row: Row, table: Table) -> SqlValue {
        var left = evalExpr(expr.getLeft(), row, table);
        var op = expr.op;
        // For IN with subqueries, don't evaluate right side through evalExpr
        // (which would call evalSubquery and cache a scalar). The IN handler
        // processes the subquery separately with its own list cache.
        var right = sqlNull();
        if op == OP_IN {
            var maybeSubquery = expr.getRight();
            if maybeSubquery.kind != EXPR_SUBQUERY {
                right = evalExpr(maybeSubquery, row, table);
            }
        } else {
            right = evalExpr(expr.getRight(), row, table);
        }

        // Arithmetic (supports INTEGER and REAL)
        if op == OP_ADD {
            if left.kind == SQL_INTEGER && right.kind == SQL_INTEGER {
                return sqlInteger(left.intValue + right.intValue);
            }
            if (left.kind == SQL_REAL || left.kind == SQL_INTEGER) && (right.kind == SQL_REAL || right.kind == SQL_INTEGER) {
                var lv = left.realValue;
                if left.kind == SQL_INTEGER { lv = left.intValue * 1.0; }
                var rv = right.realValue;
                if right.kind == SQL_INTEGER { rv = right.intValue * 1.0; }
                var res = lv + rv;
                return sqlReal(res, Fmt.Num(res));
            }
        }
        if op == OP_SUB {
            if left.kind == SQL_INTEGER && right.kind == SQL_INTEGER {
                return sqlInteger(left.intValue - right.intValue);
            }
            if (left.kind == SQL_REAL || left.kind == SQL_INTEGER) && (right.kind == SQL_REAL || right.kind == SQL_INTEGER) {
                var lv = left.realValue;
                if left.kind == SQL_INTEGER { lv = left.intValue * 1.0; }
                var rv = right.realValue;
                if right.kind == SQL_INTEGER { rv = right.intValue * 1.0; }
                var res = lv - rv;
                return sqlReal(res, Fmt.Num(res));
            }
        }
        if op == OP_MUL {
            if left.kind == SQL_INTEGER && right.kind == SQL_INTEGER {
                return sqlInteger(left.intValue * right.intValue);
            }
            if (left.kind == SQL_REAL || left.kind == SQL_INTEGER) && (right.kind == SQL_REAL || right.kind == SQL_INTEGER) {
                var lv = left.realValue;
                if left.kind == SQL_INTEGER { lv = left.intValue * 1.0; }
                var rv = right.realValue;
                if right.kind == SQL_INTEGER { rv = right.intValue * 1.0; }
                var res = lv * rv;
                return sqlReal(res, Fmt.Num(res));
            }
        }
        if op == OP_DIV {
            if left.kind == SQL_INTEGER && right.kind == SQL_INTEGER {
                if right.intValue != 0 {
                    return sqlInteger(left.intValue / right.intValue);
                }
            }
            if (left.kind == SQL_REAL || left.kind == SQL_INTEGER) && (right.kind == SQL_REAL || right.kind == SQL_INTEGER) {
                var lv = left.realValue;
                if left.kind == SQL_INTEGER { lv = left.intValue * 1.0; }
                var rv = right.realValue;
                if right.kind == SQL_INTEGER { rv = right.intValue * 1.0; }
                if rv != 0.0 {
                    var res = lv / rv;
                    return sqlReal(res, Fmt.Num(res));
                }
            }
        }

        // Comparison - return 1 for true, 0 for false
        // compare() returns 2 for NULL comparisons (SQL three-valued logic)
        if op == OP_EQ {
            var cmp = left.compare(right);
            if cmp == 2 { return sqlInteger(0); }
            if cmp == 0 { return sqlInteger(1); }
            return sqlInteger(0);
        }
        if op == OP_NE {
            var cmp = left.compare(right);
            if cmp == 2 { return sqlInteger(0); }
            if cmp != 0 { return sqlInteger(1); }
            return sqlInteger(0);
        }
        if op == OP_LT {
            var cmp = left.compare(right);
            if cmp == 2 { return sqlInteger(0); }
            if cmp < 0 { return sqlInteger(1); }
            return sqlInteger(0);
        }
        if op == OP_LE {
            var cmp = left.compare(right);
            if cmp == 2 { return sqlInteger(0); }
            if cmp <= 0 { return sqlInteger(1); }
            return sqlInteger(0);
        }
        if op == OP_GT {
            var cmp = left.compare(right);
            if cmp == 2 { return sqlInteger(0); }
            if cmp > 0 { return sqlInteger(1); }
            return sqlInteger(0);
        }
        if op == OP_GE {
            var cmp = left.compare(right);
            if cmp == 2 { return sqlInteger(0); }
            if cmp >= 0 { return sqlInteger(1); }
            return sqlInteger(0);
        }

        // IS NULL / IS NOT NULL
        if op == OP_IS {
            if right.kind == SQL_NULL {
                // IS NULL
                if left.kind == SQL_NULL { return sqlInteger(1); }
                return sqlInteger(0);
            } else {
                // IS NOT NULL (right is int 1 as marker)
                if left.kind != SQL_NULL { return sqlInteger(1); }
                return sqlInteger(0);
            }
        }

        // LIKE pattern matching
        if op == OP_LIKE {
            if left.kind == SQL_NULL { return sqlInteger(0); }
            var leftStr = left.toString();
            var pattern = right.toString();
            if matchLike(leftStr, pattern) {
                return sqlInteger(1);
            }
            return sqlInteger(0);
        }

        // Logical
        if op == OP_AND {
            if left.intValue != 0 && right.intValue != 0 {
                return sqlInteger(1);
            }
            return sqlInteger(0);
        }
        if op == OP_OR {
            if left.intValue != 0 || right.intValue != 0 {
                return sqlInteger(1);
            }
            return sqlInteger(0);
        }

        // IN operator - right side is a subquery or value list
        if op == OP_IN {
            if left.kind == SQL_NULL { return sqlInteger(0); }
            var rightExpr = expr.getRight();
            if rightExpr.kind == EXPR_SUBQUERY {
                // Delegate to dedicated method that properly saves/restores
                // executor state (avoids string corruption in native codegen)
                var subValues = evalInSubquery(rightExpr);
                // Compare left value against subquery results
                var i = 0;
                while i < subValues.count() {
                    if left.compare(subValues.get(i)) == 0 {
                        return sqlInteger(1);
                    }
                    i = i + 1;
                }
            } else if rightExpr.kind == EXPR_FUNCTION {
                // IN value list (args contain the list values)
                var i = 0;
                while i < rightExpr.args.count() {
                    var listVal = evalExpr(rightExpr.args.get(i), row, table);
                    if left.compare(listVal) == 0 {
                        return sqlInteger(1);
                    }
                    i = i + 1;
                }
            }
            return sqlInteger(0);
        }

        // String concatenation
        if op == OP_CONCAT {
            var leftStr = "";
            var rightStr = "";
            if left.kind == SQL_TEXT {
                leftStr = left.textValue;
            } else if left.kind == SQL_INTEGER {
                leftStr = Fmt.Int(left.intValue);
            }
            if right.kind == SQL_TEXT {
                rightStr = right.textValue;
            } else if right.kind == SQL_INTEGER {
                rightStr = Fmt.Int(right.intValue);
            }
            return sqlText(leftStr + rightStr);
        }

        return sqlNull();
    }

    expose func evalUnary(expr: Expr, row: Row, table: Table) -> SqlValue {
        var operand = evalExpr(expr.getOperand(), row, table);

        if expr.op == OP_NEG {
            if operand.kind == SQL_INTEGER {
                return sqlInteger(-operand.intValue);
            }
            if operand.kind == SQL_REAL {
                var neg = -operand.realValue;
                return sqlReal(neg, Fmt.Num(neg));
            }
        }
        if expr.op == OP_NOT {
            if operand.kind == SQL_NULL {
                return sqlInteger(0);
            }
            if operand.intValue == 0 {
                return sqlInteger(1);
            }
            return sqlInteger(0);
        }

        return sqlNull();
    }

    // Deep-clone a SqlValue with fresh string allocation to avoid retain issues
    hide func cloneValue(v: SqlValue) -> SqlValue {
        var c = new SqlValue();
        c.kind = v.kind;
        c.intValue = v.intValue;
        c.realValue = v.realValue;
        if v.kind == SQL_TEXT || v.kind == SQL_BLOB || v.kind == SQL_REAL {
            var len = String.Length(v.textValue);
            c.textValue = String.Substring(v.textValue, 0, len);
        } else {
            c.textValue = "";
        }
        return c;
    }

    // LIKE pattern matching: % matches any sequence, _ matches single char
    hide func matchLike(text: String, pattern: String) -> Boolean {
        var tLen = String.Length(text);
        var pLen = String.Length(pattern);
        var ti = 0;
        var pi = 0;
        var starTi = -1;
        var starPi = -1;

        while ti < tLen {
            if pi < pLen {
                var pch = String.Substring(pattern, pi, 1);
                if pch == "%" {
                    starTi = ti;
                    starPi = pi;
                    pi = pi + 1;
                    continue;
                }
                var tch = String.Substring(text, ti, 1);
                if pch == "_" || String.ToLower(pch) == String.ToLower(tch) {
                    ti = ti + 1;
                    pi = pi + 1;
                    continue;
                }
            }
            // Mismatch - backtrack to last %
            if starPi >= 0 {
                starTi = starTi + 1;
                ti = starTi;
                pi = starPi + 1;
                continue;
            }
            return false;
        }

        // Skip trailing % in pattern
        while pi < pLen && String.Substring(pattern, pi, 1) == "%" {
            pi = pi + 1;
        }
        return pi == pLen;
    }

    expose func evalFunction(expr: Expr, row: Row, table: Table) -> SqlValue {
        var name = String.ToUpper(expr.funcName);

        // String functions
        if name == "UPPER" && expr.args.count() > 0 {
            var arg = evalExpr(expr.args.get(0), row, table);
            if arg.kind == SQL_TEXT {
                return sqlText(String.ToUpper(arg.textValue));
            }
        }
        if name == "LOWER" && expr.args.count() > 0 {
            var arg = evalExpr(expr.args.get(0), row, table);
            if arg.kind == SQL_TEXT {
                return sqlText(String.ToLower(arg.textValue));
            }
        }
        if name == "LENGTH" && expr.args.count() > 0 {
            var arg = evalExpr(expr.args.get(0), row, table);
            if arg.kind == SQL_TEXT {
                return sqlInteger(String.Length(arg.textValue));
            }
        }

        // SUBSTR(string, start) or SUBSTR(string, start, length)
        if (name == "SUBSTR" || name == "SUBSTRING") && expr.args.count() >= 2 {
            var strArg = evalExpr(expr.args.get(0), row, table);
            var startArg = evalExpr(expr.args.get(1), row, table);
            if strArg.kind == SQL_TEXT && startArg.kind == SQL_INTEGER {
                var str = strArg.textValue;
                var start = startArg.intValue - 1;  // SQL uses 1-based indexing
                if start < 0 { start = 0; }
                var len = String.Length(str) - start;

                if expr.args.count() >= 3 {
                    var lenArg = evalExpr(expr.args.get(2), row, table);
                    if lenArg.kind == SQL_INTEGER {
                        len = lenArg.intValue;
                    }
                }

                if start >= String.Length(str) {
                    return sqlText("");
                }
                return sqlText(String.Substring(str, start, len));
            }
        }

        // TRIM(string) - removes leading and trailing spaces
        if name == "TRIM" && expr.args.count() > 0 {
            var arg = evalExpr(expr.args.get(0), row, table);
            if arg.kind == SQL_TEXT {
                var s = arg.textValue;
                // Trim leading spaces
                var start = 0;
                while start < String.Length(s) && String.Substring(s, start, 1) == " " {
                    start = start + 1;
                }
                // Trim trailing spaces
                var end = String.Length(s);
                while end > start && String.Substring(s, end - 1, 1) == " " {
                    end = end - 1;
                }
                return sqlText(String.Substring(s, start, end - start));
            }
        }

        // LTRIM(string) - removes leading spaces
        if name == "LTRIM" && expr.args.count() > 0 {
            var arg = evalExpr(expr.args.get(0), row, table);
            if arg.kind == SQL_TEXT {
                var s = arg.textValue;
                var start = 0;
                while start < String.Length(s) && String.Substring(s, start, 1) == " " {
                    start = start + 1;
                }
                return sqlText(String.Substring(s, start, String.Length(s) - start));
            }
        }

        // RTRIM(string) - removes trailing spaces
        if name == "RTRIM" && expr.args.count() > 0 {
            var arg = evalExpr(expr.args.get(0), row, table);
            if arg.kind == SQL_TEXT {
                var s = arg.textValue;
                var end = String.Length(s);
                while end > 0 && String.Substring(s, end - 1, 1) == " " {
                    end = end - 1;
                }
                return sqlText(String.Substring(s, 0, end));
            }
        }

        // REPLACE(string, from, to)
        if name == "REPLACE" && expr.args.count() >= 3 {
            var strArg = evalExpr(expr.args.get(0), row, table);
            var fromArg = evalExpr(expr.args.get(1), row, table);
            var toArg = evalExpr(expr.args.get(2), row, table);
            if strArg.kind == SQL_TEXT && fromArg.kind == SQL_TEXT && toArg.kind == SQL_TEXT {
                var str = strArg.textValue;
                var from = fromArg.textValue;
                var to = toArg.textValue;
                // Simple replacement - find and replace all occurrences
                var result = "";
                var i = 0;
                var fromLen = String.Length(from);
                var strLen = String.Length(str);
                while i < strLen {
                    if i + fromLen <= strLen && String.Substring(str, i, fromLen) == from {
                        result = result + to;
                        i = i + fromLen;
                    } else {
                        result = result + String.Substring(str, i, 1);
                        i = i + 1;
                    }
                }
                return sqlText(result);
            }
        }

        // CONCAT(str1, str2, ...) or string concatenation
        if name == "CONCAT" && expr.args.count() > 0 {
            var result = "";
            var i = 0;
            while i < expr.args.count() {
                var arg = evalExpr(expr.args.get(i), row, table);
                if arg.kind == SQL_TEXT {
                    result = result + arg.textValue;
                } else if arg.kind == SQL_INTEGER {
                    result = result + Fmt.Int(arg.intValue);
                }
                i = i + 1;
            }
            return sqlText(result);
        }

        // INSTR(string, substring) - find position of substring (1-based, 0 if not found)
        if name == "INSTR" && expr.args.count() >= 2 {
            var strArg = evalExpr(expr.args.get(0), row, table);
            var subArg = evalExpr(expr.args.get(1), row, table);
            if strArg.kind == SQL_TEXT && subArg.kind == SQL_TEXT {
                var str = strArg.textValue;
                var sub = subArg.textValue;
                var subLen = String.Length(sub);
                var strLen = String.Length(str);
                var i = 0;
                while i + subLen <= strLen {
                    if String.Substring(str, i, subLen) == sub {
                        return sqlInteger(i + 1);  // 1-based
                    }
                    i = i + 1;
                }
                return sqlInteger(0);  // Not found
            }
        }

        // Math functions
        if name == "ABS" && expr.args.count() > 0 {
            var arg = evalExpr(expr.args.get(0), row, table);
            if arg.kind == SQL_INTEGER {
                var v = arg.intValue;
                if v < 0 { v = -v; }
                return sqlInteger(v);
            }
        }

        // MOD(a, b) or a % b
        if name == "MOD" && expr.args.count() >= 2 {
            var a = evalExpr(expr.args.get(0), row, table);
            var b = evalExpr(expr.args.get(1), row, table);
            if a.kind == SQL_INTEGER && b.kind == SQL_INTEGER {
                if b.intValue != 0 {
                    return sqlInteger(a.intValue % b.intValue);
                }
            }
        }

        // ROUND(value) - rounds to nearest integer
        if name == "ROUND" && expr.args.count() > 0 {
            var arg = evalExpr(expr.args.get(0), row, table);
            if arg.kind == SQL_INTEGER {
                return arg;  // Already an integer
            }
        }

        // MIN(a, b) - minimum of two values (different from aggregate MIN)
        if name == "MIN" && expr.args.count() == 2 {
            var a = evalExpr(expr.args.get(0), row, table);
            var b = evalExpr(expr.args.get(1), row, table);
            if a.compare(b) <= 0 {
                return a;
            }
            return b;
        }

        // MAX(a, b) - maximum of two values (different from aggregate MAX)
        if name == "MAX" && expr.args.count() == 2 {
            var a = evalExpr(expr.args.get(0), row, table);
            var b = evalExpr(expr.args.get(1), row, table);
            if a.compare(b) >= 0 {
                return a;
            }
            return b;
        }

        // Null handling functions
        if name == "COALESCE" {
            var i = 0;
            while i < expr.args.count() {
                var arg = evalExpr(expr.args.get(i), row, table);
                if arg.kind != SQL_NULL {
                    return arg;
                }
                i = i + 1;
            }
        }

        // IFNULL(expr, value) - returns value if expr is NULL
        if name == "IFNULL" && expr.args.count() >= 2 {
            var arg = evalExpr(expr.args.get(0), row, table);
            if arg.kind == SQL_NULL {
                return evalExpr(expr.args.get(1), row, table);
            }
            return arg;
        }

        // NULLIF(expr1, expr2) - returns NULL if expr1 == expr2
        if name == "NULLIF" && expr.args.count() >= 2 {
            var a = evalExpr(expr.args.get(0), row, table);
            var b = evalExpr(expr.args.get(1), row, table);
            if a.compare(b) == 0 {
                return sqlNull();
            }
            return a;
        }

        // IIF(condition, true_value, false_value) - inline IF
        if name == "IIF" && expr.args.count() >= 3 {
            var cond = evalExpr(expr.args.get(0), row, table);
            if cond.intValue != 0 {
                return evalExpr(expr.args.get(1), row, table);
            }
            return evalExpr(expr.args.get(2), row, table);
        }

        // TYPEOF(expr) - returns the type name
        if name == "TYPEOF" && expr.args.count() > 0 {
            var arg = evalExpr(expr.args.get(0), row, table);
            if arg.kind == SQL_NULL { return sqlText("null"); }
            if arg.kind == SQL_INTEGER { return sqlText("integer"); }
            if arg.kind == SQL_TEXT { return sqlText("text"); }
            if arg.kind == SQL_REAL { return sqlText("real"); }
            if arg.kind == SQL_BLOB { return sqlText("blob"); }
            return sqlText("unknown");
        }

        return sqlNull();
    }

    expose func evalCondition(expr: Expr?, row: Row, table: Table) -> Boolean {
        if expr == null {
            return true;
        }
        var e = expr;
        var result = evalExpr(e, row, table);
        return result.intValue != 0;
    }

    //=========================================================================
    // INDEX-BASED LOOKUPS
    //=========================================================================

    // Check if WHERE clause is a simple equality that can use an index
    // Returns the column name and value if usable, null otherwise
    expose func canUseIndex(expr: Expr?, tableName: String) -> Boolean {
        if expr == null {
            return false;
        }
        var e = expr;

        // Must be a binary expression with OP_EQ
        if e.kind != EXPR_BINARY || e.op != OP_EQ {
            return false;
        }

        var left = e.getLeft();
        var right = e.getRight();

        // Check for column = literal pattern
        if left.kind == EXPR_COLUMN && right.kind == EXPR_LITERAL {
            var colName = left.columnName;
            var maybeIdx = indexMgr.findIndexForColumn(tableName, colName);
            return maybeIdx != null;
        }

        // Check for literal = column pattern
        if left.kind == EXPR_LITERAL && right.kind == EXPR_COLUMN {
            var colName = right.columnName;
            var maybeIdx = indexMgr.findIndexForColumn(tableName, colName);
            return maybeIdx != null;
        }

        return false;
    }

    // Get matching row indices using an index
    expose func indexLookup(expr: Expr, tableName: String, table: Table) -> List[Integer] {
        var left = expr.getLeft();
        var right = expr.getRight();

        var colName = "";
        var lookupValue = sqlNull();

        // Extract column name and lookup value
        if left.kind == EXPR_COLUMN && right.kind == EXPR_LITERAL {
            colName = left.columnName;
            lookupValue = right.literalValue;
        } else if left.kind == EXPR_LITERAL && right.kind == EXPR_COLUMN {
            colName = right.columnName;
            lookupValue = left.literalValue;
        }

        // Find the index
        var maybeIdx = indexMgr.findIndexForColumn(tableName, colName);
        if maybeIdx == null {
            // Fall back to empty list (caller should do linear scan)
            var empty: List[Integer] = [];
            return empty;
        }

        var idx = maybeIdx;
        return idx.lookupSingle(lookupValue, table);
    }

    //=========================================================================
    // AGGREGATE FUNCTIONS
    //=========================================================================

    // Check if expression is an aggregate function
    // Note: MIN/MAX with exactly 2 arguments are treated as scalar functions
    expose func isAggregateExpr(expr: Expr) -> Boolean {
        if expr.kind == EXPR_FUNCTION {
            var funcName = String.ToUpper(expr.funcName);
            if funcName == "COUNT" { return true; }
            if funcName == "COUNT_DISTINCT" { return true; }
            if funcName == "SUM" { return true; }
            if funcName == "AVG" { return true; }
            // MIN/MAX with 2 args = scalar, with 1 arg = aggregate
            if funcName == "MIN" && expr.args.count() != 2 { return true; }
            if funcName == "MAX" && expr.args.count() != 2 { return true; }
        }
        return false;
    }

    // Check if SELECT has any aggregate functions
    expose func hasAggregates(stmt: SelectStmt) -> Boolean {
        var c = 0;
        while c < stmt.columns.count() {
            var colExpr = stmt.columns.get(c);
            if isAggregateExpr(colExpr) {
                return true;
            }
            c = c + 1;
        }
        return false;
    }

    // Evaluate an aggregate function over a list of row indices
    expose func evalAggregate(expr: Expr, matchingRows: List[Integer], table: Table) -> SqlValue {
        var funcName = String.ToUpper(expr.funcName);
        var hasArg = expr.args.count() > 0;

        // COUNT(DISTINCT column) - count distinct non-NULL values
        if funcName == "COUNT_DISTINCT" && hasArg {
            var seen = new List[String]();
            var i = 0;
            while i < matchingRows.count() {
                var rowIdx = matchingRows.get(i);
                var maybeRow = table.getRow(rowIdx);
                if maybeRow != null {
                    var row = maybeRow;
                    var argExpr = expr.args.get(0);
                    var val = evalExpr(argExpr, row, table);
                    if val.kind != SQL_NULL {
                        var valStr = val.toString();
                        var found = false;
                        var k = 0;
                        while k < seen.count() {
                            if seen.get(k) == valStr {
                                found = true;
                                k = seen.count();
                            }
                            k = k + 1;
                        }
                        if found == false {
                            seen.add(valStr);
                        }
                    }
                }
                i = i + 1;
            }
            return sqlInteger(seen.count());
        }

        // COUNT(*)
        if funcName == "COUNT" && hasArg {
            var arg0 = expr.args.get(0);
            if arg0.kind == EXPR_STAR {
                return sqlInteger(matchingRows.count());
            }
        }

        // COUNT(column) - count non-NULL values
        if funcName == "COUNT" {
            var count = 0;
            var i = 0;
            while i < matchingRows.count() {
                var rowIdx = matchingRows.get(i);
                var maybeRow = table.getRow(rowIdx);
                if maybeRow != null {
                    var row = maybeRow;
                    if hasArg {
                        var argExpr = expr.args.get(0);
                        var val = evalExpr(argExpr, row, table);
                        if val.kind != SQL_NULL {
                            count = count + 1;
                        }
                    }
                }
                i = i + 1;
            }
            return sqlInteger(count);
        }

        // SUM(column)
        if funcName == "SUM" {
            var sumInt = 0;
            var sumReal = 0.0;
            var hasValue = false;
            var hasReal = false;
            var i = 0;
            while i < matchingRows.count() {
                var rowIdx = matchingRows.get(i);
                var maybeRow = table.getRow(rowIdx);
                if maybeRow != null {
                    var row = maybeRow;
                    if hasArg {
                        var argExpr = expr.args.get(0);
                        var val = evalExpr(argExpr, row, table);
                        if val.kind == SQL_INTEGER {
                            sumInt = sumInt + val.intValue;
                            hasValue = true;
                        } else if val.kind == SQL_REAL {
                            sumReal = sumReal + val.realValue;
                            hasValue = true;
                            hasReal = true;
                        }
                    }
                }
                i = i + 1;
            }
            if hasValue == false {
                return sqlNull();
            }
            if hasReal {
                var total = sumReal + sumInt * 1.0;
                return sqlReal(total, Fmt.Num(total));
            }
            return sqlInteger(sumInt);
        }

        // AVG(column)
        if funcName == "AVG" {
            var sumInt = 0;
            var sumReal = 0.0;
            var count = 0;
            var hasReal = false;
            var i = 0;
            while i < matchingRows.count() {
                var rowIdx = matchingRows.get(i);
                var maybeRow = table.getRow(rowIdx);
                if maybeRow != null {
                    var row = maybeRow;
                    if hasArg {
                        var argExpr = expr.args.get(0);
                        var val = evalExpr(argExpr, row, table);
                        if val.kind == SQL_INTEGER {
                            sumInt = sumInt + val.intValue;
                            count = count + 1;
                        } else if val.kind == SQL_REAL {
                            sumReal = sumReal + val.realValue;
                            count = count + 1;
                            hasReal = true;
                        }
                    }
                }
                i = i + 1;
            }
            if count == 0 {
                return sqlNull();
            }
            var total = sumReal + sumInt * 1.0;
            var avg = total / count;
            return sqlReal(avg, Fmt.Num(avg));
        }

        // MIN(column) - handles INTEGER and REAL
        if funcName == "MIN" {
            var hasMin = false;
            var minResult = sqlNull();
            var i = 0;
            while i < matchingRows.count() {
                var rowIdx = matchingRows.get(i);
                var maybeRow = table.getRow(rowIdx);
                if maybeRow != null {
                    var row = maybeRow;
                    if hasArg {
                        var argExpr = expr.args.get(0);
                        var val = evalExpr(argExpr, row, table);
                        if val.kind != SQL_NULL {
                            if hasMin == false {
                                minResult = val;
                                hasMin = true;
                            } else {
                                var cmp = val.compare(minResult);
                                if cmp < 0 {
                                    minResult = val;
                                }
                            }
                        }
                    }
                }
                i = i + 1;
            }
            if hasMin == false {
                return sqlNull();
            }
            return minResult;
        }

        // MAX(column) - handles INTEGER and REAL
        if funcName == "MAX" {
            var hasMax = false;
            var maxResult = sqlNull();
            var i = 0;
            while i < matchingRows.count() {
                var rowIdx = matchingRows.get(i);
                var maybeRow = table.getRow(rowIdx);
                if maybeRow != null {
                    var row = maybeRow;
                    if hasArg {
                        var argExpr = expr.args.get(0);
                        var val = evalExpr(argExpr, row, table);
                        if val.kind != SQL_NULL {
                            if hasMax == false {
                                maxResult = val;
                                hasMax = true;
                            } else {
                                var cmp = val.compare(maxResult);
                                if cmp > 0 {
                                    maxResult = val;
                                }
                            }
                        }
                    }
                }
                i = i + 1;
            }
            if hasMax == false {
                return sqlNull();
            }
            return maxResult;
        }

        return sqlNull();
    }

    //=========================================================================
    // STATEMENT EXECUTION
    //=========================================================================

    expose func executeCreateTable(stmt: CreateTableStmt) -> QueryResult {
        var result = new QueryResult();
        result.init();

        if db.findTable(stmt.tableName) != null {
            result.setError("Table '" + stmt.tableName + "' already exists");
            return result;
        }

        var table = new Table();
        table.initWithName(stmt.tableName);

        var i = 0;
        while i < stmt.columnCount() {
            var stmtCol = stmt.getColumn(i);
            table.addColumn(stmtCol);
            i = i + 1;
        }

        db.addTable(table);

        // Persist to storage engine if active
        if storageEngine != null {
            var se = storageEngine;
            se.persistTable(table);
            se.flush();
        }

        result.message = "Table '" + stmt.tableName + "' created";
        return result;
    }

    expose func executeInsert(stmt: InsertStmt) -> QueryResult {
        var result = new QueryResult();
        result.init();

        var table = db.findTable(stmt.tableName);
        if table == null {
            result.setError("Table '" + stmt.tableName + "' not found");
            return result;
        }

        var t = table;
        var hasColumnList = stmt.columnNames.count() > 0;
        var rowsInserted = 0;
        var r = 0;
        while r < stmt.rowCount() {
            var valueExprs = stmt.valueRows.get(r);
            var row = new Row();
            row.initWithCount(t.columnCount());

            var c = 0;
            while c < t.columnCount() {
                var col = t.getColumn(c);
                if col != null {
                    var column = col;

                    // Find the value index for this column
                    var valIdx = -1;
                    if hasColumnList {
                        // Map column name to value position
                        var ci = 0;
                        while ci < stmt.columnNames.count() {
                            if String.ToUpper(stmt.columnNames.get(ci)) == String.ToUpper(column.name) {
                                valIdx = ci;
                                break;
                            }
                            ci = ci + 1;
                        }
                    } else {
                        // No column list â€” positional mapping
                        if c < valueExprs.count() {
                            valIdx = c;
                        }
                    }

                    // Check for autoincrement
                    if column.autoIncrement {
                        if valIdx >= 0 {
                            var valExpr = valueExprs.get(valIdx);
                            if valExpr.kind == EXPR_LITERAL && valExpr.literalValue.kind == SQL_NULL {
                                var autoVal = sqlInteger(t.nextAutoIncrement());
                                row.setValue(c, autoVal);
                                c = c + 1;
                                continue;
                            }
                        } else {
                            // Column not in INSERT list â€” auto-generate
                            var autoVal = sqlInteger(t.nextAutoIncrement());
                            row.setValue(c, autoVal);
                            c = c + 1;
                            continue;
                        }
                    }

                    if valIdx >= 0 {
                        var valExpr = valueExprs.get(valIdx);
                        var val = evalExpr(valExpr, row, t);
                        row.setValue(c, val);
                    } else if column.hasDefault {
                        row.setValue(c, column.defaultValue);
                    } else {
                        row.setValue(c, sqlNull());
                    }
                }
                c = c + 1;
            }

            // Validate constraints before inserting
            var constraintError = validateConstraints(t, row, -1);
            if constraintError != "" {
                result.setError(constraintError);
                return result;
            }

            var newRowIdx = t.rowCount();
            t.addRow(row);

            // Update all indexes on this table
            updateIndexesAfterInsert(stmt.tableName, row, newRowIdx, t);

            // Persist row to storage engine and track location
            if storageEngine != null {
                var se = storageEngine;
                var insertOk = se.insertRowStorage(stmt.tableName, row);
                if insertOk {
                    se.trackRowLocation(stmt.tableName, se.lastInsertPageId, se.lastInsertSlotIdx);
                }
                se.updateAutoIncrement(stmt.tableName, t.autoIncrementValue);
            }

            rowsInserted = rowsInserted + 1;
            r = r + 1;
        }

        // Flush after all rows inserted
        if storageEngine != null && rowsInserted > 0 {
            var se = storageEngine;
            se.flush();
        }

        result.message = "Inserted " + Fmt.Int(rowsInserted) + " row(s)";
        result.rowsAffected = rowsInserted;
        return result;
    }

    // Validate constraints for a row (returns error message or empty string)
    hide func validateConstraints(table: Table, row: Row, excludeRowIdx: Integer) -> String {
        var c = 0;
        while c < table.columnCount() {
            var maybeCol = table.getColumn(c);
            if maybeCol != null {
                var col = maybeCol;
                var val = row.getValue(c);

                // Check NOT NULL constraint
                if col.notNull && val.kind == SQL_NULL {
                    return "NOT NULL constraint failed: " + col.name;
                }

                // Check PRIMARY KEY constraint (implies NOT NULL and UNIQUE)
                if col.primaryKey {
                    if val.kind == SQL_NULL {
                        return "PRIMARY KEY constraint failed: " + col.name + " cannot be NULL";
                    }
                    // Check uniqueness using nullSafeEquals
                    var i = 0;
                    while i < table.rowCount() {
                        if i != excludeRowIdx {
                            var maybeRow = table.getRow(i);
                            if maybeRow != null {
                                var existingRow = maybeRow;
                                if existingRow.deleted == false {
                                    var existingVal = existingRow.getValue(c);
                                    if val.nullSafeEquals(existingVal) {
                                        return "PRIMARY KEY constraint failed: duplicate value in " + col.name;
                                    }
                                }
                            }
                        }
                        i = i + 1;
                    }
                }

                // Check UNIQUE constraint
                if col.unique && val.kind != SQL_NULL {
                    var i = 0;
                    while i < table.rowCount() {
                        if i != excludeRowIdx {
                            var maybeRow = table.getRow(i);
                            if maybeRow != null {
                                var existingRow = maybeRow;
                                if existingRow.deleted == false {
                                    var existingVal = existingRow.getValue(c);
                                    if val.nullSafeEquals(existingVal) {
                                        return "UNIQUE constraint failed: duplicate value in " + col.name;
                                    }
                                }
                            }
                        }
                        i = i + 1;
                    }
                }

                // Check FOREIGN KEY constraint
                if col.isForeignKey {
                    if val.kind != SQL_NULL {
                        var refTable = db.findTable(col.refTableName);
                        if refTable == null {
                            return "FOREIGN KEY constraint failed: referenced table '" + col.refTableName + "' not found";
                        }
                        var rt = refTable;
                        var refColIdx = rt.findColumnIndex(col.refColumnName);
                        if refColIdx >= 0 {
                            var found = false;
                            var i = 0;
                            while i < rt.rowCount() {
                                var maybeRow = rt.getRow(i);
                                if maybeRow != null {
                                    var refRow = maybeRow;
                                    if refRow.deleted == false {
                                        var refVal = refRow.getValue(refColIdx);
                                        if val.nullSafeEquals(refVal) {
                                            found = true;
                                            i = rt.rowCount();  // break
                                        }
                                    }
                                }
                                i = i + 1;
                            }
                            if found == false {
                                return "FOREIGN KEY constraint failed: " + col.name + " references " + col.refTableName + "(" + col.refColumnName + ")";
                            }
                        }
                    }
                }
            }
            c = c + 1;
        }
        return "";
    }

    // Update all indexes for a table after inserting a row
    hide func updateIndexesAfterInsert(tableName: String, row: Row, rowIdx: Integer, table: Table) {
        var i = 0;
        while i < indexMgr.indexCount() {
            var idx = indexMgr.indexes.get(i);
            if idx.tableName == tableName {
                idx.addEntry(row, rowIdx, table);
            }
            i = i + 1;
        }
    }

    expose func executeSelect(stmt: SelectStmt) -> QueryResult {
        // Check for multi-table (JOIN) query
        if stmt.tableNames.count() > 1 {
            return executeCrossJoin(stmt);
        }

        var result = new QueryResult();
        result.init();

        var table = db.findTable(stmt.tableName);
        if table == null {
            result.setError("Table '" + stmt.tableName + "' not found");
            return result;
        }

        var t = table;
        currentTableAlias = stmt.tableAlias;

        // Build column names for result
        if stmt.selectAll {
            var c = 0;
            while c < t.columnCount() {
                var col = t.getColumn(c);
                if col != null {
                    var column = col;
                    result.addColumnName(column.name);
                }
                c = c + 1;
            }
        } else {
            var c = 0;
            while c < stmt.columns.count() {
                // Check for column alias first
                var alias = "";
                if c < stmt.columnAliases.count() {
                    alias = stmt.columnAliases.get(c);
                }
                if alias != "" {
                    result.addColumnName(alias);
                } else {
                    var colExpr = stmt.columns.get(c);
                    if colExpr.kind == EXPR_COLUMN {
                        result.addColumnName(colExpr.columnName);
                    } else if colExpr.kind == EXPR_FUNCTION {
                        var displayName = colExpr.funcName;
                        if displayName == "COUNT_DISTINCT" {
                            displayName = "COUNT";
                        }
                        result.addColumnName(displayName);
                    } else {
                        result.addColumnName("col" + Fmt.Int(c));
                    }
                }
                c = c + 1;
            }
        }

        // First pass: collect matching row indices
        // Try to use index lookup for simple equality conditions
        var matchingRows = new List[Integer]();
        var usedIndex = false;

        if stmt.whereClause != null && canUseIndex(stmt.whereClause, stmt.tableName) {
            var wc = stmt.whereClause;
            matchingRows = indexLookup(wc, stmt.tableName, t);
            usedIndex = true;
            // Filter out deleted rows from index results
            var filtered = new List[Integer]();
            var fi = 0;
            while fi < matchingRows.count() {
                var rowIdx = matchingRows.get(fi);
                var maybeRow = t.getRow(rowIdx);
                if maybeRow != null {
                    var row = maybeRow;
                    if row.deleted == false {
                        filtered.add(rowIdx);
                    }
                }
                fi = fi + 1;
            }
            matchingRows = filtered;
        }

        // Fall back to linear scan if no index was used
        if usedIndex == false {
            var r = 0;
            while r < t.rowCount() {
                var row = t.getRow(r);
                if row != null {
                    var rowData = row;
                    if rowData.deleted == false {
                        if evalCondition(stmt.whereClause, rowData, t) {
                            matchingRows.add(r);
                        }
                    }
                }
                r = r + 1;
            }
        }

        // Check if this is an aggregate query
        var isAggregate = hasAggregates(stmt);

        if isAggregate && stmt.groupByExprs.count() == 0 {
            // Aggregate query without GROUP BY: return single row
            var resultRow = new Row();
            resultRow.init();

            var c = 0;
            while c < stmt.columns.count() {
                var colExpr = stmt.columns.get(c);
                if isAggregateExpr(colExpr) {
                    var val = evalAggregate(colExpr, matchingRows, t);
                    resultRow.addValue(val);
                } else if colExpr.kind == EXPR_COLUMN {
                    // For non-aggregate columns, use first matching row value
                    if matchingRows.count() > 0 {
                        var firstRow = t.getRow(matchingRows.get(0));
                        if firstRow != null {
                            var fr = firstRow;
                            var val = evalExpr(colExpr, fr, t);
                            resultRow.addValue(val);
                        } else {
                            resultRow.addValue(sqlNull());
                        }
                    } else {
                        resultRow.addValue(sqlNull());
                    }
                } else {
                    resultRow.addValue(sqlNull());
                }
                c = c + 1;
            }
            result.addRow(resultRow);

        } else if stmt.groupByExprs.count() > 0 {
            // GROUP BY query
            executeGroupBy(stmt, matchingRows, t, result);

        } else {
            // Regular (non-aggregate) query
            var i = 0;
            while i < matchingRows.count() {
                var rowIdx = matchingRows.get(i);
                var row = t.getRow(rowIdx);
                if row != null {
                    var rowData = row;
                    var resultRow = new Row();
                    resultRow.init();

                    if stmt.selectAll {
                        var c = 0;
                        while c < rowData.columnCount() {
                            resultRow.addValue(cloneValue(rowData.getValue(c)));
                            c = c + 1;
                        }
                    } else {
                        var c = 0;
                        while c < stmt.columns.count() {
                            var colExpr = stmt.columns.get(c);
                            var val = evalExpr(colExpr, rowData, t);
                            resultRow.addValue(cloneValue(val));
                            c = c + 1;
                        }
                    }

                    result.addRow(resultRow);
                }
                i = i + 1;
            }
        }

        // Apply DISTINCT
        if stmt.isDistinct {
            applyDistinct(result);
        }

        // Apply ORDER BY
        if stmt.orderByExprs.count() > 0 {
            sortResults(result, stmt.orderByExprs, stmt.orderByDir, t);
        }

        // Apply LIMIT/OFFSET
        if stmt.limitValue >= 0 || stmt.offsetValue > 0 {
            applyLimitOffset(result, stmt.limitValue, stmt.offsetValue);
        }

        currentTableAlias = "";
        return result;
    }

    // Execute GROUP BY query
    expose func executeGroupBy(stmt: SelectStmt, matchingRows: List[Integer], table: Table, result: QueryResult) {
        // Build groups based on GROUP BY columns
        var groupKeys = new List[String]();
        var groupRowLists = new List[List[Integer]]();

        var i = 0;
        while i < matchingRows.count() {
            var rowIdx = matchingRows.get(i);
            var row = table.getRow(rowIdx);
            if row != null {
                var rowData = row;
                // Build group key from GROUP BY expressions
                var key = "";
                var g = 0;
                while g < stmt.groupByExprs.count() {
                    var groupExpr = stmt.groupByExprs.get(g);
                    var val = evalExpr(groupExpr, rowData, table);
                    if g > 0 {
                        key = key + "|";
                    }
                    key = key + val.toString();
                    g = g + 1;
                }

                // Find or create group
                var groupIdx = -1;
                var k = 0;
                while k < groupKeys.count() {
                    if groupKeys.get(k) == key {
                        groupIdx = k;
                        k = groupKeys.count();  // break
                    }
                    k = k + 1;
                }

                if groupIdx < 0 {
                    groupKeys.add(key);
                    var newList = new List[Integer]();
                    newList.add(rowIdx);
                    groupRowLists.add(newList);
                } else {
                    var existingList = groupRowLists.get(groupIdx);
                    existingList.add(rowIdx);
                }
            }
            i = i + 1;
        }

        // Build result rows from groups
        var g = 0;
        while g < groupKeys.count() {
            var groupRows = groupRowLists.get(g);
            var resultRow = new Row();
            resultRow.init();

            // Get first row in group for non-aggregate columns
            var firstRowIdx = groupRows.get(0);
            var firstRow = table.getRow(firstRowIdx);

            var c = 0;
            while c < stmt.columns.count() {
                var colExpr = stmt.columns.get(c);
                if isAggregateExpr(colExpr) {
                    var val = evalAggregate(colExpr, groupRows, table);
                    resultRow.addValue(val);
                } else if firstRow != null {
                    var fr = firstRow;
                    var val = evalExpr(colExpr, fr, table);
                    resultRow.addValue(val);
                } else {
                    resultRow.addValue(sqlNull());
                }
                c = c + 1;
            }

            // Check HAVING condition before adding row
            if stmt.havingClause != null {
                var hc = stmt.havingClause;
                if evalHavingExpr(hc, groupRows, table) == false {
                    g = g + 1;
                    continue;
                }
            }

            result.addRow(resultRow);
            g = g + 1;
        }
    }

    // Evaluate HAVING expression for a group
    expose func evalHavingExpr(expr: Expr, groupRows: List[Integer], table: Table) -> Boolean {
        // Handle binary expressions (comparisons and logical operators)
        if expr.kind == EXPR_BINARY {
            var left = expr.getLeft();
            var right = expr.getRight();
            var op = expr.op;

            // Handle logical operators
            if op == OP_AND {
                return evalHavingExpr(left, groupRows, table) && evalHavingExpr(right, groupRows, table);
            }
            if op == OP_OR {
                return evalHavingExpr(left, groupRows, table) || evalHavingExpr(right, groupRows, table);
            }

            // Evaluate left and right sides for comparison
            var leftVal = evalHavingValue(left, groupRows, table);
            var rightVal = evalHavingValue(right, groupRows, table);

            // Comparison operators (handle NULL: compare returns 2)
            var cmp = leftVal.compare(rightVal);
            if cmp == 2 { return false; }
            if op == OP_EQ { return cmp == 0; }
            if op == OP_NE { return cmp != 0; }
            if op == OP_LT { return cmp < 0; }
            if op == OP_LE { return cmp <= 0; }
            if op == OP_GT { return cmp > 0; }
            if op == OP_GE { return cmp >= 0; }
        }

        return false;
    }

    // Evaluate a value in HAVING context (handles aggregates)
    expose func evalHavingValue(expr: Expr, groupRows: List[Integer], table: Table) -> SqlValue {
        // If it's an aggregate function, evaluate it on the group
        if expr.kind == EXPR_FUNCTION {
            if isAggregateExpr(expr) {
                return evalAggregate(expr, groupRows, table);
            }
        }

        // If it's a literal, return its value
        if expr.kind == EXPR_LITERAL {
            return expr.literalValue;
        }

        // If it's a column ref, evaluate using first row in group
        if expr.kind == EXPR_COLUMN {
            if groupRows.count() > 0 {
                var firstRowIdx = groupRows.get(0);
                var maybeRow = table.getRow(firstRowIdx);
                if maybeRow != null {
                    var row = maybeRow;
                    return evalExpr(expr, row, table);
                }
            }
        }

        return sqlNull();
    }

    // Apply DISTINCT - remove duplicate rows
    expose func applyDistinct(result: QueryResult) {
        var seenKeys = new List[String]();
        var uniqueRows = new List[Row]();

        var i = 0;
        while i < result.rowCount() {
            var row = result.getRow(i);
            if row != null {
                var r = row;
                // Build key from all column values
                var key = "";
                var c = 0;
                while c < r.columnCount() {
                    if c > 0 {
                        key = key + "|";
                    }
                    key = key + r.getValue(c).toString();
                    c = c + 1;
                }

                // Check if already seen
                var found = false;
                var k = 0;
                while k < seenKeys.count() {
                    if seenKeys.get(k) == key {
                        found = true;
                        k = seenKeys.count();  // break
                    }
                    k = k + 1;
                }

                if found == false {
                    seenKeys.add(key);
                    uniqueRows.add(r);
                }
            }
            i = i + 1;
        }

        // Replace result rows with unique rows
        result.rows = uniqueRows;
    }

    expose func executeUpdate(stmt: UpdateStmt) -> QueryResult {
        var result = new QueryResult();
        result.init();

        var table = db.findTable(stmt.tableName);
        if table == null {
            result.setError("Table '" + stmt.tableName + "' not found");
            return result;
        }

        var t = table;
        var rowsUpdated = 0;
        var updatedIndices: List[Integer] = [];

        var r = 0;
        while r < t.rowCount() {
            var row = t.getRow(r);
            if row != null {
                var rowData = row;
                if rowData.deleted == false {
                    if evalCondition(stmt.whereClause, rowData, t) {
                        // Create a copy of the row with updated values
                        var updatedRow = new Row();
                        updatedRow.initWithCount(t.columnCount());
                        var c = 0;
                        while c < t.columnCount() {
                            updatedRow.setValue(c, rowData.getValue(c));
                            c = c + 1;
                        }

                        // Apply updates to the copy
                        var i = 0;
                        while i < stmt.setColumns.count() {
                            var colName = stmt.setColumns.get(i);
                            var valExpr = stmt.setValues.get(i);
                            var colIdx = t.findColumnIndex(colName);
                            if colIdx >= 0 {
                                var val = evalExpr(valExpr, rowData, t);
                                updatedRow.setValue(colIdx, val);
                            }
                            i = i + 1;
                        }

                        // Validate constraints (exclude current row index for uniqueness check)
                        var constraintError = validateConstraints(t, updatedRow, r);
                        if constraintError != "" {
                            result.setError(constraintError);
                            return result;
                        }

                        // Apply the updates to the actual row
                        i = 0;
                        while i < stmt.setColumns.count() {
                            var colName = stmt.setColumns.get(i);
                            var colIdx = t.findColumnIndex(colName);
                            if colIdx >= 0 {
                                rowData.setValue(colIdx, updatedRow.getValue(colIdx));
                            }
                            i = i + 1;
                        }
                        updatedIndices.add(r);
                        rowsUpdated = rowsUpdated + 1;
                    }
                }
            }
            r = r + 1;
        }

        // Persist updated rows â€” try incremental in-place updates first
        if storageEngine != null && rowsUpdated > 0 {
            var se = storageEngine;
            var needsRewrite = false;
            var ui = 0;
            while ui < updatedIndices.count() {
                var rowIdx = updatedIndices.get(ui);
                var loc = se.findRowLocation(stmt.tableName, rowIdx);
                var locPageId = loc.get(0);
                var locSlotIdx = loc.get(1);
                if locPageId != INVALID_PAGE_ID {
                    var updRow = t.getRow(rowIdx);
                    var ok = se.updateRowByLocation(stmt.tableName, locPageId, locSlotIdx, updRow);
                    if ok == false {
                        needsRewrite = true;
                    }
                } else {
                    needsRewrite = true;
                }
                ui = ui + 1;
            }
            // Fall back to full rewrite if any in-place update failed
            // rewriteTableRows() clears + rebuilds row tracking internally
            if needsRewrite {
                se.rewriteTableRows(stmt.tableName, t.rows);
            }
            se.flush();
        }

        result.message = "Updated " + Fmt.Int(rowsUpdated) + " row(s)";
        result.rowsAffected = rowsUpdated;
        return result;
    }

    expose func executeDelete(stmt: DeleteStmt) -> QueryResult {
        var result = new QueryResult();
        result.init();

        var table = db.findTable(stmt.tableName);
        if table == null {
            result.setError("Table '" + stmt.tableName + "' not found");
            return result;
        }

        var t = table;
        var rowsDeleted = 0;
        var deletedIndices: List[Integer] = [];

        var r = 0;
        while r < t.rowCount() {
            var row = t.getRow(r);
            if row != null {
                var rowData = row;
                if rowData.deleted == false {
                    if evalCondition(stmt.whereClause, rowData, t) {
                        rowData.deleted = true;
                        deletedIndices.add(r);
                        rowsDeleted = rowsDeleted + 1;
                    }
                }
            }
            r = r + 1;
        }

        // Compact rows list to remove soft-deleted entries
        if rowsDeleted > 0 {
            // Compact in-memory list first
            var compacted: List[Row] = [];
            var cr = 0;
            while cr < t.rowCount() {
                var checkRow = t.getRow(cr);
                if checkRow != null {
                    var checkData = checkRow;
                    if checkData.deleted == false {
                        compacted.add(checkData);
                    }
                }
                cr = cr + 1;
            }
            t.rows = compacted;

            // Persist via full table rewrite (rewriteTableRows clears + rebuilds tracking)
            if storageEngine != null {
                var se = storageEngine;
                se.rewriteTableRows(stmt.tableName, t.rows);
                se.flush();
            }
        }

        result.message = "Deleted " + Fmt.Int(rowsDeleted) + " row(s)";
        result.rowsAffected = rowsDeleted;
        return result;
    }

    //=========================================================================
    // HELPER METHODS
    //=========================================================================

    hide func sortResults(result: QueryResult, orderExprs: List[Expr], orderDir: List[Integer], table: Table) {
        // Simple bubble sort
        var n = result.rowCount();
        var i = 0;
        while i < n - 1 {
            var j = 0;
            while j < n - i - 1 {
                var row1 = result.getRow(j);
                var row2 = result.getRow(j + 1);
                if row1 != null && row2 != null {
                    var r1 = row1;
                    var r2 = row2;
                    var shouldSwap = false;

                    var e = 0;
                    while e < orderExprs.count() {
                        var orderExpr = orderExprs.get(e);
                        var isDesc = orderDir.get(e);
                        var val1 = evalExpr(orderExpr, r1, table);
                        var val2 = evalExpr(orderExpr, r2, table);
                        var cmp = val1.compare(val2);

                        // Handle NULL (cmp==2): NULLs sort last
                        if cmp == 2 {
                            if val1.kind == SQL_NULL && val2.kind != SQL_NULL {
                                shouldSwap = isDesc == 1;
                            } else if val1.kind != SQL_NULL && val2.kind == SQL_NULL {
                                shouldSwap = isDesc == 0;
                            }
                            break;
                        }
                        if cmp != 0 {
                            if isDesc == 1 {
                                shouldSwap = cmp < 0;
                            } else {
                                shouldSwap = cmp > 0;
                            }
                            break;
                        }
                        e = e + 1;
                    }

                    if shouldSwap {
                        result.swapRows(j, j + 1);
                    }
                }
                j = j + 1;
            }
            i = i + 1;
        }
    }

    hide func applyLimitOffset(result: QueryResult, limitVal: Integer, offsetVal: Integer) {
        var newRows: List[Row] = [];
        var i = offsetVal;
        var count = 0;
        while i < result.rowCount() {
            if limitVal >= 0 && count >= limitVal {
                break;
            }
            var row = result.getRow(i);
            if row != null {
                // Deep-clone row to avoid string retain issues when old list is freed
                var clonedRow = new Row();
                clonedRow.init();
                var vc = 0;
                while vc < row.columnCount() {
                    clonedRow.addValue(cloneValue(row.getValue(vc)));
                    vc = vc + 1;
                }
                newRows.add(clonedRow);
                count = count + 1;
            }
            i = i + 1;
        }
        result.rows = newRows;
    }

    //=========================================================================
    // SUBQUERY EXECUTION (avoids full executeSql recursion)
    //=========================================================================

    // Dedicated path for subquery execution that parses and runs a SELECT
    // without going through the full executeSql dispatch. This avoids
    // string lifetime corruption in native codegen during recursive calls.
    expose func executeSubquerySelect(sql: String) -> QueryResult {
        var parser = new Parser(sql);
        if parser.currentKind() == TK_SELECT {
            parser.advance();
            var stmt = parser.parseSelectStmt();
            if parser.hasError {
                var result = new QueryResult();
                result.init();
                result.setError(parser.error);
                return result;
            }
            return executeSelect(stmt);
        }
        var result = new QueryResult();
        result.init();
        result.setError("Subquery must be a SELECT statement");
        return result;
    }

    //=========================================================================
    // MAIN EXECUTION ENTRY POINT
    //=========================================================================

    expose func executeSql(sql: String) -> QueryResult {
        // Clear subquery cache for each new top-level SQL statement
        subqueryCacheKeys = [];
        subqueryCacheScalars = [];
        subqueryCacheLists = [];

        var parser = new Parser(sql);

        var kind = parser.currentKind();

        if kind == TK_CREATE {
            parser.advance();
            if parser.currentKind() == TK_TABLE {
                var stmt = parser.parseCreateTableStmt();
                if parser.hasError {
                    var result = new QueryResult();
                    result.init();
                    result.setError(parser.error);
                    return result;
                }
                return executeCreateTable(stmt);
            }
            if parser.currentKind() == TK_INDEX || parser.currentKind() == TK_UNIQUE {
                var stmt = parser.parseCreateIndexStmt();
                if parser.hasError {
                    var result = new QueryResult();
                    result.init();
                    result.setError(parser.error);
                    return result;
                }
                return executeCreateIndex(stmt);
            }
            // CREATE DATABASE [name] [FILE 'path']
            if parser.currentKind() == TK_DATABASE {
                parser.advance();
                if parser.currentKind() == TK_IDENTIFIER {
                    var dbName = parser.currentText();
                    parser.advance();
                    // Check for optional FILE 'path' clause
                    if parser.currentKind() == TK_FILE {
                        parser.advance();
                        if parser.currentKind() == TK_STRING {
                            var filePath = parser.currentText();
                            return executeCreateDatabaseWithFile(dbName, filePath);
                        }
                        var result = new QueryResult();
                        result.init();
                        result.setError("FILE requires a file path string");
                        return result;
                    }
                    return executeCreateDatabase(dbName);
                }
                var result = new QueryResult();
                result.init();
                result.setError("CREATE DATABASE requires a database name");
                return result;
            }
        }

        if kind == TK_INSERT {
            parser.advance();
            var stmt = parser.parseInsertStmt();
            if parser.hasError {
                var result = new QueryResult();
                result.init();
                result.setError(parser.error);
                return result;
            }
            return executeInsert(stmt);
        }

        if kind == TK_SELECT {
            parser.advance();
            var stmt = parser.parseSelectStmt();
            if parser.hasError {
                var result = new QueryResult();
                result.init();
                result.setError(parser.error);
                return result;
            }
            var firstResult = executeSelect(stmt);
            if firstResult.success == false {
                return firstResult;
            }

            // Check for UNION or UNION ALL
            if parser.currentKind() == TK_UNION {
                parser.advance();
                var unionAll = false;
                if parser.currentKind() == TK_ALL {
                    unionAll = true;
                    parser.advance();
                }
                if parser.currentKind() == TK_SELECT {
                    parser.advance();
                    var stmt2 = parser.parseSelectStmt();
                    if parser.hasError {
                        var result = new QueryResult();
                        result.init();
                        result.setError(parser.error);
                        return result;
                    }
                    var secondResult = executeSelect(stmt2);
                    if secondResult.success == false {
                        return secondResult;
                    }
                    return executeUnion(firstResult, secondResult, unionAll);
                }
            }

            // Check for EXCEPT
            if parser.currentKind() == TK_EXCEPT {
                parser.advance();
                if parser.currentKind() == TK_SELECT {
                    parser.advance();
                    var stmt2 = parser.parseSelectStmt();
                    if parser.hasError {
                        var result = new QueryResult();
                        result.init();
                        result.setError(parser.error);
                        return result;
                    }
                    var secondResult = executeSelect(stmt2);
                    if secondResult.success == false {
                        return secondResult;
                    }
                    return executeExcept(firstResult, secondResult);
                }
            }

            // Check for INTERSECT
            if parser.currentKind() == TK_INTERSECT {
                parser.advance();
                if parser.currentKind() == TK_SELECT {
                    parser.advance();
                    var stmt2 = parser.parseSelectStmt();
                    if parser.hasError {
                        var result = new QueryResult();
                        result.init();
                        result.setError(parser.error);
                        return result;
                    }
                    var secondResult = executeSelect(stmt2);
                    if secondResult.success == false {
                        return secondResult;
                    }
                    return executeIntersect(firstResult, secondResult);
                }
            }

            return firstResult;
        }

        if kind == TK_UPDATE {
            parser.advance();
            var stmt = parser.parseUpdateStmt();
            if parser.hasError {
                var result = new QueryResult();
                result.init();
                result.setError(parser.error);
                return result;
            }
            return executeUpdate(stmt);
        }

        if kind == TK_DELETE {
            parser.advance();
            var stmt = parser.parseDeleteStmt();
            if parser.hasError {
                var result = new QueryResult();
                result.init();
                result.setError(parser.error);
                return result;
            }
            return executeDelete(stmt);
        }

        if kind == TK_DROP {
            parser.advance();
            if parser.currentKind() == TK_TABLE {
                parser.advance();
                if parser.currentKind() == TK_IDENTIFIER {
                    var tableName = parser.currentText();
                    if db.dropTable(tableName) {
                        // Persist table drop to storage engine
                        if storageEngine != null {
                            var se = storageEngine;
                            se.dropTableStorage(tableName);
                            se.flush();
                        }
                        var result = new QueryResult();
                        result.init();
                        result.message = "Table '" + tableName + "' dropped";
                        return result;
                    } else {
                        var result = new QueryResult();
                        result.init();
                        result.setError("Table '" + tableName + "' not found");
                        return result;
                    }
                }
            }
            if parser.currentKind() == TK_INDEX {
                var stmt = parser.parseDropIndexStmt();
                if parser.hasError {
                    var result = new QueryResult();
                    result.init();
                    result.setError(parser.error);
                    return result;
                }
                return executeDropIndex(stmt);
            }
            // DROP DATABASE
            if parser.currentKind() == TK_DATABASE {
                parser.advance();
                if parser.currentKind() == TK_IDENTIFIER {
                    var dbName = parser.currentText();
                    return executeDropDatabase(dbName);
                }
                var result = new QueryResult();
                result.init();
                result.setError("DROP DATABASE requires a database name");
                return result;
            }
        }

        // USE command: USE database_name
        if kind == TK_USE {
            parser.advance();
            if parser.currentKind() == TK_IDENTIFIER || parser.currentKind() == TK_DATABASE {
                var dbName = parser.currentText();
                parser.advance();
                // Handle "USE DATABASE name" syntax
                if parser.currentKind() == TK_IDENTIFIER {
                    dbName = parser.currentText();
                }
                return executeUseDatabase(dbName);
            }
            var result = new QueryResult();
            result.init();
            result.setError("USE requires a database name: USE database_name");
            return result;
        }

        if kind == TK_SHOW {
            parser.advance();
            var result = new QueryResult();
            result.init();

            // SHOW DATABASES
            if parser.currentKind() == TK_DATABASES {
                result.addColumnName("database_name");
                var dbNames = server.listDatabases();
                var i = 0;
                while i < dbNames.count() {
                    var row = new Row();
                    row.init();
                    var dbName = dbNames.get(i);
                    // Mark current database with asterisk
                    if dbName == server.currentDbName {
                        row.addValue(sqlText(dbName + " *"));
                    } else {
                        row.addValue(sqlText(dbName));
                    }
                    result.addRow(row);
                    i = i + 1;
                }
                return result;
            }

            // SHOW TABLES (default)
            result.addColumnName("table_name");
            var i = 0;
            while i < db.tableCount() {
                var t = db.getTable(i);
                if t != null {
                    var table = t;
                    var row = new Row();
                    row.init();
                    row.addValue(sqlText(table.name));
                    result.addRow(row);
                }
                i = i + 1;
            }
            return result;
        }

        // SAVE command: SAVE 'filename' or SAVE TO 'filename'
        if kind == TK_SAVE {
            parser.advance();
            // Optional TO keyword
            if parser.currentKind() == TK_TO {
                parser.advance();
            }
            if parser.currentKind() == TK_STRING {
                var filename = parser.currentText();
                return executeSave(filename);
            }
            var result = new QueryResult();
            result.init();
            result.setError("SAVE requires a filename: SAVE 'filename'");
            return result;
        }

        // OPEN command: OPEN 'filename' or OPEN FROM 'filename'
        if kind == TK_OPEN {
            parser.advance();
            // Optional FROM keyword
            if parser.currentKind() == TK_FROM {
                parser.advance();
            }
            if parser.currentKind() == TK_STRING {
                var filename = parser.currentText();
                return executeOpen(filename);
            }
            var result = new QueryResult();
            result.init();
            result.setError("OPEN requires a filename: OPEN 'filename'");
            return result;
        }

        // CLOSE command: close persistent database
        if kind == TK_CLOSE {
            return executeClose();
        }

        // EXPORT command: EXPORT table TO 'filename'
        if kind == TK_EXPORT {
            parser.advance();
            if parser.currentKind() == TK_IDENTIFIER {
                var tableName = parser.currentText();
                parser.advance();
                if parser.currentKind() == TK_TO {
                    parser.advance();
                    if parser.currentKind() == TK_STRING {
                        var filename = parser.currentText();
                        return executeExport(tableName, filename);
                    }
                }
            }
            var result = new QueryResult();
            result.init();
            result.setError("EXPORT syntax: EXPORT tablename TO 'filename.csv'");
            return result;
        }

        // IMPORT command: IMPORT INTO table FROM 'filename'
        if kind == TK_IMPORT {
            parser.advance();
            if parser.currentKind() == TK_INTO {
                parser.advance();
            }
            if parser.currentKind() == TK_IDENTIFIER {
                var tableName = parser.currentText();
                parser.advance();
                if parser.currentKind() == TK_FROM {
                    parser.advance();
                    if parser.currentKind() == TK_STRING {
                        var filename = parser.currentText();
                        return executeImport(tableName, filename);
                    }
                }
            }
            var result = new QueryResult();
            result.init();
            result.setError("IMPORT syntax: IMPORT INTO tablename FROM 'filename.csv'");
            return result;
        }

        // VACUUM command
        if kind == TK_VACUUM {
            return executeVacuum();
        }

        // HELP command
        if kind == TK_HELP {
            return executeHelp();
        }

        // DESCRIBE command: DESCRIBE tablename
        if kind == TK_DESCRIBE {
            parser.advance();
            if parser.currentKind() == TK_IDENTIFIER {
                var tableName = parser.currentText();
                return executeDescribe(tableName);
            }
            var result = new QueryResult();
            result.init();
            result.setError("DESCRIBE requires a table name");
            return result;
        }

        // ALTER TABLE command
        if kind == TK_ALTER {
            parser.advance();
            if parser.currentKind() == TK_TABLE {
                parser.advance();
                if parser.currentKind() == TK_IDENTIFIER {
                    var tableName = parser.currentText();
                    parser.advance();
                    return executeAlterTable(parser, tableName);
                }
            }
            var result = new QueryResult();
            result.init();
            result.setError("ALTER TABLE syntax: ALTER TABLE tablename ADD/DROP/RENAME ...");
            return result;
        }

        // Transaction stubs
        if kind == TK_BEGIN {
            var result = new QueryResult();
            result.init();
            result.message = "BEGIN (transactions not yet supported - auto-commit mode)";
            return result;
        }
        if kind == TK_COMMIT {
            var result = new QueryResult();
            result.init();
            result.message = "COMMIT (transactions not yet supported - auto-commit mode)";
            return result;
        }
        if kind == TK_ROLLBACK {
            var result = new QueryResult();
            result.init();
            result.message = "ROLLBACK (transactions not yet supported - auto-commit mode)";
            return result;
        }

        var result = new QueryResult();
        result.init();
        result.setError("Unknown SQL statement");
        return result;
    }

    expose func executeCreateIndex(stmt: CreateIndexStmt) -> QueryResult {
        var result = new QueryResult();
        result.init();

        var table = db.findTable(stmt.tableName);
        if table == null {
            result.setError("Table '" + stmt.tableName + "' not found");
            return result;
        }

        var idx = new SqlIndex();
        idx.initWithNames(stmt.indexName, stmt.tableName);
        idx.isUnique = stmt.isUnique;

        var i = 0;
        while i < stmt.columnCount() {
            idx.addColumn(stmt.columnNames.get(i));
            i = i + 1;
        }

        var t = table;
        idx.rebuild(t);
        indexMgr.addIndex(idx);

        result.message = "Index '" + stmt.indexName + "' created";
        return result;
    }

    expose func executeDropIndex(stmt: DropIndexStmt) -> QueryResult {
        var result = new QueryResult();
        result.init();

        if indexMgr.dropIndex(stmt.indexName) {
            result.message = "Index '" + stmt.indexName + "' dropped";
        } else {
            result.setError("Index '" + stmt.indexName + "' not found");
        }

        return result;
    }

    //=========================================================================
    // MULTI-DATABASE OPERATIONS (Phase 1)
    //=========================================================================

    // CREATE DATABASE
    expose func executeCreateDatabase(dbName: String) -> QueryResult {
        var result = new QueryResult();
        result.init();

        if server.databaseExists(dbName) {
            result.setError("Database '" + dbName + "' already exists");
            return result;
        }

        if server.createDatabase(dbName) {
            result.message = "Database '" + dbName + "' created";
        } else {
            result.setError("Failed to create database '" + dbName + "'");
        }

        return result;
    }

    // CREATE DATABASE with persistent file
    expose func executeCreateDatabaseWithFile(dbName: String, filePath: String) -> QueryResult {
        var result = new QueryResult();
        result.init();

        if server.databaseExists(dbName) {
            result.setError("Database '" + dbName + "' already exists");
            return result;
        }

        if server.createDatabaseWithFile(dbName, filePath) {
            result.message = "Database '" + dbName + "' created with persistent storage at '" + filePath + "'";
        } else {
            result.setError("Failed to create persistent database '" + dbName + "'");
        }

        return result;
    }

    // DROP DATABASE
    expose func executeDropDatabase(dbName: String) -> QueryResult {
        var result = new QueryResult();
        result.init();

        if dbName == "main" {
            result.setError("Cannot drop the 'main' database");
            return result;
        }

        if dbName == server.currentDbName {
            result.setError("Cannot drop the current database. Use another database first.");
            return result;
        }

        if server.databaseExists(dbName) == false {
            result.setError("Database '" + dbName + "' does not exist");
            return result;
        }

        if server.dropDatabase(dbName) {
            result.message = "Database '" + dbName + "' dropped";
        } else {
            result.setError("Failed to drop database '" + dbName + "'");
        }

        return result;
    }

    // USE database
    expose func executeUseDatabase(dbName: String) -> QueryResult {
        var result = new QueryResult();
        result.init();

        if server.databaseExists(dbName) == false {
            result.setError("Database '" + dbName + "' does not exist");
            return result;
        }

        if server.useDatabase(dbName) {
            refreshCurrentDatabase();
            // Switch storage engine to match the new database
            storageEngine = server.currentStorageEngine();
            result.message = "Switched to database '" + dbName + "'";
        } else {
            result.setError("Failed to switch to database '" + dbName + "'");
        }

        return result;
    }

    //=========================================================================
    // JOIN OPERATIONS
    //=========================================================================

    // Create a row with a specific number of NULL values
    hide func makeJoinRow(numCols: Integer) -> Row {
        var row = new Row();
        row.init();
        var i = 0;
        while i < numCols {
            row.addValue(sqlNull());
            i = i + 1;
        }
        return row;
    }

    // Find column value in a combined row for JOIN queries
    hide func findJoinColumnValue(tableName: String, columnName: String,
                                   tables: List[Table], aliases: List[String],
                                   combinedRow: Row, colOffsets: List[Integer]) -> SqlValue {
        var ti = 0;
        while ti < tables.count() {
            var tbl = tables.get(ti);
            var alias = aliases.get(ti);

            // Check if this table matches the requested table name or alias
            if tableName == alias || tableName == tbl.name || tableName == "" {
                var colIdx = tbl.findColumnIndex(columnName);
                if colIdx >= 0 {
                    var offset = colOffsets.get(ti);
                    return combinedRow.getValue(offset + colIdx);
                }
            }
            ti = ti + 1;
        }
        return sqlNull();
    }

    // Evaluate expression in JOIN context
    hide func evalJoinExpr(expr: Expr, tables: List[Table], aliases: List[String],
                           combinedRow: Row, colOffsets: List[Integer]) -> SqlValue {
        if expr.kind == EXPR_LITERAL {
            return expr.literalValue;
        }

        if expr.kind == EXPR_COLUMN {
            return findJoinColumnValue(expr.tableName, expr.columnName,
                                       tables, aliases, combinedRow, colOffsets);
        }

        if expr.kind == EXPR_BINARY {
            var left = evalJoinExpr(expr.getLeft(), tables, aliases, combinedRow, colOffsets);
            var right = evalJoinExpr(expr.getRight(), tables, aliases, combinedRow, colOffsets);
            var op = expr.op;

            // Comparison operators (handle NULL: compare returns 2)
            if op == OP_EQ {
                var cmp = left.compare(right);
                if cmp == 2 { return sqlInteger(0); }
                if cmp == 0 { return sqlInteger(1); }
                return sqlInteger(0);
            }
            if op == OP_NE {
                var cmp = left.compare(right);
                if cmp == 2 { return sqlInteger(0); }
                if cmp != 0 { return sqlInteger(1); }
                return sqlInteger(0);
            }
            if op == OP_LT {
                var cmp = left.compare(right);
                if cmp == 2 { return sqlInteger(0); }
                if cmp < 0 { return sqlInteger(1); }
                return sqlInteger(0);
            }
            if op == OP_LE {
                var cmp = left.compare(right);
                if cmp == 2 { return sqlInteger(0); }
                if cmp <= 0 { return sqlInteger(1); }
                return sqlInteger(0);
            }
            if op == OP_GT {
                var cmp = left.compare(right);
                if cmp == 2 { return sqlInteger(0); }
                if cmp > 0 { return sqlInteger(1); }
                return sqlInteger(0);
            }
            if op == OP_GE {
                var cmp = left.compare(right);
                if cmp == 2 { return sqlInteger(0); }
                if cmp >= 0 { return sqlInteger(1); }
                return sqlInteger(0);
            }

            // Logical operators
            if op == OP_AND {
                if left.intValue != 0 && right.intValue != 0 { return sqlInteger(1); }
                return sqlInteger(0);
            }
            if op == OP_OR {
                if left.intValue != 0 || right.intValue != 0 { return sqlInteger(1); }
                return sqlInteger(0);
            }

            // Arithmetic operators
            if op == OP_ADD { return sqlInteger(left.intValue + right.intValue); }
            if op == OP_SUB { return sqlInteger(left.intValue - right.intValue); }
            if op == OP_MUL { return sqlInteger(left.intValue * right.intValue); }
            if op == OP_DIV {
                if right.intValue != 0 {
                    return sqlInteger(left.intValue / right.intValue);
                }
                return sqlNull();
            }
        }

        return sqlNull();
    }

    // Execute a multi-table JOIN query
    expose func executeCrossJoin(stmt: SelectStmt) -> QueryResult {
        var result = new QueryResult();
        result.init();

        // Load all tables
        var tables = new List[Table]();
        var aliases = new List[String]();
        var colOffsets = new List[Integer]();
        var totalCols = 0;

        var ti = 0;
        while ti < stmt.tableNames.count() {
            var tblName = stmt.tableNames.get(ti);
            var maybeTable = db.findTable(tblName);
            if maybeTable == null {
                result.setError("Table '" + tblName + "' does not exist");
                return result;
            }
            var tbl = maybeTable;
            tables.add(tbl);

            var alias = stmt.tableAliases.get(ti);
            if alias == "" {
                alias = tblName;
            }
            aliases.add(alias);

            colOffsets.add(totalCols);
            totalCols = totalCols + tbl.columnCount();
            ti = ti + 1;
        }

        // Build column names for result
        if stmt.selectAll {
            ti = 0;
            while ti < tables.count() {
                var tbl = tables.get(ti);
                var alias = aliases.get(ti);
                var c = 0;
                while c < tbl.columnCount() {
                    var maybeCol = tbl.getColumn(c);
                    if maybeCol != null {
                        var col = maybeCol;
                        result.addColumnName(alias + "." + col.name);
                    }
                    c = c + 1;
                }
                ti = ti + 1;
            }
        } else {
            var c = 0;
            while c < stmt.columns.count() {
                // Check for column alias first
                var alias = "";
                if c < stmt.columnAliases.count() {
                    alias = stmt.columnAliases.get(c);
                }
                if alias != "" {
                    result.addColumnName(alias);
                } else {
                    var colExpr = stmt.columns.get(c);
                    if colExpr.kind == EXPR_COLUMN {
                        if colExpr.tableName != "" {
                            result.addColumnName(colExpr.tableName + "." + colExpr.columnName);
                        } else {
                            result.addColumnName(colExpr.columnName);
                        }
                    } else if colExpr.kind == EXPR_FUNCTION {
                        var displayName = colExpr.funcName;
                        if displayName == "COUNT_DISTINCT" {
                            displayName = "COUNT";
                        }
                        result.addColumnName(displayName);
                    } else {
                        result.addColumnName("expr" + Fmt.Int(c));
                    }
                }
                c = c + 1;
            }
        }

        // Build cartesian product starting with first table
        var combinedRows = new List[Row]();

        if tables.count() > 0 {
            var firstTable = tables.get(0);
            var r = 0;
            while r < firstTable.rowCount() {
                var maybeRow = firstTable.getRow(r);
                if maybeRow != null {
                    var srcRow = maybeRow;
                    if srcRow.deleted == false {
                        var newRow = makeJoinRow(totalCols);
                        var c = 0;
                        while c < firstTable.columnCount() {
                            newRow.setValue(c, srcRow.getValue(c));
                            c = c + 1;
                        }
                        combinedRows.add(newRow);
                    }
                }
                r = r + 1;
            }
        }

        // Extend with each additional table
        ti = 1;
        while ti < tables.count() {
            var tbl = tables.get(ti);
            var offset = colOffsets.get(ti);
            var newCombined = new List[Row]();

            // Get join type (0=CROSS, 1=INNER, 2=LEFT, 3=RIGHT, 4=FULL)
            var joinType = 0;
            if ti - 1 < stmt.joinTypes.count() {
                joinType = stmt.joinTypes.get(ti - 1);
            }

            // Check if we have a join condition
            var hasJoinCond = ti - 1 < stmt.joinConditions.count();

            // For RIGHT/FULL JOIN: track matched right rows
            var rightMatched = new List[Integer]();
            if joinType == 3 || joinType == 4 {
                var rInit = 0;
                while rInit < tbl.rowCount() {
                    rightMatched.add(0);
                    rInit = rInit + 1;
                }
            }

            var ci = 0;
            while ci < combinedRows.count() {
                var existing = combinedRows.get(ci);
                var foundMatch = false;

                var r = 0;
                while r < tbl.rowCount() {
                    var maybeRow = tbl.getRow(r);
                    if maybeRow != null {
                        var srcRow = maybeRow;
                        if srcRow.deleted == false {
                            // Create combined row
                            var newRow = makeJoinRow(totalCols);
                            var c = 0;
                            while c < offset {
                                newRow.setValue(c, existing.getValue(c));
                                c = c + 1;
                            }
                            c = 0;
                            while c < tbl.columnCount() {
                                newRow.setValue(offset + c, srcRow.getValue(c));
                                c = c + 1;
                            }

                            // Check join condition for non-CROSS joins
                            var includeRow = true;
                            if hasJoinCond && (joinType == 1 || joinType == 2 || joinType == 3 || joinType == 4) {
                                var joinCond = stmt.joinConditions.get(ti - 1);
                                var joinResult = evalJoinExpr(joinCond, tables, aliases, newRow, colOffsets);
                                if joinResult.intValue == 0 {
                                    includeRow = false;
                                }
                            }

                            if includeRow {
                                newCombined.add(newRow);
                                foundMatch = true;
                                if joinType == 3 || joinType == 4 {
                                    rightMatched.set(r, 1);
                                }
                            }
                        }
                    }
                    r = r + 1;
                }

                // LEFT/FULL JOIN: add NULL row if no match
                if (joinType == 2 || joinType == 4) && foundMatch == false {
                    var nullRow = makeJoinRow(totalCols);
                    var c = 0;
                    while c < offset {
                        nullRow.setValue(c, existing.getValue(c));
                        c = c + 1;
                    }
                    newCombined.add(nullRow);
                }

                ci = ci + 1;
            }

            // RIGHT/FULL JOIN: add unmatched right rows
            if joinType == 3 || joinType == 4 {
                var rCheck = 0;
                while rCheck < tbl.rowCount() {
                    if rightMatched.get(rCheck) == 0 {
                        var maybeRightRow = tbl.getRow(rCheck);
                        if maybeRightRow != null {
                            var rightRow = maybeRightRow;
                            if rightRow.deleted == false {
                                var nullRow = makeJoinRow(totalCols);
                                var c = 0;
                                while c < tbl.columnCount() {
                                    nullRow.setValue(offset + c, rightRow.getValue(c));
                                    c = c + 1;
                                }
                                newCombined.add(nullRow);
                            }
                        }
                    }
                    rCheck = rCheck + 1;
                }
            }

            combinedRows = newCombined;
            ti = ti + 1;
        }

        // Apply WHERE clause
        var filteredRows = new List[Row]();
        var ri = 0;
        while ri < combinedRows.count() {
            var row = combinedRows.get(ri);
            var includeRow = true;

            if stmt.whereClause != null {
                var wc = stmt.whereClause;
                var whereResult = evalJoinExpr(wc, tables, aliases, row, colOffsets);
                if whereResult.intValue == 0 {
                    includeRow = false;
                }
            }

            if includeRow {
                filteredRows.add(row);
            }
            ri = ri + 1;
        }

        // Check for GROUP BY / aggregates on JOIN results
        var isAggregate = hasAggregates(stmt);

        if isAggregate || stmt.groupByExprs.count() > 0 {
            // GROUP BY on JOIN results
            executeJoinGroupBy(stmt, filteredRows, tables, aliases, colOffsets, totalCols, result);
        } else {
            // Build result rows (regular non-aggregate query)
            ri = 0;
            while ri < filteredRows.count() {
                var combinedRow = filteredRows.get(ri);
                var resultRow = new Row();
                resultRow.init();

                if stmt.selectAll {
                    var c = 0;
                    while c < totalCols {
                        resultRow.addValue(cloneValue(combinedRow.getValue(c)));
                        c = c + 1;
                    }
                } else {
                    var c = 0;
                    while c < stmt.columns.count() {
                        var colExpr = stmt.columns.get(c);
                        var val = evalJoinExpr(colExpr, tables, aliases, combinedRow, colOffsets);
                        resultRow.addValue(cloneValue(val));
                        c = c + 1;
                    }
                }

                result.addRow(resultRow);
                ri = ri + 1;
            }
        }

        // Apply DISTINCT
        if stmt.isDistinct {
            applyDistinct(result);
        }

        // Apply ORDER BY on JOIN results
        if stmt.orderByExprs.count() > 0 {
            sortJoinResults(result, stmt);
        }

        // Apply LIMIT/OFFSET
        if stmt.limitValue >= 0 || stmt.offsetValue > 0 {
            applyLimitOffset(result, stmt.limitValue, stmt.offsetValue);
        }

        return result;
    }

    // Execute GROUP BY on JOIN results
    hide func executeJoinGroupBy(stmt: SelectStmt, filteredRows: List[Row],
                                  tables: List[Table], aliases: List[String],
                                  colOffsets: List[Integer], totalCols: Integer,
                                  result: QueryResult) {
        var groupKeys = new List[String]();
        var groupRowLists = new List[List[Row]]();

        if stmt.groupByExprs.count() > 0 {
            var i = 0;
            while i < filteredRows.count() {
                var row = filteredRows.get(i);
                var key = "";
                var g = 0;
                while g < stmt.groupByExprs.count() {
                    var groupExpr = stmt.groupByExprs.get(g);
                    var val = evalJoinExpr(groupExpr, tables, aliases, row, colOffsets);
                    if g > 0 { key = key + "|"; }
                    key = key + val.toString();
                    g = g + 1;
                }

                var groupIdx = -1;
                var k = 0;
                while k < groupKeys.count() {
                    if groupKeys.get(k) == key {
                        groupIdx = k;
                        k = groupKeys.count();
                    }
                    k = k + 1;
                }

                if groupIdx < 0 {
                    groupKeys.add(key);
                    var newList = new List[Row]();
                    newList.add(row);
                    groupRowLists.add(newList);
                } else {
                    groupRowLists.get(groupIdx).add(row);
                }
                i = i + 1;
            }
        } else {
            // No GROUP BY but has aggregates â€” treat all rows as one group
            groupKeys.add("");
            groupRowLists.add(filteredRows);
        }

        // Build result rows from groups
        var g = 0;
        while g < groupKeys.count() {
            var groupRows = groupRowLists.get(g);
            var resultRow = new Row();
            resultRow.init();

            var firstRow = groupRows.get(0);

            var c = 0;
            while c < stmt.columns.count() {
                var colExpr = stmt.columns.get(c);
                if isAggregateExpr(colExpr) {
                    var val = evalJoinAggregate(colExpr, groupRows, tables, aliases, colOffsets);
                    resultRow.addValue(cloneValue(val));
                } else {
                    var val = evalJoinExpr(colExpr, tables, aliases, firstRow, colOffsets);
                    resultRow.addValue(cloneValue(val));
                }
                c = c + 1;
            }

            // Check HAVING condition
            if stmt.havingClause != null {
                var hc = stmt.havingClause;
                if evalJoinHaving(hc, groupRows, tables, aliases, colOffsets) == false {
                    g = g + 1;
                    continue;
                }
            }

            result.addRow(resultRow);
            g = g + 1;
        }
    }

    // Evaluate aggregate function over JOIN group rows
    hide func evalJoinAggregate(expr: Expr, groupRows: List[Row],
                                 tables: List[Table], aliases: List[String],
                                 colOffsets: List[Integer]) -> SqlValue {
        var funcName = String.ToUpper(expr.funcName);
        var hasArg = expr.args.count() > 0;

        // COUNT(*)
        if funcName == "COUNT" && hasArg {
            var arg0 = expr.args.get(0);
            if arg0.kind == EXPR_STAR {
                return sqlInteger(groupRows.count());
            }
        }

        // COUNT_DISTINCT
        if funcName == "COUNT_DISTINCT" && hasArg {
            var seen = new List[String]();
            var i = 0;
            while i < groupRows.count() {
                var row = groupRows.get(i);
                var val = evalJoinExpr(expr.args.get(0), tables, aliases, row, colOffsets);
                if val.kind != SQL_NULL {
                    var valStr = val.toString();
                    var found = false;
                    var k = 0;
                    while k < seen.count() {
                        if seen.get(k) == valStr { found = true; k = seen.count(); }
                        k = k + 1;
                    }
                    if found == false { seen.add(valStr); }
                }
                i = i + 1;
            }
            return sqlInteger(seen.count());
        }

        // COUNT(column)
        if funcName == "COUNT" {
            var count = 0;
            var i = 0;
            while i < groupRows.count() {
                var row = groupRows.get(i);
                if hasArg {
                    var val = evalJoinExpr(expr.args.get(0), tables, aliases, row, colOffsets);
                    if val.kind != SQL_NULL { count = count + 1; }
                }
                i = i + 1;
            }
            return sqlInteger(count);
        }

        // SUM
        if funcName == "SUM" {
            var sumInt = 0;
            var sumReal = 0.0;
            var hasValue = false;
            var hasReal = false;
            var i = 0;
            while i < groupRows.count() {
                var row = groupRows.get(i);
                if hasArg {
                    var val = evalJoinExpr(expr.args.get(0), tables, aliases, row, colOffsets);
                    if val.kind == SQL_INTEGER { sumInt = sumInt + val.intValue; hasValue = true; }
                    else if val.kind == SQL_REAL { sumReal = sumReal + val.realValue; hasValue = true; hasReal = true; }
                }
                i = i + 1;
            }
            if hasValue == false { return sqlNull(); }
            if hasReal {
                var total = sumReal + sumInt * 1.0;
                return sqlReal(total, Fmt.Num(total));
            }
            return sqlInteger(sumInt);
        }

        // AVG
        if funcName == "AVG" {
            var sumInt = 0;
            var sumReal = 0.0;
            var count = 0;
            var hasReal = false;
            var i = 0;
            while i < groupRows.count() {
                var row = groupRows.get(i);
                if hasArg {
                    var val = evalJoinExpr(expr.args.get(0), tables, aliases, row, colOffsets);
                    if val.kind == SQL_INTEGER { sumInt = sumInt + val.intValue; count = count + 1; }
                    else if val.kind == SQL_REAL { sumReal = sumReal + val.realValue; count = count + 1; hasReal = true; }
                }
                i = i + 1;
            }
            if count == 0 { return sqlNull(); }
            var total = sumReal + sumInt * 1.0;
            var avg = total / count;
            return sqlReal(avg, Fmt.Num(avg));
        }

        // MIN
        if funcName == "MIN" {
            var hasMin = false;
            var minResult = sqlNull();
            var i = 0;
            while i < groupRows.count() {
                var row = groupRows.get(i);
                if hasArg {
                    var val = evalJoinExpr(expr.args.get(0), tables, aliases, row, colOffsets);
                    if val.kind != SQL_NULL {
                        if hasMin == false { minResult = val; hasMin = true; }
                        else if val.compare(minResult) < 0 { minResult = val; }
                    }
                }
                i = i + 1;
            }
            return minResult;
        }

        // MAX
        if funcName == "MAX" {
            var hasMax = false;
            var maxResult = sqlNull();
            var i = 0;
            while i < groupRows.count() {
                var row = groupRows.get(i);
                if hasArg {
                    var val = evalJoinExpr(expr.args.get(0), tables, aliases, row, colOffsets);
                    if val.kind != SQL_NULL {
                        if hasMax == false { maxResult = val; hasMax = true; }
                        else if val.compare(maxResult) > 0 { maxResult = val; }
                    }
                }
                i = i + 1;
            }
            return maxResult;
        }

        return sqlNull();
    }

    // Evaluate HAVING expression for JOIN groups
    hide func evalJoinHaving(expr: Expr, groupRows: List[Row],
                              tables: List[Table], aliases: List[String],
                              colOffsets: List[Integer]) -> Boolean {
        if expr.kind == EXPR_BINARY {
            var left = expr.getLeft();
            var right = expr.getRight();
            var op = expr.op;

            if op == OP_AND {
                return evalJoinHaving(left, groupRows, tables, aliases, colOffsets) && evalJoinHaving(right, groupRows, tables, aliases, colOffsets);
            }
            if op == OP_OR {
                return evalJoinHaving(left, groupRows, tables, aliases, colOffsets) || evalJoinHaving(right, groupRows, tables, aliases, colOffsets);
            }

            var leftVal = evalJoinHavingValue(left, groupRows, tables, aliases, colOffsets);
            var rightVal = evalJoinHavingValue(right, groupRows, tables, aliases, colOffsets);

            var cmp = leftVal.compare(rightVal);
            if cmp == 2 { return false; }
            if op == OP_EQ { return cmp == 0; }
            if op == OP_NE { return cmp != 0; }
            if op == OP_LT { return cmp < 0; }
            if op == OP_LE { return cmp <= 0; }
            if op == OP_GT { return cmp > 0; }
            if op == OP_GE { return cmp >= 0; }
        }
        return false;
    }

    // Evaluate a value in JOIN HAVING context
    hide func evalJoinHavingValue(expr: Expr, groupRows: List[Row],
                                    tables: List[Table], aliases: List[String],
                                    colOffsets: List[Integer]) -> SqlValue {
        if expr.kind == EXPR_FUNCTION && isAggregateExpr(expr) {
            return evalJoinAggregate(expr, groupRows, tables, aliases, colOffsets);
        }
        if expr.kind == EXPR_LITERAL {
            return expr.literalValue;
        }
        if expr.kind == EXPR_COLUMN && groupRows.count() > 0 {
            var firstRow = groupRows.get(0);
            return evalJoinExpr(expr, tables, aliases, firstRow, colOffsets);
        }
        return sqlNull();
    }

    // Sort JOIN results using result column name resolution
    hide func sortJoinResults(result: QueryResult, stmt: SelectStmt) {
        var n = result.rowCount();
        var i = 0;
        while i < n - 1 {
            var j = 0;
            while j < n - i - 1 {
                var row1 = result.getRow(j);
                var row2 = result.getRow(j + 1);
                if row1 != null && row2 != null {
                    var r1 = row1;
                    var r2 = row2;
                    var shouldSwap = false;

                    var e = 0;
                    while e < stmt.orderByExprs.count() {
                        var orderExpr = stmt.orderByExprs.get(e);
                        var isDesc = stmt.orderByDir.get(e);

                        var colIdx = findResultColumnIndex(result, orderExpr);
                        if colIdx >= 0 {
                            var val1 = r1.getValue(colIdx);
                            var val2 = r2.getValue(colIdx);
                            var cmp = val1.compare(val2);

                            if cmp == 2 {
                                if val1.kind == SQL_NULL && val2.kind != SQL_NULL {
                                    shouldSwap = isDesc == 1;
                                } else if val1.kind != SQL_NULL && val2.kind == SQL_NULL {
                                    shouldSwap = isDesc == 0;
                                }
                                break;
                            }
                            if cmp != 0 {
                                if isDesc == 1 { shouldSwap = cmp < 0; }
                                else { shouldSwap = cmp > 0; }
                                break;
                            }
                        }
                        e = e + 1;
                    }

                    if shouldSwap {
                        result.swapRows(j, j + 1);
                    }
                }
                j = j + 1;
            }
            i = i + 1;
        }
    }

    // Find column index in result for ORDER BY expression
    hide func findResultColumnIndex(result: QueryResult, expr: Expr) -> Integer {
        if expr.kind == EXPR_COLUMN {
            var searchName = expr.columnName;
            var searchTable = expr.tableName;

            var i = 0;
            while i < result.columnNames.count() {
                var colName = result.columnNames.get(i);

                // Try qualified match (e.g., "o.amount")
                if searchTable != "" {
                    if colName == searchTable + "." + searchName {
                        return i;
                    }
                }

                // Try exact name match
                if colName == searchName {
                    return i;
                }

                // Try suffix match (e.g., column named "orders.amount" matches "amount")
                var suffix = "." + searchName;
                var suffixLen = String.Length(suffix);
                var colLen = String.Length(colName);
                if colLen > suffixLen {
                    if String.Substring(colName, colLen - suffixLen, suffixLen) == suffix {
                        return i;
                    }
                }
                i = i + 1;
            }
        }
        if expr.kind == EXPR_FUNCTION {
            var funcName = expr.funcName;
            var i = 0;
            while i < result.columnNames.count() {
                if result.columnNames.get(i) == funcName {
                    return i;
                }
                i = i + 1;
            }
        }
        return -1;
    }

    //=========================================================================
    // STORAGE & PERSISTENCE (Phase 10)
    //=========================================================================

    // SAVE command - save database to file as SQL dump
    expose func executeSave(filename: String) -> QueryResult {
        var result = new QueryResult();
        result.init();

        var content = "";

        // Generate CREATE TABLE statements
        var ti = 0;
        while ti < db.tableCount() {
            var maybeTable = db.getTable(ti);
            if maybeTable != null {
                var table = maybeTable;
                content = content + generateCreateTable(table) + "\n\n";

                // Clone table name to prevent string corruption during serialization
                var tblName = String.Substring(table.name, 0, String.Length(table.name));

                // Generate INSERT statements for each row
                var ri = 0;
                while ri < table.rowCount() {
                    var maybeRow = table.getRow(ri);
                    if maybeRow != null {
                        var row = maybeRow;
                        if row.deleted == false {
                            content = content + generateInsert(tblName, row) + "\n";
                        }
                    }
                    ri = ri + 1;
                }
                if table.rowCount() > 0 {
                    content = content + "\n";
                }
            }
            ti = ti + 1;
        }

        // Generate CREATE INDEX statements
        var ii = 0;
        while ii < indexMgr.indexCount() {
            var maybeIdx = indexMgr.getIndex(ii);
            if maybeIdx != null {
                var idx = maybeIdx;
                content = content + generateCreateIndex(idx) + "\n";
            }
            ii = ii + 1;
        }

        // Write to file
        IO.File.WriteAllText(filename, content);

        // Verify the file was actually written
        if IO.File.Exists(filename) == false {
            result.setError("Failed to save database to '" + filename + "': file could not be written");
            return result;
        }

        result.message = "Database saved to '" + filename + "'";
        return result;
    }

    // Generate CREATE TABLE statement for a table
    hide func generateCreateTable(table: Table) -> String {
        var sql = "CREATE TABLE " + table.name + " (\n";
        var ci = 0;
        while ci < table.columnCount() {
            var maybeCol = table.getColumn(ci);
            if maybeCol != null {
                var col = maybeCol;
                if ci > 0 {
                    sql = sql + ",\n";
                }
                sql = sql + "  " + col.name + " " + col.typeName();
                if col.primaryKey {
                    sql = sql + " PRIMARY KEY";
                }
                if col.autoIncrement {
                    sql = sql + " AUTOINCREMENT";
                }
                if col.notNull {
                    sql = sql + " NOT NULL";
                }
                if col.unique {
                    sql = sql + " UNIQUE";
                }
                if col.hasDefault {
                    sql = sql + " DEFAULT " + col.defaultValue.toSqlString();
                }
                if col.isForeignKey {
                    sql = sql + " REFERENCES " + col.refTableName + "(" + col.refColumnName + ")";
                }
            }
            ci = ci + 1;
        }
        sql = sql + "\n);";
        return sql;
    }

    // Generate INSERT statement for a row
    hide func generateInsert(tableName: String, row: Row) -> String {
        var sql = "INSERT INTO " + tableName + " VALUES (";
        var ci = 0;
        while ci < row.columnCount() {
            if ci > 0 {
                sql = sql + ", ";
            }
            var val = cloneValue(row.getValue(ci));
            sql = sql + val.toSqlString();
            ci = ci + 1;
        }
        sql = sql + ");";
        return sql;
    }

    // Generate CREATE INDEX statement
    hide func generateCreateIndex(idx: SqlIndex) -> String {
        var sql = "CREATE ";
        if idx.isUnique {
            sql = sql + "UNIQUE ";
        }
        sql = sql + "INDEX " + idx.name + " ON " + idx.tableName + " (";
        var ci = 0;
        while ci < idx.columnCount() {
            if ci > 0 {
                sql = sql + ", ";
            }
            sql = sql + idx.getColumnName(ci);
            ci = ci + 1;
        }
        sql = sql + ");";
        return sql;
    }

    // OPEN command - load database from SQL dump file or persistent .vdb file
    expose func executeOpen(filename: String) -> QueryResult {
        var result = new QueryResult();
        result.init();

        // Detect persistent binary database by .vdb extension
        if String.EndsWith(filename, ".vdb") {
            return executeOpenPersistent(filename);
        }

        // SQL dump mode (existing behavior)
        if IO.File.Exists(filename) == false {
            result.setError("File not found: " + filename);
            return result;
        }

        var content = IO.File.ReadAllText(filename);
        if content == "" {
            result.setError("Failed to read file or file is empty: " + filename);
            return result;
        }

        // Split content into statements by semicolon
        var statements = splitStatements(content);
        var executed = 0;
        var errors = 0;

        var i = 0;
        while i < statements.count() {
            var stmt = String.Trim(statements.get(i));
            if stmt != "" {
                var stmtResult = executeSql(stmt);
                if stmtResult.success {
                    executed = executed + 1;
                } else {
                    errors = errors + 1;
                }
            }
            i = i + 1;
        }

        result.message = "Loaded '" + filename + "': " + Fmt.Int(executed) + " statements executed";
        if errors > 0 {
            result.message = result.message + ", " + Fmt.Int(errors) + " errors";
        }
        return result;
    }

    // Open a persistent binary database (.vdb file)
    hide func executeOpenPersistent(filename: String) -> QueryResult {
        var result = new QueryResult();
        result.init();

        // Close any existing storage engine
        if storageEngine != null {
            var oldSe = storageEngine;
            oldSe.closeDatabase();
            storageEngine = null;
        }

        var se = new StorageEngine();
        se.init();

        var isNew = IO.File.Exists(filename) == false;
        var ok = false;
        if isNew {
            ok = se.createDatabase(filename);
        } else {
            ok = se.openDatabase(filename);
        }

        if ok == false {
            result.setError("Failed to open database: " + filename);
            return result;
        }

        // Auto-enable WAL for new databases
        if isNew {
            var walDir = filename + ".wal";
            se.enableWal(walDir);
        }
        // Note: for existing databases, WAL is auto-enabled in openDatabase() if WAL dir exists

        storageEngine = se;

        if isNew == false {
            // Load all tables from persistent storage into in-memory model
            var tables = se.loadAllTables();
            var i = 0;
            while i < tables.count() {
                db.addTable(tables.get(i));
                i = i + 1;
            }
            result.message = "Opened persistent database '" + filename + "': " + Fmt.Int(tables.count()) + " table(s) loaded";
        } else {
            result.message = "Created persistent database '" + filename + "'";
        }

        return result;
    }

    // CLOSE command - flush and close persistent storage
    expose func executeClose() -> QueryResult {
        var result = new QueryResult();
        result.init();

        if storageEngine == null {
            result.message = "No persistent database open";
            return result;
        }

        var se = storageEngine;
        se.closeDatabase();
        storageEngine = null;
        result.message = "Database closed";
        return result;
    }

    // Split SQL content into individual statements
    hide func splitStatements(content: String) -> List[String] {
        var statements: List[String] = [];
        var current = "";
        var inString = false;
        var stringChar = "";

        var i = 0;
        var len = String.Length(content);
        while i < len {
            var ch = String.Substring(content, i, 1);

            if inString {
                current = current + ch;
                if ch == stringChar {
                    inString = false;
                }
            } else {
                if ch == "'" || ch == "\"" {
                    inString = true;
                    stringChar = ch;
                    current = current + ch;
                } else if ch == ";" {
                    statements.add(current);
                    current = "";
                } else {
                    current = current + ch;
                }
            }
            i = i + 1;
        }

        // Add any remaining content
        if String.Trim(current) != "" {
            statements.add(current);
        }

        return statements;
    }

    // EXPORT command - export table to CSV
    expose func executeExport(tableName: String, filename: String) -> QueryResult {
        var result = new QueryResult();
        result.init();

        var maybeTable = db.findTable(tableName);
        if maybeTable == null {
            result.setError("Table '" + tableName + "' not found");
            return result;
        }
        var table = maybeTable;

        var csv = "";

        // Header row
        var ci = 0;
        while ci < table.columnCount() {
            var maybeCol = table.getColumn(ci);
            if maybeCol != null {
                var col = maybeCol;
                if ci > 0 {
                    csv = csv + ",";
                }
                csv = csv + escapeCSV(col.name);
            }
            ci = ci + 1;
        }
        csv = csv + "\n";

        // Data rows
        var ri = 0;
        while ri < table.rowCount() {
            var maybeRow = table.getRow(ri);
            if maybeRow != null {
                var row = maybeRow;
                if row.deleted == false {
                    ci = 0;
                    while ci < row.columnCount() {
                        if ci > 0 {
                            csv = csv + ",";
                        }
                        var val = row.getValue(ci);
                        if val.isNull() {
                            csv = csv + "";
                        } else {
                            csv = csv + escapeCSV(val.toString());
                        }
                        ci = ci + 1;
                    }
                    csv = csv + "\n";
                }
            }
            ri = ri + 1;
        }

        IO.File.WriteAllText(filename, csv);

        var rowCount = 0;
        ri = 0;
        while ri < table.rowCount() {
            var maybeRow = table.getRow(ri);
            if maybeRow != null {
                var row = maybeRow;
                if row.deleted == false {
                    rowCount = rowCount + 1;
                }
            }
            ri = ri + 1;
        }
        result.message = "Exported " + Fmt.Int(rowCount) + " rows to '" + filename + "'";

        return result;
    }

    // Escape a value for CSV output
    hide func escapeCSV(value: String) -> String {
        var needsQuotes = false;
        var i = 0;
        var len = String.Length(value);
        while i < len {
            var ch = String.Substring(value, i, 1);
            if ch == "," || ch == "\"" || ch == "\n" || ch == "\r" {
                needsQuotes = true;
                break;
            }
            i = i + 1;
        }

        if needsQuotes {
            // Escape quotes by doubling them
            var escaped = "";
            i = 0;
            while i < len {
                var ch = String.Substring(value, i, 1);
                if ch == "\"" {
                    escaped = escaped + "\"\"";
                } else {
                    escaped = escaped + ch;
                }
                i = i + 1;
            }
            return "\"" + escaped + "\"";
        }
        return value;
    }

    // IMPORT command - import CSV data into table
    expose func executeImport(tableName: String, filename: String) -> QueryResult {
        var result = new QueryResult();
        result.init();

        var maybeTable = db.findTable(tableName);
        if maybeTable == null {
            result.setError("Table '" + tableName + "' not found");
            return result;
        }
        var table = maybeTable;

        if IO.File.Exists(filename) == false {
            result.setError("File not found: " + filename);
            return result;
        }

        var content = IO.File.ReadAllText(filename);
        if content == "" {
            result.setError("Failed to read file or file is empty: " + filename);
            return result;
        }

        var lines = splitLines(content);
        if lines.count() < 2 {
            result.setError("CSV file must have at least a header row and one data row");
            return result;
        }

        // Parse header to get column mapping
        var headerFields = parseCSVLine(lines.get(0));
        var colIndices: List[Integer] = [];
        var fi = 0;
        while fi < headerFields.count() {
            var fieldName = String.Trim(headerFields.get(fi));
            var colIdx = table.findColumnIndex(fieldName);
            colIndices.add(colIdx);
            fi = fi + 1;
        }

        // Import data rows
        var imported = 0;
        var li = 1;
        while li < lines.count() {
            var line = String.Trim(lines.get(li));
            if line != "" {
                var fields = parseCSVLine(line);
                var values: List[SqlValue] = [];

                // Build row with correct column order
                var ci = 0;
                while ci < table.columnCount() {
                    var val = sqlNull();

                    // Find if this column has data in the CSV
                    var csvIdx = -1;
                    var fi2 = 0;
                    while fi2 < colIndices.count() {
                        if colIndices.get(fi2) == ci {
                            csvIdx = fi2;
                            break;
                        }
                        fi2 = fi2 + 1;
                    }

                    if csvIdx >= 0 && csvIdx < fields.count() {
                        var fieldVal = fields.get(csvIdx);
                        val = parseCSVValue(fieldVal, table, ci);
                    }
                    values.add(val);
                    ci = ci + 1;
                }

                if table.insertRow(values) {
                    imported = imported + 1;
                }
            }
            li = li + 1;
        }

        result.message = "Imported " + Fmt.Int(imported) + " rows from '" + filename + "'";
        return result;
    }

    // Split content into lines
    hide func splitLines(content: String) -> List[String] {
        var lines: List[String] = [];
        var current = "";
        var i = 0;
        var len = String.Length(content);
        while i < len {
            var ch = String.Substring(content, i, 1);
            if ch == "\n" {
                lines.add(current);
                current = "";
            } else if ch != "\r" {
                current = current + ch;
            }
            i = i + 1;
        }
        if current != "" {
            lines.add(current);
        }
        return lines;
    }

    // Parse a CSV line into fields
    hide func parseCSVLine(line: String) -> List[String] {
        var fields: List[String] = [];
        var current = "";
        var inQuotes = false;
        var i = 0;
        var len = String.Length(line);

        while i < len {
            var ch = String.Substring(line, i, 1);

            if inQuotes {
                if ch == "\"" {
                    // Check for escaped quote
                    if i + 1 < len && String.Substring(line, i + 1, 1) == "\"" {
                        current = current + "\"";
                        i = i + 1;
                    } else {
                        inQuotes = false;
                    }
                } else {
                    current = current + ch;
                }
            } else {
                if ch == "\"" {
                    inQuotes = true;
                } else if ch == "," {
                    fields.add(current);
                    current = "";
                } else {
                    current = current + ch;
                }
            }
            i = i + 1;
        }
        fields.add(current);
        return fields;
    }

    // Parse a CSV value according to column type
    hide func parseCSVValue(value: String, table: Table, colIdx: Integer) -> SqlValue {
        var trimmed = String.Trim(value);
        if trimmed == "" {
            return sqlNull();
        }

        var maybeCol = table.getColumn(colIdx);
        if maybeCol == null {
            return sqlText(trimmed);
        }
        var col = maybeCol;

        if col.typeCode == SQL_INTEGER {
            return sqlInteger(stringToInt(trimmed));
        }
        if col.typeCode == SQL_REAL {
            return sqlReal(stringToNumber(trimmed), trimmed);
        }
        return sqlText(trimmed);
    }

    // VACUUM command - remove deleted rows and reclaim space
    expose func executeVacuum() -> QueryResult {
        var result = new QueryResult();
        result.init();

        var totalRemoved = 0;

        var ti = 0;
        while ti < db.tableCount() {
            var maybeTable = db.getTable(ti);
            if maybeTable != null {
                var table = maybeTable;
                var newRows: List[Row] = [];
                var removed = 0;

                var ri = 0;
                while ri < table.rowCount() {
                    var maybeRow = table.getRow(ri);
                    if maybeRow != null {
                        var row = maybeRow;
                        if row.deleted {
                            removed = removed + 1;
                        } else {
                            newRows.add(row);
                        }
                    }
                    ri = ri + 1;
                }

                table.rows = newRows;
                totalRemoved = totalRemoved + removed;
            }
            ti = ti + 1;
        }

        result.message = "VACUUM complete: removed " + Fmt.Int(totalRemoved) + " deleted rows";
        return result;
    }

    // HELP command
    expose func executeHelp() -> QueryResult {
        var result = new QueryResult();
        result.init();
        result.addColumnName("command");
        result.addColumnName("description");

        var commands: List[List[String]] = [];

        var row1 = new Row();
        row1.init();
        row1.addValue(sqlText("CREATE TABLE name (...)"));
        row1.addValue(sqlText("Create a new table"));
        result.addRow(row1);

        var row2 = new Row();
        row2.init();
        row2.addValue(sqlText("DROP TABLE name"));
        row2.addValue(sqlText("Delete a table"));
        result.addRow(row2);

        var row3 = new Row();
        row3.init();
        row3.addValue(sqlText("INSERT INTO table VALUES (...)"));
        row3.addValue(sqlText("Insert a row"));
        result.addRow(row3);

        var row4 = new Row();
        row4.init();
        row4.addValue(sqlText("SELECT ... FROM table WHERE ..."));
        row4.addValue(sqlText("Query data"));
        result.addRow(row4);

        var row5 = new Row();
        row5.init();
        row5.addValue(sqlText("UPDATE table SET col=val WHERE ..."));
        row5.addValue(sqlText("Update rows"));
        result.addRow(row5);

        var row6 = new Row();
        row6.init();
        row6.addValue(sqlText("DELETE FROM table WHERE ..."));
        row6.addValue(sqlText("Delete rows"));
        result.addRow(row6);

        var row7 = new Row();
        row7.init();
        row7.addValue(sqlText("SAVE 'filename'"));
        row7.addValue(sqlText("Save database to file"));
        result.addRow(row7);

        var row8 = new Row();
        row8.init();
        row8.addValue(sqlText("OPEN 'filename'"));
        row8.addValue(sqlText("Load database from file (.sql or .vdb)"));
        result.addRow(row8);

        var row8b = new Row();
        row8b.init();
        row8b.addValue(sqlText("CLOSE"));
        row8b.addValue(sqlText("Close persistent database (.vdb)"));
        result.addRow(row8b);

        var row9 = new Row();
        row9.init();
        row9.addValue(sqlText("EXPORT table TO 'file.csv'"));
        row9.addValue(sqlText("Export table to CSV"));
        result.addRow(row9);

        var row10 = new Row();
        row10.init();
        row10.addValue(sqlText("IMPORT INTO table FROM 'file.csv'"));
        row10.addValue(sqlText("Import CSV into table"));
        result.addRow(row10);

        var row11 = new Row();
        row11.init();
        row11.addValue(sqlText("SHOW TABLES"));
        row11.addValue(sqlText("List all tables"));
        result.addRow(row11);

        var row12 = new Row();
        row12.init();
        row12.addValue(sqlText("DESCRIBE table"));
        row12.addValue(sqlText("Show table schema"));
        result.addRow(row12);

        var row13 = new Row();
        row13.init();
        row13.addValue(sqlText("VACUUM"));
        row13.addValue(sqlText("Remove deleted rows"));
        result.addRow(row13);

        return result;
    }

    // DESCRIBE command - show table schema
    expose func executeDescribe(tableName: String) -> QueryResult {
        var result = new QueryResult();
        result.init();

        var maybeTable = db.findTable(tableName);
        if maybeTable == null {
            result.setError("Table '" + tableName + "' not found");
            return result;
        }
        var table = maybeTable;

        result.addColumnName("column");
        result.addColumnName("type");
        result.addColumnName("constraints");

        var ci = 0;
        while ci < table.columnCount() {
            var maybeCol = table.getColumn(ci);
            if maybeCol != null {
                var col = maybeCol;
                var row = new Row();
                row.init();
                row.addValue(sqlText(col.name));
                row.addValue(sqlText(col.typeName()));

                var constraints = "";
                if col.primaryKey {
                    constraints = "PRIMARY KEY";
                }
                if col.autoIncrement {
                    if constraints != "" { constraints = constraints + " "; }
                    constraints = constraints + "AUTOINCREMENT";
                }
                if col.notNull {
                    if constraints != "" { constraints = constraints + " "; }
                    constraints = constraints + "NOT NULL";
                }
                if col.unique {
                    if constraints != "" { constraints = constraints + " "; }
                    constraints = constraints + "UNIQUE";
                }
                if col.hasDefault {
                    if constraints != "" { constraints = constraints + " "; }
                    constraints = constraints + "DEFAULT " + col.defaultValue.toString();
                }
                if col.isForeignKey {
                    if constraints != "" { constraints = constraints + " "; }
                    constraints = constraints + "REFERENCES " + col.refTableName + "(" + col.refColumnName + ")";
                }
                row.addValue(sqlText(constraints));
                result.addRow(row);
            }
            ci = ci + 1;
        }

        return result;
    }

    // ALTER TABLE command
    expose func executeAlterTable(parser: Parser, tableName: String) -> QueryResult {
        var result = new QueryResult();
        result.init();

        var maybeTable = db.findTable(tableName);
        if maybeTable == null {
            result.setError("Table '" + tableName + "' not found");
            return result;
        }
        var table = maybeTable;

        var kind = parser.currentKind();

        // ALTER TABLE ... ADD COLUMN
        if kind == TK_ADD {
            parser.advance();
            if parser.currentKind() == TK_COLUMN {
                parser.advance();
            }
            if parser.currentKind() == TK_IDENTIFIER {
                var colName = parser.currentText();
                parser.advance();
                var typeCode = SQL_TEXT;
                if parser.currentKind() == TK_INT || parser.currentKind() == TK_INTEGER_TYPE {
                    typeCode = SQL_INTEGER;
                    parser.advance();
                } else if parser.currentKind() == TK_REAL {
                    typeCode = SQL_REAL;
                    parser.advance();
                } else if parser.currentKind() == TK_TEXT || parser.currentKind() == TK_VARCHAR {
                    typeCode = SQL_TEXT;
                    parser.advance();
                } else if parser.currentKind() == TK_BLOB {
                    typeCode = SQL_BLOB;
                    parser.advance();
                }

                var col = makeColumn(colName, typeCode);
                table.addColumn(col);

                // Add NULL value to all existing rows
                var ri = 0;
                while ri < table.rowCount() {
                    var maybeRow = table.getRow(ri);
                    if maybeRow != null {
                        var row = maybeRow;
                        row.addValue(sqlNull());
                    }
                    ri = ri + 1;
                }

                result.message = "Column '" + colName + "' added to table '" + tableName + "'";
                return result;
            }
        }

        // ALTER TABLE ... DROP COLUMN
        if kind == TK_DROP {
            parser.advance();
            if parser.currentKind() == TK_COLUMN {
                parser.advance();
            }
            if parser.currentKind() == TK_IDENTIFIER {
                var colName = parser.currentText();
                var colIdx = table.findColumnIndex(colName);
                if colIdx < 0 {
                    result.setError("Column '" + colName + "' not found in table '" + tableName + "'");
                    return result;
                }

                // Remove column from schema
                var newColumns: List[Column] = [];
                var ci = 0;
                while ci < table.columnCount() {
                    if ci != colIdx {
                        var maybeCol = table.getColumn(ci);
                        if maybeCol != null {
                            newColumns.add(maybeCol);
                        }
                    }
                    ci = ci + 1;
                }
                table.columns = newColumns;

                // Remove column value from all rows
                var ri = 0;
                while ri < table.rowCount() {
                    var maybeRow = table.getRow(ri);
                    if maybeRow != null {
                        var row = maybeRow;
                        var newValues: List[SqlValue] = [];
                        var vi = 0;
                        while vi < row.columnCount() {
                            if vi != colIdx {
                                newValues.add(row.getValue(vi));
                            }
                            vi = vi + 1;
                        }
                        row.values = newValues;
                    }
                    ri = ri + 1;
                }

                result.message = "Column '" + colName + "' dropped from table '" + tableName + "'";
                return result;
            }
        }

        // ALTER TABLE ... RENAME TO
        if kind == TK_RENAME {
            parser.advance();
            if parser.currentKind() == TK_TO {
                parser.advance();
                if parser.currentKind() == TK_IDENTIFIER {
                    var newName = parser.currentText();
                    var oldName = table.name;
                    table.name = newName;
                    result.message = "Table '" + oldName + "' renamed to '" + newName + "'";
                    return result;
                }
            }
            // RENAME COLUMN
            if parser.currentKind() == TK_COLUMN {
                parser.advance();
                if parser.currentKind() == TK_IDENTIFIER {
                    var oldColName = parser.currentText();
                    parser.advance();
                    if parser.currentKind() == TK_TO {
                        parser.advance();
                        if parser.currentKind() == TK_IDENTIFIER {
                            var newColName = parser.currentText();
                            var colIdx = table.findColumnIndex(oldColName);
                            if colIdx < 0 {
                                result.setError("Column '" + oldColName + "' not found");
                                return result;
                            }
                            var maybeCol = table.getColumn(colIdx);
                            if maybeCol != null {
                                var col = maybeCol;
                                col.name = newColName;
                                result.message = "Column '" + oldColName + "' renamed to '" + newColName + "'";
                                return result;
                            }
                        }
                    }
                }
            }
        }

        result.setError("Unsupported ALTER TABLE syntax");
        return result;
    }

    //=========================================================================
    // UNION OPERATION (Phase 11)
    //=========================================================================

    // Execute UNION or UNION ALL
    expose func executeUnion(first: QueryResult, second: QueryResult, unionAll: Boolean) -> QueryResult {
        var result = new QueryResult();
        result.init();

        // Copy column names from first result
        var ci = 0;
        while ci < first.columnNames.count() {
            result.addColumnName(first.columnNames.get(ci));
            ci = ci + 1;
        }

        // Add all rows from first result
        var ri = 0;
        while ri < first.rowCount() {
            var row = first.getRow(ri);
            if row != null {
                result.addRow(row);
            }
            ri = ri + 1;
        }

        // Add rows from second result
        ri = 0;
        while ri < second.rowCount() {
            var row = second.getRow(ri);
            if row != null {
                var r = row;
                if unionAll {
                    // UNION ALL: add all rows including duplicates
                    result.addRow(r);
                } else {
                    // UNION: only add if not duplicate
                    if isDuplicateRow(result, r) == false {
                        result.addRow(r);
                    }
                }
            }
            ri = ri + 1;
        }

        return result;
    }

    // Check if a row is a duplicate of any existing row in result
    hide func isDuplicateRow(result: QueryResult, row: Row) -> Boolean {
        var ri = 0;
        while ri < result.rowCount() {
            var existingRow = result.getRow(ri);
            if existingRow != null {
                var er = existingRow;
                if rowsEqual(er, row) {
                    return true;
                }
            }
            ri = ri + 1;
        }
        return false;
    }

    // Check if two rows are equal
    hide func rowsEqual(row1: Row, row2: Row) -> Boolean {
        if row1.columnCount() != row2.columnCount() {
            return false;
        }
        var ci = 0;
        while ci < row1.columnCount() {
            var v1 = row1.getValue(ci);
            var v2 = row2.getValue(ci);
            if v1.compare(v2) != 0 {
                return false;
            }
            ci = ci + 1;
        }
        return true;
    }

    //=========================================================================
    // EXCEPT OPERATION (Phase 8)
    //=========================================================================

    // Execute EXCEPT - returns rows in first that are not in second
    expose func executeExcept(first: QueryResult, second: QueryResult) -> QueryResult {
        var result = new QueryResult();
        result.init();

        // Copy column names from first result
        var ci = 0;
        while ci < first.columnNames.count() {
            result.addColumnName(first.columnNames.get(ci));
            ci = ci + 1;
        }

        // Add rows from first that are not in second
        var ri = 0;
        while ri < first.rowCount() {
            var row = first.getRow(ri);
            if row != null {
                var r = row;
                // Check if this row exists in second result
                if isRowInResult(second, r) == false {
                    // Only add if not already in result (avoid duplicates)
                    if isDuplicateRow(result, r) == false {
                        result.addRow(r);
                    }
                }
            }
            ri = ri + 1;
        }

        return result;
    }

    //=========================================================================
    // INTERSECT OPERATION (Phase 8)
    //=========================================================================

    // Execute INTERSECT - returns rows that exist in both results
    expose func executeIntersect(first: QueryResult, second: QueryResult) -> QueryResult {
        var result = new QueryResult();
        result.init();

        // Copy column names from first result
        var ci = 0;
        while ci < first.columnNames.count() {
            result.addColumnName(first.columnNames.get(ci));
            ci = ci + 1;
        }

        // Add rows from first that also exist in second
        var ri = 0;
        while ri < first.rowCount() {
            var row = first.getRow(ri);
            if row != null {
                var r = row;
                // Check if this row exists in second result
                if isRowInResult(second, r) {
                    // Only add if not already in result (avoid duplicates)
                    if isDuplicateRow(result, r) == false {
                        result.addRow(r);
                    }
                }
            }
            ri = ri + 1;
        }

        return result;
    }

    // Check if a row exists in a result set
    hide func isRowInResult(result: QueryResult, row: Row) -> Boolean {
        var ri = 0;
        while ri < result.rowCount() {
            var existingRow = result.getRow(ri);
            if existingRow != null {
                var er = existingRow;
                if rowsEqual(er, row) {
                    return true;
                }
            }
            ri = ri + 1;
        }
        return false;
    }
}
