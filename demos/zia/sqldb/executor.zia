// executor.zia — SQL Executor (Core)
// Part of ViperSQL
//
// The Executor is the central query processing engine. It owns per-session
// state and coordinates statement execution through delegated handlers:
//   - DdlHandler (ddl.zia): CREATE/DROP/ALTER TABLE, INDEX, VIEW, DATABASE, USER
//   - DmlHandler (dml.zia): INSERT, UPDATE, DELETE with constraints and cascades
//   - QueryHandler (query.zia): SELECT, GROUP BY, sorting, subqueries, CTEs
//
// This file retains:
//   - Executor entity fields and initialization
//   - Expression evaluation (evalExpr, evalCondition, evalColumn, etc.)
//   - Index-based lookups (canUseIndex, indexLookup, indexRangeLookup)
//   - SQL dispatch (executeSqlDispatch → delegates to handlers)
//   - Transaction management (BEGIN/COMMIT/ROLLBACK, journal)
//   - Concurrency control (shared/exclusive locking)
//
// Each client connection gets its own Executor instance sharing the
// thread-safe DatabaseServer and StorageEngine. Per-connection state
// (transaction journal, subquery context, temp tables) is isolated.

module executor;

bind String = Viper.String;
bind Fmt = Viper.Fmt;
bind IO = Viper.IO;
bind Viper.Math;
bind DateTime = Viper.Time.DateTime;

bind "./types";
bind "./schema";
bind "./table";
bind "./index";
bind "./expr";
bind "./stmt";
bind "./parser";
bind "./database";
bind "./result";
bind "./server";
bind "./storage/page";
bind "./storage/serializer";
bind "./storage/pager";
bind "./storage/buffer";
bind "./storage/schema_page";
bind "./storage/data_page";
bind "./storage/engine";
bind "./storage/btree";
bind "./storage/btree_node";
bind "./setops";
bind "./join";
bind "./persistence";
bind "./csv";
bind "./optimizer/optimizer";
bind "./storage/txn";
bind "./sql_functions";
bind "./sql_window";
bind "./system_views";
bind "./ddl";
bind "./dml";
bind "./query";

//=============================================================================
// TRANSACTION JOURNAL
//=============================================================================

// Journal entry types
final JOURNAL_INSERT = 1;   // Row inserted — undo: remove it
final JOURNAL_DELETE = 2;   // Row soft-deleted — undo: undelete it
final JOURNAL_UPDATE = 3;   // Row updated — undo: restore old values

entity JournalEntry {
    expose Integer entryType;
    expose String tableName;
    expose Integer rowIndex;     // Row index at time of operation
    expose Row beforeImage;      // Old row data (for UPDATE/DELETE undo)

    expose func init() {
        entryType = 0;
        tableName = "";
        rowIndex = -1;
    }

    expose func initInsert(tbl: String, idx: Integer) {
        entryType = JOURNAL_INSERT;
        tableName = tbl;
        rowIndex = idx;
    }

    expose func initDelete(tbl: String, idx: Integer, oldRow: Row) {
        entryType = JOURNAL_DELETE;
        tableName = tbl;
        rowIndex = idx;
        beforeImage = oldRow;
    }

    expose func initUpdate(tbl: String, idx: Integer, oldRow: Row) {
        entryType = JOURNAL_UPDATE;
        tableName = tbl;
        rowIndex = idx;
        beforeImage = oldRow;
    }
}

//=============================================================================
// EXECUTOR ENTITY
//=============================================================================

entity Executor {
    // Multi-database server (Phase 1)
    expose DatabaseServer server;

    // These point to server's current database/index manager
    // Using non-optional because server always has a current database
    expose Database db;
    expose IndexManager indexMgr;

    // Helper modules (initialized in init())
    expose JoinEngine joinEngine;
    expose PersistenceManager persistence;
    expose CsvHandler csvHandler;

    // Query optimizer (cost-based access path selection)
    expose QueryOptimizer optimizer;

    // Delegated statement handlers (see ddl.zia, dml.zia, query.zia)
    expose DdlHandler ddlHandler;
    expose DmlHandler dmlHandler;
    expose QueryHandler queryHandler;

    // Persistent storage engine (null when using in-memory mode)
    expose StorageEngine? storageEngine;

    // Transaction state
    expose Boolean inTransaction;
    expose List[JournalEntry] journal;
    expose List[String] txnDirtyTables;  // Tables modified during transaction

    // Context for correlated subqueries
    expose Row? outerRow;
    expose Table? outerTable;
    expose String outerTableAlias;
    expose String currentTableAlias;
    expose Integer subqueryDepth;

    // Per-executor current database context (for multi-user: each executor tracks its own)
    expose String currentDbName;
    expose Integer currentDbIndex;

    // Concurrency control: session ID and shared lock manager
    // In standalone mode (init()), sessionId=0 and tableLockMgr=null (no locking).
    // In multi-user mode (initWithServer()), uses shared lock manager from server.
    expose Integer sessionId;
    expose TableLockManager? tableLockMgr;

    // Current authenticated user (Phase 13: privilege checking)
    // Defaults to "admin" for backward compatibility in standalone mode.
    expose String currentUser;

    // Per-session temporary tables (CREATE TEMP TABLE goes here)
    expose Database? tempDb;

    // Random seed for RANDOM() function
    expose Integer randomSeed;

    // Subquery result cache to avoid re-executing the same subquery per row
    // This prevents native codegen string corruption from repeated recursive calls
    // Stores cloned scalar values (for scalar subqueries) and value lists (for IN subqueries)
    hide List[String] subqueryCacheKeys;
    hide List[SqlValue] subqueryCacheScalars;
    hide List[List[SqlValue]] subqueryCacheLists;

    // B-tree index tracking for persistent databases (Phase 10)
    // Parallel lists mapping index names to B-tree instances
    expose List[BTree] btrees;
    expose List[String] btreeIndexNames;

    expose func init() {
        server = new DatabaseServer();
        server.init();
        // Initialize db and indexMgr - server always has 'main' database after init
        // Direct assignment from server lists (guaranteed non-null after server.init())
        db = server.dbList.get(0);
        indexMgr = server.indexManagers.get(0);
        storageEngine = null;
        currentDbName = "main";
        currentDbIndex = 0;
        sessionId = 0;
        tableLockMgr = null;
        currentUser = "admin";
        inTransaction = false;
        journal = [];
        txnDirtyTables = [];
        outerRow = null;
        outerTable = null;
        outerTableAlias = "";
        currentTableAlias = "";
        subqueryDepth = 0;
        randomSeed = 42;
        var td = new Database();
        td.initWithName("tempdb");
        tempDb = td;
        subqueryCacheKeys = [];
        subqueryCacheScalars = [];
        subqueryCacheLists = [];
        btrees = [];
        btreeIndexNames = [];
        joinEngine = new JoinEngine(self);
        persistence = new PersistenceManager(self);
        csvHandler = new CsvHandler(self);
        optimizer = new QueryOptimizer();
        optimizer.init();
        ddlHandler = new DdlHandler(self);
        dmlHandler = new DmlHandler(self);
        queryHandler = new QueryHandler(self);
    }

    // Initialize with a shared DatabaseServer (for multi-user: multiple executors share one server)
    // sessId is the unique session identifier used for table-level lock ownership.
    expose func initWithServer(existingServer: DatabaseServer, sessId: Integer) {
        server = existingServer;
        // Start on the 'main' database (index 0)
        db = server.dbList.get(0);
        indexMgr = server.indexManagers.get(0);
        storageEngine = server.getStorageEngine("main");
        currentDbName = "main";
        currentDbIndex = 0;
        sessionId = sessId;
        tableLockMgr = server.tableLockMgr;
        currentUser = "admin";
        inTransaction = false;
        journal = [];
        txnDirtyTables = [];
        outerRow = null;
        outerTable = null;
        outerTableAlias = "";
        currentTableAlias = "";
        subqueryDepth = 0;
        randomSeed = 42;
        var td = new Database();
        td.initWithName("tempdb");
        tempDb = td;
        subqueryCacheKeys = [];
        subqueryCacheScalars = [];
        subqueryCacheLists = [];
        btrees = [];
        btreeIndexNames = [];
        joinEngine = new JoinEngine(self);
        persistence = new PersistenceManager(self);
        csvHandler = new CsvHandler(self);
        optimizer = new QueryOptimizer();
        optimizer.init();
        ddlHandler = new DdlHandler(self);
        dmlHandler = new DmlHandler(self);
        queryHandler = new QueryHandler(self);
    }

    // Set the current user for privilege checking (called after authentication)
    expose func setCurrentUser(user: String) {
        currentUser = user;
    }

    // Check if current user is a superuser (admin bypasses all privilege checks)
    expose func isSuperuser() -> Boolean {
        return currentUser == "admin";
    }

    // Refresh db and indexMgr references from per-executor current database
    expose func refreshCurrentDatabase() {
        db = server.dbList.get(currentDbIndex);
        indexMgr = server.indexManagers.get(currentDbIndex);
    }

    // Look up a table by name, checking temp tables first, then current database.
    // This ensures temp tables shadow regular tables with the same name.
    expose func findTable(tableName: String) -> Table? {
        if tempDb != null {
            var tdb = tempDb;
            var tempTable = tdb.findTable(tableName);
            if tempTable != null {
                return tempTable;
            }
        }
        return db.findTable(tableName);
    }

    // Check if a table is a temp table
    expose func isTempTable(tableName: String) -> Boolean {
        if tempDb != null {
            var tdb = tempDb;
            return tdb.findTable(tableName) != null;
        }
        return false;
    }

    // Clean up all temp tables (called on session disconnect)
    expose func cleanupTempTables() {
        var td = new Database();
        td.initWithName("tempdb");
        tempDb = td;
    }

    // Check if currently in a transaction block (for PG wire protocol status)
    expose func isInTransaction() -> Boolean {
        return inTransaction;
    }

    //=========================================================================
    // EXPRESSION EVALUATION
    //=========================================================================

    expose func evalExpr(expr: Expr, row: Row, table: Table) -> SqlValue {
        if expr.kind == EXPR_LITERAL {
            return expr.literalValue;
        }
        if expr.kind == EXPR_COLUMN {
            return evalColumn(expr, row, table);
        }
        if expr.kind == EXPR_BINARY {
            return evalBinary(expr, row, table);
        }
        if expr.kind == EXPR_UNARY {
            return evalUnary(expr, row, table);
        }
        if expr.kind == EXPR_FUNCTION {
            return evalFunction(expr, row, table);
        }
        if expr.kind == EXPR_SUBQUERY {
            return evalSubquery(expr, row, table);
        }
        if expr.kind == EXPR_EXISTS {
            return evalExists(expr, row, table);
        }
        if expr.kind == EXPR_CASE {
            return evalCase(expr, row, table);
        }
        return sqlNull();
    }

    // Evaluate a CASE expression
    expose func evalCase(expr: Expr, row: Row, table: Table) -> SqlValue {
        // Evaluate each WHEN condition until one is true
        var i = 0;
        while i < expr.caseConditions.count() {
            var condition = expr.caseConditions.get(i);
            var condResult = evalExpr(condition, row, table);

            // Condition is true if non-zero integer or non-empty string
            var isTrue = false;
            if condResult.kind == SQL_INTEGER && condResult.intValue != 0 {
                isTrue = true;
            } else if condResult.kind == SQL_TEXT && condResult.textValue != "" {
                isTrue = true;
            }

            if isTrue {
                // Return the corresponding THEN result
                var result = expr.caseResults.get(i);
                return evalExpr(result, row, table);
            }
            i = i + 1;
        }

        // No condition matched - return ELSE value or NULL
        if expr.caseElse != null {
            var elseExpr = expr.caseElse;
            return evalExpr(elseExpr, row, table);
        }
        return sqlNull();
    }

    // Evaluate EXISTS (SELECT ...) — returns 1 if subquery has rows, 0 otherwise
    hide func evalExists(expr: Expr, outerRowContext: Row, outerTableContext: Table) -> SqlValue {
        // Save outer context for correlated subqueries
        var savedOuterRow = outerRow;
        var savedOuterTable = outerTable;
        var savedOuterAlias = outerTableAlias;
        var savedCurrentAlias = currentTableAlias;

        outerRow = outerRowContext;
        outerTable = outerTableContext;
        // Use table alias if set, otherwise fall back to table name
        if currentTableAlias != "" {
            outerTableAlias = currentTableAlias;
        } else {
            outerTableAlias = outerTableContext.name;
        }

        var sql = flattenSubqueries(expr.subquerySQL);

        subqueryDepth = subqueryDepth + 1;
        var subResult = queryHandler.executeSubquerySelect(sql);
        subqueryDepth = subqueryDepth - 1;

        // Restore context
        outerRow = savedOuterRow;
        outerTable = savedOuterTable;
        outerTableAlias = savedOuterAlias;
        currentTableAlias = savedCurrentAlias;

        if subResult.success && subResult.rowCount() > 0 {
            return sqlInteger(1);
        }
        return sqlInteger(0);
    }

    // Flatten nested subqueries in a SQL string by pre-evaluating inner
    // (SELECT ...) expressions and substituting their results as literals.
    // This avoids deep recursion through executeSelect which causes
    // stack overflow in native codegen.
    expose func flattenSubqueries(sql: String) -> String {
        // Look for "( SELECT" or "(SELECT" pattern (parser adds space after paren)
        var result = sql;
        var maxPasses = 4;
        var pass = 0;
        while pass < maxPasses {
            // Find the LAST occurrence of a subquery pattern to flatten innermost first
            var idx = -1;
            var searchPos = 0;
            var len = String.Length(result);
            while searchPos < len - 9 {
                var ch = String.Substring(result, searchPos, 1);
                if ch == "(" {
                    // Check if followed by SELECT (with optional space)
                    var remaining = len - searchPos - 1;
                    if remaining >= 7 {
                        var after = String.Substring(result, searchPos + 1, 7);
                        var upperAfter = String.ToUpper(after);
                        if upperAfter == "SELECT " || upperAfter == " SELECT" {
                            idx = searchPos;
                        }
                    }
                }
                searchPos = searchPos + 1;
            }

            if idx < 0 {
                return result;
            }

            // Found inner subquery at idx. Extract it.
            // Find matching closing paren
            var depth = 1;
            var pos = idx + 1;
            while pos < len && depth > 0 {
                var ch = String.Substring(result, pos, 1);
                if ch == "(" {
                    depth = depth + 1;
                } else if ch == ")" {
                    depth = depth - 1;
                }
                if depth > 0 {
                    pos = pos + 1;
                }
            }
            if depth != 0 {
                return result;
            }

            // Extract the inner SQL (without outer parens)
            var innerSql = String.Substring(result, idx + 1, pos - idx - 1);

            // Execute the inner subquery
            var savedOuterRow2 = outerRow;
            var savedOuterTable2 = outerTable;
            var savedOuterAlias2 = outerTableAlias;
            var savedCurrentAlias2 = currentTableAlias;

            var innerResult = queryHandler.executeSubquerySelect(innerSql);

            outerRow = savedOuterRow2;
            outerTable = savedOuterTable2;
            outerTableAlias = savedOuterAlias2;
            currentTableAlias = savedCurrentAlias2;

            // Get scalar result
            var replacement = "NULL";
            if innerResult.success && innerResult.rowCount() > 0 {
                var firstRow = innerResult.getRow(0);
                if firstRow != null {
                    var fr = firstRow;
                    if fr.columnCount() > 0 {
                        var val = fr.getValue(0);
                        if val.kind == SQL_INTEGER {
                            replacement = Fmt.Int(val.intValue);
                        } else if val.kind == SQL_REAL {
                            replacement = val.textValue;
                        } else if val.kind == SQL_TEXT {
                            replacement = "'" + val.textValue + "'";
                        }
                    }
                }
            }

            // Substitute: before + replacement + after
            var before = String.Substring(result, 0, idx);
            var after = String.Substring(result, pos + 1, len - pos - 1);
            result = before + replacement + after;

            pass = pass + 1;
        }
        return result;
    }

    // Evaluate a scalar subquery (with caching for non-correlated subqueries)
    expose func evalSubquery(expr: Expr, outerRowContext: Row, outerTableContext: Table) -> SqlValue {
        // Guard against very deep nesting to prevent stack overflow
        if subqueryDepth >= 8 {
            return sqlNull();
        }

        // Check scalar subquery cache first (avoids repeated recursive calls
        // that cause string corruption in native codegen)
        var cacheKey = expr.subquerySQL;
        var ci = 0;
        while ci < subqueryCacheKeys.count() {
            if subqueryCacheKeys.get(ci) == cacheKey {
                return subqueryCacheScalars.get(ci);
            }
            ci = ci + 1;
        }

        // Set outer context for correlated subqueries
        var savedOuterRow = outerRow;
        var savedOuterTable = outerTable;
        var savedOuterAlias = outerTableAlias;
        var savedCurrentAlias = currentTableAlias;

        outerRow = outerRowContext;
        outerTable = outerTableContext;
        outerTableAlias = currentTableAlias;

        // Clone and flatten nested subqueries to avoid deep recursion stack overflow
        var sql = String.Substring(expr.subquerySQL, 0, String.Length(expr.subquerySQL));
        sql = flattenSubqueries(sql);

        // Execute the subquery via dedicated path to avoid full executeSql recursion
        subqueryDepth = subqueryDepth + 1;
        var result = queryHandler.executeSubquerySelect(sql);
        subqueryDepth = subqueryDepth - 1;

        // Restore ALL outer context including currentTableAlias
        outerRow = savedOuterRow;
        outerTable = savedOuterTable;
        outerTableAlias = savedOuterAlias;
        currentTableAlias = savedCurrentAlias;

        // Return scalar value from first row, first column
        // Clone the value to prevent string lifetime issues with nested subqueries
        if result.success && result.rowCount() > 0 {
            var firstRow = result.getRow(0);
            if firstRow != null {
                var r = firstRow;
                if r.columnCount() > 0 {
                    var val = cloneValue(r.getValue(0));
                    // Cache the cloned value for subsequent calls
                    subqueryCacheKeys.add(cacheKey);
                    subqueryCacheScalars.add(val);
                    // Add empty list to keep indices aligned
                    var emptyList: List[SqlValue] = [];
                    subqueryCacheLists.add(emptyList);
                    return val;
                }
            }
        }
        // Cache null result too
        var nullVal = sqlNull();
        subqueryCacheKeys.add(cacheKey);
        subqueryCacheScalars.add(nullVal);
        var emptyList2: List[SqlValue] = [];
        subqueryCacheLists.add(emptyList2);
        return nullVal;
    }

    // Evaluate an IN subquery: returns the list of cloned values from the subquery.
    // Uses same save/restore pattern as evalSubquery to avoid string corruption
    // in native codegen during recursive calls.
    expose func evalInSubquery(subqueryExpr: Expr) -> List[SqlValue] {
        // Check list cache first
        var cacheKey = subqueryExpr.subquerySQL;
        var ci = 0;
        while ci < subqueryCacheKeys.count() {
            if subqueryCacheKeys.get(ci) == cacheKey {
                return subqueryCacheLists.get(ci);
            }
            ci = ci + 1;
        }

        // Save ALL executor state
        var savedOuterRow = outerRow;
        var savedOuterTable = outerTable;
        var savedOuterAlias = outerTableAlias;
        var savedCurrentAlias = currentTableAlias;

        // Clone and flatten nested subqueries
        var sql = String.Substring(subqueryExpr.subquerySQL, 0, String.Length(subqueryExpr.subquerySQL));
        sql = flattenSubqueries(sql);

        subqueryDepth = subqueryDepth + 1;
        var subResult = queryHandler.executeSubquerySelect(sql);
        subqueryDepth = subqueryDepth - 1;

        // Restore ALL executor state
        outerRow = savedOuterRow;
        outerTable = savedOuterTable;
        outerTableAlias = savedOuterAlias;
        currentTableAlias = savedCurrentAlias;

        // Clone all result values
        var values = new List[SqlValue]();
        if subResult.success {
            var si = 0;
            while si < subResult.rowCount() {
                var subRow = subResult.getRow(si);
                if subRow != null {
                    var sr = subRow;
                    if sr.columnCount() > 0 {
                        values.add(cloneValue(sr.getValue(0)));
                    }
                }
                si = si + 1;
            }
        }

        // Cache the result
        subqueryCacheKeys.add(cacheKey);
        subqueryCacheScalars.add(sqlNull());
        subqueryCacheLists.add(values);
        return values;
    }

    expose func evalColumn(expr: Expr, row: Row, table: Table) -> SqlValue {
        // Check outer context for correlated subqueries
        if expr.tableName != "" && outerTableAlias != "" {
            if expr.tableName == outerTableAlias {
                if outerTable != null && outerRow != null {
                    var ot = outerTable;
                    var orow = outerRow;
                    var outerColIdx = ot.findColumnIndex(expr.columnName);
                    if outerColIdx >= 0 {
                        return orow.getValue(outerColIdx);
                    }
                }
                return sqlNull();
            }
        }

        var colIdx = table.findColumnIndex(expr.columnName);
        if colIdx < 0 {
            // Try outer context
            if expr.tableName == "" && outerTable != null && outerRow != null {
                var ot = outerTable;
                var orow = outerRow;
                var outerColIdx = ot.findColumnIndex(expr.columnName);
                if outerColIdx >= 0 {
                    return orow.getValue(outerColIdx);
                }
            }
            return sqlNull();
        }
        return row.getValue(colIdx);
    }

    expose func evalBinary(expr: Expr, row: Row, table: Table) -> SqlValue {
        var left = evalExpr(expr.getLeft(), row, table);
        var op = expr.op;

        // Short-circuit AND/OR: avoid evaluating right side when unnecessary
        if op == OP_AND {
            if left.intValue == 0 {
                return sqlInteger(0);
            }
            var rightVal = evalExpr(expr.getRight(), row, table);
            if rightVal.intValue != 0 {
                return sqlInteger(1);
            }
            return sqlInteger(0);
        }
        if op == OP_OR {
            if left.intValue != 0 {
                return sqlInteger(1);
            }
            var rightVal = evalExpr(expr.getRight(), row, table);
            if rightVal.intValue != 0 {
                return sqlInteger(1);
            }
            return sqlInteger(0);
        }

        // For IN with subqueries, don't evaluate right side through evalExpr
        // (which would call evalSubquery and cache a scalar). The IN handler
        // processes the subquery separately with its own list cache.
        var right = sqlNull();
        if op == OP_IN {
            var maybeSubquery = expr.getRight();
            if maybeSubquery.kind != EXPR_SUBQUERY {
                right = evalExpr(maybeSubquery, row, table);
            }
        } else {
            right = evalExpr(expr.getRight(), row, table);
        }

        // Arithmetic (supports INTEGER and REAL)
        if op == OP_ADD {
            if left.kind == SQL_INTEGER && right.kind == SQL_INTEGER {
                return sqlInteger(left.intValue + right.intValue);
            }
            // DATE + INTEGER = DATE (add days)
            if left.kind == SQL_DATE && right.kind == SQL_INTEGER {
                return sqlDate(DateTime.AddDays(left.intValue, right.intValue));
            }
            if left.kind == SQL_INTEGER && right.kind == SQL_DATE {
                return sqlDate(DateTime.AddDays(right.intValue, left.intValue));
            }
            if (left.kind == SQL_REAL || left.kind == SQL_INTEGER) && (right.kind == SQL_REAL || right.kind == SQL_INTEGER) {
                var lv = left.realValue;
                if left.kind == SQL_INTEGER { lv = left.intValue * 1.0; }
                var rv = right.realValue;
                if right.kind == SQL_INTEGER { rv = right.intValue * 1.0; }
                var res = lv + rv;
                return sqlReal(res, Fmt.Num(res));
            }
        }
        if op == OP_SUB {
            if left.kind == SQL_INTEGER && right.kind == SQL_INTEGER {
                return sqlInteger(left.intValue - right.intValue);
            }
            // DATE - INTEGER = DATE (subtract days)
            if left.kind == SQL_DATE && right.kind == SQL_INTEGER {
                return sqlDate(DateTime.AddDays(left.intValue, 0 - right.intValue));
            }
            // DATE - DATE = INTEGER (difference in days)
            if left.kind == SQL_DATE && right.kind == SQL_DATE {
                var diffSecs = DateTime.Diff(left.intValue, right.intValue);
                if diffSecs >= 0 {
                    return sqlInteger((diffSecs + 43200) / 86400);
                }
                return sqlInteger((diffSecs - 43200) / 86400);
            }
            // TIMESTAMP - TIMESTAMP = INTEGER (difference in seconds)
            if left.kind == SQL_TIMESTAMP && right.kind == SQL_TIMESTAMP {
                return sqlInteger(left.intValue - right.intValue);
            }
            if (left.kind == SQL_REAL || left.kind == SQL_INTEGER) && (right.kind == SQL_REAL || right.kind == SQL_INTEGER) {
                var lv = left.realValue;
                if left.kind == SQL_INTEGER { lv = left.intValue * 1.0; }
                var rv = right.realValue;
                if right.kind == SQL_INTEGER { rv = right.intValue * 1.0; }
                var res = lv - rv;
                return sqlReal(res, Fmt.Num(res));
            }
        }
        if op == OP_MUL {
            if left.kind == SQL_INTEGER && right.kind == SQL_INTEGER {
                return sqlInteger(left.intValue * right.intValue);
            }
            if (left.kind == SQL_REAL || left.kind == SQL_INTEGER) && (right.kind == SQL_REAL || right.kind == SQL_INTEGER) {
                var lv = left.realValue;
                if left.kind == SQL_INTEGER { lv = left.intValue * 1.0; }
                var rv = right.realValue;
                if right.kind == SQL_INTEGER { rv = right.intValue * 1.0; }
                var res = lv * rv;
                return sqlReal(res, Fmt.Num(res));
            }
        }
        if op == OP_DIV {
            if left.kind == SQL_INTEGER && right.kind == SQL_INTEGER {
                if right.intValue != 0 {
                    return sqlInteger(left.intValue / right.intValue);
                }
            }
            if (left.kind == SQL_REAL || left.kind == SQL_INTEGER) && (right.kind == SQL_REAL || right.kind == SQL_INTEGER) {
                var lv = left.realValue;
                if left.kind == SQL_INTEGER { lv = left.intValue * 1.0; }
                var rv = right.realValue;
                if right.kind == SQL_INTEGER { rv = right.intValue * 1.0; }
                if rv != 0.0 {
                    var res = lv / rv;
                    return sqlReal(res, Fmt.Num(res));
                }
            }
        }

        // Comparison - return 1 for true, 0 for false
        // compare() returns 2 for NULL comparisons (SQL three-valued logic)
        if op == OP_EQ {
            var cmp = left.compare(right);
            if cmp == 2 { return sqlInteger(0); }
            if cmp == 0 { return sqlInteger(1); }
            return sqlInteger(0);
        }
        if op == OP_NE {
            var cmp = left.compare(right);
            if cmp == 2 { return sqlInteger(0); }
            if cmp != 0 { return sqlInteger(1); }
            return sqlInteger(0);
        }
        if op == OP_LT {
            var cmp = left.compare(right);
            if cmp == 2 { return sqlInteger(0); }
            if cmp < 0 { return sqlInteger(1); }
            return sqlInteger(0);
        }
        if op == OP_LE {
            var cmp = left.compare(right);
            if cmp == 2 { return sqlInteger(0); }
            if cmp <= 0 { return sqlInteger(1); }
            return sqlInteger(0);
        }
        if op == OP_GT {
            var cmp = left.compare(right);
            if cmp == 2 { return sqlInteger(0); }
            if cmp > 0 { return sqlInteger(1); }
            return sqlInteger(0);
        }
        if op == OP_GE {
            var cmp = left.compare(right);
            if cmp == 2 { return sqlInteger(0); }
            if cmp >= 0 { return sqlInteger(1); }
            return sqlInteger(0);
        }

        // IS NULL / IS NOT NULL / IS TRUE / IS FALSE / IS NOT TRUE / IS NOT FALSE
        if op == OP_IS {
            if right.kind == SQL_NULL {
                // IS NULL
                if left.kind == SQL_NULL { return sqlInteger(1); }
                return sqlInteger(0);
            } else if right.intValue == 1 {
                // IS NOT NULL
                if left.kind != SQL_NULL { return sqlInteger(1); }
                return sqlInteger(0);
            } else if right.intValue == 5 {
                // IS TRUE
                if left.kind == SQL_NULL { return sqlInteger(0); }
                if left.intValue != 0 { return sqlInteger(1); }
                return sqlInteger(0);
            } else if right.intValue == 6 {
                // IS FALSE
                if left.kind == SQL_NULL { return sqlInteger(0); }
                if left.intValue == 0 { return sqlInteger(1); }
                return sqlInteger(0);
            } else if right.intValue == 3 {
                // IS NOT TRUE (true when NULL, false, or 0)
                if left.kind == SQL_NULL { return sqlInteger(1); }
                if left.intValue == 0 { return sqlInteger(1); }
                return sqlInteger(0);
            } else if right.intValue == 4 {
                // IS NOT FALSE (true when NULL, true, or non-zero)
                if left.kind == SQL_NULL { return sqlInteger(1); }
                if left.intValue != 0 { return sqlInteger(1); }
                return sqlInteger(0);
            }
        }

        // LIKE pattern matching
        if op == OP_LIKE {
            if left.kind == SQL_NULL { return sqlInteger(0); }
            var leftStr = left.toString();
            var pattern = right.toString();
            if matchLike(leftStr, pattern) {
                return sqlInteger(1);
            }
            return sqlInteger(0);
        }

        // AND/OR handled above with short-circuit evaluation

        // IN operator - right side is a subquery or value list
        if op == OP_IN {
            if left.kind == SQL_NULL { return sqlInteger(0); }
            var rightExpr = expr.getRight();
            if rightExpr.kind == EXPR_SUBQUERY {
                // Delegate to dedicated method that properly saves/restores
                // executor state (avoids string corruption in native codegen)
                var subValues = evalInSubquery(rightExpr);
                // Compare left value against subquery results
                var i = 0;
                while i < subValues.count() {
                    if left.compare(subValues.get(i)) == 0 {
                        return sqlInteger(1);
                    }
                    i = i + 1;
                }
            } else if rightExpr.kind == EXPR_FUNCTION {
                // IN value list (args contain the list values)
                var i = 0;
                while i < rightExpr.args.count() {
                    var listVal = evalExpr(rightExpr.args.get(i), row, table);
                    if left.compare(listVal) == 0 {
                        return sqlInteger(1);
                    }
                    i = i + 1;
                }
            }
            return sqlInteger(0);
        }

        // String concatenation
        if op == OP_CONCAT {
            var leftStr = left.toString();
            var rightStr = right.toString();
            if left.kind == SQL_NULL { leftStr = ""; }
            if right.kind == SQL_NULL { rightStr = ""; }
            return sqlText(leftStr + rightStr);
        }

        return sqlNull();
    }

    expose func evalUnary(expr: Expr, row: Row, table: Table) -> SqlValue {
        var operand = evalExpr(expr.getOperand(), row, table);

        if expr.op == OP_NEG {
            if operand.kind == SQL_INTEGER {
                return sqlInteger(-operand.intValue);
            }
            if operand.kind == SQL_REAL {
                var neg = -operand.realValue;
                return sqlReal(neg, Fmt.Num(neg));
            }
        }
        if expr.op == OP_NOT {
            if operand.kind == SQL_NULL {
                return sqlInteger(0);
            }
            if operand.intValue == 0 {
                return sqlInteger(1);
            }
            return sqlInteger(0);
        }

        return sqlNull();
    }

    // Deep-clone a SqlValue with fresh string allocation to avoid retain issues
    expose func cloneValue(v: SqlValue) -> SqlValue {
        var c = new SqlValue();
        c.kind = v.kind;
        c.intValue = v.intValue;
        c.realValue = v.realValue;
        if v.kind == SQL_TEXT || v.kind == SQL_BLOB || v.kind == SQL_REAL {
            var len = String.Length(v.textValue);
            c.textValue = String.Substring(v.textValue, 0, len);
        } else {
            c.textValue = "";
        }
        return c;
    }

    // LIKE pattern matching: % matches any sequence, _ matches single char
    hide func matchLike(text: String, pattern: String) -> Boolean {
        var tLen = String.Length(text);
        var pLen = String.Length(pattern);
        var ti = 0;
        var pi = 0;
        var starTi = -1;
        var starPi = -1;

        while ti < tLen {
            if pi < pLen {
                var pch = String.Substring(pattern, pi, 1);
                if pch == "%" {
                    starTi = ti;
                    starPi = pi;
                    pi = pi + 1;
                    continue;
                }
                var tch = String.Substring(text, ti, 1);
                if pch == "_" || String.ToLower(pch) == String.ToLower(tch) {
                    ti = ti + 1;
                    pi = pi + 1;
                    continue;
                }
            }
            // Mismatch - backtrack to last %
            if starPi >= 0 {
                starTi = starTi + 1;
                ti = starTi;
                pi = starPi + 1;
                continue;
            }
            return false;
        }

        // Skip trailing % in pattern
        while pi < pLen && String.Substring(pattern, pi, 1) == "%" {
            pi = pi + 1;
        }
        return pi == pLen;
    }

    expose func evalFunction(expr: Expr, row: Row, table: Table) -> SqlValue {
        var name = String.ToUpper(expr.funcName);

        // Short-circuit functions (need lazy argument evaluation)
        if name == "COALESCE" {
            var i = 0;
            while i < expr.args.count() {
                var arg = evalExpr(expr.args.get(i), row, table);
                if arg.kind != SQL_NULL { return arg; }
                i = i + 1;
            }
            return sqlNull();
        }
        if name == "IFNULL" && expr.args.count() >= 2 {
            var arg = evalExpr(expr.args.get(0), row, table);
            if arg.kind == SQL_NULL { return evalExpr(expr.args.get(1), row, table); }
            return arg;
        }
        if name == "IIF" && expr.args.count() >= 3 {
            var cond = evalExpr(expr.args.get(0), row, table);
            if cond.intValue != 0 { return evalExpr(expr.args.get(1), row, table); }
            return evalExpr(expr.args.get(2), row, table);
        }
        // RANDOM needs executor state (randomSeed)
        if name == "RANDOM" || name == "RAND" {
            randomSeed = (randomSeed * 1103515245 + 12345) % 2147483647;
            var rv = randomSeed;
            if rv < 0 { rv = -rv; }
            return sqlInteger(rv);
        }

        // Pre-evaluate all arguments for delegation to sql_functions module
        var evalArgs: List[SqlValue] = [];
        var ai = 0;
        while ai < expr.args.count() {
            evalArgs.add(evalExpr(expr.args.get(ai), row, table));
            ai = ai + 1;
        }

        // Delegate to sql_functions module
        return dispatchSqlFunctionOrNull(name, evalArgs);
    }

    // (CAST/conditional/string/math/date functions delegated to sql_functions module)

    expose func evalCondition(expr: Expr?, row: Row, table: Table) -> Boolean {
        if expr == null {
            return true;
        }
        var e = expr;
        var result = evalExpr(e, row, table);
        return result.intValue != 0;
    }

    //=========================================================================
    // INDEX-BASED LOOKUPS
    //=========================================================================

    // Check if WHERE clause is a simple equality that can use an index
    // Returns the column name and value if usable, null otherwise
    expose func canUseIndex(expr: Expr?, tableName: String) -> Boolean {
        if expr == null {
            return false;
        }
        var e = expr;

        // Must be a binary expression with OP_EQ
        if e.kind != EXPR_BINARY || e.op != OP_EQ {
            return false;
        }

        var left = e.getLeft();
        var right = e.getRight();

        // Check for column = literal pattern
        if left.kind == EXPR_COLUMN && right.kind == EXPR_LITERAL {
            var colName = left.columnName;
            var maybeIdx = indexMgr.findIndexForColumn(tableName, colName);
            return maybeIdx != null;
        }

        // Check for literal = column pattern
        if left.kind == EXPR_LITERAL && right.kind == EXPR_COLUMN {
            var colName = right.columnName;
            var maybeIdx = indexMgr.findIndexForColumn(tableName, colName);
            return maybeIdx != null;
        }

        return false;
    }

    // Check if a range predicate (>, >=, <, <=) can use an index
    expose func canUseIndexRange(expr: Expr?, tableName: String) -> Boolean {
        if expr == null {
            return false;
        }
        var e = expr;
        if e.kind != EXPR_BINARY {
            return false;
        }

        // Check for range operators
        var isRange = e.op == OP_GT || e.op == OP_GE || e.op == OP_LT || e.op == OP_LE;
        if isRange == false {
            // Check for BETWEEN (AND of two range conditions on same column)
            if e.op == OP_AND {
                return canUseBetweenIndex(e, tableName);
            }
            return false;
        }

        var left = e.getLeft();
        var right = e.getRight();

        // column op literal
        if left.kind == EXPR_COLUMN && right.kind == EXPR_LITERAL {
            return indexMgr.findIndexForColumn(tableName, left.columnName) != null;
        }
        // literal op column
        if left.kind == EXPR_LITERAL && right.kind == EXPR_COLUMN {
            return indexMgr.findIndexForColumn(tableName, right.columnName) != null;
        }
        return false;
    }

    // Check if a BETWEEN-style AND expression can use an index
    hide func canUseBetweenIndex(expr: Expr, tableName: String) -> Boolean {
        var left = expr.getLeft();
        var right = expr.getRight();

        // Both sides must be range comparisons on the same column
        if left.kind != EXPR_BINARY || right.kind != EXPR_BINARY {
            return false;
        }

        var leftIsRange = left.op == OP_GE || left.op == OP_GT;
        var rightIsRange = right.op == OP_LE || right.op == OP_LT;
        if leftIsRange == false || rightIsRange == false {
            return false;
        }

        // Extract column names
        var leftCol = "";
        if left.getLeft().kind == EXPR_COLUMN {
            leftCol = left.getLeft().columnName;
        }
        var rightCol = "";
        if right.getLeft().kind == EXPR_COLUMN {
            rightCol = right.getLeft().columnName;
        }

        if leftCol == "" || leftCol != rightCol {
            return false;
        }

        return indexMgr.findIndexForColumn(tableName, leftCol) != null;
    }

    // Perform index range lookup
    expose func indexRangeLookup(expr: Expr, tableName: String, table: Table) -> List[Integer] {
        var left = expr.getLeft();
        var right = expr.getRight();

        // Handle BETWEEN (AND of two range conditions)
        if expr.op == OP_AND {
            return indexBetweenLookup(expr, tableName, table);
        }

        var colName = "";
        var boundVal = sqlNull();
        var rangeType = 0;

        // column op literal
        if left.kind == EXPR_COLUMN && right.kind == EXPR_LITERAL {
            colName = left.columnName;
            boundVal = right.literalValue;
            if expr.op == OP_GT { rangeType = 1; }
            else if expr.op == OP_GE { rangeType = 2; }
            else if expr.op == OP_LT { rangeType = 3; }
            else if expr.op == OP_LE { rangeType = 4; }
        }
        // literal op column — reverse the operator direction
        else if left.kind == EXPR_LITERAL && right.kind == EXPR_COLUMN {
            colName = right.columnName;
            boundVal = left.literalValue;
            if expr.op == OP_GT { rangeType = 3; }
            else if expr.op == OP_GE { rangeType = 4; }
            else if expr.op == OP_LT { rangeType = 1; }
            else if expr.op == OP_LE { rangeType = 2; }
        }

        if colName == "" || rangeType == 0 {
            return new List[Integer]();
        }

        var maybeIdx = indexMgr.findIndexForColumn(tableName, colName);
        if maybeIdx == null {
            return new List[Integer]();
        }
        var idx = maybeIdx;
        return idx.lookupRange(boundVal, sqlNull(), rangeType, table);
    }

    // Handle BETWEEN via AND of two range conditions
    hide func indexBetweenLookup(expr: Expr, tableName: String, table: Table) -> List[Integer] {
        var leftExpr = expr.getLeft();
        var rightExpr = expr.getRight();

        // Extract column and bounds
        var colName = "";
        var lowerVal = sqlNull();
        var upperVal = sqlNull();

        if leftExpr.getLeft().kind == EXPR_COLUMN {
            colName = leftExpr.getLeft().columnName;
        }
        if leftExpr.getRight().kind == EXPR_LITERAL {
            lowerVal = leftExpr.getRight().literalValue;
        }
        if rightExpr.getRight().kind == EXPR_LITERAL {
            upperVal = rightExpr.getRight().literalValue;
        }

        if colName == "" {
            return new List[Integer]();
        }

        var maybeIdx = indexMgr.findIndexForColumn(tableName, colName);
        if maybeIdx == null {
            return new List[Integer]();
        }
        var idx = maybeIdx;
        return idx.lookupRange(lowerVal, upperVal, 5, table);
    }

    // Get matching row indices using an index
    expose func indexLookup(expr: Expr, tableName: String, table: Table) -> List[Integer] {
        var left = expr.getLeft();
        var right = expr.getRight();

        var colName = "";
        var lookupValue = sqlNull();

        // Extract column name and lookup value
        if left.kind == EXPR_COLUMN && right.kind == EXPR_LITERAL {
            colName = left.columnName;
            lookupValue = right.literalValue;
        } else if left.kind == EXPR_LITERAL && right.kind == EXPR_COLUMN {
            colName = right.columnName;
            lookupValue = left.literalValue;
        }

        // Find the index
        var maybeIdx = indexMgr.findIndexForColumn(tableName, colName);
        if maybeIdx == null {
            // Fall back to empty list (caller should do linear scan)
            var empty: List[Integer] = [];
            return empty;
        }

        var idx = maybeIdx;
        return idx.lookupSingle(lookupValue, table);
    }

    //=========================================================================
    // AGGREGATE FUNCTIONS
    //=========================================================================

    // Check if expression is an aggregate function
    // Note: MIN/MAX with exactly 2 arguments are treated as scalar functions
    expose func isAggregateExpr(expr: Expr) -> Boolean {
        if expr.kind == EXPR_FUNCTION {
            var funcName = String.ToUpper(expr.funcName);
            if funcName == "COUNT" { return true; }
            if funcName == "COUNT_DISTINCT" { return true; }
            if funcName == "SUM" { return true; }
            if funcName == "AVG" { return true; }
            // MIN/MAX with 2 args = scalar, with 1 arg = aggregate
            if funcName == "MIN" && expr.args.count() != 2 { return true; }
            if funcName == "MAX" && expr.args.count() != 2 { return true; }
        }
        return false;
    }

    // Check if SELECT has any aggregate functions
    expose func hasAggregates(stmt: SelectStmt) -> Boolean {
        var c = 0;
        while c < stmt.columns.count() {
            var colExpr = stmt.columns.get(c);
            if isAggregateExpr(colExpr) {
                return true;
            }
            c = c + 1;
        }
        return false;
    }

    // Multiplicative hash for GROUP BY and hash join bucketing.
    // Returns a positive integer hash in [0, 32767).
    expose func computeKeyHash(s: String) -> Integer {
        var hash = 0;
        var i = 0;
        var len = String.Length(s);
        while i < len {
            var ch = String.Substring(s, i, 1);
            var c = String.Asc(ch);
            hash = (hash * 31 + c) % 32767;
            i = i + 1;
        }
        return hash;
    }

    // Rebuild all indexes for a table (after DELETE compaction changes row indices)
    expose func rebuildTableIndexes(tableName: String, table: Table) {
        var i = 0;
        while i < indexMgr.indexCount() {
            var idx = indexMgr.indexes.get(i);
            if idx.tableName == tableName {
                idx.rebuild(table);
            }
            i = i + 1;
        }
        // Also rebuild B-tree indexes for persistent databases
        if storageEngine != null {
            rebuildBTreeIndexes(tableName, table);
        }
    }

    //=========================================================================
    // B-TREE INDEX MANAGEMENT (Phase 10)
    //=========================================================================

    // Find a B-tree by index name
    expose func findBTreeForIndex(indexName: String) -> BTree? {
        var i = 0;
        while i < btreeIndexNames.count() {
            if btreeIndexNames.get(i) == indexName {
                return btrees.get(i);
            }
            i = i + 1;
        }
        return null;
    }

    // Register a B-tree for an index
    expose func addBTree(indexName: String, btree: BTree) {
        btreeIndexNames.add(indexName);
        btrees.add(btree);
    }

    // Remove a B-tree for an index
    expose func removeBTree(indexName: String) {
        var newNames: List[String] = [];
        var newTrees: List[BTree] = [];
        var i = 0;
        while i < btreeIndexNames.count() {
            if btreeIndexNames.get(i) != indexName {
                newNames.add(btreeIndexNames.get(i));
                newTrees.add(btrees.get(i));
            }
            i = i + 1;
        }
        btreeIndexNames = newNames;
        btrees = newTrees;
    }

    // Rebuild B-tree indexes for a table from current row data
    expose func rebuildBTreeIndexes(tableName: String, table: Table) {
        if storageEngine == null {
            return;
        }
        var se = storageEngine;

        var i = 0;
        while i < btreeIndexNames.count() {
            var idxName = btreeIndexNames.get(i);
            // Find the matching index in indexMgr to get column info
            var maybeIdx = indexMgr.findIndex(idxName);
            if maybeIdx != null {
                var sqlIdx = maybeIdx;
                if sqlIdx.tableName == tableName {
                    // Drop old B-tree, create new one
                    var oldBtree = btrees.get(i);
                    var colName = sqlIdx.getColumnName(0);
                    var newBtree = se.createBTree(idxName, 0, colName, sqlIdx.isUnique);

                    // Populate from current rows
                    var ri = 0;
                    while ri < table.rowCount() {
                        var maybeRow = table.getRow(ri);
                        if maybeRow != null {
                            var row = maybeRow;
                            if row.deleted == false {
                                var colIdx = table.findColumnIndex(colName);
                                if colIdx >= 0 {
                                    var keyVal = row.getValue(colIdx);
                                    // Get disk location for this row
                                    var loc = se.findRowLocation(tableName, ri);
                                    var pageId = loc.get(0);
                                    var slotId = loc.get(1);
                                    if pageId != INVALID_PAGE_ID {
                                        var btreeKey = new BTreeKey();
                                        btreeKey.initWithValue(keyVal, pageId, slotId);
                                        newBtree.insert(btreeKey);
                                    }
                                }
                            }
                        }
                        ri = ri + 1;
                    }

                    btrees.set(i, newBtree);

                    // Update the root page in index metadata
                    var si = 0;
                    while si < se.indexMetas.count() {
                        var im = se.indexMetas.get(si);
                        if im.indexName == idxName {
                            im.btreeRootPageId = newBtree.rootPageId;
                        }
                        si = si + 1;
                    }
                }
            }
            i = i + 1;
        }
    }

    expose func executeSql(sql: String) -> QueryResult {
        var result = executeSqlDispatch(sql);

        // For non-transactional statements, release locks after each statement.
        // During transactions, locks are held until COMMIT/ROLLBACK.
        if inTransaction == false {
            releaseSessionLocks();
        }

        return result;
    }

    hide func executeSqlDispatch(sql: String) -> QueryResult {
        // Clear subquery cache for each new top-level SQL statement
        subqueryCacheKeys = [];
        subqueryCacheScalars = [];
        subqueryCacheLists = [];

        var parser = new Parser(sql);

        var kind = parser.currentKind();

        //=====================================================================
        // WITH (Common Table Expressions)
        //=====================================================================
        if kind == TK_WITH {
            return queryHandler.executeWithCTE(sql, parser);
        }

        if kind == TK_CREATE {
            parser.advance();
            // CREATE TEMP TABLE / CREATE TEMPORARY TABLE
            var isTemp = false;
            if parser.currentKind() == TK_TEMPORARY {
                isTemp = true;
                parser.advance();
            }
            if parser.currentKind() == TK_TABLE {
                var stmt = parser.parseCreateTableStmt();
                if parser.hasError {
                    var result = new QueryResult();
                    result.init();
                    result.setError(parser.error);
                    return result;
                }
                stmt.isTemporary = isTemp;
                return ddlHandler.executeCreateTable(stmt);
            }
            if parser.currentKind() == TK_INDEX || parser.currentKind() == TK_UNIQUE {
                var stmt = parser.parseCreateIndexStmt();
                if parser.hasError {
                    var result = new QueryResult();
                    result.init();
                    result.setError(parser.error);
                    return result;
                }
                return ddlHandler.executeCreateIndex(stmt);
            }
            // CREATE DATABASE [name] [FILE 'path']
            if parser.currentKind() == TK_DATABASE {
                parser.advance();
                if parser.currentKind() == TK_IDENTIFIER {
                    var dbName = parser.currentText();
                    parser.advance();
                    // Check for optional FILE 'path' clause
                    if parser.currentKind() == TK_FILE {
                        parser.advance();
                        if parser.currentKind() == TK_STRING {
                            var filePath = parser.currentText();
                            return ddlHandler.executeCreateDatabaseWithFile(dbName, filePath);
                        }
                        var result = new QueryResult();
                        result.init();
                        result.setError("FILE requires a file path string");
                        return result;
                    }
                    return ddlHandler.executeCreateDatabase(dbName);
                }
                var result = new QueryResult();
                result.init();
                result.setError("CREATE DATABASE requires a database name");
                return result;
            }
            // CREATE VIEW name AS SELECT ...
            if parser.currentKind() == TK_VIEW {
                parser.advance();
                if parser.currentKind() != TK_IDENTIFIER {
                    var result = new QueryResult();
                    result.init();
                    result.setError("CREATE VIEW requires a view name");
                    return result;
                }
                var viewName = parser.currentText();
                parser.advance();
                if parser.currentKind() != TK_AS {
                    var result = new QueryResult();
                    result.init();
                    result.setError("Expected AS after view name");
                    return result;
                }
                parser.advance();
                // Capture the rest as the view definition SQL
                var viewSql = "";
                while parser.currentKind() != TK_EOF && parser.currentKind() != TK_SEMICOLON {
                    if parser.currentKind() == TK_STRING {
                        viewSql = viewSql + " '" + parser.currentText() + "'";
                    } else {
                        if viewSql != "" {
                            viewSql = viewSql + " ";
                        }
                        viewSql = viewSql + parser.currentText();
                    }
                    parser.advance();
                }
                return ddlHandler.executeCreateView(viewName, viewSql);
            }
            // CREATE USER name PASSWORD 'password'
            if parser.currentKind() == TK_USER {
                parser.advance();
                if parser.currentKind() != TK_IDENTIFIER {
                    var result = new QueryResult();
                    result.init();
                    result.setError("CREATE USER requires a username");
                    return result;
                }
                var userName = parser.currentText();
                parser.advance();
                if parser.currentKind() != TK_PASSWORD {
                    var result = new QueryResult();
                    result.init();
                    result.setError("Expected PASSWORD after username: CREATE USER name PASSWORD 'pass'");
                    return result;
                }
                parser.advance();
                if parser.currentKind() != TK_STRING {
                    var result = new QueryResult();
                    result.init();
                    result.setError("Expected password string");
                    return result;
                }
                var password = parser.currentText();
                return ddlHandler.executeCreateUser(userName, password);
            }
        }

        if kind == TK_INSERT {
            parser.advance();
            var stmt = parser.parseInsertStmt();
            if parser.hasError {
                var result = new QueryResult();
                result.init();
                result.setError(parser.error);
                return result;
            }
            return dmlHandler.executeInsert(stmt);
        }

        if kind == TK_SELECT {
            parser.advance();
            var stmt = parser.parseSelectStmt();
            if parser.hasError {
                var result = new QueryResult();
                result.init();
                result.setError(parser.error);
                return result;
            }
            var firstResult = queryHandler.executeSelect(stmt);
            if firstResult.success == false {
                return firstResult;
            }

            // Check for UNION or UNION ALL
            if parser.currentKind() == TK_UNION {
                parser.advance();
                var unionAll = false;
                if parser.currentKind() == TK_ALL {
                    unionAll = true;
                    parser.advance();
                }
                if parser.currentKind() == TK_SELECT {
                    parser.advance();
                    var stmt2 = parser.parseSelectStmt();
                    if parser.hasError {
                        var result = new QueryResult();
                        result.init();
                        result.setError(parser.error);
                        return result;
                    }
                    var secondResult = queryHandler.executeSelect(stmt2);
                    if secondResult.success == false {
                        return secondResult;
                    }
                    return executeUnion(firstResult, secondResult, unionAll);
                }
            }

            // Check for EXCEPT
            if parser.currentKind() == TK_EXCEPT {
                parser.advance();
                if parser.currentKind() == TK_SELECT {
                    parser.advance();
                    var stmt2 = parser.parseSelectStmt();
                    if parser.hasError {
                        var result = new QueryResult();
                        result.init();
                        result.setError(parser.error);
                        return result;
                    }
                    var secondResult = queryHandler.executeSelect(stmt2);
                    if secondResult.success == false {
                        return secondResult;
                    }
                    return executeExcept(firstResult, secondResult);
                }
            }

            // Check for INTERSECT
            if parser.currentKind() == TK_INTERSECT {
                parser.advance();
                if parser.currentKind() == TK_SELECT {
                    parser.advance();
                    var stmt2 = parser.parseSelectStmt();
                    if parser.hasError {
                        var result = new QueryResult();
                        result.init();
                        result.setError(parser.error);
                        return result;
                    }
                    var secondResult = queryHandler.executeSelect(stmt2);
                    if secondResult.success == false {
                        return secondResult;
                    }
                    return executeIntersect(firstResult, secondResult);
                }
            }

            return firstResult;
        }

        if kind == TK_UPDATE {
            parser.advance();
            var stmt = parser.parseUpdateStmt();
            if parser.hasError {
                var result = new QueryResult();
                result.init();
                result.setError(parser.error);
                return result;
            }
            return dmlHandler.executeUpdate(stmt);
        }

        if kind == TK_DELETE {
            parser.advance();
            var stmt = parser.parseDeleteStmt();
            if parser.hasError {
                var result = new QueryResult();
                result.init();
                result.setError(parser.error);
                return result;
            }
            return dmlHandler.executeDelete(stmt);
        }

        if kind == TK_DROP {
            parser.advance();
            if parser.currentKind() == TK_TABLE {
                parser.advance();
                if parser.currentKind() == TK_IDENTIFIER {
                    var tableName = parser.currentText();
                    return ddlHandler.executeDropTable(tableName);
                }
            }
            if parser.currentKind() == TK_INDEX {
                var stmt = parser.parseDropIndexStmt();
                if parser.hasError {
                    var result = new QueryResult();
                    result.init();
                    result.setError(parser.error);
                    return result;
                }
                return ddlHandler.executeDropIndex(stmt);
            }
            // DROP DATABASE
            if parser.currentKind() == TK_DATABASE {
                parser.advance();
                if parser.currentKind() == TK_IDENTIFIER {
                    var dbName = parser.currentText();
                    return ddlHandler.executeDropDatabase(dbName);
                }
                var result = new QueryResult();
                result.init();
                result.setError("DROP DATABASE requires a database name");
                return result;
            }
            // DROP VIEW
            if parser.currentKind() == TK_VIEW {
                parser.advance();
                if parser.currentKind() == TK_IDENTIFIER {
                    var viewName = parser.currentText();
                    return ddlHandler.executeDropView(viewName);
                }
                var result = new QueryResult();
                result.init();
                result.setError("DROP VIEW requires a view name");
                return result;
            }
            // DROP USER name
            if parser.currentKind() == TK_USER {
                parser.advance();
                if parser.currentKind() == TK_IDENTIFIER {
                    var userName = parser.currentText();
                    return ddlHandler.executeDropUser(userName);
                }
                var result = new QueryResult();
                result.init();
                result.setError("DROP USER requires a username");
                return result;
            }
        }

        // USE command: USE database_name
        if kind == TK_USE {
            parser.advance();
            if parser.currentKind() == TK_IDENTIFIER || parser.currentKind() == TK_DATABASE {
                var dbName = parser.currentText();
                parser.advance();
                // Handle "USE DATABASE name" syntax
                if parser.currentKind() == TK_IDENTIFIER {
                    dbName = parser.currentText();
                }
                return ddlHandler.executeUseDatabase(dbName);
            }
            var result = new QueryResult();
            result.init();
            result.setError("USE requires a database name: USE database_name");
            return result;
        }

        if kind == TK_SHOW {
            parser.advance();
            if parser.currentKind() == TK_DATABASES {
                return ddlHandler.executeShowDatabases();
            }
            if parser.currentKind() == TK_IDENTIFIER && String.ToUpper(parser.currentText()) == "USERS" {
                return ddlHandler.executeShowUsers();
            }
            if parser.currentKind() == TK_GRANT || (parser.currentKind() == TK_IDENTIFIER && String.ToUpper(parser.currentText()) == "GRANTS") {
                // SHOW GRANTS [FOR username]
                parser.advance();
                var forUser = currentUser;
                if parser.currentKind() == TK_IDENTIFIER {
                    var maybeFor = String.ToUpper(parser.currentText());
                    if maybeFor == "FOR" {
                        parser.advance();
                        if parser.currentKind() == TK_IDENTIFIER {
                            forUser = parser.currentText();
                        }
                    }
                }
                return ddlHandler.executeShowGrants(forUser);
            }
            return ddlHandler.executeShowTables();
        }

        // SAVE command: SAVE 'filename' or SAVE TO 'filename'
        if kind == TK_SAVE {
            parser.advance();
            // Optional TO keyword
            if parser.currentKind() == TK_TO {
                parser.advance();
            }
            if parser.currentKind() == TK_STRING {
                var filename = parser.currentText();
                return persistence.executeSave(filename);
            }
            var result = new QueryResult();
            result.init();
            result.setError("SAVE requires a filename: SAVE 'filename'");
            return result;
        }

        // OPEN command: OPEN 'filename' or OPEN FROM 'filename'
        if kind == TK_OPEN {
            parser.advance();
            // Optional FROM keyword
            if parser.currentKind() == TK_FROM {
                parser.advance();
            }
            if parser.currentKind() == TK_STRING {
                var filename = parser.currentText();
                return persistence.executeOpen(filename);
            }
            var result = new QueryResult();
            result.init();
            result.setError("OPEN requires a filename: OPEN 'filename'");
            return result;
        }

        // CLOSE command: close persistent database
        if kind == TK_CLOSE {
            return persistence.executeClose();
        }

        // EXPORT command: EXPORT table TO 'filename'
        if kind == TK_EXPORT {
            parser.advance();
            if parser.currentKind() == TK_IDENTIFIER {
                var tableName = parser.currentText();
                parser.advance();
                if parser.currentKind() == TK_TO {
                    parser.advance();
                    if parser.currentKind() == TK_STRING {
                        var filename = parser.currentText();
                        return csvHandler.executeExport(tableName, filename);
                    }
                }
            }
            var result = new QueryResult();
            result.init();
            result.setError("EXPORT syntax: EXPORT tablename TO 'filename.csv'");
            return result;
        }

        // IMPORT command: IMPORT INTO table FROM 'filename'
        if kind == TK_IMPORT {
            parser.advance();
            if parser.currentKind() == TK_INTO {
                parser.advance();
            }
            if parser.currentKind() == TK_IDENTIFIER {
                var tableName = parser.currentText();
                parser.advance();
                if parser.currentKind() == TK_FROM {
                    parser.advance();
                    if parser.currentKind() == TK_STRING {
                        var filename = parser.currentText();
                        return csvHandler.executeImport(tableName, filename);
                    }
                }
            }
            var result = new QueryResult();
            result.init();
            result.setError("IMPORT syntax: IMPORT INTO tablename FROM 'filename.csv'");
            return result;
        }

        // VACUUM command
        if kind == TK_VACUUM {
            return ddlHandler.executeVacuum();
        }

        // HELP command
        if kind == TK_HELP {
            return ddlHandler.executeHelp();
        }

        // DESCRIBE command: DESCRIBE tablename
        if kind == TK_DESCRIBE {
            parser.advance();
            if parser.currentKind() == TK_IDENTIFIER {
                var tableName = parser.currentText();
                return ddlHandler.executeDescribe(tableName);
            }
            var result = new QueryResult();
            result.init();
            result.setError("DESCRIBE requires a table name");
            return result;
        }

        // ALTER TABLE / ALTER USER command
        if kind == TK_ALTER {
            parser.advance();
            if parser.currentKind() == TK_TABLE {
                parser.advance();
                if parser.currentKind() == TK_IDENTIFIER {
                    var tableName = parser.currentText();
                    // Acquire exclusive lock on table being altered
                    if acquireExclusiveLock(tableName) == false {
                        return lockTimeoutError(tableName);
                    }
                    parser.advance();
                    return ddlHandler.executeAlterTable(parser, tableName);
                }
            }
            // ALTER USER name [SET] PASSWORD 'newpass'
            if parser.currentKind() == TK_USER {
                parser.advance();
                if parser.currentKind() != TK_IDENTIFIER {
                    var result = new QueryResult();
                    result.init();
                    result.setError("ALTER USER requires a username");
                    return result;
                }
                var userName = parser.currentText();
                parser.advance();
                // Optional SET keyword
                if parser.currentKind() == TK_SET {
                    parser.advance();
                }
                if parser.currentKind() != TK_PASSWORD {
                    var result = new QueryResult();
                    result.init();
                    result.setError("ALTER USER: expected PASSWORD");
                    return result;
                }
                parser.advance();
                if parser.currentKind() != TK_STRING {
                    var result = new QueryResult();
                    result.init();
                    result.setError("ALTER USER: expected password string");
                    return result;
                }
                var newPassword = parser.currentText();
                return ddlHandler.executeAlterUser(userName, newPassword);
            }
            var result = new QueryResult();
            result.init();
            result.setError("ALTER TABLE syntax: ALTER TABLE tablename ADD/DROP/RENAME ...");
            return result;
        }

        // EXPLAIN command: EXPLAIN SELECT ...
        if kind == TK_EXPLAIN {
            parser.advance();
            if parser.currentKind() == TK_SELECT {
                parser.advance();
                var stmt = parser.parseSelectStmt();
                if parser.hasError {
                    var result = new QueryResult();
                    result.init();
                    result.setError(parser.error);
                    return result;
                }
                return ddlHandler.executeExplain(stmt);
            }
            var result = new QueryResult();
            result.init();
            result.setError("EXPLAIN currently supports SELECT statements only");
            return result;
        }

        // GRANT privileges ON table TO user
        if kind == TK_GRANT {
            parser.advance();
            var privMask = parsePrivilegeList(parser);
            if privMask < 0 {
                var result = new QueryResult();
                result.init();
                result.setError("Invalid privilege name. Use SELECT, INSERT, UPDATE, DELETE, or ALL");
                return result;
            }
            if parser.currentKind() != TK_ON {
                var result = new QueryResult();
                result.init();
                result.setError("Expected ON after privilege list: GRANT ... ON tablename TO user");
                return result;
            }
            parser.advance();
            if parser.currentKind() != TK_IDENTIFIER {
                var result = new QueryResult();
                result.init();
                result.setError("Expected table name after ON");
                return result;
            }
            var tableName = parser.currentText();
            parser.advance();
            if parser.currentKind() != TK_TO {
                var result = new QueryResult();
                result.init();
                result.setError("Expected TO after table name: GRANT ... ON tablename TO user");
                return result;
            }
            parser.advance();
            var grantee = "";
            if parser.currentKind() == TK_IDENTIFIER {
                grantee = parser.currentText();
            } else {
                var result = new QueryResult();
                result.init();
                result.setError("Expected username or PUBLIC after TO");
                return result;
            }
            return ddlHandler.executeGrant(privMask, tableName, grantee);
        }

        // REVOKE privileges ON table FROM user
        if kind == TK_REVOKE {
            parser.advance();
            var privMask = parsePrivilegeList(parser);
            if privMask < 0 {
                var result = new QueryResult();
                result.init();
                result.setError("Invalid privilege name. Use SELECT, INSERT, UPDATE, DELETE, or ALL");
                return result;
            }
            if parser.currentKind() != TK_ON {
                var result = new QueryResult();
                result.init();
                result.setError("Expected ON after privilege list: REVOKE ... ON tablename FROM user");
                return result;
            }
            parser.advance();
            if parser.currentKind() != TK_IDENTIFIER {
                var result = new QueryResult();
                result.init();
                result.setError("Expected table name after ON");
                return result;
            }
            var tableName = parser.currentText();
            parser.advance();
            if parser.currentKind() != TK_FROM {
                var result = new QueryResult();
                result.init();
                result.setError("Expected FROM after table name: REVOKE ... ON tablename FROM user");
                return result;
            }
            parser.advance();
            var grantee = "";
            if parser.currentKind() == TK_IDENTIFIER {
                grantee = parser.currentText();
            } else {
                var result = new QueryResult();
                result.init();
                result.setError("Expected username or PUBLIC after FROM");
                return result;
            }
            return ddlHandler.executeRevoke(privMask, tableName, grantee);
        }

        // Transaction commands
        if kind == TK_BEGIN {
            return executeBegin();
        }
        if kind == TK_COMMIT {
            return executeCommit();
        }
        if kind == TK_ROLLBACK {
            return executeRollback();
        }

        var result = new QueryResult();
        result.init();
        result.setError("Unknown SQL statement");
        return result;
    }
    //=========================================================================
    // PRIVILEGE HELPERS (Phase 13)
    //=========================================================================

    // Parse a comma-separated list of privilege names into a bitmask.
    // Returns -1 on error.
    hide func parsePrivilegeList(parser: Parser) -> Integer {
        var mask = 0;
        var first = true;
        while true {
            if first == false {
                if parser.currentKind() == TK_COMMA {
                    parser.advance();
                } else {
                    return mask;
                }
            }
            first = false;
            var text = String.ToUpper(parser.currentText());
            if text == "ALL" {
                parser.advance();
                // Optional PRIVILEGES keyword
                if parser.currentKind() == TK_PRIVILEGES {
                    parser.advance();
                }
                mask = PRIV_ALL;
                return mask;
            }
            if parser.currentKind() == TK_SELECT {
                mask = mask + PRIV_SELECT;
                parser.advance();
            } else if parser.currentKind() == TK_INSERT {
                mask = mask + PRIV_INSERT;
                parser.advance();
            } else if parser.currentKind() == TK_UPDATE {
                mask = mask + PRIV_UPDATE;
                parser.advance();
            } else if parser.currentKind() == TK_DELETE {
                mask = mask + PRIV_DELETE;
                parser.advance();
            } else {
                if mask == 0 { return -1; }
                return mask;
            }
        }
        return mask;
    }

    // Check if the current user has a privilege on a table.
    // Returns null if allowed, or an error QueryResult if denied.
    expose func checkPrivilege(tableName: String, privMask: Integer) -> QueryResult? {
        // Skip for temp tables and system views
        if isTempTable(tableName) { return null; }
        if isSystemView(tableName) { return null; }
        // Superuser bypasses all checks
        if isSuperuser() { return null; }
        // Check privilege via server
        if server.hasPrivilege(currentUser, tableName, privMask) {
            return null;
        }
        var result = new QueryResult();
        result.init();
        var privName = "access";
        if privMask == PRIV_SELECT { privName = "SELECT"; }
        if privMask == PRIV_INSERT { privName = "INSERT"; }
        if privMask == PRIV_UPDATE { privName = "UPDATE"; }
        if privMask == PRIV_DELETE { privName = "DELETE"; }
        result.setError("Permission denied: " + privName + " on '" + tableName + "' for user '" + currentUser + "'");
        return result;
    }

    // Check if the current user is the owner of a table (or superuser).
    // Returns null if allowed, or an error QueryResult if denied.
    expose func checkOwnership(tableName: String) -> QueryResult? {
        if isSuperuser() { return null; }
        var owner = server.getTableOwner(tableName);
        if owner == currentUser { return null; }
        var result = new QueryResult();
        result.init();
        result.setError("Permission denied: must be owner of table '" + tableName + "'");
        return result;
    }

    //=========================================================================
    // CONCURRENCY CONTROL HELPERS
    //=========================================================================

    // Acquire a shared (read) lock on a table. No-op in standalone mode.
    expose func acquireSharedLock(tableName: String) -> Boolean {
        if tableLockMgr == null { return true; }
        var lm = tableLockMgr;
        return lm.acquireTableLock(sessionId, tableName, LOCK_SHARED);
    }

    // Acquire an exclusive (write) lock on a table. No-op in standalone mode.
    expose func acquireExclusiveLock(tableName: String) -> Boolean {
        if tableLockMgr == null { return true; }
        var lm = tableLockMgr;
        return lm.acquireTableLock(sessionId, tableName, LOCK_EXCLUSIVE);
    }

    // Release all locks held by this session. No-op in standalone mode.
    expose func releaseSessionLocks() {
        if tableLockMgr == null { return; }
        var lm = tableLockMgr;
        lm.releaseAllLocks(sessionId);
    }

    // Return a lock timeout error result for the given table
    expose func lockTimeoutError(tableName: String) -> QueryResult {
        var result = new QueryResult();
        result.init();
        result.setError("Lock timeout: could not acquire lock on '" + tableName + "'");
        return result;
    }

    //=========================================================================
    // TRANSACTION MANAGEMENT
    //=========================================================================

    hide func executeBegin() -> QueryResult {
        var result = new QueryResult();
        result.init();
        if inTransaction {
            result.setError("Already in a transaction");
            return result;
        }
        inTransaction = true;
        journal = [];
        txnDirtyTables = [];
        result.message = "BEGIN";
        return result;
    }

    hide func executeCommit() -> QueryResult {
        var result = new QueryResult();
        result.init();
        if inTransaction == false {
            result.setError("No active transaction");
            return result;
        }

        // Compact any tables with soft-deleted rows
        var i = 0;
        while i < txnDirtyTables.count() {
            var tblName = txnDirtyTables.get(i);
            var table = findTable(tblName);
            if table != null {
                var t = table;
                compactTable(t);
                rebuildTableIndexes(tblName, t);
            }
            i = i + 1;
        }

        // Flush storage engine
        if storageEngine != null {
            var se = storageEngine;
            se.flush();
        }

        inTransaction = false;
        journal = [];
        txnDirtyTables = [];

        // Release all table locks held during the transaction
        releaseSessionLocks();

        result.message = "COMMIT";
        return result;
    }

    hide func executeRollback() -> QueryResult {
        var result = new QueryResult();
        result.init();
        if inTransaction == false {
            result.setError("No active transaction");
            return result;
        }

        // Undo journal entries in reverse order
        var i = journal.count() - 1;
        while i >= 0 {
            var entry = journal.get(i);
            undoJournalEntry(entry);
            i = i - 1;
        }

        // Rebuild indexes for all affected tables
        var t = 0;
        while t < txnDirtyTables.count() {
            var tblName = txnDirtyTables.get(t);
            var table = findTable(tblName);
            if table != null {
                var tbl = table;
                rebuildTableIndexes(tblName, tbl);
            }
            t = t + 1;
        }

        inTransaction = false;
        journal = [];
        txnDirtyTables = [];

        // Release all table locks held during the transaction
        releaseSessionLocks();

        result.message = "ROLLBACK";
        return result;
    }

    // Undo a single journal entry
    hide func undoJournalEntry(entry: JournalEntry) {
        var table = findTable(entry.tableName);
        if table == null { return; }
        var t = table;

        if entry.entryType == JOURNAL_INSERT {
            // Undo INSERT: remove the inserted row
            if entry.rowIndex < t.rowCount() {
                t.rows.removeAt(entry.rowIndex);
            }
        } else if entry.entryType == JOURNAL_DELETE {
            // Undo DELETE: unmark the soft-deleted row
            if entry.rowIndex < t.rowCount() {
                var row = t.getRow(entry.rowIndex);
                if row != null {
                    var r = row;
                    r.deleted = false;
                }
            }
        } else if entry.entryType == JOURNAL_UPDATE {
            // Undo UPDATE: restore old values from before image
            if entry.rowIndex < t.rowCount() {
                var row = t.getRow(entry.rowIndex);
                if row != null {
                    var r = row;
                    var c = 0;
                    while c < entry.beforeImage.columnCount() {
                        r.setValue(c, entry.beforeImage.getValue(c));
                        c = c + 1;
                    }
                }
            }
        }
    }

    // Compact a table by removing soft-deleted rows
    expose func compactTable(t: Table) {
        var compacted: List[Row] = [];
        var cr = 0;
        while cr < t.rowCount() {
            var checkRow = t.getRow(cr);
            if checkRow != null {
                var checkData = checkRow;
                if checkData.deleted == false {
                    compacted.add(checkData);
                }
            }
            cr = cr + 1;
        }
        t.rows = compacted;
    }

    // Undo journal entries back to a savepoint (for statement-level atomicity)
    expose func undoToSavepoint(savepoint: Integer) {
        var i = journal.count() - 1;
        while i >= savepoint {
            var entry = journal.get(i);
            undoJournalEntry(entry);
            i = i - 1;
        }
        // Remove undone entries from journal
        while journal.count() > savepoint {
            journal.removeAt(journal.count() - 1);
        }
        // Rebuild indexes for affected tables
        var t = 0;
        while t < txnDirtyTables.count() {
            var tblName = txnDirtyTables.get(t);
            var table = findTable(tblName);
            if table != null {
                var tbl = table;
                rebuildTableIndexes(tblName, tbl);
            }
            t = t + 1;
        }
    }

    // Track a table as modified (for transaction rollback and statement atomicity)
    expose func markTableDirty(tableName: String) {
        // Check if already tracked
        var i = 0;
        while i < txnDirtyTables.count() {
            if txnDirtyTables.get(i) == tableName {
                return;
            }
            i = i + 1;
        }
        txnDirtyTables.add(tableName);
    }

    // Record a journal entry for INSERT (always records for statement-level atomicity)
    expose func journalInsert(tableName: String, rowIndex: Integer) {
        var entry = new JournalEntry();
        entry.init();
        entry.initInsert(tableName, rowIndex);
        journal.add(entry);
        markTableDirty(tableName);
    }

    // Record a journal entry for DELETE (always records for statement-level atomicity)
    expose func journalDelete(tableName: String, rowIndex: Integer, row: Row) {
        var entry = new JournalEntry();
        entry.init();
        entry.initDelete(tableName, rowIndex, row);
        journal.add(entry);
        markTableDirty(tableName);
    }

    // Record a journal entry for UPDATE (deep-copy before image)
    expose func journalUpdate(tableName: String, rowIndex: Integer, row: Row) {
        // Deep-copy the row as before image
        var copy = new Row();
        copy.initWithCount(row.columnCount());
        var c = 0;
        while c < row.columnCount() {
            var val = row.getValue(c);
            copy.setValue(c, val);
            c = c + 1;
        }
        var entry = new JournalEntry();
        entry.init();
        entry.initUpdate(tableName, rowIndex, copy);
        journal.add(entry);
        markTableDirty(tableName);
    }

    // Clear the journal after a successful non-transactional statement
    expose func clearStatementJournal() {
        if inTransaction == false {
            journal = [];
            txnDirtyTables = [];
        }
    }

    // DDL, DML, and query functions are delegated to handler entities.
    // See ddl.zia (DdlHandler), dml.zia (DmlHandler), query.zia (QueryHandler).

}
