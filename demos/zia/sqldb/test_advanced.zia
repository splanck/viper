// test_advanced.zia - Tests for Phase 11: Advanced Features
// Part of SQLite Clone - ViperLang Implementation

module test_advanced;

bind "./executor";

//=============================================================================
// TEST UTILITIES
//=============================================================================

Integer passed = 0;
Integer failed = 0;

func assertTrue(cond: Boolean, desc: String) {
    if cond {
        Viper.Terminal.Say("  PASS: " + desc);
        passed = passed + 1;
    } else {
        Viper.Terminal.Say("  FAIL: " + desc);
        failed = failed + 1;
    }
}

func assertFalse(cond: Boolean, desc: String) {
    assertTrue(cond == false, desc);
}

//=============================================================================
// TESTS
//=============================================================================

func testUnion() {
    Viper.Terminal.Say("Testing UNION...");
    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE t1 (id INTEGER, name TEXT)");
    exec.executeSql("CREATE TABLE t2 (id INTEGER, name TEXT)");

    exec.executeSql("INSERT INTO t1 VALUES (1, 'Alice')");
    exec.executeSql("INSERT INTO t1 VALUES (2, 'Bob')");
    exec.executeSql("INSERT INTO t2 VALUES (2, 'Bob')");
    exec.executeSql("INSERT INTO t2 VALUES (3, 'Charlie')");

    // UNION removes duplicates
    var result = exec.executeSql("SELECT id, name FROM t1 UNION SELECT id, name FROM t2");
    assertTrue(result.success, "UNION should succeed");
    assertTrue(result.rowCount() == 3, "UNION should return 3 unique rows (Alice, Bob, Charlie)");
}

func testUnionAll() {
    Viper.Terminal.Say("Testing UNION ALL...");
    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE t1 (id INTEGER, name TEXT)");
    exec.executeSql("CREATE TABLE t2 (id INTEGER, name TEXT)");

    exec.executeSql("INSERT INTO t1 VALUES (1, 'Alice')");
    exec.executeSql("INSERT INTO t1 VALUES (2, 'Bob')");
    exec.executeSql("INSERT INTO t2 VALUES (2, 'Bob')");
    exec.executeSql("INSERT INTO t2 VALUES (3, 'Charlie')");

    // UNION ALL keeps duplicates
    var result = exec.executeSql("SELECT id, name FROM t1 UNION ALL SELECT id, name FROM t2");
    assertTrue(result.success, "UNION ALL should succeed");
    assertTrue(result.rowCount() == 4, "UNION ALL should return 4 rows (with duplicate Bob)");
}

func testCaseExpression() {
    Viper.Terminal.Say("Testing CASE expressions...");
    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE products (name TEXT, price INTEGER)");
    exec.executeSql("INSERT INTO products VALUES ('Apple', 50)");
    exec.executeSql("INSERT INTO products VALUES ('Banana', 100)");
    exec.executeSql("INSERT INTO products VALUES ('Cherry', 200)");

    // Simple CASE expression
    var result = exec.executeSql("SELECT name, CASE WHEN price < 75 THEN 'cheap' WHEN price < 150 THEN 'medium' ELSE 'expensive' END FROM products");
    assertTrue(result.success, "CASE expression should succeed");
    assertTrue(result.rowCount() == 3, "Should return 3 rows");

    // Check the first row (Apple = 50, should be 'cheap')
    var row0 = result.getRow(0);
    if row0 != null {
        var r = row0;
        assertTrue(r.getValue(1).textValue == "cheap", "Apple should be 'cheap'");
    }

    // Check the second row (Banana = 100, should be 'medium')
    var row1 = result.getRow(1);
    if row1 != null {
        var r = row1;
        assertTrue(r.getValue(1).textValue == "medium", "Banana should be 'medium'");
    }

    // Check the third row (Cherry = 200, should be 'expensive')
    var row2 = result.getRow(2);
    if row2 != null {
        var r = row2;
        assertTrue(r.getValue(1).textValue == "expensive", "Cherry should be 'expensive'");
    }
}

func testCaseWithoutElse() {
    Viper.Terminal.Say("Testing CASE without ELSE...");
    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE scores (name TEXT, score INTEGER)");
    exec.executeSql("INSERT INTO scores VALUES ('Alice', 90)");
    exec.executeSql("INSERT INTO scores VALUES ('Bob', 50)");

    // CASE without ELSE returns NULL when no condition matches
    var result = exec.executeSql("SELECT name, CASE WHEN score >= 80 THEN 'pass' END FROM scores");
    assertTrue(result.success, "CASE without ELSE should succeed");
    assertTrue(result.rowCount() == 2, "Should return 2 rows");

    // Bob's score (50) shouldn't match, should be NULL
    var row1 = result.getRow(1);
    if row1 != null {
        var r = row1;
        assertTrue(r.getValue(1).isNull(), "Bob should have NULL (no matching condition)");
    }
}

func testCaseInWhere() {
    Viper.Terminal.Say("Testing CASE in WHERE clause...");
    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE items (name TEXT, category TEXT, price INTEGER)");
    exec.executeSql("INSERT INTO items VALUES ('Apple', 'fruit', 50)");
    exec.executeSql("INSERT INTO items VALUES ('Laptop', 'electronics', 1000)");
    exec.executeSql("INSERT INTO items VALUES ('Banana', 'fruit', 30)");

    // Use CASE in WHERE to apply different price thresholds by category
    var result = exec.executeSql("SELECT name FROM items WHERE price > CASE WHEN category = 'fruit' THEN 40 ELSE 500 END");
    assertTrue(result.success, "CASE in WHERE should succeed");
    assertTrue(result.rowCount() == 2, "Should return 2 rows (Apple > 40, Laptop > 500)");
}

//=============================================================================
// EXCEPT TESTS (Phase 8)
//=============================================================================

func testExcept() {
    Viper.Terminal.Say("Testing EXCEPT...");
    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE t1 (id INTEGER, name TEXT)");
    exec.executeSql("CREATE TABLE t2 (id INTEGER, name TEXT)");

    exec.executeSql("INSERT INTO t1 VALUES (1, 'Alice')");
    exec.executeSql("INSERT INTO t1 VALUES (2, 'Bob')");
    exec.executeSql("INSERT INTO t1 VALUES (3, 'Charlie')");
    exec.executeSql("INSERT INTO t2 VALUES (2, 'Bob')");
    exec.executeSql("INSERT INTO t2 VALUES (4, 'Diana')");

    // EXCEPT returns rows in first that are not in second
    var result = exec.executeSql("SELECT id, name FROM t1 EXCEPT SELECT id, name FROM t2");
    assertTrue(result.success, "EXCEPT should succeed");
    assertTrue(result.rowCount() == 2, "EXCEPT should return 2 rows (Alice, Charlie - not Bob)");
}

func testExceptWithDuplicates() {
    Viper.Terminal.Say("Testing EXCEPT with duplicates...");
    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE t1 (id INTEGER, name TEXT)");
    exec.executeSql("CREATE TABLE t2 (id INTEGER, name TEXT)");

    // t1 has duplicate rows
    exec.executeSql("INSERT INTO t1 VALUES (1, 'Alice')");
    exec.executeSql("INSERT INTO t1 VALUES (1, 'Alice')");
    exec.executeSql("INSERT INTO t1 VALUES (2, 'Bob')");
    exec.executeSql("INSERT INTO t2 VALUES (2, 'Bob')");

    // EXCEPT removes duplicates from first result
    var result = exec.executeSql("SELECT id, name FROM t1 EXCEPT SELECT id, name FROM t2");
    assertTrue(result.success, "EXCEPT with duplicates should succeed");
    assertTrue(result.rowCount() == 1, "EXCEPT should return 1 row (Alice, deduplicated)");
}

//=============================================================================
// INTERSECT TESTS (Phase 8)
//=============================================================================

func testIntersect() {
    Viper.Terminal.Say("Testing INTERSECT...");
    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE t1 (id INTEGER, name TEXT)");
    exec.executeSql("CREATE TABLE t2 (id INTEGER, name TEXT)");

    exec.executeSql("INSERT INTO t1 VALUES (1, 'Alice')");
    exec.executeSql("INSERT INTO t1 VALUES (2, 'Bob')");
    exec.executeSql("INSERT INTO t1 VALUES (3, 'Charlie')");
    exec.executeSql("INSERT INTO t2 VALUES (2, 'Bob')");
    exec.executeSql("INSERT INTO t2 VALUES (3, 'Charlie')");
    exec.executeSql("INSERT INTO t2 VALUES (4, 'Diana')");

    // INTERSECT returns rows that exist in both
    var result = exec.executeSql("SELECT id, name FROM t1 INTERSECT SELECT id, name FROM t2");
    assertTrue(result.success, "INTERSECT should succeed");
    assertTrue(result.rowCount() == 2, "INTERSECT should return 2 rows (Bob, Charlie)");
}

func testIntersectWithDuplicates() {
    Viper.Terminal.Say("Testing INTERSECT with duplicates...");
    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE t1 (id INTEGER, name TEXT)");
    exec.executeSql("CREATE TABLE t2 (id INTEGER, name TEXT)");

    // Both tables have duplicate rows that match
    exec.executeSql("INSERT INTO t1 VALUES (1, 'Alice')");
    exec.executeSql("INSERT INTO t1 VALUES (1, 'Alice')");
    exec.executeSql("INSERT INTO t2 VALUES (1, 'Alice')");
    exec.executeSql("INSERT INTO t2 VALUES (1, 'Alice')");

    // INTERSECT removes duplicates
    var result = exec.executeSql("SELECT id, name FROM t1 INTERSECT SELECT id, name FROM t2");
    assertTrue(result.success, "INTERSECT with duplicates should succeed");
    assertTrue(result.rowCount() == 1, "INTERSECT should return 1 row (Alice, deduplicated)");
}

func testIntersectNoMatch() {
    Viper.Terminal.Say("Testing INTERSECT with no matching rows...");
    var exec = new Executor();
    exec.init();

    exec.executeSql("CREATE TABLE t1 (id INTEGER, name TEXT)");
    exec.executeSql("CREATE TABLE t2 (id INTEGER, name TEXT)");

    exec.executeSql("INSERT INTO t1 VALUES (1, 'Alice')");
    exec.executeSql("INSERT INTO t2 VALUES (2, 'Bob')");

    // No matching rows
    var result = exec.executeSql("SELECT id, name FROM t1 INTERSECT SELECT id, name FROM t2");
    assertTrue(result.success, "INTERSECT with no match should succeed");
    assertTrue(result.rowCount() == 0, "INTERSECT should return 0 rows");
}

//=============================================================================
// MAIN
//=============================================================================

func start() {
    Viper.Terminal.Say("=== Phase 11: Advanced Features Tests ===");
    Viper.Terminal.Say("");

    testUnion();
    testUnionAll();
    testCaseExpression();
    testCaseWithoutElse();
    testCaseInWhere();

    // Phase 8: EXCEPT and INTERSECT
    testExcept();
    testExceptWithDuplicates();
    testIntersect();
    testIntersectWithDuplicates();
    testIntersectNoMatch();

    Viper.Terminal.Say("");
    Viper.Terminal.Say("=== Results ===");
    Viper.Terminal.Say("Passed: " + Viper.Fmt.Int(passed));
    Viper.Terminal.Say("Failed: " + Viper.Fmt.Int(failed));
}
