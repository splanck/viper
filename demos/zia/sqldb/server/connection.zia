// connection.zia — SQL Connection Handler
// Part of ViperSQL - Multi-User Foundation (Phase 7) + PG Wire Protocol (Phase 9)
//
// Handles client TCP connections in two modes:
//   1. PG Wire Protocol (Phase 9) — Binary PostgreSQL v3 protocol for psql/JDBC/ODBC
//   2. Text Protocol (Phase 7) — Simple text-based protocol for nc/telnet
//
// The server auto-detects the protocol based on the first bytes received.

module connection;

bind Terminal = Viper.Terminal;
bind String = Viper.String;
bind Network = Viper.Network;
bind Fmt = Viper.Fmt;
bind Threads = Viper.Threads;
bind Viper.Collections;

bind "../executor";
bind "../result";
bind "../server";
bind "../session";
bind "../types";
bind "./pg_wire";

//=============================================================================
// CONSTANTS
//=============================================================================

final SQL_MAX_QUERY_SIZE = 65536;    // 64KB max query
final SQL_RECV_TIMEOUT = 300000;     // 5 minute idle timeout

//=============================================================================
// SHARED SERVER STATE
//=============================================================================

// The shared DatabaseServer — set by sql_server_init() before accepting connections
var shared_server: DatabaseServer;

// Session counter (protected by Monitor)
var session_counter: Integer;
var session_lock: List[Integer];

// Server statistics
var active_connections: Integer;
var total_queries: Integer;

//=============================================================================
// INITIALIZATION
//=============================================================================

// Initialize the connection module with a shared DatabaseServer
func sql_connection_init(server: DatabaseServer) {
    shared_server = server;
    session_counter = 0;
    session_lock = [];
    active_connections = 0;
    total_queries = 0;
}

// Get a new session ID (thread-safe)
func nextSessionId() -> Integer {
    Threads.Monitor.Enter(session_lock);
    session_counter = session_counter + 1;
    var id = session_counter;
    Threads.Monitor.Exit(session_lock);
    return id;
}

// Increment active connection count
func connectionOpened() {
    Threads.Monitor.Enter(session_lock);
    active_connections = active_connections + 1;
    Threads.Monitor.Exit(session_lock);
}

// Decrement active connection count
func connectionClosed() {
    Threads.Monitor.Enter(session_lock);
    active_connections = active_connections - 1;
    Threads.Monitor.Exit(session_lock);
}

// Increment query count
func queryExecuted() {
    Threads.Monitor.Enter(session_lock);
    total_queries = total_queries + 1;
    Threads.Monitor.Exit(session_lock);
}

// Get current active connection count
func sql_getActiveConnections() -> Integer {
    return active_connections;
}

// Get total queries executed
func sql_getTotalQueries() -> Integer {
    return total_queries;
}

//=============================================================================
// PG WIRE PROTOCOL CONNECTION HANDLER (Phase 9)
//=============================================================================

// Handle a PostgreSQL wire protocol client connection.
// Called by the thread pool worker for each accepted connection.
func handlePgClient(client: Ptr) {
    var clientHost = Network.Tcp.get_Host(client);
    var sessionId = nextSessionId();
    connectionOpened();

    Terminal.Say("[PG Session " + Fmt.Int(sessionId) + "] Connected from " + clientHost);

    // Set recv timeout
    Network.Tcp.SetRecvTimeout(client, SQL_RECV_TIMEOUT);

    // Perform PG startup handshake (SSL negotiation, password exchange)
    var startupInfo = pgHandleStartup(client, sessionId, true);
    if startupInfo == null {
        Terminal.Say("[PG Session " + Fmt.Int(sessionId) + "] Startup failed, closing");
        connectionClosed();
        Network.Tcp.Close(client);
        return;
    }
    var info = startupInfo;

    // Verify credentials against server user database
    if shared_server.verifyPassword(info.user, info.password) == false {
        pgSendErrorResponse(client, "28P01", "password authentication failed for user \"" + info.user + "\"");
        Terminal.Say("[PG Session " + Fmt.Int(sessionId) + "] Auth failed for " + info.user);
        connectionClosed();
        Network.Tcp.Close(client);
        return;
    }

    // Auth successful — complete handshake (AuthOk, params, BackendKeyData, ReadyForQuery)
    pgCompleteStartup(client, sessionId, info.user);

    // Create a per-connection session with its own executor
    var session = new Session();
    session.initWithServer(sessionId, clientHost, shared_server);
    session.username = info.user;
    session.authenticated = true;
    session.executor.setCurrentUser(info.user);

    // Switch to requested database if specified
    if info.database != "" && info.database != "main" {
        var useResult = session.executeSql("USE " + info.database);
        if useResult.success == false {
            // Database doesn't exist — send error but continue on 'main'
            pgSendNotice(client, "database \"" + info.database + "\" does not exist, using \"main\"");
        }
    }

    Terminal.Say("[PG Session " + Fmt.Int(sessionId) + "] User=" + info.user + " DB=" + session.executor.currentDbName);

    // Main query loop — read messages and respond
    var running = true;
    var inErrorRecovery = false;
    while running {
        var msg = pgReadMessage(client);

        if msg.valid == false {
            // Connection closed or read error
            running = false;
        } else if msg.msgType == PG_QUERY {
            // Simple Query protocol
            inErrorRecovery = false;
            var query = pgExtractQuery(msg.body);
            handlePgQuery(client, session, query);
        } else if msg.msgType == PG_TERMINATE {
            // Client wants to disconnect
            running = false;

        // Extended query protocol (Phase 11)
        } else if msg.msgType == PG_PARSE {
            if inErrorRecovery == false {
                var ok = handlePgParse(client, session, msg.body);
                if ok == false { inErrorRecovery = true; }
            }
        } else if msg.msgType == PG_BIND {
            if inErrorRecovery == false {
                var ok = handlePgBind(client, session, msg.body);
                if ok == false { inErrorRecovery = true; }
            }
        } else if msg.msgType == PG_DESCRIBE {
            if inErrorRecovery == false {
                var ok = handlePgDescribe(client, session, msg.body);
                if ok == false { inErrorRecovery = true; }
            }
        } else if msg.msgType == PG_EXECUTE {
            if inErrorRecovery == false {
                var ok = handlePgExecute(client, session, msg.body);
                if ok == false { inErrorRecovery = true; }
            }
        } else if msg.msgType == PG_CLOSE_MSG {
            if inErrorRecovery == false {
                handlePgClose(client, session, msg.body);
            }
        } else if msg.msgType == PG_FLUSH {
            // Flush — no-op (we send responses immediately)
        } else if msg.msgType == PG_SYNC {
            // Sync — end of extended query batch
            inErrorRecovery = false;
            pgSendReadyForQuery(client, getTxnStatus(session));
        } else {
            // Unknown message type — ignore silently
        }
    }

    // Cleanup: roll back any active transaction
    session.executeSql("ROLLBACK");
    session.disconnect();

    Terminal.Say("[PG Session " + Fmt.Int(sessionId) + "] Disconnected");
    connectionClosed();
    Network.Tcp.Close(client);
}

// Handle a single PG Query message
func handlePgQuery(client: Ptr, session: Session, query: String) {
    var trimmed = String.Trim(query);

    // Empty query
    if String.Length(trimmed) == 0 {
        pgSendEmptyQueryResponse(client);
        pgSendReadyForQuery(client, getTxnStatus(session));
        return;
    }

    // Handle multiple semicolon-separated queries (psql sends these)
    // For simplicity, split on ';' and execute each
    var queries = splitQueries(trimmed);
    var qi = 0;
    while qi < queries.count() {
        var q = String.Trim(queries.get(qi));
        if String.Length(q) > 0 {
            executePgSingleQuery(client, session, q);
        }
        qi = qi + 1;
    }

    // Send ReadyForQuery after all queries in the batch
    pgSendReadyForQuery(client, getTxnStatus(session));
}

// Execute a single query and send PG wire protocol responses
func executePgSingleQuery(client: Ptr, session: Session, query: String) {
    queryExecuted();

    // Intercept PG-specific SET commands that our executor doesn't handle
    var upper = String.ToUpper(query);
    if isPgSetCommand(upper) {
        pgSendCommandComplete(client, "SET");
        return;
    }

    // Intercept pg_catalog queries (sent by psql on connect)
    if isPgCatalogQuery(upper) {
        sendEmptySelectResult(client, query);
        return;
    }

    // Execute the query
    var result = session.executeSql(query);

    if result.success == false {
        // Send error response
        pgSendErrorResponse(client, "42000", result.message);
        return;
    }

    // Determine if this is a SELECT-type query (has column names)
    if result.columnNames.count() > 0 {
        // Send RowDescription
        pgSendRowDescription(client, result.columnNames);

        // Send DataRows
        var ri = 0;
        while ri < result.rows.count() {
            var row = result.rows.get(ri);
            var values: List[String] = [];
            var nullFlags: List[Integer] = [];

            var ci = 0;
            while ci < row.columnCount() {
                var val = row.getValue(ci);
                if val.isNull() {
                    values.add("");
                    nullFlags.add(1);
                } else {
                    values.add(val.toString());
                    nullFlags.add(0);
                }
                ci = ci + 1;
            }

            pgSendDataRow(client, values, nullFlags);
            ri = ri + 1;
        }

        // Send CommandComplete
        var tag = pgCommandTag(query, result.rowsAffected, result.rows.count());
        pgSendCommandComplete(client, tag);
    } else {
        // Non-SELECT: just CommandComplete
        var tag = pgCommandTag(query, result.rowsAffected, 0);
        pgSendCommandComplete(client, tag);
    }
}

// Get the PG transaction status byte for ReadyForQuery
func getTxnStatus(session: Session) -> Integer {
    if session.executor.isInTransaction() {
        return PG_TXN_IN_TXN;
    }
    return PG_TXN_IDLE;
}

// Check if this is a PG-specific SET command we should handle silently
func isPgSetCommand(upper: String) -> Boolean {
    if stringStartsWithConn(upper, "SET CLIENT_ENCODING") { return true; }
    if stringStartsWithConn(upper, "SET DATESTYLE") { return true; }
    if stringStartsWithConn(upper, "SET TIMEZONE") { return true; }
    if stringStartsWithConn(upper, "SET EXTRA_FLOAT_DIGITS") { return true; }
    if stringStartsWithConn(upper, "SET APPLICATION_NAME") { return true; }
    if stringStartsWithConn(upper, "SET SEARCH_PATH") { return true; }
    if stringStartsWithConn(upper, "SET INTERVALSTYLE") { return true; }
    if stringStartsWithConn(upper, "SET LOCK_TIMEOUT") { return true; }
    if stringStartsWithConn(upper, "SET STATEMENT_TIMEOUT") { return true; }
    if stringStartsWithConn(upper, "SET IDLE_IN_TRANSACTION_SESSION_TIMEOUT") { return true; }
    if stringStartsWithConn(upper, "SET ROW_SECURITY") { return true; }
    if stringStartsWithConn(upper, "RESET") { return true; }
    return false;
}

// Check if this is a pg_catalog system query (sent by psql/drivers on connect)
func isPgCatalogQuery(upper: String) -> Boolean {
    if stringContainsConn(upper, "PG_CATALOG") { return true; }
    if stringContainsConn(upper, "PG_CLASS") { return true; }
    if stringContainsConn(upper, "PG_NAMESPACE") { return true; }
    if stringContainsConn(upper, "PG_ATTRIBUTE") { return true; }
    if stringContainsConn(upper, "PG_TYPE") { return true; }
    if stringContainsConn(upper, "PG_SETTINGS") { return true; }
    if stringContainsConn(upper, "PG_DATABASE") { return true; }
    if stringContainsConn(upper, "PG_ROLES") { return true; }
    if stringContainsConn(upper, "PG_USER") { return true; }
    if stringContainsConn(upper, "PG_PROC") { return true; }
    if stringContainsConn(upper, "CURRENT_SCHEMA") { return true; }
    // version() function call
    if upper == "SELECT VERSION()" { return true; }
    return false;
}

//=============================================================================
// EXTENDED QUERY PROTOCOL HANDLERS (Phase 11)
//=============================================================================

// Handle Parse message — create a prepared statement
// Returns true on success, false if error was sent
func handlePgParse(client: Ptr, session: Session, body: Bytes) -> Boolean {
    var parsed = pgParseParse(body);

    // If unnamed statement, replace any existing one
    if parsed.stmtName == "" {
        session.removePreparedStmt("");
    } else {
        // Named statement — check for duplicate
        var existing = session.findPreparedStmt(parsed.stmtName);
        if existing != null {
            pgSendErrorResponse(client, "42P05", "prepared statement \"" + parsed.stmtName + "\" already exists");
            return false;
        }
    }

    var stmt = new PreparedStatement();
    stmt.init();
    stmt.name = parsed.stmtName;
    stmt.query = parsed.query;
    stmt.paramCount = countParams(parsed.query);
    stmt.paramOids = parsed.paramOids;

    session.addPreparedStmt(stmt);
    pgSendParseComplete(client);
    return true;
}

// Handle Bind message — bind parameters to create a portal
// Returns true on success, false if error was sent
func handlePgBind(client: Ptr, session: Session, body: Bytes) -> Boolean {
    var parsed = pgParseBind(body);

    // Find the prepared statement
    var maybeStmt = session.findPreparedStmt(parsed.stmtName);
    if maybeStmt == null {
        pgSendErrorResponse(client, "26000", "prepared statement \"" + parsed.stmtName + "\" does not exist");
        return false;
    }
    var stmt = maybeStmt;

    // Substitute parameters into the query
    var boundQuery = substituteParams(stmt.query, parsed.paramValues, parsed.paramNulls);

    // If unnamed portal, replace any existing one
    if parsed.portalName == "" {
        session.removePortal("");
    } else {
        var existing = session.findPortal(parsed.portalName);
        if existing != null {
            pgSendErrorResponse(client, "42P03", "cursor \"" + parsed.portalName + "\" already exists");
            return false;
        }
    }

    var portal = new Portal();
    portal.init();
    portal.name = parsed.portalName;
    portal.stmtName = parsed.stmtName;
    portal.boundQuery = boundQuery;

    session.addPortal(portal);
    pgSendBindComplete(client);
    return true;
}

// Handle Describe message — describe a statement or portal
// Returns true on success, false if error was sent
func handlePgDescribe(client: Ptr, session: Session, body: Bytes) -> Boolean {
    var parsed = pgParseDescribe(body);

    if parsed.describeType == 83 {
        // 'S' — Describe Statement
        var maybeStmt = session.findPreparedStmt(parsed.name);
        if maybeStmt == null {
            pgSendErrorResponse(client, "26000", "prepared statement \"" + parsed.name + "\" does not exist");
            return false;
        }
        var stmt = maybeStmt;

        // Send ParameterDescription
        var paramOids: List[Integer] = [];
        var pi = 0;
        while pi < stmt.paramCount {
            if pi < stmt.paramOids.count() && stmt.paramOids.get(pi) != 0 {
                paramOids.add(stmt.paramOids.get(pi));
            } else {
                paramOids.add(PG_OID_TEXT);
            }
            pi = pi + 1;
        }
        pgSendParameterDescription(client, paramOids);

        // Try to determine result columns by executing with NULLs substituted
        var queryForDesc = substituteAllNull(stmt.query, stmt.paramCount);
        var upperQ = String.ToUpper(String.Trim(queryForDesc));
        if stringStartsWithConn(upperQ, "SELECT") || stringStartsWithConn(upperQ, "SHOW") || stringStartsWithConn(upperQ, "WITH") {
            // Execute to get column info
            var result = session.executeSql(queryForDesc);
            if result.success && result.columnNames.count() > 0 {
                var oids = inferColumnOids(result);
                pgSendRowDescriptionTyped(client, result.columnNames, oids);
            } else {
                pgSendNoData(client);
            }
        } else {
            pgSendNoData(client);
        }
        return true;

    } else if parsed.describeType == 80 {
        // 'P' — Describe Portal
        var maybePortal = session.findPortal(parsed.name);
        if maybePortal == null {
            pgSendErrorResponse(client, "34000", "cursor \"" + parsed.name + "\" does not exist");
            return false;
        }
        var portal = maybePortal;

        // Execute the portal if not already done to get column info
        if portal.executed == false {
            var result = session.executeSql(portal.boundQuery);
            portal.result = result;
            portal.executed = true;
        }

        if portal.result.success && portal.result.columnNames.count() > 0 {
            var oids = inferColumnOids(portal.result);
            pgSendRowDescriptionTyped(client, portal.result.columnNames, oids);
            portal.descSent = true;
        } else {
            pgSendNoData(client);
        }
        return true;
    }

    pgSendErrorResponse(client, "08P01", "invalid Describe message type");
    return false;
}

// Handle Execute message — execute a portal and send results
// Returns true on success, false if error was sent
func handlePgExecute(client: Ptr, session: Session, body: Bytes) -> Boolean {
    var parsed = pgParseExecute(body);

    var maybePortal = session.findPortal(parsed.portalName);
    if maybePortal == null {
        pgSendErrorResponse(client, "34000", "cursor \"" + parsed.portalName + "\" does not exist");
        return false;
    }
    var portal = maybePortal;

    // Execute the portal query if not yet done
    if portal.executed == false {
        queryExecuted();

        // Intercept PG-specific SET commands
        var upper = String.ToUpper(portal.boundQuery);
        if isPgSetCommand(upper) {
            portal.executed = true;
            var setResult = new QueryResult();
            setResult.init();
            setResult.message = "SET";
            portal.result = setResult;
            pgSendCommandComplete(client, "SET");
            return true;
        }

        // Intercept pg_catalog queries
        if isPgCatalogQuery(upper) {
            portal.executed = true;
            var catResult = new QueryResult();
            catResult.init();
            portal.result = catResult;
            sendEmptySelectResult(client, portal.boundQuery);
            return true;
        }

        var result = session.executeSql(portal.boundQuery);
        portal.result = result;
        portal.executed = true;
    }

    // Check for execution error
    if portal.result.success == false {
        pgSendErrorResponse(client, "42000", portal.result.message);
        return false;
    }

    // Send results
    if portal.result.columnNames.count() > 0 {
        // SELECT-like: send DataRows
        var totalRows = portal.result.rows.count();
        var startRow = portal.rowsSent;

        // Determine end row
        var endRow = totalRows;
        if parsed.maxRows > 0 && startRow + parsed.maxRows < totalRows {
            endRow = startRow + parsed.maxRows;
        }

        // Send DataRows
        var ri = startRow;
        while ri < endRow {
            var row = portal.result.rows.get(ri);
            var values: List[String] = [];
            var nullFlags: List[Integer] = [];

            var ci = 0;
            while ci < row.columnCount() {
                var val = row.getValue(ci);
                if val.isNull() {
                    values.add("");
                    nullFlags.add(1);
                } else {
                    values.add(val.toString());
                    nullFlags.add(0);
                }
                ci = ci + 1;
            }

            pgSendDataRow(client, values, nullFlags);
            ri = ri + 1;
        }

        portal.rowsSent = endRow;

        // Check if more rows remain (portal suspension)
        if endRow < totalRows {
            pgSendPortalSuspended(client);
        } else {
            var tag = pgCommandTag(portal.boundQuery, portal.result.rowsAffected, totalRows);
            pgSendCommandComplete(client, tag);
        }
    } else {
        // DML/DDL: just CommandComplete
        var tag = pgCommandTag(portal.boundQuery, portal.result.rowsAffected, 0);
        pgSendCommandComplete(client, tag);
    }

    return true;
}

// Handle Close message — close a statement or portal
func handlePgClose(client: Ptr, session: Session, body: Bytes) {
    var parsed = pgParseClose(body);

    if parsed.closeType == 83 {
        // 'S' — Close Statement
        session.removePreparedStmt(parsed.name);
    } else if parsed.closeType == 80 {
        // 'P' — Close Portal
        session.removePortal(parsed.name);
    }

    pgSendCloseComplete(client);
}

//=============================================================================
// PARAMETER SUBSTITUTION (Phase 11)
//=============================================================================

// Count the highest $N parameter placeholder in a query
func countParams(query: String) -> Integer {
    var maxParam = 0;
    var len = String.Length(query);
    var inQuote = false;
    var i = 0;

    while i < len {
        var ch = String.Substring(query, i, 1);
        if ch == "'" {
            inQuote = !inQuote;
            i = i + 1;
        } else if ch == "$" && inQuote == false {
            // Read digits after $
            var numStr = "";
            var j = i + 1;
            while j < len {
                var digit = String.Substring(query, j, 1);
                var code = String.Asc(digit);
                if code >= 48 && code <= 57 {
                    numStr = numStr + digit;
                    j = j + 1;
                } else {
                    break;
                }
            }
            if String.Length(numStr) > 0 {
                var paramNum = stringToInt(numStr);
                if paramNum > maxParam {
                    maxParam = paramNum;
                }
            }
            i = j;
        } else {
            i = i + 1;
        }
    }

    return maxParam;
}

// Substitute $1, $2, ... in a query with actual parameter values
func substituteParams(query: String, paramValues: List[String], paramNulls: List[Integer]) -> String {
    var result = "";
    var len = String.Length(query);
    var inQuote = false;
    var i = 0;

    while i < len {
        var ch = String.Substring(query, i, 1);

        if ch == "'" {
            inQuote = !inQuote;
            result = result + ch;
            i = i + 1;
        } else if ch == "$" && inQuote == false {
            // Read digits after $
            var numStr = "";
            var j = i + 1;
            while j < len {
                var digit = String.Substring(query, j, 1);
                var code = String.Asc(digit);
                if code >= 48 && code <= 57 {
                    numStr = numStr + digit;
                    j = j + 1;
                } else {
                    break;
                }
            }

            if String.Length(numStr) > 0 {
                var paramIdx = stringToInt(numStr) - 1;
                if paramIdx >= 0 && paramIdx < paramValues.count() {
                    if paramNulls.get(paramIdx) == 1 {
                        result = result + "NULL";
                    } else {
                        var val = paramValues.get(paramIdx);
                        if isNumericParam(val) {
                            result = result + val;
                        } else {
                            result = result + "'" + escapeParamString(val) + "'";
                        }
                    }
                } else {
                    // Parameter index out of range — leave as-is
                    result = result + "$" + numStr;
                }
                i = j;
            } else {
                result = result + ch;
                i = i + 1;
            }
        } else {
            result = result + ch;
            i = i + 1;
        }
    }

    return result;
}

// Replace all $N with NULL for Describe on unbound statements
func substituteAllNull(query: String, paramCount: Integer) -> String {
    var nullValues: List[String] = [];
    var nullFlags: List[Integer] = [];
    var i = 0;
    while i < paramCount {
        nullValues.add("");
        nullFlags.add(1);
        i = i + 1;
    }
    return substituteParams(query, nullValues, nullFlags);
}

// Check if a string looks like a numeric value
func isNumericParam(val: String) -> Boolean {
    var len = String.Length(val);
    if len == 0 { return false; }

    var start = 0;
    var firstCh = String.Substring(val, 0, 1);
    if firstCh == "-" || firstCh == "+" {
        start = 1;
        if len == 1 { return false; }
    }

    var hasDot = false;
    var i = start;
    while i < len {
        var ch = String.Substring(val, i, 1);
        var code = String.Asc(ch);
        if code >= 48 && code <= 57 {
            // digit — ok
        } else if ch == "." && hasDot == false {
            hasDot = true;
        } else {
            return false;
        }
        i = i + 1;
    }
    return true;
}

// Escape single quotes in a parameter value (double them)
func escapeParamString(val: String) -> String {
    var result = "";
    var len = String.Length(val);
    var i = 0;
    while i < len {
        var ch = String.Substring(val, i, 1);
        if ch == "'" {
            result = result + "''";
        } else {
            result = result + ch;
        }
        i = i + 1;
    }
    return result;
}

//=============================================================================
// TYPE OID INFERENCE (Phase 11)
//=============================================================================

// Infer PostgreSQL type OIDs from the first row's SqlValue kinds
func inferColumnOids(result: QueryResult) -> List[Integer] {
    var oids: List[Integer] = [];
    var ci = 0;
    while ci < result.columnNames.count() {
        if result.rowCount() > 0 {
            var maybeRow = result.getRow(0);
            if maybeRow != null {
                var row = maybeRow;
                if ci < row.columnCount() {
                    var val = row.getValue(ci);
                    if val.kind == SQL_INTEGER {
                        oids.add(PG_OID_INT4);
                    } else if val.kind == SQL_REAL {
                        oids.add(PG_OID_FLOAT8);
                    } else if val.kind == SQL_BLOB {
                        oids.add(PG_OID_BYTEA);
                    } else if val.kind == SQL_BOOLEAN {
                        oids.add(PG_OID_BOOL);
                    } else if val.kind == SQL_DATE {
                        oids.add(PG_OID_DATE);
                    } else if val.kind == SQL_TIMESTAMP {
                        oids.add(PG_OID_TIMESTAMP);
                    } else {
                        oids.add(PG_OID_TEXT);
                    }
                } else {
                    oids.add(PG_OID_TEXT);
                }
            } else {
                oids.add(PG_OID_TEXT);
            }
        } else {
            oids.add(PG_OID_TEXT);
        }
        ci = ci + 1;
    }
    return oids;
}

//=============================================================================
// PG_CATALOG QUERY HANDLING
//=============================================================================

// Send an empty SELECT result (0 rows) for pg_catalog queries
func sendEmptySelectResult(client: Ptr, query: String) {
    // For version() queries, return a reasonable version string
    var upper = String.ToUpper(query);
    if upper == "SELECT VERSION()" {
        var cols: List[String] = [];
        cols.add("version");
        pgSendRowDescription(client, cols);

        var vals: List[String] = [];
        vals.add("ViperSQL 0.1 on Viper VM, 64-bit");
        var nulls: List[Integer] = [];
        nulls.add(0);
        pgSendDataRow(client, vals, nulls);

        pgSendCommandComplete(client, "SELECT 1");
        return;
    }

    // For all other pg_catalog queries, send empty result with no columns
    var emptyCols: List[String] = [];
    pgSendRowDescription(client, emptyCols);
    pgSendCommandComplete(client, "SELECT 0");
}

//=============================================================================
// TEXT PROTOCOL CONNECTION HANDLER (Phase 7 — preserved for compatibility)
//=============================================================================

// Handle a single SQL client connection using the simple text protocol.
func handleSqlClient(client: Ptr) {
    var clientHost = Network.Tcp.get_Host(client);
    var sessionId = nextSessionId();
    connectionOpened();

    // Create a per-connection session with its own executor
    var session = new Session();
    session.initWithServer(sessionId, clientHost, shared_server);
    session.authenticated = true;  // Text protocol uses trust mode

    Terminal.Say("[Session " + Fmt.Int(sessionId) + "] Connected from " + clientHost);

    // Set recv timeout
    Network.Tcp.SetRecvTimeout(client, SQL_RECV_TIMEOUT);

    // Send welcome banner
    var banner = "ViperSQL Server\nReady.\n\n";
    Network.Tcp.SendStr(client, banner);

    // Recv/execute/send loop
    var running = true;
    while running {
        // Receive a query (text terminated by newline)
        var rawQuery = Network.Tcp.RecvStr(client, SQL_MAX_QUERY_SIZE);

        // Empty recv = client disconnected or timeout
        if String.Length(rawQuery) == 0 {
            running = false;
        } else {
            // Trim whitespace
            var query = String.Trim(rawQuery);

            if String.Length(query) == 0 {
                // Empty query, just send ready prompt
                Network.Tcp.SendStr(client, "\n");
            } else if query == "quit" || query == "exit" || query == "\\q" {
                // Client wants to disconnect
                Network.Tcp.SendStr(client, "BYE\n\n");
                running = false;
            } else {
                // Execute the SQL query
                queryExecuted();
                var result = session.executeSql(query);

                // Format and send the result
                var response = formatResultForClient(result);
                Network.Tcp.SendStr(client, response);
            }
        }
    }

    // Cleanup: roll back any active transaction (no-op if none active)
    session.executeSql("ROLLBACK");
    session.disconnect();

    Terminal.Say("[Session " + Fmt.Int(sessionId) + "] Disconnected");
    connectionClosed();
    Network.Tcp.Close(client);
}

//=============================================================================
// RESULT FORMATTING (Text Protocol)
//=============================================================================

// Format a QueryResult as text for the client
// Uses tab-separated columns, newline-separated rows, double-newline terminator
func formatResultForClient(result: QueryResult) -> String {
    var output = "";

    if result.success == false {
        output = "ERROR: " + result.message + "\n\n";
        return output;
    }

    // Column headers
    if result.columnNames.count() > 0 {
        var i = 0;
        while i < result.columnNames.count() {
            if i > 0 {
                output = output + "\t";
            }
            output = output + result.columnNames.get(i);
            i = i + 1;
        }
        output = output + "\n";

        // Separator
        i = 0;
        while i < result.columnNames.count() {
            if i > 0 {
                output = output + "\t";
            }
            output = output + "--------";
            i = i + 1;
        }
        output = output + "\n";
    }

    // Data rows
    var rowIdx = 0;
    while rowIdx < result.rows.count() {
        var row = result.rows.get(rowIdx);
        var colIdx = 0;
        while colIdx < row.columnCount() {
            if colIdx > 0 {
                output = output + "\t";
            }
            output = output + row.getValue(colIdx).toString();
            colIdx = colIdx + 1;
        }
        output = output + "\n";
        rowIdx = rowIdx + 1;
    }

    // Status line
    if result.rowsAffected > 0 {
        output = output + "(" + Fmt.Int(result.rowsAffected) + " rows affected)\n";
    } else if result.rows.count() > 0 {
        output = output + "(" + Fmt.Int(result.rows.count()) + " rows)\n";
    }

    // Message (if any)
    if String.Length(result.message) > 0 && result.rows.count() == 0 {
        output = output + result.message + "\n";
    }

    // Double newline terminates the response
    output = output + "\n";
    return output;
}

//=============================================================================
// STRING HELPERS (local to avoid cross-module dependencies)
//=============================================================================

func stringStartsWithConn(s: String, prefix: String) -> Boolean {
    var prefixLen = String.Length(prefix);
    if String.Length(s) < prefixLen { return false; }
    return String.Substring(s, 0, prefixLen) == prefix;
}

func stringContainsConn(s: String, sub: String) -> Boolean {
    var sLen = String.Length(s);
    var subLen = String.Length(sub);
    if subLen > sLen { return false; }
    var i = 0;
    while i <= sLen - subLen {
        if String.Substring(s, i, subLen) == sub { return true; }
        i = i + 1;
    }
    return false;
}

// Split a query string on semicolons (respecting quoted strings)
func splitQueries(input: String) -> List[String] {
    var queries: List[String] = [];
    var current = "";
    var inSingleQuote = false;
    var inDoubleQuote = false;
    var i = 0;
    var len = String.Length(input);

    while i < len {
        var ch = String.Substring(input, i, 1);

        if ch == "'" && inDoubleQuote == false {
            inSingleQuote = !inSingleQuote;
            current = current + ch;
        } else if ch == "\"" && inSingleQuote == false {
            inDoubleQuote = !inDoubleQuote;
            current = current + ch;
        } else if ch == ";" && inSingleQuote == false && inDoubleQuote == false {
            queries.add(current);
            current = "";
        } else {
            current = current + ch;
        }
        i = i + 1;
    }

    // Add the last query if non-empty
    var trimmed = String.Trim(current);
    if String.Length(trimmed) > 0 {
        queries.add(current);
    }

    return queries;
}
