// dml.zia — DML (INSERT/UPDATE/DELETE) Handler
// Part of ViperSQL
//
// Implements SQL DML operations: INSERT, UPDATE, DELETE including
// multi-table variants (INSERT...SELECT, UPDATE...FROM, DELETE...USING),
// constraint validation, index maintenance, and foreign key cascades.
//
// The DmlHandler is invoked by the Executor for all data modification
// statements. It holds a back-reference to the Executor for access to
// shared state (database, indexes, storage engine, transaction journal).

module dml;

bind String = Viper.String;
bind Fmt = Viper.Fmt;

bind "./types";
bind "./schema";
bind "./table";
bind "./expr";
bind "./stmt";
bind "./result";
bind "./database";
bind "./index";
bind "./parser";
bind "./executor";
bind "./sql_functions";
bind "./storage/page";
bind "./storage/engine";
bind "./storage/btree";
bind "./storage/btree_node";
bind "./optimizer/optimizer";

// Coerce a value to match a column's declared type.
// Used on INSERT/UPDATE to auto-convert compatible values.
func coerceToColumnType(val: SqlValue, targetType: Integer) -> SqlValue {
    if val.kind == SQL_NULL { return val; }

    // Already the right type
    if val.kind == targetType { return val; }

    // Coerce to BOOLEAN
    if targetType == SQL_BOOLEAN {
        if val.kind == SQL_INTEGER { return sqlBoolean(val.intValue != 0); }
        if val.kind == SQL_TEXT {
            var upper = String.ToUpper(val.textValue);
            if upper == "TRUE" || upper == "T" || upper == "1" || upper == "YES" {
                return sqlBoolean(true);
            }
            return sqlBoolean(false);
        }
        return val;
    }

    // Coerce to DATE
    if targetType == SQL_DATE {
        if val.kind == SQL_TEXT { return sqlDate(parseDateText(val.textValue)); }
        if val.kind == SQL_TIMESTAMP { return sqlDate(timestampToDate(val.intValue)); }
        if val.kind == SQL_INTEGER { return sqlDate(val.intValue); }
        return val;
    }

    // Coerce to TIMESTAMP
    if targetType == SQL_TIMESTAMP {
        if val.kind == SQL_TEXT { return sqlTimestamp(parseDateTimeArg(val)); }
        if val.kind == SQL_DATE { return sqlTimestamp(dateToTimestamp(val.intValue)); }
        if val.kind == SQL_INTEGER { return sqlTimestamp(val.intValue); }
        return val;
    }

    // Coerce to JSON
    if targetType == SQL_JSON {
        if val.kind == SQL_TEXT { return sqlJson(val.textValue); }
        return val;
    }

    return val;
}

//=============================================================================
// DML HANDLER ENTITY
//=============================================================================

entity DmlHandler {
    expose Executor exec;

    expose func init(executor: Executor) {
        exec = executor;
    }

    expose func executeInsert(stmt: InsertStmt) -> QueryResult {
        // Acquire exclusive lock on target table
        if exec.acquireExclusiveLock(stmt.tableName) == false {
            return exec.lockTimeoutError(stmt.tableName);
        }
        // Privilege check: INSERT requires PRIV_INSERT
        var insertPrivErr = exec.checkPrivilege(stmt.tableName, PRIV_INSERT);
        if insertPrivErr != null { return insertPrivErr; }

        var result = new QueryResult();
        result.init();

        var table = exec.findTable(stmt.tableName);
        if table == null {
            result.setError("Table '" + stmt.tableName + "' not found");
            return result;
        }

        var t = table!;

        // Partition routing: if inserting into a partitioned parent, route to child
        if t.isPartitioned {
            return executeInsertPartitioned(stmt, t);
        }

        var hasColumnList = stmt.columnNames.count() > 0;

        // Handle INSERT...SELECT
        if stmt.hasSelect {
            return executeInsertSelect(stmt, t);
        }

        // Handle INSERT ... DEFAULT VALUES
        if stmt.hasDefaultValues {
            return executeInsertDefaults(stmt, t);
        }

        // Statement-level atomicity: save journal position for rollback on error
        var stmtSavepoint = exec.journal.count();

        var rowsInserted = 0;
        var r = 0;
        while r < stmt.rowCount() {
            var valueExprs = stmt.valueRows.get(r);
            var row = new Row();
            row.initWithCount(t.columnCount());

            // Build positional index mapping that skips generated columns
            var posMap: List[Integer] = [];
            var pc = 0;
            while pc < t.columnCount() {
                var pcCol = t.getColumn(pc);
                if pcCol != null {
                    var pcc = pcCol;
                    if pcc.isGenerated == false {
                        posMap.add(pc);
                    }
                }
                pc = pc + 1;
            }

            var c = 0;
            while c < t.columnCount() {
                var col = t.getColumn(c);
                if col != null {
                    var column = col;

                    // Skip generated columns — they'll be computed later
                    if column.isGenerated {
                        c = c + 1;
                        continue;
                    }

                    // Find the value index for this column
                    var valIdx = -1;
                    if hasColumnList {
                        // Map column name to value position
                        var ci = 0;
                        while ci < stmt.columnNames.count() {
                            if String.ToUpper(stmt.columnNames.get(ci)) == String.ToUpper(column.name) {
                                valIdx = ci;
                                break;
                            }
                            ci = ci + 1;
                        }
                    } else {
                        // No column list — positional mapping (skip generated cols)
                        var posIdx = 0;
                        while posIdx < posMap.count() {
                            if posMap.get(posIdx) == c {
                                if posIdx < valueExprs.count() {
                                    valIdx = posIdx;
                                }
                                break;
                            }
                            posIdx = posIdx + 1;
                        }
                    }

                    // Check for autoincrement
                    if column.autoIncrement {
                        if valIdx >= 0 {
                            var valExpr = valueExprs.get(valIdx);
                            if valExpr.kind == EXPR_LITERAL && valExpr.literalValue.kind == SQL_NULL {
                                var autoVal = sqlInteger(t.nextAutoIncrement());
                                row.setValue(c, autoVal);
                                c = c + 1;
                                continue;
                            }
                        } else {
                            // Column not in INSERT list — auto-generate
                            var autoVal = sqlInteger(t.nextAutoIncrement());
                            row.setValue(c, autoVal);
                            c = c + 1;
                            continue;
                        }
                    }

                    if valIdx >= 0 {
                        var valExpr = valueExprs.get(valIdx);
                        var val = exec.evalExpr(valExpr, row, t);
                        val = coerceToColumnType(val, column.typeCode);
                        row.setValue(c, val);
                    } else if column.hasDefault {
                        row.setValue(c, column.defaultValue);
                    } else {
                        row.setValue(c, sqlNull());
                    }
                }
                c = c + 1;
            }

            // Compute generated columns before constraint validation
            computeGeneratedColumns(t, row);

            // Validate constraints before inserting
            var constraintError = validateConstraints(t, row, -1);
            if constraintError != "" {
                // ON CONFLICT handling
                if stmt.hasOnConflict && isUniqueViolation(constraintError) {
                    if stmt.onConflictDoNothing {
                        // Skip this row silently
                        r = r + 1;
                        continue;
                    }
                    // DO UPDATE SET — find conflicting row and update it
                    var conflictIdx = findConflictingRow(t, row, stmt.conflictColumns);
                    if conflictIdx >= 0 {
                        applyOnConflictUpdate(t, conflictIdx, stmt.onConflictSetColumns, stmt.onConflictSetValues, row);
                        rowsInserted = rowsInserted + 1;
                        r = r + 1;
                        continue;
                    }
                }
                // Statement-level rollback: undo all rows from this statement
                exec.undoToSavepoint(stmtSavepoint);
                result.setError(constraintError);
                return result;
            }

            // Fire BEFORE INSERT triggers
            var beforeErr = exec.fireTriggers(stmt.tableName, TRIGGER_BEFORE, TRIGGER_INSERT, null, row, t);
            if beforeErr != "" {
                exec.undoToSavepoint(stmtSavepoint);
                result.setError(beforeErr);
                return result;
            }

            // MVCC: stamp row with creating transaction ID
            if exec.mvccTxnId > 0 {
                row.xmin = exec.mvccTxnId;
            }

            var newRowIdx = t.rowCount();
            t.addRow(row);

            // Update all indexes on this table
            var indexError = updateIndexesAfterInsert(stmt.tableName, row, newRowIdx, t);
            if indexError != "" {
                // Undo the row addition and all previous rows from this statement
                t.rows.removeAt(newRowIdx);
                exec.undoToSavepoint(stmtSavepoint);
                result.setError(indexError);
                return result;
            }

            // Record in transaction journal
            exec.journalInsert(stmt.tableName, newRowIdx);

            // Persist row to storage engine and track location
            if exec.storageEngine != null {
                var se = exec.storageEngine;
                var insertOk = se.insertRowStorage(stmt.tableName, row);
                if insertOk {
                    se.trackRowLocation(stmt.tableName, se.lastInsertPageId, se.lastInsertSlotIdx);
                }
                se.updateAutoIncrement(stmt.tableName, t.autoIncrementValue);
            }

            // Fire AFTER INSERT triggers
            exec.fireTriggers(stmt.tableName, TRIGGER_AFTER, TRIGGER_INSERT, null, row, t);

            rowsInserted = rowsInserted + 1;
            r = r + 1;
        }

        // Flush after all rows inserted
        if exec.storageEngine != null && rowsInserted > 0 {
            var se = exec.storageEngine;
            se.flush();
        }

        // Update optimizer statistics
        if rowsInserted > 0 {
            exec.optimizer.stats.setRowCount(stmt.tableName, t.rowCount());
        }

        // Handle RETURNING clause
        if stmt.hasReturning && rowsInserted > 0 {
            return buildInsertReturning(stmt, t, rowsInserted);
        }

        result.message = "Inserted " + Fmt.Int(rowsInserted) + " row(s)";
        result.rowsAffected = rowsInserted;
        exec.recordInsert(stmt.tableName, rowsInserted);
        exec.clearStatementJournal();
        return result;
    }

    // Build RETURNING result for INSERT — returns the last N inserted rows
    hide func buildInsertReturning(stmt: InsertStmt, t: Table, rowsInserted: Integer) -> QueryResult {
        var result = new QueryResult();
        result.init();
        // Build column names for RETURNING result
        buildReturningColumns(result, stmt.returningExprs, stmt.returningAliases, t);
        // The inserted rows are the last N rows in the table
        var startIdx = t.rowCount() - rowsInserted;
        var i = startIdx;
        while i < t.rowCount() {
            var maybeRow = t.getRow(i);
            if maybeRow != null {
                var rowData = maybeRow;
                var outRow = new Row();
                outRow.init();
                buildReturningRow(outRow, stmt.returningExprs, rowData, t);
                result.addRow(outRow);
            }
            i = i + 1;
        }
        result.rowsAffected = rowsInserted;
        exec.recordInsert(stmt.tableName, rowsInserted);
        exec.clearStatementJournal();
        return result;
    }

    // Build column names for a RETURNING result
    hide func buildReturningColumns(result: QueryResult, exprs: List[Expr], aliases: List[String], t: Table) {
        var i = 0;
        while i < exprs.count() {
            var expr = exprs.get(i);
            var alias = aliases.get(i);
            if alias != "" {
                result.addColumnName(alias);
            } else if expr.kind == EXPR_STAR {
                var c = 0;
                while c < t.columnCount() {
                    var col = t.getColumn(c);
                    if col != null {
                        result.addColumnName(col.name);
                    }
                    c = c + 1;
                }
            } else if expr.kind == EXPR_COLUMN {
                result.addColumnName(expr.columnName);
            } else {
                result.addColumnName("expr_" + Fmt.Int(i));
            }
            i = i + 1;
        }
    }

    // Build a RETURNING result row from row data
    hide func buildReturningRow(outRow: Row, exprs: List[Expr], rowData: Row, t: Table) {
        var i = 0;
        while i < exprs.count() {
            var expr = exprs.get(i);
            if expr.kind == EXPR_STAR {
                var c = 0;
                while c < t.columnCount() {
                    outRow.addValue(rowData.values.get(c));
                    c = c + 1;
                }
            } else {
                var val = exec.evalExpr(expr, rowData, t);
                outRow.addValue(val);
            }
            i = i + 1;
        }
    }

    //=========================================================================
    // ON CONFLICT (UPSERT) HELPERS
    //=========================================================================

    hide func isUniqueViolation(errorMsg: String) -> Boolean {
        var upper = String.ToUpper(errorMsg);
        if String.IndexOf(upper, "UNIQUE") >= 0 { return true; }
        if String.IndexOf(upper, "DUPLICATE") >= 0 { return true; }
        if String.IndexOf(upper, "PRIMARY KEY") >= 0 { return true; }
        return false;
    }

    // Find the row that conflicts with the new row on the specified conflict columns
    hide func findConflictingRow(t: Table, newRow: Row, conflictColumns: List[String]) -> Integer {
        // If no conflict columns specified, check primary key / unique columns
        var checkCols: List[Integer] = [];
        if conflictColumns.count() > 0 {
            var ci = 0;
            while ci < conflictColumns.count() {
                var idx = t.findColumnIndex(conflictColumns.get(ci));
                if idx >= 0 { checkCols.add(idx); }
                ci = ci + 1;
            }
        } else {
            // Use primary key columns as default conflict target
            var ci = 0;
            while ci < t.columnCount() {
                var col = t.getColumn(ci);
                if col != null {
                    if col.primaryKey { checkCols.add(ci); }
                }
                ci = ci + 1;
            }
        }

        if checkCols.count() == 0 { return -1; }

        var ri = 0;
        while ri < t.rowCount() {
            var maybeRow = t.getRow(ri);
            if maybeRow != null {
                var existingRow = maybeRow;
                if existingRow.deleted == false {
                    var allMatch = true;
                    var ci = 0;
                    while ci < checkCols.count() {
                        var colIdx = checkCols.get(ci);
                        var existVal = existingRow.values.get(colIdx);
                        var newVal = newRow.values.get(colIdx);
                        if existVal.toString() != newVal.toString() {
                            allMatch = false;
                            ci = checkCols.count(); // break
                        }
                        ci = ci + 1;
                    }
                    if allMatch { return ri; }
                }
            }
            ri = ri + 1;
        }
        return -1;
    }

    // Apply ON CONFLICT DO UPDATE SET to a conflicting row
    hide func applyOnConflictUpdate(t: Table, rowIdx: Integer, setCols: List[String], setVals: List[Expr], newRow: Row) {
        var maybeRow = t.getRow(rowIdx);
        if maybeRow == null { return; }
        var existingRow = maybeRow;
        var i = 0;
        while i < setCols.count() {
            var colIdx = t.findColumnIndex(setCols.get(i));
            if colIdx >= 0 {
                // Evaluate the expression — `excluded.col` references the new row values
                var val = exec.evalExpr(setVals.get(i), newRow, t);
                existingRow.setValue(colIdx, val);
            }
            i = i + 1;
        }
    }

    // Execute INSERT ... DEFAULT VALUES
    hide func executeInsertDefaults(stmt: InsertStmt, t: Table) -> QueryResult {
        var result = new QueryResult();
        result.init();

        var row = new Row();
        row.initWithCount(t.columnCount());

        var c = 0;
        while c < t.columnCount() {
            var col = t.getColumn(c);
            if col != null {
                var column = col;
                if column.autoIncrement {
                    var autoVal = sqlInteger(t.nextAutoIncrement());
                    row.setValue(c, autoVal);
                } else if column.hasDefault {
                    row.setValue(c, column.defaultValue);
                } else {
                    row.setValue(c, sqlNull());
                }
            }
            c = c + 1;
        }

        // Validate constraints
        var constraintError = validateConstraints(t, row, -1);
        if constraintError != "" {
            result.setError(constraintError);
            return result;
        }

        // Fire BEFORE INSERT triggers
        var beforeErr = exec.fireTriggers(stmt.tableName, TRIGGER_BEFORE, TRIGGER_INSERT, null, row, t);
        if beforeErr != "" {
            result.setError(beforeErr);
            return result;
        }

        // MVCC: stamp row with creating transaction ID
        if exec.mvccTxnId > 0 {
            row.xmin = exec.mvccTxnId;
        }

        var newRowIdx = t.rowCount();
        t.addRow(row);

        // Update indexes
        var indexError = updateIndexesAfterInsert(stmt.tableName, row, newRowIdx, t);
        if indexError != "" {
            t.rows.removeAt(newRowIdx);
            result.setError(indexError);
            return result;
        }

        // Record in transaction journal
        exec.journalInsert(stmt.tableName, newRowIdx);

        // Persist row to storage engine
        if exec.storageEngine != null {
            var se = exec.storageEngine;
            var insertOk = se.insertRowStorage(stmt.tableName, row);
            if insertOk {
                se.trackRowLocation(stmt.tableName, se.lastInsertPageId, se.lastInsertSlotIdx);
            }
        }

        // Fire AFTER INSERT triggers
        exec.fireTriggers(stmt.tableName, TRIGGER_AFTER, TRIGGER_INSERT, null, row, t);

        // Handle RETURNING
        if stmt.hasReturning {
            return buildInsertReturning(stmt, t, 1);
        }

        result.message = "Inserted 1 row(s)";
        result.rowsAffected = 1;
        exec.recordInsert(stmt.tableName, 1);
        exec.clearStatementJournal();
        return result;
    }

    // Execute INSERT...SELECT
    hide func executeInsertSelect(stmt: InsertStmt, t: Table) -> QueryResult {
        var result = new QueryResult();
        result.init();

        // Execute the SELECT query
        var selectResult = exec.executeSql(stmt.selectSQL);
        if selectResult.success == false {
            result.setError(selectResult.message);
            return result;
        }

        var hasColumnList = stmt.columnNames.count() > 0;
        var rowsInserted = 0;
        var ri = 0;
        while ri < selectResult.rowCount() {
            var srcRow = selectResult.getRow(ri);
            var newRow = new Row();
            newRow.initWithCount(t.columnCount());

            var c = 0;
            while c < t.columnCount() {
                var col = t.getColumn(c);
                if col != null {
                    var column = col;

                    // Find the source value index for this column
                    var valIdx = -1;
                    if hasColumnList {
                        // Map column name to SELECT result column position
                        var ci = 0;
                        while ci < stmt.columnNames.count() {
                            if String.ToUpper(stmt.columnNames.get(ci)) == String.ToUpper(column.name) {
                                valIdx = ci;
                                break;
                            }
                            ci = ci + 1;
                        }
                    } else {
                        // Positional mapping
                        if c < srcRow.columnCount() {
                            valIdx = c;
                        }
                    }

                    // Handle autoincrement
                    if column.autoIncrement {
                        if valIdx >= 0 {
                            var srcVal = srcRow.getValue(valIdx);
                            if srcVal.isNull() {
                                newRow.setValue(c, sqlInteger(t.nextAutoIncrement()));
                                c = c + 1;
                                continue;
                            }
                        } else {
                            newRow.setValue(c, sqlInteger(t.nextAutoIncrement()));
                            c = c + 1;
                            continue;
                        }
                    }

                    if valIdx >= 0 {
                        var srcVal = srcRow.getValue(valIdx);
                        srcVal = coerceToColumnType(srcVal, column.typeCode);
                        newRow.setValue(c, srcVal);
                    } else if column.hasDefault {
                        newRow.setValue(c, column.defaultValue);
                    } else {
                        newRow.setValue(c, sqlNull());
                    }
                }
                c = c + 1;
            }

            // Validate constraints
            var constraintError = validateConstraints(t, newRow, -1);
            if constraintError != "" {
                result.setError(constraintError);
                return result;
            }

            var newRowIdx = t.rowCount();
            t.addRow(newRow);
            updateIndexesAfterInsert(stmt.tableName, newRow, newRowIdx, t);

            if exec.storageEngine != null {
                var se = exec.storageEngine;
                var insertOk = se.insertRowStorage(stmt.tableName, newRow);
                if insertOk {
                    se.trackRowLocation(stmt.tableName, se.lastInsertPageId, se.lastInsertSlotIdx);
                }
                se.updateAutoIncrement(stmt.tableName, t.autoIncrementValue);
            }

            rowsInserted = rowsInserted + 1;
            ri = ri + 1;
        }

        if exec.storageEngine != null && rowsInserted > 0 {
            var se = exec.storageEngine;
            se.flush();
        }

        // Update optimizer statistics
        if rowsInserted > 0 {
            exec.optimizer.stats.setRowCount(stmt.tableName, t.rowCount());
        }

        result.message = "Inserted " + Fmt.Int(rowsInserted) + " row(s)";
        result.rowsAffected = rowsInserted;
        exec.recordInsert(stmt.tableName, rowsInserted);
        exec.clearStatementJournal();
        return result;
    }

    // Validate constraints for a row (returns error message or empty string)
    hide func validateConstraints(table: Table, row: Row, excludeRowIdx: Integer) -> String {
        // Phase 68: Count PK columns for composite PK handling
        var pkColCount = 0;
        var pkc = 0;
        while pkc < table.columnCount() {
            var maybePkCol = table.getColumn(pkc);
            if maybePkCol != null {
                var pk = maybePkCol;
                if pk.primaryKey { pkColCount = pkColCount + 1; }
            }
            pkc = pkc + 1;
        }
        var isCompositePk = pkColCount > 1;

        var c = 0;
        while c < table.columnCount() {
            var maybeCol = table.getColumn(c);
            if maybeCol != null {
                var col = maybeCol;
                var val = row.getValue(c);

                // Check NOT NULL constraint
                if col.notNull && val.kind == SQL_NULL {
                    return "NOT NULL constraint failed: " + col.name;
                }

                // Check PRIMARY KEY constraint (implies NOT NULL and UNIQUE)
                if col.primaryKey {
                    if val.kind == SQL_NULL {
                        return "PRIMARY KEY constraint failed: " + col.name + " cannot be NULL";
                    }
                    // For single PK, check uniqueness per-column
                    // For composite PK, uniqueness checked after loop
                    if isCompositePk == false {
                        var i = 0;
                        while i < table.rowCount() {
                            if i != excludeRowIdx {
                                var maybeRow = table.getRow(i);
                                if maybeRow != null {
                                    var existingRow = maybeRow;
                                    if existingRow.deleted == false {
                                        var existingVal = existingRow.getValue(c);
                                        if val.nullSafeEquals(existingVal) {
                                            return "PRIMARY KEY constraint failed: duplicate value in " + col.name;
                                        }
                                    }
                                }
                            }
                            i = i + 1;
                        }
                    }
                }

                // Check UNIQUE constraint
                if col.unique && val.kind != SQL_NULL {
                    var i = 0;
                    while i < table.rowCount() {
                        if i != excludeRowIdx {
                            var maybeRow = table.getRow(i);
                            if maybeRow != null {
                                var existingRow = maybeRow;
                                if existingRow.deleted == false {
                                    var existingVal = existingRow.getValue(c);
                                    if val.nullSafeEquals(existingVal) {
                                        return "UNIQUE constraint failed: duplicate value in " + col.name;
                                    }
                                }
                            }
                        }
                        i = i + 1;
                    }
                }

                // Check FOREIGN KEY constraint
                if col.isForeignKey {
                    if val.kind != SQL_NULL {
                        var refTable = exec.findTable(col.refTableName);
                        if refTable == null {
                            return "FOREIGN KEY constraint failed: referenced table '" + col.refTableName + "' not found";
                        }
                        var rt = refTable;
                        var refColIdx = rt.findColumnIndex(col.refColumnName);
                        if refColIdx >= 0 {
                            var found = false;
                            var i = 0;
                            while i < rt.rowCount() {
                                var maybeRow = rt.getRow(i);
                                if maybeRow != null {
                                    var refRow = maybeRow;
                                    if refRow.deleted == false {
                                        var refVal = refRow.getValue(refColIdx);
                                        if val.nullSafeEquals(refVal) {
                                            found = true;
                                            i = rt.rowCount();  // break
                                        }
                                    }
                                }
                                i = i + 1;
                            }
                            if found == false {
                                return "FOREIGN KEY constraint failed: " + col.name + " references " + col.refTableName + "(" + col.refColumnName + ")";
                            }
                        }
                    }
                }

                // Check CHECK constraint (NULL values always pass per SQL standard)
                if col.checkExprSQL != "" && val.kind != SQL_NULL {
                    var checkResult = evaluateCheckConstraint(col.checkExprSQL, col.name, val);
                    if checkResult != "" {
                        return checkResult;
                    }
                }
            }
            c = c + 1;
        }

        // Phase 68: composite PRIMARY KEY uniqueness check
        if isCompositePk {
            var ri = 0;
            while ri < table.rowCount() {
                if ri != excludeRowIdx {
                    var maybeRow = table.getRow(ri);
                    if maybeRow != null {
                        var existingRow = maybeRow;
                        if existingRow.deleted == false {
                            var allMatch = true;
                            var ci = 0;
                            while ci < table.columnCount() {
                                var maybePkCol2 = table.getColumn(ci);
                                if maybePkCol2 != null {
                                    var pkCol2 = maybePkCol2;
                                    if pkCol2.primaryKey {
                                        var newVal = row.getValue(ci);
                                        var existVal = existingRow.getValue(ci);
                                        if newVal.nullSafeEquals(existVal) == false {
                                            allMatch = false;
                                            ci = table.columnCount(); // break
                                        }
                                    }
                                }
                                ci = ci + 1;
                            }
                            if allMatch {
                                return "PRIMARY KEY constraint failed: duplicate composite key";
                            }
                        }
                    }
                }
                ri = ri + 1;
            }
        }

        return "";
    }

    // Evaluate a CHECK constraint expression against a column value
    hide func evaluateCheckConstraint(checkSQL: String, colName: String, val: SqlValue) -> String {
        // Build a SQL expression that substitutes the column name with the actual value
        // We parse the check expression and evaluate it with a single-column temp row/table
        var tempTable = new Table();
        tempTable.init();
        var tempCol = new Column();
        tempCol.initWithName(colName, val.kind);
        tempTable.addColumn(tempCol);

        var tempRow = new Row();
        tempRow.initWithCount(1);
        tempRow.setValue(0, val);

        // Parse and evaluate the check expression
        var parser = new Parser(checkSQL);
        var checkExpr = parser.parseExpr();
        if parser.hasError {
            return "CHECK constraint parse error: " + parser.error;
        }

        var result = exec.evalExpr(checkExpr, tempRow, tempTable);

        // CHECK passes if result is non-zero (true)
        if result.kind == SQL_INTEGER && result.intValue != 0 {
            return "";
        }
        if result.kind == SQL_NULL {
            // NULL in CHECK is considered passing (SQL standard)
            return "";
        }
        return "CHECK constraint failed: " + colName;
    }

    // Compute generated column values for a row.
    // Parses each generated column's expression and evaluates against the current row.
    hide func computeGeneratedColumns(t: Table, row: Row) {
        var c = 0;
        while c < t.columnCount() {
            var maybeCol = t.getColumn(c);
            if maybeCol != null {
                var col = maybeCol;
                if col.isGenerated && col.generatedExprSQL != "" {
                    var parser = new Parser(col.generatedExprSQL);
                    var genExpr = parser.parseExpr();
                    if parser.hasError == false {
                        var val = exec.evalExpr(genExpr, row, t);
                        val = coerceToColumnType(val, col.typeCode);
                        row.setValue(c, val);
                    }
                }
            }
            c = c + 1;
        }
    }

    // Update all indexes for a table after inserting a row
    hide func updateIndexesAfterInsert(tableName: String, row: Row, rowIdx: Integer, table: Table) -> String {
        var i = 0;
        while i < exec.indexMgr.indexCount() {
            var idx = exec.indexMgr.indexes.get(i);
            if idx.tableName == tableName {
                // Phase 74: Skip partial index if row doesn't match predicate
                if idx.isPartial && idx.matchesWhere(row, table) == false {
                    i = i + 1;
                    continue;
                }
                var ok = idx.addEntry(row, rowIdx, table);
                if ok == false {
                    return "UNIQUE constraint failed: duplicate value in index '" + idx.name + "'";
                }
                // Also insert into B-tree if persistent
                if exec.storageEngine != null {
                    var btree = exec.findBTreeForIndex(idx.name);
                    if btree != null {
                        var bt = btree;
                        var se = exec.storageEngine;
                        var colIdx = table.findColumnIndex(idx.getColumnName(0));
                        if colIdx >= 0 {
                            var keyVal = row.getValue(colIdx);
                            var btreeKey = new BTreeKey();
                            btreeKey.initWithValue(keyVal, se.lastInsertPageId, se.lastInsertSlotIdx);
                            bt.insert(btreeKey);
                        }
                    }
                }
            }
            i = i + 1;
        }
        return "";
    }

    //=========================================================================
    // Multi-table UPDATE...FROM
    //=========================================================================
    hide func executeUpdateFrom(stmt: UpdateStmt) -> QueryResult {
        var result = new QueryResult();
        result.init();

        var table = exec.findTable(stmt.tableName);
        if table == null {
            result.setError("Table '" + stmt.tableName + "' not found");
            return result;
        }
        var t1 = table!;

        var fromTable = exec.findTable(stmt.fromTableName);
        if fromTable == null {
            result.setError("FROM table '" + stmt.fromTableName + "' not found");
            return result;
        }
        var t2 = fromTable!;
        var t2Alias = stmt.fromTableAlias;

        // Build merged table schema for expression evaluation
        var mergedTable = new Table();
        mergedTable.init();
        // Add columns from target table (with table name prefix handling)
        var c = 0;
        while c < t1.columnCount() {
            var col = t1.getColumn(c);
            if col != null {
                var mc = new Column();
                mc.initWithName(col.name, col.typeCode);
                mergedTable.addColumn(mc);
            }
            c = c + 1;
        }
        // Add columns from FROM table
        c = 0;
        while c < t2.columnCount() {
            var col = t2.getColumn(c);
            if col != null {
                var mc = new Column();
                mc.initWithName(col.name, col.typeCode);
                mergedTable.addColumn(mc);
            }
            c = c + 1;
        }

        var stmtSavepoint = exec.journal.count();
        var rowsUpdated = 0;
        var t1ColCount = t1.columnCount();

        // Nested loop: for each t1 row, find matching t2 rows
        var r1 = 0;
        while r1 < t1.rowCount() {
            var row1 = t1.getRow(r1);
            if row1 != null {
                var rd1 = row1;
                if rd1.deleted == false {
                    var r2 = 0;
                    while r2 < t2.rowCount() {
                        var row2 = t2.getRow(r2);
                        if row2 != null {
                            var rd2 = row2;
                            if rd2.deleted == false {
                                // Build merged row
                                var mergedRow = new Row();
                                mergedRow.initWithCount(t1ColCount + t2.columnCount());
                                var mc = 0;
                                while mc < t1ColCount {
                                    mergedRow.setValue(mc, rd1.getValue(mc));
                                    mc = mc + 1;
                                }
                                mc = 0;
                                while mc < t2.columnCount() {
                                    mergedRow.setValue(t1ColCount + mc, rd2.getValue(mc));
                                    mc = mc + 1;
                                }

                                // Evaluate WHERE against merged context
                                // Need to handle table-qualified column names
                                if evalConditionMultiTable(stmt.whereClause, mergedRow, mergedTable, stmt.tableName, t1, t2Alias, t2) {
                                    // Record before-image for rollback
                                    exec.journalUpdate(stmt.tableName, r1, rd1);

                                    // Evaluate SET expressions in merged context
                                    var si = 0;
                                    while si < stmt.setColumns.count() {
                                        var colName = stmt.setColumns.get(si);
                                        var valExpr = stmt.setValues.get(si);
                                        var colIdx = t1.findColumnIndex(colName);
                                        if colIdx >= 0 {
                                            var val = evalExprMultiTable(valExpr, mergedRow, mergedTable, stmt.tableName, t1, t2Alias, t2);
                                            rd1.setValue(colIdx, val);
                                        }
                                        si = si + 1;
                                    }
                                    rowsUpdated = rowsUpdated + 1;
                                    r2 = t2.rowCount(); // break inner loop (first match only)
                                }
                            }
                        }
                        r2 = r2 + 1;
                    }
                }
            }
            r1 = r1 + 1;
        }

        result.message = "Updated " + Fmt.Int(rowsUpdated) + " row(s)";
        result.rowsAffected = rowsUpdated;
        exec.recordUpdate(stmt.tableName, rowsUpdated);
        exec.clearStatementJournal();
        return result;
    }

    //=========================================================================
    // Multi-table DELETE...USING
    //=========================================================================
    hide func executeDeleteUsing(stmt: DeleteStmt) -> QueryResult {
        var result = new QueryResult();
        result.init();

        var table = exec.findTable(stmt.tableName);
        if table == null {
            result.setError("Table '" + stmt.tableName + "' not found");
            return result;
        }
        var t1 = table!;

        var usingTable = exec.findTable(stmt.usingTableName);
        if usingTable == null {
            result.setError("USING table '" + stmt.usingTableName + "' not found");
            return result;
        }
        var t2 = usingTable!;
        var t2Alias = stmt.usingTableAlias;

        // Build merged table schema
        var mergedTable = new Table();
        mergedTable.init();
        var c = 0;
        while c < t1.columnCount() {
            var col = t1.getColumn(c);
            if col != null {
                var mc = new Column();
                mc.initWithName(col.name, col.typeCode);
                mergedTable.addColumn(mc);
            }
            c = c + 1;
        }
        c = 0;
        while c < t2.columnCount() {
            var col = t2.getColumn(c);
            if col != null {
                var mc = new Column();
                mc.initWithName(col.name, col.typeCode);
                mergedTable.addColumn(mc);
            }
            c = c + 1;
        }

        var stmtSavepoint = exec.journal.count();
        var rowsDeleted = 0;
        var deletedIndices: List[Integer] = [];
        var t1ColCount = t1.columnCount();

        var r1 = 0;
        while r1 < t1.rowCount() {
            var row1 = t1.getRow(r1);
            if row1 != null {
                var rd1 = row1;
                if rd1.deleted == false {
                    var r2 = 0;
                    while r2 < t2.rowCount() {
                        var row2 = t2.getRow(r2);
                        if row2 != null {
                            var rd2 = row2;
                            if rd2.deleted == false {
                                var mergedRow = new Row();
                                mergedRow.initWithCount(t1ColCount + t2.columnCount());
                                var mc = 0;
                                while mc < t1ColCount {
                                    mergedRow.setValue(mc, rd1.getValue(mc));
                                    mc = mc + 1;
                                }
                                mc = 0;
                                while mc < t2.columnCount() {
                                    mergedRow.setValue(t1ColCount + mc, rd2.getValue(mc));
                                    mc = mc + 1;
                                }

                                if evalConditionMultiTable(stmt.whereClause, mergedRow, mergedTable, stmt.tableName, t1, t2Alias, t2) {
                                    exec.journalDelete(stmt.tableName, r1, rd1);
                                    rd1.deleted = true;
                                    deletedIndices.add(r1);
                                    rowsDeleted = rowsDeleted + 1;
                                    r2 = t2.rowCount(); // break
                                }
                            }
                        }
                        r2 = r2 + 1;
                    }
                }
            }
            r1 = r1 + 1;
        }

        // Compact and rebuild indexes
        if rowsDeleted > 0 && exec.inTransaction == false {
            exec.compactTable(t1);
            exec.rebuildTableIndexes(stmt.tableName, t1);
        }

        result.message = "Deleted " + Fmt.Int(rowsDeleted) + " row(s)";
        result.rowsAffected = rowsDeleted;
        exec.recordDelete(stmt.tableName, rowsDeleted);
        exec.clearStatementJournal();
        return result;
    }

    // Multi-table expression evaluation helpers
    hide func resolveColumnMultiTable(colExpr: Expr, mergedRow: Row, mergedTable: Table, t1Name: String, t1: Table, t2Name: String, t2: Table) -> SqlValue {
        var tblName = colExpr.tableName;
        var colName = colExpr.columnName;

        // If table-qualified, resolve from that table's columns
        if tblName != "" {
            if tblName == t1Name || String.ToUpper(tblName) == String.ToUpper(t1Name) {
                var idx = t1.findColumnIndex(colName);
                if idx >= 0 { return mergedRow.getValue(idx); }
            }
            if tblName == t2Name || String.ToUpper(tblName) == String.ToUpper(t2Name) {
                var idx = t2.findColumnIndex(colName);
                if idx >= 0 { return mergedRow.getValue(t1.columnCount() + idx); }
            }
        }

        // Unqualified: search t1 first, then t2
        var idx = t1.findColumnIndex(colName);
        if idx >= 0 { return mergedRow.getValue(idx); }
        idx = t2.findColumnIndex(colName);
        if idx >= 0 { return mergedRow.getValue(t1.columnCount() + idx); }

        return sqlNull();
    }

    hide func evalExprMultiTable(expr: Expr, mergedRow: Row, mergedTable: Table, t1Name: String, t1: Table, t2Name: String, t2: Table) -> SqlValue {
        if expr.kind == EXPR_LITERAL { return expr.literalValue; }
        if expr.kind == EXPR_COLUMN {
            return resolveColumnMultiTable(expr, mergedRow, mergedTable, t1Name, t1, t2Name, t2);
        }
        if expr.kind == EXPR_BINARY {
            var left = evalExprMultiTable(expr.args.get(0), mergedRow, mergedTable, t1Name, t1, t2Name, t2);
            var right = evalExprMultiTable(expr.args.get(1), mergedRow, mergedTable, t1Name, t1, t2Name, t2);
            return evalBinaryValues(expr.op, left, right);
        }
        if expr.kind == EXPR_UNARY {
            var operand = evalExprMultiTable(expr.args.get(0), mergedRow, mergedTable, t1Name, t1, t2Name, t2);
            if expr.op == OP_NEG {
                if operand.kind == SQL_INTEGER { return sqlInteger(-operand.intValue); }
            }
            if expr.op == OP_NOT {
                if operand.intValue == 0 { return sqlInteger(1); }
                return sqlInteger(0);
            }
        }
        if expr.kind == EXPR_FUNCTION {
            return exec.evalFunction(expr, mergedRow, mergedTable);
        }
        // Fall back to single-table eval for complex cases
        return exec.evalExpr(expr, mergedRow, mergedTable);
    }

    hide func evalConditionMultiTable(expr: Expr?, mergedRow: Row, mergedTable: Table, t1Name: String, t1: Table, t2Name: String, t2: Table) -> Boolean {
        if expr == null { return true; }
        var e = expr!;
        var result = evalExprMultiTable(e, mergedRow, mergedTable, t1Name, t1, t2Name, t2);
        return result.intValue != 0;
    }

    // Helper: evaluate binary operation on two SqlValues (no row context)
    hide func evalBinaryValues(op: Integer, left: SqlValue, right: SqlValue) -> SqlValue {
        if op == OP_EQ {
            var cmp = left.compare(right);
            if cmp == 2 { return sqlInteger(0); }
            if cmp == 0 { return sqlInteger(1); }
            return sqlInteger(0);
        }
        if op == OP_NE {
            var cmp = left.compare(right);
            if cmp == 2 { return sqlInteger(0); }
            if cmp != 0 { return sqlInteger(1); }
            return sqlInteger(0);
        }
        if op == OP_LT {
            var cmp = left.compare(right);
            if cmp == 2 { return sqlInteger(0); }
            if cmp < 0 { return sqlInteger(1); }
            return sqlInteger(0);
        }
        if op == OP_LE {
            var cmp = left.compare(right);
            if cmp == 2 { return sqlInteger(0); }
            if cmp <= 0 { return sqlInteger(1); }
            return sqlInteger(0);
        }
        if op == OP_GT {
            var cmp = left.compare(right);
            if cmp == 2 { return sqlInteger(0); }
            if cmp > 0 { return sqlInteger(1); }
            return sqlInteger(0);
        }
        if op == OP_GE {
            var cmp = left.compare(right);
            if cmp == 2 { return sqlInteger(0); }
            if cmp >= 0 { return sqlInteger(1); }
            return sqlInteger(0);
        }
        if op == OP_AND {
            if left.intValue != 0 && right.intValue != 0 { return sqlInteger(1); }
            return sqlInteger(0);
        }
        if op == OP_OR {
            if left.intValue != 0 || right.intValue != 0 { return sqlInteger(1); }
            return sqlInteger(0);
        }
        if op == OP_ADD {
            if left.kind == SQL_INTEGER && right.kind == SQL_INTEGER {
                return sqlInteger(left.intValue + right.intValue);
            }
        }
        if op == OP_SUB {
            if left.kind == SQL_INTEGER && right.kind == SQL_INTEGER {
                return sqlInteger(left.intValue - right.intValue);
            }
        }
        if op == OP_MUL {
            if left.kind == SQL_INTEGER && right.kind == SQL_INTEGER {
                return sqlInteger(left.intValue * right.intValue);
            }
        }
        if op == OP_DIV {
            if left.kind == SQL_INTEGER && right.kind == SQL_INTEGER {
                if right.intValue != 0 {
                    return sqlInteger(left.intValue / right.intValue);
                }
            }
        }
        if op == OP_CONCAT {
            return sqlText(left.toString() + right.toString());
        }
        return sqlNull();
    }

    expose func executeUpdate(stmt: UpdateStmt) -> QueryResult {
        // Acquire exclusive lock on target table
        if exec.acquireExclusiveLock(stmt.tableName) == false {
            return exec.lockTimeoutError(stmt.tableName);
        }
        // Also lock FROM table if present (shared for reads)
        if stmt.hasFrom && stmt.fromTableName != "" {
            if exec.acquireSharedLock(stmt.fromTableName) == false {
                return exec.lockTimeoutError(stmt.fromTableName);
            }
        }
        // Privilege check: UPDATE requires PRIV_UPDATE
        var updatePrivErr = exec.checkPrivilege(stmt.tableName, PRIV_UPDATE);
        if updatePrivErr != null { return updatePrivErr; }

        // Route to multi-table UPDATE if FROM clause present
        if stmt.hasFrom {
            return executeUpdateFrom(stmt);
        }

        var result = new QueryResult();
        result.init();

        var table = exec.findTable(stmt.tableName);
        if table == null {
            result.setError("Table '" + stmt.tableName + "' not found");
            return result;
        }

        var t = table!;
        var rowsUpdated = 0;
        var updatedIndices: List[Integer] = [];

        // Statement-level atomicity: save journal position for rollback on error
        var stmtSavepoint = exec.journal.count();

        var r = 0;
        while r < t.rowCount() {
            var row = t.getRow(r);
            if row != null {
                var rowData = row;
                if rowData.isVisible(exec.mvccSnapshotId, exec.mvccTxnId) {
                    if exec.evalCondition(stmt.whereClause, rowData, t) {
                        // Create a copy of the row with updated values
                        var updatedRow = new Row();
                        updatedRow.initWithCount(t.columnCount());
                        var c = 0;
                        while c < t.columnCount() {
                            updatedRow.setValue(c, rowData.getValue(c));
                            c = c + 1;
                        }

                        // Apply updates to the copy
                        var i = 0;
                        while i < stmt.setColumns.count() {
                            var colName = stmt.setColumns.get(i);
                            var valExpr = stmt.setValues.get(i);
                            var colIdx = t.findColumnIndex(colName);
                            if colIdx >= 0 {
                                // Block direct writes to generated columns
                                var maybeGenCol = t.getColumn(colIdx);
                                if maybeGenCol != null {
                                    var genCol = maybeGenCol;
                                    if genCol.isGenerated {
                                        exec.undoToSavepoint(stmtSavepoint);
                                        result.setError("cannot update generated column '" + colName + "'");
                                        return result;
                                    }
                                }
                                var val = exec.evalExpr(valExpr, rowData, t);
                                var maybeCol = t.getColumn(colIdx);
                                if maybeCol != null {
                                    var uc = maybeCol;
                                    val = coerceToColumnType(val, uc.typeCode);
                                }
                                updatedRow.setValue(colIdx, val);
                            }
                            i = i + 1;
                        }

                        // Recompute generated columns after SET
                        computeGeneratedColumns(t, updatedRow);

                        // Fire BEFORE UPDATE triggers (pass old row and updated copy)
                        var beforeUpdErr = exec.fireTriggers(stmt.tableName, TRIGGER_BEFORE, TRIGGER_UPDATE, rowData, updatedRow, t);
                        if beforeUpdErr != "" {
                            exec.undoToSavepoint(stmtSavepoint);
                            result.setError(beforeUpdErr);
                            return result;
                        }

                        // Validate constraints (exclude current row index for uniqueness check)
                        var constraintError = validateConstraints(t, updatedRow, r);
                        if constraintError != "" {
                            // Statement-level rollback: undo all rows updated so far
                            exec.undoToSavepoint(stmtSavepoint);
                            result.setError(constraintError);
                            return result;
                        }

                        // Record before-image in transaction journal
                        exec.journalUpdate(stmt.tableName, r, rowData);

                        // Deep-copy the old row for cascade check
                        var oldRowCopy = new Row();
                        oldRowCopy.initWithCount(t.columnCount());
                        var oc = 0;
                        while oc < t.columnCount() {
                            oldRowCopy.setValue(oc, rowData.getValue(oc));
                            oc = oc + 1;
                        }

                        // Apply the updates to the actual row
                        i = 0;
                        while i < stmt.setColumns.count() {
                            var colName = stmt.setColumns.get(i);
                            var colIdx = t.findColumnIndex(colName);
                            if colIdx >= 0 {
                                rowData.setValue(colIdx, updatedRow.getValue(colIdx));
                            }
                            i = i + 1;
                        }
                        // Also copy generated column values
                        var gc = 0;
                        while gc < t.columnCount() {
                            var gcMaybe = t.getColumn(gc);
                            if gcMaybe != null {
                                var gcCol = gcMaybe;
                                if gcCol.isGenerated {
                                    rowData.setValue(gc, updatedRow.getValue(gc));
                                }
                            }
                            gc = gc + 1;
                        }

                        // MVCC: stamp row with updating transaction ID
                        if exec.mvccTxnId > 0 {
                            rowData.xmin = exec.mvccTxnId;
                        }

                        // Handle FK cascades for this updated row
                        var cascErr = handleUpdateCascade(stmt.tableName, t, r, oldRowCopy, rowData);
                        if cascErr != "" {
                            // Undo this update and all previous updates
                            exec.undoToSavepoint(stmtSavepoint);
                            result.setError(cascErr);
                            return result;
                        }

                        // Fire AFTER UPDATE triggers (pass old copy and new row)
                        exec.fireTriggers(stmt.tableName, TRIGGER_AFTER, TRIGGER_UPDATE, oldRowCopy, rowData, t);

                        updatedIndices.add(r);
                        rowsUpdated = rowsUpdated + 1;
                    }
                }
            }
            r = r + 1;
        }

        // Persist updated rows — try incremental in-place updates first
        if exec.storageEngine != null && rowsUpdated > 0 {
            var se = exec.storageEngine;
            var needsRewrite = false;
            var ui = 0;
            while ui < updatedIndices.count() {
                var rowIdx = updatedIndices.get(ui);
                var loc = se.findRowLocation(stmt.tableName, rowIdx);
                var locPageId = loc.get(0);
                var locSlotIdx = loc.get(1);
                if locPageId != INVALID_PAGE_ID {
                    var updRow = t.getRow(rowIdx)!;
                    var ok = se.updateRowByLocation(stmt.tableName, locPageId, locSlotIdx, updRow);
                    if ok == false {
                        needsRewrite = true;
                    }
                } else {
                    needsRewrite = true;
                }
                ui = ui + 1;
            }
            // Fall back to full rewrite if any in-place update failed
            // rewriteTableRows() clears + rebuilds row tracking internally
            if needsRewrite {
                se.rewriteTableRows(stmt.tableName, t.rows);
            }
            se.flush();
        }

        // Update optimizer statistics
        if rowsUpdated > 0 {
            exec.optimizer.stats.setRowCount(stmt.tableName, t.rowCount());
        }

        // Handle RETURNING clause
        if stmt.hasReturning && rowsUpdated > 0 {
            var retResult = new QueryResult();
            retResult.init();
            buildReturningColumns(retResult, stmt.returningExprs, stmt.returningAliases, t);
            var ui = 0;
            while ui < updatedIndices.count() {
                var ri = updatedIndices.get(ui);
                var maybeRow = t.getRow(ri);
                if maybeRow != null {
                    var rd = maybeRow;
                    var outRow = new Row();
                    outRow.init();
                    buildReturningRow(outRow, stmt.returningExprs, rd, t);
                    retResult.addRow(outRow);
                }
                ui = ui + 1;
            }
            retResult.rowsAffected = rowsUpdated;
            exec.recordUpdate(stmt.tableName, rowsUpdated);
            exec.clearStatementJournal();
            return retResult;
        }

        result.message = "Updated " + Fmt.Int(rowsUpdated) + " row(s)";
        result.rowsAffected = rowsUpdated;
        exec.recordUpdate(stmt.tableName, rowsUpdated);
        exec.clearStatementJournal();
        return result;
    }

    expose func executeDelete(stmt: DeleteStmt) -> QueryResult {
        // Acquire exclusive lock on target table
        if exec.acquireExclusiveLock(stmt.tableName) == false {
            return exec.lockTimeoutError(stmt.tableName);
        }
        // Also lock USING table if present (shared for reads)
        if stmt.hasUsing && stmt.usingTableName != "" {
            if exec.acquireSharedLock(stmt.usingTableName) == false {
                return exec.lockTimeoutError(stmt.usingTableName);
            }
        }
        // Privilege check: DELETE requires PRIV_DELETE
        var deletePrivErr = exec.checkPrivilege(stmt.tableName, PRIV_DELETE);
        if deletePrivErr != null { return deletePrivErr; }

        // Route to multi-table DELETE if USING clause present
        if stmt.hasUsing {
            return executeDeleteUsing(stmt);
        }

        var result = new QueryResult();
        result.init();

        var table = exec.findTable(stmt.tableName);
        if table == null {
            result.setError("Table '" + stmt.tableName + "' not found");
            return result;
        }

        var t = table!;
        var rowsDeleted = 0;
        var deletedIndices: List[Integer] = [];

        // Statement-level atomicity savepoint
        var stmtSavepoint = exec.journal.count();

        var r = 0;
        while r < t.rowCount() {
            var row = t.getRow(r);
            if row != null {
                var rowData = row;
                if rowData.isVisible(exec.mvccSnapshotId, exec.mvccTxnId) {
                    if exec.evalCondition(stmt.whereClause, rowData, t) {
                        // Fire BEFORE DELETE triggers
                        var beforeDelErr = exec.fireTriggers(stmt.tableName, TRIGGER_BEFORE, TRIGGER_DELETE, rowData, null, t);
                        if beforeDelErr != "" {
                            exec.undoToSavepoint(stmtSavepoint);
                            result.setError(beforeDelErr);
                            return result;
                        }
                        // Record in transaction journal before soft-delete
                        exec.journalDelete(stmt.tableName, r, rowData);
                        rowData.deleted = true;
                        // MVCC: stamp row with deleting transaction ID
                        if exec.mvccTxnId > 0 {
                            rowData.xmax = exec.mvccTxnId;
                        }
                        deletedIndices.add(r);
                        rowsDeleted = rowsDeleted + 1;
                        // Fire AFTER DELETE triggers
                        exec.fireTriggers(stmt.tableName, TRIGGER_AFTER, TRIGGER_DELETE, rowData, null, t);
                    }
                }
            }
            r = r + 1;
        }

        // Handle FK cascades for deleted rows
        if rowsDeleted > 0 {
            var cascadeError = handleDeleteCascade(stmt.tableName, t, deletedIndices);
            if cascadeError != "" {
                // Statement-level rollback: undo all deletes and cascaded changes
                exec.undoToSavepoint(stmtSavepoint);
                result.setError(cascadeError);
                return result;
            }
        }

        // Collect RETURNING data before compaction (compaction removes rows)
        var retResult: QueryResult? = null;
        if stmt.hasReturning && rowsDeleted > 0 {
            var rr = new QueryResult();
            rr.init();
            buildReturningColumns(rr, stmt.returningExprs, stmt.returningAliases, t);
            var di = 0;
            while di < deletedIndices.count() {
                var ri = deletedIndices.get(di);
                var maybeRow = t.getRow(ri);
                if maybeRow != null {
                    var rd = maybeRow;
                    var outRow = new Row();
                    outRow.init();
                    buildReturningRow(outRow, stmt.returningExprs, rd, t);
                    rr.addRow(outRow);
                }
                di = di + 1;
            }
            rr.rowsAffected = rowsDeleted;
            retResult = rr;
        }

        // Compact rows (deferred during explicit transactions)
        if rowsDeleted > 0 && exec.inTransaction == false {
            exec.compactTable(t);

            // Rebuild indexes since row compaction changed indices
            exec.rebuildTableIndexes(stmt.tableName, t);

            // Persist via full table rewrite (rewriteTableRows clears + rebuilds tracking)
            if exec.storageEngine != null {
                var se = exec.storageEngine;
                se.rewriteTableRows(stmt.tableName, t.rows);
                se.flush();
            }
        }

        // Update optimizer statistics
        if rowsDeleted > 0 {
            exec.optimizer.stats.setRowCount(stmt.tableName, t.rowCount());
        }

        // Return RETURNING result if applicable
        if retResult != null {
            exec.recordDelete(stmt.tableName, rowsDeleted);
            exec.clearStatementJournal();
            return retResult;
        }

        result.message = "Deleted " + Fmt.Int(rowsDeleted) + " row(s)";
        result.rowsAffected = rowsDeleted;
        exec.recordDelete(stmt.tableName, rowsDeleted);
        exec.clearStatementJournal();
        return result;
    }

    //=========================================================================
    // FOREIGN KEY CASCADE HANDLING
    //=========================================================================

    // Handle ON DELETE CASCADE/RESTRICT/SET NULL for all tables referencing the deleted rows
    hide func handleDeleteCascade(parentTableName: String, parentTable: Table, deletedIndices: List[Integer]) -> String {
        // Find all tables that have FK references to parentTableName
        var ti = 0;
        while ti < exec.db.tableCount() {
            var maybeTable = exec.db.getTable(ti);
            if maybeTable != null {
                var childTable = maybeTable;
                var ci = 0;
                while ci < childTable.columnCount() {
                    var maybeCol = childTable.getColumn(ci);
                    if maybeCol != null {
                        var col = maybeCol;
                        if col.isForeignKey && col.refTableName == parentTableName {
                            // This column references the parent table
                            var refColIdx = parentTable.findColumnIndex(col.refColumnName);
                            if refColIdx < 0 {
                                ci = ci + 1;
                                continue;
                            }

                            // Check each deleted parent row
                            var di = 0;
                            while di < deletedIndices.count() {
                                var parentIdx = deletedIndices.get(di);
                                var parentRow = parentTable.getRow(parentIdx);
                                if parentRow != null {
                                    var pr = parentRow;
                                    var parentVal = pr.getValue(refColIdx);

                                    // Find child rows referencing this value
                                    var cr = 0;
                                    while cr < childTable.rowCount() {
                                        var childRow = childTable.getRow(cr);
                                        if childRow != null {
                                            var crd = childRow;
                                            if crd.deleted == false {
                                                var childVal = crd.getValue(ci);
                                                if childVal.nullSafeEquals(parentVal) {
                                                    // Found a referencing row
                                                    if col.onDeleteAction == FK_CASCADE {
                                                        // CASCADE: delete the child row
                                                        exec.journalDelete(childTable.name, cr, crd);
                                                        crd.deleted = true;
                                                    } else if col.onDeleteAction == FK_SET_NULL {
                                                        // SET NULL: set the FK column to NULL
                                                        exec.journalUpdate(childTable.name, cr, crd);
                                                        crd.setValue(ci, sqlNull());
                                                    } else if col.onDeleteAction == FK_RESTRICT {
                                                        return "FOREIGN KEY constraint failed: RESTRICT prevents deletion of " + parentTableName + " row referenced by " + childTable.name;
                                                    } else {
                                                        // NO ACTION: check if reference still exists
                                                        return "FOREIGN KEY constraint failed: " + childTable.name + "." + col.name + " references " + parentTableName + "(" + col.refColumnName + ")";
                                                    }
                                                }
                                            }
                                        }
                                        cr = cr + 1;
                                    }
                                }
                                di = di + 1;
                            }

                            // Compact child table if CASCADE deleted rows (outside transaction)
                            if col.onDeleteAction == FK_CASCADE && exec.inTransaction == false {
                                exec.compactTable(childTable);
                                exec.rebuildTableIndexes(childTable.name, childTable);
                            }
                        }
                    }
                    ci = ci + 1;
                }
            }
            ti = ti + 1;
        }
        return "";
    }

    // Handle ON UPDATE CASCADE/RESTRICT/SET NULL when a PK/referenced column is updated
    hide func handleUpdateCascade(parentTableName: String, parentTable: Table, rowIdx: Integer, oldRow: Row, newRow: Row) -> String {
        // Find all tables that have FK references to parentTableName
        var ti = 0;
        while ti < exec.db.tableCount() {
            var maybeTable = exec.db.getTable(ti);
            if maybeTable != null {
                var childTable = maybeTable;
                var ci = 0;
                while ci < childTable.columnCount() {
                    var maybeCol = childTable.getColumn(ci);
                    if maybeCol != null {
                        var col = maybeCol;
                        if col.isForeignKey && col.refTableName == parentTableName {
                            var refColIdx = parentTable.findColumnIndex(col.refColumnName);
                            if refColIdx < 0 {
                                ci = ci + 1;
                                continue;
                            }

                            var oldVal = oldRow.getValue(refColIdx);
                            var newVal = newRow.getValue(refColIdx);

                            // Only cascade if the referenced column actually changed
                            if oldVal.nullSafeEquals(newVal) == false {
                                // Find child rows referencing the old value
                                var cr = 0;
                                while cr < childTable.rowCount() {
                                    var childRow = childTable.getRow(cr);
                                    if childRow != null {
                                        var crd = childRow;
                                        if crd.deleted == false {
                                            var childVal = crd.getValue(ci);
                                            if childVal.nullSafeEquals(oldVal) {
                                                if col.onUpdateAction == FK_CASCADE {
                                                    // CASCADE: update the FK column to new value
                                                    exec.journalUpdate(childTable.name, cr, crd);
                                                    crd.setValue(ci, newVal);
                                                } else if col.onUpdateAction == FK_SET_NULL {
                                                    exec.journalUpdate(childTable.name, cr, crd);
                                                    crd.setValue(ci, sqlNull());
                                                } else if col.onUpdateAction == FK_RESTRICT {
                                                    return "FOREIGN KEY constraint failed: RESTRICT prevents update of " + parentTableName + " row referenced by " + childTable.name;
                                                }
                                                // NO ACTION: no error for updates (reference becomes dangling)
                                            }
                                        }
                                    }
                                    cr = cr + 1;
                                }
                            }
                        }
                    }
                    ci = ci + 1;
                }
            }
            ti = ti + 1;
        }
        return "";
    }

    //=========================================================================
    // PARTITION ROUTING (Phase 28)
    //=========================================================================

    // Route INSERT to the correct child partition of a partitioned table
    hide func executeInsertPartitioned(stmt: InsertStmt, parent: Table) -> QueryResult {
        var result = new QueryResult();
        result.init();

        if parent.partitionChildren.count() == 0 {
            result.setError("No partitions defined for table '" + stmt.tableName + "'");
            return result;
        }

        // Find partition column index
        var partColIdx = parent.findColumnIndex(parent.partitionColumn);
        if partColIdx < 0 {
            result.setError("Partition column '" + parent.partitionColumn + "' not found");
            return result;
        }

        var totalInserted = 0;
        var r = 0;
        while r < stmt.rowCount() {
            var valueExprs = stmt.valueRows.get(r);

            // Determine the value for the partition column
            var partValueIdx = partColIdx;
            // If column list specified, map to the correct position
            if stmt.columnNames.count() > 0 {
                partValueIdx = -1;
                var ci = 0;
                while ci < stmt.columnNames.count() {
                    if String.ToUpper(stmt.columnNames.get(ci)) == String.ToUpper(parent.partitionColumn) {
                        partValueIdx = ci;
                        ci = stmt.columnNames.count();
                    }
                    ci = ci + 1;
                }
                if partValueIdx < 0 {
                    result.setError("Partition column '" + parent.partitionColumn + "' not in INSERT column list");
                    return result;
                }
            }

            // Evaluate the partition key value
            var partExpr = valueExprs.get(partValueIdx);
            var partVal = exec.evalExpr(partExpr, null, parent);

            // Find the correct child partition
            var targetChild = findPartitionForValue(parent, partVal);
            if targetChild == "" {
                result.setError("No partition found for value " + partVal.toSqlString() + " in table '" + stmt.tableName + "'");
                return result;
            }

            // Re-dispatch INSERT to the child partition
            var childTable = exec.findTable(targetChild);
            if childTable == null {
                result.setError("Partition table '" + targetChild + "' not found");
                return result;
            }
            var ct = childTable;

            // Build a Row for the child table
            var row = new Row();
            row.initWithCount(ct.columnCount());
            var c = 0;
            while c < ct.columnCount() {
                var col = ct.getColumn(c);
                var valIdx = c;
                if stmt.columnNames.count() > 0 {
                    valIdx = -1;
                    var mi = 0;
                    while mi < stmt.columnNames.count() {
                        if String.ToUpper(stmt.columnNames.get(mi)) == String.ToUpper(col.name) {
                            valIdx = mi;
                            mi = stmt.columnNames.count();
                        }
                        mi = mi + 1;
                    }
                }
                if valIdx >= 0 && valIdx < valueExprs.count() {
                    var val = exec.evalExpr(valueExprs.get(valIdx), null, parent);
                    row.values.set(c, val);
                } else if col.hasDefault {
                    row.values.set(c, col.defaultValue);
                } else if col.autoIncrement {
                    row.values.set(c, sqlInteger(ct.nextAutoIncrement()));
                }
                c = c + 1;
            }

            // MVCC stamp
            if exec.mvccTxnId > 0 {
                row.xmin = exec.mvccTxnId;
            }

            ct.addRow(row);
            totalInserted = totalInserted + 1;
            r = r + 1;
        }

        exec.recordInsert(stmt.tableName, totalInserted);
        result.message = "Inserted " + Fmt.Int(totalInserted) + " row(s) into partitions of '" + stmt.tableName + "'";
        result.rowsAffected = totalInserted;
        return result;
    }

    // Find the child partition that matches a given value
    hide func findPartitionForValue(parent: Table, val: SqlValue) -> String {
        var i = 0;
        while i < parent.partitionChildren.count() {
            var childName = parent.partitionChildren.get(i);
            var child = exec.findTable(childName);
            if child != null {
                var ct = child;
                if partitionAcceptsValue(ct, val) {
                    return childName;
                }
            }
            i = i + 1;
        }
        return "";
    }

    // Check if a child partition accepts the given value
    expose func partitionAcceptsValue(child: Table, val: SqlValue) -> Boolean {
        if child.partitionType == PARTITION_RANGE {
            return rangePartitionAccepts(child, val);
        }
        if child.partitionType == PARTITION_LIST {
            return listPartitionAccepts(child, val);
        }
        if child.partitionType == PARTITION_HASH {
            return hashPartitionAccepts(child, val);
        }
        return false;
    }

    hide func rangePartitionAccepts(child: Table, val: SqlValue) -> Boolean {
        // FROM value check (val >= from, unless MINVALUE)
        if child.partRangeFromStr != "MINVALUE" && child.partRangeFromStr != "" {
            var fromVal = sqlInteger(stringToInt(child.partRangeFromStr));
            if val.intValue < fromVal.intValue {
                return false;
            }
        }
        // TO value check (val < to, unless MAXVALUE)
        if child.partRangeToStr != "MAXVALUE" && child.partRangeToStr != "" {
            var toVal = sqlInteger(stringToInt(child.partRangeToStr));
            if val.intValue >= toVal.intValue {
                return false;
            }
        }
        return true;
    }

    hide func listPartitionAccepts(child: Table, val: SqlValue) -> Boolean {
        var i = 0;
        while i < child.partListValues.count() {
            var listVal = child.partListValues.get(i);
            // Compare as strings for generality
            if val.toSqlString() == listVal || val.textValue == listVal {
                return true;
            }
            // Also try integer comparison
            if val.kind == SQL_INTEGER {
                var listInt = stringToInt(listVal);
                if val.intValue == listInt {
                    return true;
                }
            }
            i = i + 1;
        }
        return false;
    }

    hide func hashPartitionAccepts(child: Table, val: SqlValue) -> Boolean {
        if child.partHashModulus <= 0 { return false; }
        var hashVal = val.intValue;
        if hashVal < 0 { hashVal = 0 - hashVal; }
        var remainder = hashVal - ((hashVal / child.partHashModulus) * child.partHashModulus);
        return remainder == child.partHashRemainder;
    }

    //=========================================================================
    // Phase 73: MERGE INTO
    //=========================================================================

    expose func executeMerge(stmt: MergeStmt) -> QueryResult {
        // Acquire exclusive lock on target, shared on source
        if exec.acquireExclusiveLock(stmt.targetTable) == false {
            return exec.lockTimeoutError(stmt.targetTable);
        }
        if stmt.sourceTable != stmt.targetTable {
            if exec.acquireSharedLock(stmt.sourceTable) == false {
                return exec.lockTimeoutError(stmt.sourceTable);
            }
        }

        var result = new QueryResult();
        result.init();

        var targetTbl = exec.findTable(stmt.targetTable);
        if targetTbl == null {
            result.setError("Table '" + stmt.targetTable + "' not found");
            return result;
        }
        var target = targetTbl!;

        var sourceTbl = exec.findTable(stmt.sourceTable);
        if sourceTbl == null {
            result.setError("Table '" + stmt.sourceTable + "' not found");
            return result;
        }
        var source = sourceTbl!;

        // Build merged table schema (target cols + source cols)
        var mergedTable = new Table();
        mergedTable.init();
        var c = 0;
        while c < target.columnCount() {
            var col = target.getColumn(c);
            if col != null {
                var mc = new Column();
                mc.initWithName(col.name, col.typeCode);
                mergedTable.addColumn(mc);
            }
            c = c + 1;
        }
        c = 0;
        while c < source.columnCount() {
            var col = source.getColumn(c);
            if col != null {
                var mc = new Column();
                mc.initWithName(col.name, col.typeCode);
                mergedTable.addColumn(mc);
            }
            c = c + 1;
        }

        // Determine alias names for multi-table resolution
        var targetName = stmt.targetAlias;
        if targetName == "" { targetName = stmt.targetTable; }
        var sourceName = stmt.sourceAlias;
        if sourceName == "" { sourceName = stmt.sourceTable; }

        var stmtSavepoint = exec.journal.count();
        var affectedRows = 0;
        var targetColCount = target.columnCount();

        // For each source row, find matching target rows via ON condition
        var si = 0;
        while si < source.rowCount() {
            var srcRow = source.getRow(si);
            if srcRow == null { si = si + 1; continue; }
            var srcData = srcRow!;
            if srcData.deleted { si = si + 1; continue; }
            if srcData.isVisible(exec.mvccSnapshotId, exec.mvccTxnId) == false {
                si = si + 1;
                continue;
            }

            var matched = false;
            var ti = 0;
            while ti < target.rowCount() {
                var tgtRow = target.getRow(ti);
                if tgtRow == null { ti = ti + 1; continue; }
                var tgtData = tgtRow!;
                if tgtData.deleted { ti = ti + 1; continue; }
                if tgtData.isVisible(exec.mvccSnapshotId, exec.mvccTxnId) == false {
                    ti = ti + 1;
                    continue;
                }

                // Build merged row: target columns + source columns
                var mergedRow = new Row();
                mergedRow.initWithCount(targetColCount + source.columnCount());
                var mc = 0;
                while mc < targetColCount {
                    mergedRow.setValue(mc, tgtData.getValue(mc));
                    mc = mc + 1;
                }
                mc = 0;
                while mc < source.columnCount() {
                    mergedRow.setValue(targetColCount + mc, srcData.getValue(mc));
                    mc = mc + 1;
                }

                // Evaluate ON condition
                if evalConditionMultiTable(stmt.onCondition, mergedRow, mergedTable, targetName, target, sourceName, source) {
                    matched = true;
                    // WHEN MATCHED: UPDATE SET or DELETE
                    if stmt.hasWhenMatched {
                        if stmt.whenMatchedIsDelete {
                            exec.journalDelete(stmt.targetTable, ti, tgtData);
                            tgtData.deleted = true;
                            if exec.mvccTxnId > 0 {
                                tgtData.xmax = exec.mvccTxnId;
                            }
                            affectedRows = affectedRows + 1;
                        } else {
                            // UPDATE SET
                            exec.journalUpdate(stmt.targetTable, ti, tgtData);
                            var ui = 0;
                            while ui < stmt.updateColumns.count() {
                                var colName = stmt.updateColumns.get(ui);
                                var valExpr = stmt.updateValues.get(ui);
                                var colIdx = target.findColumnIndex(colName);
                                if colIdx >= 0 {
                                    var val = evalExprMultiTable(valExpr, mergedRow, mergedTable, targetName, target, sourceName, source);
                                    var maybeCol = target.getColumn(colIdx);
                                    if maybeCol != null {
                                        var uc = maybeCol;
                                        val = coerceToColumnType(val, uc.typeCode);
                                    }
                                    tgtData.setValue(colIdx, val);
                                }
                                ui = ui + 1;
                            }
                            affectedRows = affectedRows + 1;
                        }
                    }
                    ti = target.rowCount(); // break after first match
                }
                ti = ti + 1;
            }

            // WHEN NOT MATCHED: INSERT
            if matched == false && stmt.hasWhenNotMatched {
                // Build a merged row for expression eval (target is empty, source is srcData)
                var insertMergedRow = new Row();
                insertMergedRow.initWithCount(targetColCount + source.columnCount());
                var mc2 = 0;
                while mc2 < source.columnCount() {
                    insertMergedRow.setValue(targetColCount + mc2, srcData.getValue(mc2));
                    mc2 = mc2 + 1;
                }

                var newRow = new Row();
                newRow.initWithCount(targetColCount);

                // Apply default values first
                var di = 0;
                while di < targetColCount {
                    var col = target.getColumn(di);
                    if col != null {
                        var defCol = col;
                        if defCol.hasDefault {
                            newRow.setValue(di, defCol.defaultValue);
                        }
                    }
                    di = di + 1;
                }

                // Set specified columns
                if stmt.insertColumns.count() > 0 {
                    var ii = 0;
                    while ii < stmt.insertColumns.count() {
                        var colName = stmt.insertColumns.get(ii);
                        var colIdx = target.findColumnIndex(colName);
                        if colIdx >= 0 {
                            var val = evalExprMultiTable(stmt.insertValues.get(ii), insertMergedRow, mergedTable, targetName, target, sourceName, source);
                            var maybeCol = target.getColumn(colIdx);
                            if maybeCol != null {
                                var ic = maybeCol;
                                val = coerceToColumnType(val, ic.typeCode);
                            }
                            newRow.setValue(colIdx, val);
                        }
                        ii = ii + 1;
                    }
                } else {
                    // No column list: positional from VALUES
                    var ii = 0;
                    while ii < stmt.insertValues.count() && ii < targetColCount {
                        var val = evalExprMultiTable(stmt.insertValues.get(ii), insertMergedRow, mergedTable, targetName, target, sourceName, source);
                        var maybeCol = target.getColumn(ii);
                        if maybeCol != null {
                            var ic = maybeCol;
                            val = coerceToColumnType(val, ic.typeCode);
                        }
                        newRow.setValue(ii, val);
                        ii = ii + 1;
                    }
                }

                // Handle AUTOINCREMENT
                var ai = 0;
                while ai < targetColCount {
                    var col = target.getColumn(ai);
                    if col != null {
                        var aiCol = col;
                        if aiCol.autoIncrement {
                            var curVal = newRow.getValue(ai);
                            if curVal.kind == SQL_NULL || curVal.intValue == 0 {
                                newRow.setValue(ai, sqlInteger(target.nextAutoIncrement()));
                            }
                        }
                    }
                    ai = ai + 1;
                }

                target.addRow(newRow);
                exec.journalInsert(stmt.targetTable, target.rowCount() - 1);
                affectedRows = affectedRows + 1;
            }

            si = si + 1;
        }

        result.success = true;
        result.message = "MERGE " + Fmt.Int(affectedRows);
        return result;
    }
}
