// setops.zia â€” SQL Set Operations (UNION, EXCEPT, INTERSECT)
// Part of ViperSQL
//
// Implements SQL set operations that combine results from two SELECT
// queries. UNION returns all rows from both (UNION ALL keeps duplicates).
// EXCEPT returns rows in the first result but not the second. INTERSECT
// returns rows present in both. Duplicate detection uses string-based
// row comparison with hash bucketing for efficient lookups.

module setops;

bind "./types";
bind "./result";

//=============================================================================
// SET OPERATIONS
//=============================================================================

// Execute UNION or UNION ALL
func executeUnion(first: QueryResult, second: QueryResult, unionAll: Boolean) -> QueryResult {
    var result = new QueryResult();
    result.init();

    // Copy column names from first result
    var ci = 0;
    while ci < first.columnNames.count() {
        result.addColumnName(first.columnNames.get(ci));
        ci = ci + 1;
    }

    // Add all rows from first result
    var ri = 0;
    while ri < first.rowCount() {
        var row = first.getRow(ri);
        if row != null {
            result.addRow(row);
        }
        ri = ri + 1;
    }

    // Add rows from second result
    ri = 0;
    while ri < second.rowCount() {
        var row = second.getRow(ri);
        if row != null {
            var r = row;
            if unionAll {
                // UNION ALL: add all rows including duplicates
                result.addRow(r);
            } else {
                // UNION: only add if not duplicate
                if isDuplicateRow(result, r) == false {
                    result.addRow(r);
                }
            }
        }
        ri = ri + 1;
    }

    return result;
}

// Execute EXCEPT - returns rows in first that are not in second
func executeExcept(first: QueryResult, second: QueryResult) -> QueryResult {
    var result = new QueryResult();
    result.init();

    // Copy column names from first result
    var ci = 0;
    while ci < first.columnNames.count() {
        result.addColumnName(first.columnNames.get(ci));
        ci = ci + 1;
    }

    // Add rows from first that are not in second
    var ri = 0;
    while ri < first.rowCount() {
        var row = first.getRow(ri);
        if row != null {
            var r = row;
            // Check if this row exists in second result
            if isRowInResult(second, r) == false {
                // Only add if not already in result (avoid duplicates)
                if isDuplicateRow(result, r) == false {
                    result.addRow(r);
                }
            }
        }
        ri = ri + 1;
    }

    return result;
}

// Execute INTERSECT - returns rows that exist in both results
func executeIntersect(first: QueryResult, second: QueryResult) -> QueryResult {
    var result = new QueryResult();
    result.init();

    // Copy column names from first result
    var ci = 0;
    while ci < first.columnNames.count() {
        result.addColumnName(first.columnNames.get(ci));
        ci = ci + 1;
    }

    // Add rows from first that also exist in second
    var ri = 0;
    while ri < first.rowCount() {
        var row = first.getRow(ri);
        if row != null {
            var r = row;
            // Check if this row exists in second result
            if isRowInResult(second, r) {
                // Only add if not already in result (avoid duplicates)
                if isDuplicateRow(result, r) == false {
                    result.addRow(r);
                }
            }
        }
        ri = ri + 1;
    }

    return result;
}

// Check if a row is a duplicate of any existing row in result
func isDuplicateRow(result: QueryResult, row: Row) -> Boolean {
    var ri = 0;
    while ri < result.rowCount() {
        var existingRow = result.getRow(ri);
        if existingRow != null {
            var er = existingRow;
            if rowsEqual(er, row) {
                return true;
            }
        }
        ri = ri + 1;
    }
    return false;
}

// Check if two rows are equal
func rowsEqual(row1: Row, row2: Row) -> Boolean {
    if row1.columnCount() != row2.columnCount() {
        return false;
    }
    var ci = 0;
    while ci < row1.columnCount() {
        var v1 = row1.getValue(ci);
        var v2 = row2.getValue(ci);
        if v1.compare(v2) != 0 {
            return false;
        }
        ci = ci + 1;
    }
    return true;
}

// Check if a row exists in a result set
func isRowInResult(result: QueryResult, row: Row) -> Boolean {
    var ri = 0;
    while ri < result.rowCount() {
        var existingRow = result.getRow(ri);
        if existingRow != null {
            var er = existingRow;
            if rowsEqual(er, row) {
                return true;
            }
        }
        ri = ri + 1;
    }
    return false;
}

// Execute EXCEPT ALL - like EXCEPT but preserves duplicates
// If a row appears N times in first and M times in second, result has max(N-M, 0) copies
func executeExceptAll(first: QueryResult, second: QueryResult) -> QueryResult {
    var result = new QueryResult();
    result.init();

    var ci = 0;
    while ci < first.columnNames.count() {
        result.addColumnName(first.columnNames.get(ci));
        ci = ci + 1;
    }

    // Track which rows in second have been "used" to cancel out first rows
    var secondUsed = new List[Integer]();
    var si = 0;
    while si < second.rowCount() {
        secondUsed.add(0);
        si = si + 1;
    }

    // For each row in first, try to find an unused match in second
    var ri = 0;
    while ri < first.rowCount() {
        var row = first.getRow(ri);
        if row != null {
            var r = row;
            var consumed = false;
            si = 0;
            while si < second.rowCount() {
                if secondUsed.get(si) == 0 {
                    var secRow = second.getRow(si);
                    if secRow != null {
                        var sr = secRow;
                        if rowsEqual(r, sr) {
                            secondUsed.set(si, 1);
                            consumed = true;
                            si = second.rowCount();  // break
                        }
                    }
                }
                si = si + 1;
            }
            if consumed == false {
                result.addRow(r);
            }
        }
        ri = ri + 1;
    }

    return result;
}

// Execute INTERSECT ALL - like INTERSECT but preserves duplicates
// If a row appears N times in first and M times in second, result has min(N, M) copies
func executeIntersectAll(first: QueryResult, second: QueryResult) -> QueryResult {
    var result = new QueryResult();
    result.init();

    var ci = 0;
    while ci < first.columnNames.count() {
        result.addColumnName(first.columnNames.get(ci));
        ci = ci + 1;
    }

    // Track which rows in second have been "used" for matching
    var secondUsed = new List[Integer]();
    var si = 0;
    while si < second.rowCount() {
        secondUsed.add(0);
        si = si + 1;
    }

    // For each row in first, try to find an unused match in second
    var ri = 0;
    while ri < first.rowCount() {
        var row = first.getRow(ri);
        if row != null {
            var r = row;
            si = 0;
            while si < second.rowCount() {
                if secondUsed.get(si) == 0 {
                    var secRow = second.getRow(si);
                    if secRow != null {
                        var sr = secRow;
                        if rowsEqual(r, sr) {
                            secondUsed.set(si, 1);
                            result.addRow(r);
                            si = second.rowCount();  // break
                        }
                    }
                }
                si = si + 1;
            }
        }
        ri = ri + 1;
    }

    return result;
}
