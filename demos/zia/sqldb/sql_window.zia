// sql_window.zia — Window Function Engine
// Part of ViperSQL
//
// Provides window function computation over result sets.
// Functions operate on QueryResult data without needing executor state.

module sql_window;

bind String = Viper.String;
bind Fmt = Viper.Fmt;

bind "./types";
bind "./table";
bind "./expr";
bind "./stmt";
bind "./result";

//=============================================================================
// WINDOW EXPRESSION RESOLUTION
//=============================================================================

// Resolve an expression against a result row (using column names from result)
func resolveWindowExpr(expr: Expr, row: Row, result: QueryResult) -> SqlValue {
    if expr.kind == EXPR_LITERAL { return expr.literalValue; }
    if expr.kind == EXPR_COLUMN {
        var ci = 0;
        while ci < result.columnNames.count() {
            if String.ToUpper(result.columnNames.get(ci)) == String.ToUpper(expr.columnName) {
                return row.getValue(ci);
            }
            ci = ci + 1;
        }
    }
    if expr.kind == EXPR_UNARY && expr.args.count() > 0 {
        var operand = resolveWindowExpr(expr.args.get(0), row, result);
        if expr.op == OP_NEG && operand.kind == SQL_INTEGER {
            return sqlInteger(0 - operand.intValue);
        }
    }
    return sqlNull();
}

//=============================================================================
// WINDOW SORTING
//=============================================================================

// Compare two rows for window sorting: first by partition key, then by ORDER BY
func compareWindowRows(idxA: Integer, idxB: Integer, partKeys: List[String], winExpr: Expr, result: QueryResult) -> Integer {
    var keyA = partKeys.get(idxA);
    var keyB = partKeys.get(idxB);
    if keyA < keyB { return -1; }
    if keyA > keyB { return 1; }

    var rowA = result.rows.get(idxA);
    var rowB = result.rows.get(idxB);
    var oi = 0;
    while oi < winExpr.windowOrderBy.count() {
        var oExpr = winExpr.windowOrderBy.get(oi);
        var valA = resolveWindowExpr(oExpr, rowA, result);
        var valB = resolveWindowExpr(oExpr, rowB, result);
        var cmp = valA.compare(valB);
        if cmp == 2 { cmp = 0; }  // NULL == NULL for ordering
        var dir = 0;
        if oi < winExpr.windowOrderDir.count() {
            dir = winExpr.windowOrderDir.get(oi);
        }
        if dir == 1 { cmp = -cmp; }  // DESC
        if cmp != 0 { return cmp; }
        oi = oi + 1;
    }
    return 0;
}

// Sort indices by partition key and window ORDER BY (insertion sort)
func sortWindowIndices(indices: List[Integer], partKeys: List[String], winExpr: Expr, result: QueryResult) {
    var n = indices.count();
    var i = 1;
    while i < n {
        var key = indices.get(i);
        var j = i - 1;
        while j >= 0 && compareWindowRows(indices.get(j), key, partKeys, winExpr, result) > 0 {
            indices.set(j + 1, indices.get(j));
            j = j - 1;
        }
        indices.set(j + 1, key);
        i = i + 1;
    }
}

// Check if two rows have equal ORDER BY values
func windowOrderValuesEqual(winExpr: Expr, rowA: Row, rowB: Row, result: QueryResult) -> Boolean {
    var oi = 0;
    while oi < winExpr.windowOrderBy.count() {
        var oExpr = winExpr.windowOrderBy.get(oi);
        var valA = resolveWindowExpr(oExpr, rowA, result);
        var valB = resolveWindowExpr(oExpr, rowB, result);
        var cmp = valA.compare(valB);
        if cmp != 0 { return false; }
        oi = oi + 1;
    }
    return true;
}

//=============================================================================
// FRAME BOUNDS COMPUTATION (Phase 61)
//=============================================================================

// Compute frame start index within partition (0-based relative to partStart)
// Returns the first row index (relative to partition start) included in the frame.
func computeFrameStart(winExpr: Expr, wi: Integer, partSize: Integer) -> Integer {
    var kind = winExpr.frameStartKind;
    if kind == 1 {
        // UNBOUNDED PRECEDING
        return 0;
    } else if kind == 2 {
        // N PRECEDING
        var start = wi - winExpr.frameStartN;
        if start < 0 { return 0; }
        return start;
    } else if kind == 3 {
        // CURRENT ROW
        return wi;
    } else if kind == 4 {
        // N FOLLOWING
        var start = wi + winExpr.frameStartN;
        if start >= partSize { return partSize; }
        return start;
    } else if kind == 5 {
        // UNBOUNDED FOLLOWING
        return partSize - 1;
    }
    // Default: UNBOUNDED PRECEDING
    return 0;
}

// Compute frame end index within partition (0-based relative to partStart, inclusive)
func computeFrameEnd(winExpr: Expr, wi: Integer, partSize: Integer) -> Integer {
    var kind = winExpr.frameEndKind;
    if kind == 1 {
        // UNBOUNDED PRECEDING
        return 0;
    } else if kind == 2 {
        // N PRECEDING
        var end = wi - winExpr.frameEndN;
        if end < 0 { return -1; } // empty frame
        return end;
    } else if kind == 3 {
        // CURRENT ROW
        return wi;
    } else if kind == 4 {
        // N FOLLOWING
        var end = wi + winExpr.frameEndN;
        if end >= partSize { return partSize - 1; }
        return end;
    } else if kind == 5 {
        // UNBOUNDED FOLLOWING
        return partSize - 1;
    }
    // Default: CURRENT ROW (for running aggregates with ORDER BY)
    return wi;
}

// Format a ratio numer/denom as a decimal string (e.g. "0.25", "0.75")
func formatDecimalRatio(numer: Integer, denom: Integer) -> String {
    if numer == 0 { return "0"; }
    if numer == denom { return "1"; }
    var intPart = numer / denom;
    var fracNumer = numer - (intPart * denom);
    // Compute 4 decimal digits
    var scaled = (fracNumer * 10000) / denom;
    var d1 = scaled / 1000;
    var d2 = (scaled - d1 * 1000) / 100;
    var d3 = (scaled - d1 * 1000 - d2 * 100) / 10;
    var d4 = scaled - d1 * 1000 - d2 * 100 - d3 * 10;
    // Build fractional part, stripping trailing zeros
    var frac = "";
    if d4 != 0 {
        frac = Fmt.Int(d1) + Fmt.Int(d2) + Fmt.Int(d3) + Fmt.Int(d4);
    } else if d3 != 0 {
        frac = Fmt.Int(d1) + Fmt.Int(d2) + Fmt.Int(d3);
    } else if d2 != 0 {
        frac = Fmt.Int(d1) + Fmt.Int(d2);
    } else {
        frac = Fmt.Int(d1);
    }
    return Fmt.Int(intPart) + "." + frac;
}

// Check if an explicit frame is specified
func hasExplicitFrame(winExpr: Expr) -> Boolean {
    return winExpr.frameMode > 0;
}

//=============================================================================
// WINDOW FUNCTION COMPUTATION
//=============================================================================

// Compute window function values for a specific result column
func computeWindowColumn(winExpr: Expr, result: QueryResult, colIdx: Integer, table: Table) {
    var funcName = String.ToUpper(winExpr.funcName);
    var rowCount = result.rowCount();
    if rowCount == 0 { return; }

    // Build partition keys for each row
    var partKeys: List[String] = [];
    var ri = 0;
    while ri < rowCount {
        var row = result.rows.get(ri);
        var key = "";
        var pi = 0;
        while pi < winExpr.partitionBy.count() {
            if pi > 0 { key = key + "|"; }
            var pExpr = winExpr.partitionBy.get(pi);
            var pVal = resolveWindowExpr(pExpr, row, result);
            key = key + pVal.toString();
            pi = pi + 1;
        }
        partKeys.add(key);
        ri = ri + 1;
    }

    // Build sort indices
    var indices: List[Integer] = [];
    ri = 0;
    while ri < rowCount {
        indices.add(ri);
        ri = ri + 1;
    }

    // Sort indices by (partitionKey, orderBy columns)
    sortWindowIndices(indices, partKeys, winExpr, result);

    // Initialize window values with nulls
    var windowValues: List[SqlValue] = [];
    ri = 0;
    while ri < rowCount {
        windowValues.add(sqlNull());
        ri = ri + 1;
    }

    // Process rows in sorted order, tracking partitions
    var partStart = 0;
    while partStart < rowCount {
        var currentPartKey = partKeys.get(indices.get(partStart));
        var partEnd = partStart + 1;
        while partEnd < rowCount && partKeys.get(indices.get(partEnd)) == currentPartKey {
            partEnd = partEnd + 1;
        }

        var partSize = partEnd - partStart;
        var hasWindowOrder = winExpr.windowOrderBy.count() > 0;

        if funcName == "ROW_NUMBER" {
            var wi = 0;
            while wi < partSize {
                var origIdx = indices.get(partStart + wi);
                windowValues.set(origIdx, sqlInteger(wi + 1));
                wi = wi + 1;
            }
        } else if funcName == "RANK" {
            var wi = 0;
            var currentRank = 1;
            while wi < partSize {
                var origIdx = indices.get(partStart + wi);
                if wi > 0 {
                    var prevIdx = indices.get(partStart + wi - 1);
                    if windowOrderValuesEqual(winExpr, result.rows.get(origIdx), result.rows.get(prevIdx), result) == false {
                        currentRank = wi + 1;
                    }
                }
                windowValues.set(origIdx, sqlInteger(currentRank));
                wi = wi + 1;
            }
        } else if funcName == "DENSE_RANK" {
            var wi = 0;
            var currentRank = 1;
            while wi < partSize {
                var origIdx = indices.get(partStart + wi);
                if wi > 0 {
                    var prevIdx = indices.get(partStart + wi - 1);
                    if windowOrderValuesEqual(winExpr, result.rows.get(origIdx), result.rows.get(prevIdx), result) == false {
                        currentRank = currentRank + 1;
                    }
                }
                windowValues.set(origIdx, sqlInteger(currentRank));
                wi = wi + 1;
            }
        } else if funcName == "SUM" {
            if hasExplicitFrame(winExpr) {
                var wi = 0;
                while wi < partSize {
                    var origIdx = indices.get(partStart + wi);
                    var fStart = computeFrameStart(winExpr, wi, partSize);
                    var fEnd = computeFrameEnd(winExpr, wi, partSize);
                    var frameSum = 0;
                    var fi = fStart;
                    while fi <= fEnd && fi < partSize {
                        if fi == wi && winExpr.frameExclude == 1 { fi = fi + 1; continue; }
                        var fOrigIdx = indices.get(partStart + fi);
                        var fRow = result.rows.get(fOrigIdx);
                        if winExpr.args.count() > 0 {
                            var argVal = resolveWindowExpr(winExpr.args.get(0), fRow, result);
                            if argVal.kind == SQL_INTEGER { frameSum = frameSum + argVal.intValue; }
                        }
                        fi = fi + 1;
                    }
                    windowValues.set(origIdx, sqlInteger(frameSum));
                    wi = wi + 1;
                }
            } else if hasWindowOrder {
                var runningSum = 0;
                var wi = 0;
                while wi < partSize {
                    var origIdx = indices.get(partStart + wi);
                    var row = result.rows.get(origIdx);
                    if winExpr.args.count() > 0 {
                        var argVal = resolveWindowExpr(winExpr.args.get(0), row, result);
                        if argVal.kind == SQL_INTEGER {
                            runningSum = runningSum + argVal.intValue;
                        }
                    }
                    windowValues.set(origIdx, sqlInteger(runningSum));
                    wi = wi + 1;
                }
            } else {
                var totalSum = 0;
                var wi = 0;
                while wi < partSize {
                    var origIdx = indices.get(partStart + wi);
                    var row = result.rows.get(origIdx);
                    if winExpr.args.count() > 0 {
                        var argVal = resolveWindowExpr(winExpr.args.get(0), row, result);
                        if argVal.kind == SQL_INTEGER { totalSum = totalSum + argVal.intValue; }
                    }
                    wi = wi + 1;
                }
                wi = 0;
                while wi < partSize {
                    windowValues.set(indices.get(partStart + wi), sqlInteger(totalSum));
                    wi = wi + 1;
                }
            }
        } else if funcName == "COUNT" {
            if hasExplicitFrame(winExpr) {
                var wi = 0;
                while wi < partSize {
                    var origIdx = indices.get(partStart + wi);
                    var fStart = computeFrameStart(winExpr, wi, partSize);
                    var fEnd = computeFrameEnd(winExpr, wi, partSize);
                    var frameCount = 0;
                    var fi = fStart;
                    while fi <= fEnd && fi < partSize {
                        if fi == wi && winExpr.frameExclude == 1 { fi = fi + 1; continue; }
                        frameCount = frameCount + 1;
                        fi = fi + 1;
                    }
                    windowValues.set(origIdx, sqlInteger(frameCount));
                    wi = wi + 1;
                }
            } else if hasWindowOrder {
                var runningCount = 0;
                var wi = 0;
                while wi < partSize {
                    var origIdx = indices.get(partStart + wi);
                    runningCount = runningCount + 1;
                    windowValues.set(origIdx, sqlInteger(runningCount));
                    wi = wi + 1;
                }
            } else {
                var wi = 0;
                while wi < partSize {
                    windowValues.set(indices.get(partStart + wi), sqlInteger(partSize));
                    wi = wi + 1;
                }
            }
        } else if funcName == "AVG" {
            if hasExplicitFrame(winExpr) {
                var wi = 0;
                while wi < partSize {
                    var origIdx = indices.get(partStart + wi);
                    var fStart = computeFrameStart(winExpr, wi, partSize);
                    var fEnd = computeFrameEnd(winExpr, wi, partSize);
                    var frameSum = 0;
                    var frameCount = 0;
                    var fi = fStart;
                    while fi <= fEnd && fi < partSize {
                        if fi == wi && winExpr.frameExclude == 1 { fi = fi + 1; continue; }
                        var fOrigIdx = indices.get(partStart + fi);
                        var fRow = result.rows.get(fOrigIdx);
                        if winExpr.args.count() > 0 {
                            var argVal = resolveWindowExpr(winExpr.args.get(0), fRow, result);
                            if argVal.kind == SQL_INTEGER { frameSum = frameSum + argVal.intValue; }
                        }
                        frameCount = frameCount + 1;
                        fi = fi + 1;
                    }
                    if frameCount > 0 {
                        windowValues.set(origIdx, sqlInteger(frameSum / frameCount));
                    }
                    wi = wi + 1;
                }
            } else if hasWindowOrder {
                var runningSum = 0;
                var runningCount = 0;
                var wi = 0;
                while wi < partSize {
                    var origIdx = indices.get(partStart + wi);
                    var row = result.rows.get(origIdx);
                    if winExpr.args.count() > 0 {
                        var argVal = resolveWindowExpr(winExpr.args.get(0), row, result);
                        if argVal.kind == SQL_INTEGER { runningSum = runningSum + argVal.intValue; }
                    }
                    runningCount = runningCount + 1;
                    windowValues.set(origIdx, sqlInteger(runningSum / runningCount));
                    wi = wi + 1;
                }
            } else {
                var totalSum = 0;
                var wi = 0;
                while wi < partSize {
                    var origIdx = indices.get(partStart + wi);
                    var row = result.rows.get(origIdx);
                    if winExpr.args.count() > 0 {
                        var argVal = resolveWindowExpr(winExpr.args.get(0), row, result);
                        if argVal.kind == SQL_INTEGER { totalSum = totalSum + argVal.intValue; }
                    }
                    wi = wi + 1;
                }
                var avgVal = totalSum / partSize;
                wi = 0;
                while wi < partSize {
                    windowValues.set(indices.get(partStart + wi), sqlInteger(avgVal));
                    wi = wi + 1;
                }
            }
        } else if funcName == "MIN" {
            if hasExplicitFrame(winExpr) {
                var wi = 0;
                while wi < partSize {
                    var origIdx = indices.get(partStart + wi);
                    var fStart = computeFrameStart(winExpr, wi, partSize);
                    var fEnd = computeFrameEnd(winExpr, wi, partSize);
                    var frameMin = sqlNull();
                    var fi = fStart;
                    while fi <= fEnd && fi < partSize {
                        if fi == wi && winExpr.frameExclude == 1 { fi = fi + 1; continue; }
                        var fOrigIdx = indices.get(partStart + fi);
                        var fRow = result.rows.get(fOrigIdx);
                        if winExpr.args.count() > 0 {
                            var argVal = resolveWindowExpr(winExpr.args.get(0), fRow, result);
                            if frameMin.kind == SQL_NULL || argVal.compare(frameMin) < 0 { frameMin = argVal; }
                        }
                        fi = fi + 1;
                    }
                    windowValues.set(origIdx, frameMin);
                    wi = wi + 1;
                }
            } else if hasWindowOrder {
                var runMin = sqlNull();
                var wi = 0;
                while wi < partSize {
                    var origIdx = indices.get(partStart + wi);
                    var row = result.rows.get(origIdx);
                    if winExpr.args.count() > 0 {
                        var argVal = resolveWindowExpr(winExpr.args.get(0), row, result);
                        if runMin.kind == SQL_NULL || argVal.compare(runMin) < 0 {
                            runMin = argVal;
                        }
                    }
                    windowValues.set(origIdx, runMin);
                    wi = wi + 1;
                }
            } else {
                var partMin = sqlNull();
                var wi = 0;
                while wi < partSize {
                    var origIdx = indices.get(partStart + wi);
                    var row = result.rows.get(origIdx);
                    if winExpr.args.count() > 0 {
                        var argVal = resolveWindowExpr(winExpr.args.get(0), row, result);
                        if partMin.kind == SQL_NULL || argVal.compare(partMin) < 0 { partMin = argVal; }
                    }
                    wi = wi + 1;
                }
                wi = 0;
                while wi < partSize {
                    windowValues.set(indices.get(partStart + wi), partMin);
                    wi = wi + 1;
                }
            }
        } else if funcName == "MAX" {
            if hasExplicitFrame(winExpr) {
                var wi = 0;
                while wi < partSize {
                    var origIdx = indices.get(partStart + wi);
                    var fStart = computeFrameStart(winExpr, wi, partSize);
                    var fEnd = computeFrameEnd(winExpr, wi, partSize);
                    var frameMax = sqlNull();
                    var fi = fStart;
                    while fi <= fEnd && fi < partSize {
                        if fi == wi && winExpr.frameExclude == 1 { fi = fi + 1; continue; }
                        var fOrigIdx = indices.get(partStart + fi);
                        var fRow = result.rows.get(fOrigIdx);
                        if winExpr.args.count() > 0 {
                            var argVal = resolveWindowExpr(winExpr.args.get(0), fRow, result);
                            if frameMax.kind == SQL_NULL || argVal.compare(frameMax) > 0 { frameMax = argVal; }
                        }
                        fi = fi + 1;
                    }
                    windowValues.set(origIdx, frameMax);
                    wi = wi + 1;
                }
            } else if hasWindowOrder {
                var runMax = sqlNull();
                var wi = 0;
                while wi < partSize {
                    var origIdx = indices.get(partStart + wi);
                    var row = result.rows.get(origIdx);
                    if winExpr.args.count() > 0 {
                        var argVal = resolveWindowExpr(winExpr.args.get(0), row, result);
                        if runMax.kind == SQL_NULL || argVal.compare(runMax) > 0 { runMax = argVal; }
                    }
                    windowValues.set(origIdx, runMax);
                    wi = wi + 1;
                }
            } else {
                var partMax = sqlNull();
                var wi = 0;
                while wi < partSize {
                    var origIdx = indices.get(partStart + wi);
                    var row = result.rows.get(origIdx);
                    if winExpr.args.count() > 0 {
                        var argVal = resolveWindowExpr(winExpr.args.get(0), row, result);
                        if partMax.kind == SQL_NULL || argVal.compare(partMax) > 0 { partMax = argVal; }
                    }
                    wi = wi + 1;
                }
                wi = 0;
                while wi < partSize {
                    windowValues.set(indices.get(partStart + wi), partMax);
                    wi = wi + 1;
                }
            }
        } else if funcName == "LAG" {
            // LAG(expr [, offset [, default]]) — value from offset rows before
            var lagOffset = 1;
            if winExpr.args.count() > 1 {
                var offVal = resolveWindowExpr(winExpr.args.get(1), result.rows.get(indices.get(partStart)), result);
                if offVal.kind == SQL_INTEGER { lagOffset = offVal.intValue; }
            }
            var lagDefault = sqlNull();
            if winExpr.args.count() > 2 {
                lagDefault = resolveWindowExpr(winExpr.args.get(2), result.rows.get(indices.get(partStart)), result);
            }
            var wi = 0;
            while wi < partSize {
                var origIdx = indices.get(partStart + wi);
                var srcIdx = wi - lagOffset;
                if srcIdx >= 0 && srcIdx < partSize {
                    var srcOrigIdx = indices.get(partStart + srcIdx);
                    var srcRow = result.rows.get(srcOrigIdx);
                    if winExpr.args.count() > 0 {
                        windowValues.set(origIdx, resolveWindowExpr(winExpr.args.get(0), srcRow, result));
                    }
                } else {
                    windowValues.set(origIdx, lagDefault);
                }
                wi = wi + 1;
            }
        } else if funcName == "LEAD" {
            // LEAD(expr [, offset [, default]]) — value from offset rows after
            var leadOffset = 1;
            if winExpr.args.count() > 1 {
                var offVal = resolveWindowExpr(winExpr.args.get(1), result.rows.get(indices.get(partStart)), result);
                if offVal.kind == SQL_INTEGER { leadOffset = offVal.intValue; }
            }
            var leadDefault = sqlNull();
            if winExpr.args.count() > 2 {
                leadDefault = resolveWindowExpr(winExpr.args.get(2), result.rows.get(indices.get(partStart)), result);
            }
            var wi = 0;
            while wi < partSize {
                var origIdx = indices.get(partStart + wi);
                var srcIdx = wi + leadOffset;
                if srcIdx >= 0 && srcIdx < partSize {
                    var srcOrigIdx = indices.get(partStart + srcIdx);
                    var srcRow = result.rows.get(srcOrigIdx);
                    if winExpr.args.count() > 0 {
                        windowValues.set(origIdx, resolveWindowExpr(winExpr.args.get(0), srcRow, result));
                    }
                } else {
                    windowValues.set(origIdx, leadDefault);
                }
                wi = wi + 1;
            }
        } else if funcName == "FIRST_VALUE" {
            // FIRST_VALUE(expr) — first value in partition
            var wi = 0;
            while wi < partSize {
                var origIdx = indices.get(partStart + wi);
                var firstOrigIdx = indices.get(partStart);
                var firstRow = result.rows.get(firstOrigIdx);
                if winExpr.args.count() > 0 {
                    windowValues.set(origIdx, resolveWindowExpr(winExpr.args.get(0), firstRow, result));
                }
                wi = wi + 1;
            }
        } else if funcName == "LAST_VALUE" {
            // LAST_VALUE(expr) — last value in partition
            var wi = 0;
            while wi < partSize {
                var origIdx = indices.get(partStart + wi);
                var lastOrigIdx = indices.get(partStart + partSize - 1);
                var lastRow = result.rows.get(lastOrigIdx);
                if winExpr.args.count() > 0 {
                    windowValues.set(origIdx, resolveWindowExpr(winExpr.args.get(0), lastRow, result));
                }
                wi = wi + 1;
            }
        } else if funcName == "NTH_VALUE" {
            // NTH_VALUE(expr, n) — value from nth row (1-based) in partition
            var nthPos = 1;
            if winExpr.args.count() > 1 {
                var nVal = resolveWindowExpr(winExpr.args.get(1), result.rows.get(indices.get(partStart)), result);
                if nVal.kind == SQL_INTEGER { nthPos = nVal.intValue; }
            }
            var wi = 0;
            while wi < partSize {
                var origIdx = indices.get(partStart + wi);
                if nthPos >= 1 && nthPos <= partSize {
                    var nthOrigIdx = indices.get(partStart + nthPos - 1);
                    var nthRow = result.rows.get(nthOrigIdx);
                    if winExpr.args.count() > 0 {
                        windowValues.set(origIdx, resolveWindowExpr(winExpr.args.get(0), nthRow, result));
                    }
                }
                // else stays NULL (out of range)
                wi = wi + 1;
            }
        } else if funcName == "NTILE" {
            // NTILE(n) — divide partition into n buckets
            var numBuckets = 1;
            if winExpr.args.count() > 0 {
                var bVal = resolveWindowExpr(winExpr.args.get(0), result.rows.get(indices.get(partStart)), result);
                if bVal.kind == SQL_INTEGER && bVal.intValue > 0 { numBuckets = bVal.intValue; }
            }
            var wi = 0;
            while wi < partSize {
                var origIdx = indices.get(partStart + wi);
                // Calculate bucket: distribute rows as evenly as possible
                // Each bucket gets at least (partSize / numBuckets) rows
                // First (partSize % numBuckets) buckets get one extra row
                var baseSize = partSize / numBuckets;
                var extra = partSize - (baseSize * numBuckets);
                var bucket = 0;
                var threshold = 0;
                var b = 0;
                while b < numBuckets {
                    var bSize = baseSize;
                    if b < extra { bSize = bSize + 1; }
                    threshold = threshold + bSize;
                    if wi < threshold {
                        bucket = b + 1;
                        b = numBuckets;  // break
                    }
                    b = b + 1;
                }
                windowValues.set(origIdx, sqlInteger(bucket));
                wi = wi + 1;
            }
        } else if funcName == "PERCENT_RANK" {
            // PERCENT_RANK() = (rank - 1) / (total_rows - 1), returns 0 if single row
            var wi = 0;
            var currentRank = 1;
            while wi < partSize {
                var origIdx = indices.get(partStart + wi);
                if wi > 0 {
                    var prevIdx = indices.get(partStart + wi - 1);
                    if windowOrderValuesEqual(winExpr, result.rows.get(origIdx), result.rows.get(prevIdx), result) == false {
                        currentRank = wi + 1;
                    }
                }
                if partSize <= 1 {
                    windowValues.set(origIdx, sqlText("0"));
                } else {
                    var numer = currentRank - 1;
                    var denom = partSize - 1;
                    windowValues.set(origIdx, sqlText(formatDecimalRatio(numer, denom)));
                }
                wi = wi + 1;
            }
        } else if funcName == "CUME_DIST" {
            // CUME_DIST() = number of rows with value <= current / total rows
            var wi = 0;
            while wi < partSize {
                var origIdx = indices.get(partStart + wi);
                // Count rows with ORDER BY value <= current
                // Since sorted, find last row with same value
                var lastSame = wi;
                while lastSame + 1 < partSize {
                    var nextIdx = indices.get(partStart + lastSame + 1);
                    if windowOrderValuesEqual(winExpr, result.rows.get(origIdx), result.rows.get(nextIdx), result) {
                        lastSame = lastSame + 1;
                    } else {
                        lastSame = lastSame;  // break equivalent
                        nextIdx = nextIdx;  // dummy to exit
                        lastSame = lastSame + partSize;  // force exit
                    }
                }
                if lastSame >= partSize { lastSame = lastSame - partSize; }
                var numLE = lastSame + 1;
                windowValues.set(origIdx, sqlText(formatDecimalRatio(numLE, partSize)));
                wi = wi + 1;
            }
        }

        partStart = partEnd;
    }

    // Replace result column values with computed window values
    ri = 0;
    while ri < rowCount {
        var row = result.rows.get(ri);
        if colIdx < row.columnCount() {
            row.setValue(colIdx, windowValues.get(ri));
        }
        ri = ri + 1;
    }
}

// Apply window functions to the result set
func applyWindowFunctions(stmt: SelectStmt, result: QueryResult, table: Table) {
    // Phase 75: Resolve named window references (OVER w → copy from WINDOW w AS (...))
    if stmt.windowDefNames.count() > 0 {
        var ci = 0;
        while ci < stmt.columns.count() {
            var colExpr = stmt.columns.get(ci);
            if colExpr.kind == EXPR_WINDOW && colExpr.windowRefName != "" {
                resolveNamedWindow(colExpr, stmt);
            }
            ci = ci + 1;
        }
    }

    var colIdx = 0;
    while colIdx < stmt.columns.count() {
        var colExpr = stmt.columns.get(colIdx);
        if colExpr.kind == EXPR_WINDOW {
            computeWindowColumn(colExpr, result, colIdx, table);
        }
        colIdx = colIdx + 1;
    }
}

// Phase 75: Copy window spec from named definition to a window expression
func resolveNamedWindow(expr: Expr, stmt: SelectStmt) {
    var refName = expr.windowRefName;
    var wi = 0;
    while wi < stmt.windowDefNames.count() {
        if stmt.windowDefNames.get(wi) == refName {
            var def = stmt.windowDefExprs.get(wi);
            // Copy partition, order, frame from definition
            var pi = 0;
            while pi < def.partitionBy.count() {
                expr.partitionBy.add(def.partitionBy.get(pi));
                pi = pi + 1;
            }
            var oi = 0;
            while oi < def.windowOrderBy.count() {
                expr.windowOrderBy.add(def.windowOrderBy.get(oi));
                if oi < def.windowOrderDir.count() {
                    expr.windowOrderDir.add(def.windowOrderDir.get(oi));
                } else {
                    expr.windowOrderDir.add(0);
                }
                oi = oi + 1;
            }
            if def.frameMode != 0 {
                expr.frameMode = def.frameMode;
                expr.frameStartKind = def.frameStartKind;
                expr.frameStartN = def.frameStartN;
                expr.frameEndKind = def.frameEndKind;
                expr.frameEndN = def.frameEndN;
                expr.frameExclude = def.frameExclude;
            }
            expr.windowRefName = ""; // Mark as resolved
            return;
        }
        wi = wi + 1;
    }
}
