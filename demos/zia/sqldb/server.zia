// server.zia - Multi-Database Server (Phase 1)
// Part of ViperSQL - Production Database Server
// Manages multiple databases in a single server instance

module server;

bind Fmt = Viper.Fmt;
bind IO = Viper.IO;
bind Threads = Viper.Threads;

bind "./database";
bind "./table";
bind "./index";
bind "./storage/page";
bind "./storage/serializer";
bind "./storage/pager";
bind "./storage/buffer";
bind "./storage/schema_page";
bind "./storage/data_page";
bind "./storage/engine";
bind "./storage/txn";

//=============================================================================
// DATABASE SERVER ENTITY
//=============================================================================

// Thread-safe: all public methods are protected by a Monitor lock.
entity DatabaseServer {
    // Map of database name to Database object
    // Since Zia doesn't have native Map, we use parallel lists
    expose List[String] dbNames;
    expose List[Database] dbList;
    expose List[IndexManager] indexManagers;

    // Parallel list tracking per-database storage engines (null for in-memory databases)
    expose List[StorageEngine?] storageEngines;
    // Parallel list tracking per-database file paths ("" for in-memory databases)
    expose List[String] dbFilePaths;

    // Current database context
    expose String currentDbName;
    expose Integer currentDbIndex;

    // Shared table lock manager for concurrent access control
    expose TableLockManager tableLockMgr;

    // User management (Phase 10: Authentication)
    expose List[String] userNames;
    expose List[String] userPasswords;

    // Monitor object for thread safety
    hide List[Integer] lock;

    expose func init() {
        dbNames = [];
        dbList = [];
        indexManagers = [];
        storageEngines = [];
        dbFilePaths = [];
        currentDbName = "";
        currentDbIndex = -1;
        lock = [];
        userNames = [];
        userPasswords = [];
        tableLockMgr = new TableLockManager();
        tableLockMgr.init();

        // Create default database (use internal variants to avoid deadlock)
        createDatabaseInternal("main");
        useDatabaseInternal("main");

        // Create default superuser
        createUserInternal("admin", "admin");
    }

    //=========================================================================
    // DATABASE MANAGEMENT
    //=========================================================================

    // Create a new database
    expose func createDatabase(name: String) -> Boolean {
        Threads.Monitor.Enter(lock);
        var result = createDatabaseInternal(name);
        Threads.Monitor.Exit(lock);
        return result;
    }

    hide func createDatabaseInternal(name: String) -> Boolean {
        // Check if database already exists
        var i = 0;
        while i < dbNames.count() {
            if dbNames.get(i) == name {
                return false;
            }
            i = i + 1;
        }

        // Create new database
        var db = new Database();
        db.initWithName(name);
        dbNames.add(name);
        dbList.add(db);

        // Create index manager for this database
        var idxMgr = new IndexManager();
        idxMgr.init();
        indexManagers.add(idxMgr);

        // No storage engine by default (in-memory)
        storageEngines.add(null);
        dbFilePaths.add("");

        return true;
    }

    // Create a new database with persistent file storage
    expose func createDatabaseWithFile(name: String, filePath: String) -> Boolean {
        Threads.Monitor.Enter(lock);
        var result = createDatabaseWithFileInternal(name, filePath);
        Threads.Monitor.Exit(lock);
        return result;
    }

    hide func createDatabaseWithFileInternal(name: String, filePath: String) -> Boolean {
        // Check if database already exists
        var i = 0;
        while i < dbNames.count() {
            if dbNames.get(i) == name {
                return false;
            }
            i = i + 1;
        }

        // Create new database
        var db = new Database();
        db.initWithName(name);
        dbNames.add(name);
        dbList.add(db);

        // Create index manager for this database
        var idxMgr = new IndexManager();
        idxMgr.init();
        indexManagers.add(idxMgr);

        // Create storage engine for persistent file
        var se = new StorageEngine();
        se.init();

        var isNew = true;
        var ok = false;
        if IO.File.Exists(filePath) {
            ok = se.openDatabase(filePath);
            isNew = false;
        } else {
            ok = se.createDatabase(filePath);
        }

        if ok == false {
            // Rollback: remove the database we just added
            var newDbNames: List[String] = [];
            var newDbList: List[Database] = [];
            var newIdxMgrs: List[IndexManager] = [];
            var j = 0;
            while j < dbNames.count() - 1 {
                newDbNames.add(dbNames.get(j));
                newDbList.add(dbList.get(j));
                newIdxMgrs.add(indexManagers.get(j));
                j = j + 1;
            }
            dbNames = newDbNames;
            dbList = newDbList;
            indexManagers = newIdxMgrs;
            return false;
        }

        // Auto-enable WAL for persistent databases
        if isNew {
            var walDir = filePath + ".wal";
            se.enableWal(walDir);
        }

        storageEngines.add(se);
        dbFilePaths.add(filePath);

        // If reopening existing file, load tables
        if isNew == false {
            var tables = se.loadAllTables();
            var k = 0;
            while k < tables.count() {
                db.addTable(tables.get(k));
                k = k + 1;
            }
        }

        return true;
    }

    // Drop a database
    expose func dropDatabase(name: String) -> Boolean {
        Threads.Monitor.Enter(lock);
        var result = dropDatabaseInternal(name);
        Threads.Monitor.Exit(lock);
        return result;
    }

    hide func dropDatabaseInternal(name: String) -> Boolean {
        // Cannot drop current database
        if name == currentDbName {
            return false;
        }

        // Cannot drop 'main' database
        if name == "main" {
            return false;
        }

        // Find the index of the database to drop
        var dropIdx = -1;
        var i = 0;
        while i < dbNames.count() {
            if dbNames.get(i) == name {
                dropIdx = i;
                i = dbNames.count();  // break
            }
            i = i + 1;
        }

        if dropIdx < 0 {
            return false;  // Database not found
        }

        // Close storage engine if this database has one
        var maybeSe = storageEngines.get(dropIdx);
        if maybeSe != null {
            var se = maybeSe;
            se.closeDatabase();
        }

        // Workaround for BUG-002: List.remove() doesn't work
        // Rebuild lists without the dropped database
        var newDbNames: List[String] = [];
        var newDbList: List[Database] = [];
        var newIndexManagers: List[IndexManager] = [];
        var newStorageEngines: List[StorageEngine?] = [];
        var newDbFilePaths: List[String] = [];

        i = 0;
        while i < dbNames.count() {
            if i != dropIdx {
                newDbNames.add(dbNames.get(i));
                newDbList.add(dbList.get(i));
                newIndexManagers.add(indexManagers.get(i));
                newStorageEngines.add(storageEngines.get(i));
                newDbFilePaths.add(dbFilePaths.get(i));
            }
            i = i + 1;
        }

        dbNames = newDbNames;
        dbList = newDbList;
        indexManagers = newIndexManagers;
        storageEngines = newStorageEngines;
        dbFilePaths = newDbFilePaths;

        // Update currentDbIndex if needed (if current was after dropped)
        if currentDbIndex > dropIdx {
            currentDbIndex = currentDbIndex - 1;
        }

        return true;
    }

    // Switch to a different database
    expose func useDatabase(name: String) -> Boolean {
        Threads.Monitor.Enter(lock);
        var result = useDatabaseInternal(name);
        Threads.Monitor.Exit(lock);
        return result;
    }

    hide func useDatabaseInternal(name: String) -> Boolean {
        var i = 0;
        while i < dbNames.count() {
            if dbNames.get(i) == name {
                currentDbName = name;
                currentDbIndex = i;
                return true;
            }
            i = i + 1;
        }
        return false;
    }

    // Check if a database exists
    expose func databaseExists(name: String) -> Boolean {
        Threads.Monitor.Enter(lock);
        var result = databaseExistsInternal(name);
        Threads.Monitor.Exit(lock);
        return result;
    }

    hide func databaseExistsInternal(name: String) -> Boolean {
        var i = 0;
        while i < dbNames.count() {
            if dbNames.get(i) == name {
                return true;
            }
            i = i + 1;
        }
        return false;
    }

    // Get list of all database names
    expose func listDatabases() -> List[String] {
        Threads.Monitor.Enter(lock);
        var result = dbNames;
        Threads.Monitor.Exit(lock);
        return result;
    }

    // Get database count
    expose func databaseCount() -> Integer {
        Threads.Monitor.Enter(lock);
        var result = dbNames.count();
        Threads.Monitor.Exit(lock);
        return result;
    }

    // Get database by name
    expose func getDatabase(name: String) -> Database? {
        Threads.Monitor.Enter(lock);
        var result = getDatabaseInternal(name);
        Threads.Monitor.Exit(lock);
        return result;
    }

    hide func getDatabaseInternal(name: String) -> Database? {
        var i = 0;
        while i < dbNames.count() {
            if dbNames.get(i) == name {
                return dbList.get(i);
            }
            i = i + 1;
        }
        return null;
    }

    // Get index manager for a database
    expose func getIndexManager(name: String) -> IndexManager? {
        Threads.Monitor.Enter(lock);
        var result = getIndexManagerInternal(name);
        Threads.Monitor.Exit(lock);
        return result;
    }

    hide func getIndexManagerInternal(name: String) -> IndexManager? {
        var i = 0;
        while i < dbNames.count() {
            if dbNames.get(i) == name {
                return indexManagers.get(i);
            }
            i = i + 1;
        }
        return null;
    }

    // Get storage engine for a database (null if in-memory)
    expose func getStorageEngine(name: String) -> StorageEngine? {
        Threads.Monitor.Enter(lock);
        var result = getStorageEngineInternal(name);
        Threads.Monitor.Exit(lock);
        return result;
    }

    hide func getStorageEngineInternal(name: String) -> StorageEngine? {
        var i = 0;
        while i < dbNames.count() {
            if dbNames.get(i) == name {
                return storageEngines.get(i);
            }
            i = i + 1;
        }
        return null;
    }

    // Get storage engine for current database
    expose func currentStorageEngine() -> StorageEngine? {
        Threads.Monitor.Enter(lock);
        var result = currentStorageEngineInternal();
        Threads.Monitor.Exit(lock);
        return result;
    }

    hide func currentStorageEngineInternal() -> StorageEngine? {
        if currentDbIndex < 0 || currentDbIndex >= storageEngines.count() {
            return null;
        }
        return storageEngines.get(currentDbIndex);
    }

    //=========================================================================
    // CURRENT DATABASE ACCESS
    //=========================================================================

    // Get current database
    expose func currentDatabase() -> Database? {
        Threads.Monitor.Enter(lock);
        var result = currentDatabaseInternal();
        Threads.Monitor.Exit(lock);
        return result;
    }

    hide func currentDatabaseInternal() -> Database? {
        if currentDbIndex < 0 || currentDbIndex >= dbList.count() {
            return null;
        }
        return dbList.get(currentDbIndex);
    }

    // Get current index manager
    expose func currentIndexManager() -> IndexManager? {
        Threads.Monitor.Enter(lock);
        var result = currentIndexManagerInternal();
        Threads.Monitor.Exit(lock);
        return result;
    }

    hide func currentIndexManagerInternal() -> IndexManager? {
        if currentDbIndex < 0 || currentDbIndex >= indexManagers.count() {
            return null;
        }
        return indexManagers.get(currentDbIndex);
    }

    //=========================================================================
    // UTILITY METHODS
    //=========================================================================

    // Get statistics for a database
    expose func getDatabaseStats(name: String) -> String {
        Threads.Monitor.Enter(lock);
        var maybeDb = getDatabaseInternal(name);
        if maybeDb == null {
            Threads.Monitor.Exit(lock);
            return "Database not found";
        }
        var db = maybeDb;

        var stats = "Database: " + name + "\n";
        stats = stats + "Tables: " + Fmt.Int(db.tableCount()) + "\n";

        // Count total rows across all tables
        var totalRows = 0;
        var i = 0;
        while i < db.tableCount() {
            var maybeTable = db.getTable(i);
            if maybeTable != null {
                var table = maybeTable;
                totalRows = totalRows + table.rowCount();
            }
            i = i + 1;
        }
        stats = stats + "Total rows: " + Fmt.Int(totalRows);

        Threads.Monitor.Exit(lock);
        return stats;
    }

    //=========================================================================
    // USER MANAGEMENT (Phase 10)
    //=========================================================================

    // Create a new user
    expose func createUser(name: String, password: String) -> Boolean {
        Threads.Monitor.Enter(lock);
        var result = createUserInternal(name, password);
        Threads.Monitor.Exit(lock);
        return result;
    }

    hide func createUserInternal(name: String, password: String) -> Boolean {
        var i = 0;
        while i < userNames.count() {
            if userNames.get(i) == name {
                return false;
            }
            i = i + 1;
        }
        userNames.add(name);
        userPasswords.add(password);
        return true;
    }

    // Drop a user
    expose func dropUser(name: String) -> Boolean {
        Threads.Monitor.Enter(lock);
        var result = dropUserInternal(name);
        Threads.Monitor.Exit(lock);
        return result;
    }

    hide func dropUserInternal(name: String) -> Boolean {
        var dropIdx = -1;
        var i = 0;
        while i < userNames.count() {
            if userNames.get(i) == name {
                dropIdx = i;
                i = userNames.count();
            }
            i = i + 1;
        }
        if dropIdx < 0 { return false; }

        // Rebuild without dropped user
        var newNames: List[String] = [];
        var newPasswords: List[String] = [];
        i = 0;
        while i < userNames.count() {
            if i != dropIdx {
                newNames.add(userNames.get(i));
                newPasswords.add(userPasswords.get(i));
            }
            i = i + 1;
        }
        userNames = newNames;
        userPasswords = newPasswords;
        return true;
    }

    // Check if user exists
    expose func userExists(name: String) -> Boolean {
        Threads.Monitor.Enter(lock);
        var i = 0;
        while i < userNames.count() {
            if userNames.get(i) == name {
                Threads.Monitor.Exit(lock);
                return true;
            }
            i = i + 1;
        }
        Threads.Monitor.Exit(lock);
        return false;
    }

    // Verify user password
    expose func verifyPassword(name: String, password: String) -> Boolean {
        Threads.Monitor.Enter(lock);
        var i = 0;
        while i < userNames.count() {
            if userNames.get(i) == name {
                var result = userPasswords.get(i) == password;
                Threads.Monitor.Exit(lock);
                return result;
            }
            i = i + 1;
        }
        Threads.Monitor.Exit(lock);
        return false;
    }

    // List all users
    expose func listUsers() -> List[String] {
        Threads.Monitor.Enter(lock);
        var result = userNames;
        Threads.Monitor.Exit(lock);
        return result;
    }

    // Change user password
    expose func changePassword(name: String, newPassword: String) -> Boolean {
        Threads.Monitor.Enter(lock);
        var i = 0;
        while i < userNames.count() {
            if userNames.get(i) == name {
                userPasswords.set(i, newPassword);
                Threads.Monitor.Exit(lock);
                return true;
            }
            i = i + 1;
        }
        Threads.Monitor.Exit(lock);
        return false;
    }

    // Get user count
    expose func userCount() -> Integer {
        Threads.Monitor.Enter(lock);
        var result = userNames.count();
        Threads.Monitor.Exit(lock);
        return result;
    }

    // Clear all data from current database (for testing)
    expose func clearCurrentDatabase() {
        Threads.Monitor.Enter(lock);
        if currentDbIndex >= 0 && currentDbIndex < dbList.count() {
            var db = dbList.get(currentDbIndex);
            // Create a fresh database with the same name
            var newDb = new Database();
            newDb.initWithName(db.name);
            dbList.set(currentDbIndex, newDb);

            // Create a fresh index manager
            var newIdxMgr = new IndexManager();
            newIdxMgr.init();
            indexManagers.set(currentDbIndex, newIdxMgr);
        }
        Threads.Monitor.Exit(lock);
    }
}

// Factory function
func makeServer() -> DatabaseServer {
    var server = new DatabaseServer();
    server.init();
    return server;
}
