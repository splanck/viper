// parser.zia — SQL Parser
// Part of ViperSQL
//
// Recursive descent parser that converts a stream of SQL tokens (from the
// Lexer) into typed AST nodes (SelectStmt, InsertStmt, CreateTableStmt, etc.).
// Supports the full ViperSQL SQL dialect including DDL, DML, transactions,
// CTEs, window functions, set operations, and user management commands.

module parser;

bind String = Viper.String;
bind Fmt = Viper.Fmt;

bind "./token";
bind "./lexer";
bind "./types";
bind "./schema";
bind "./expr";
bind "./stmt";

//=============================================================================
// PARSER ENTITY
//=============================================================================

entity Parser {
    hide Lexer lexer;
    hide Token currentToken;
    expose String error;
    expose Boolean hasError;

    expose func init(sql: String) {
        lexer = new Lexer(sql);
        currentToken = lexer.nextToken();
        error = "";
        hasError = false;
    }

    expose func advance() {
        currentToken = lexer.nextToken();
    }

    expose func matchToken(kind: Integer) -> Boolean {
        if currentToken.kind == kind {
            advance();
            return true;
        }
        return false;
    }

    expose func expect(kind: Integer) -> Boolean {
        if currentToken.kind == kind {
            advance();
            return true;
        }
        hasError = true;
        error = "Expected token " + Fmt.Int(kind) + ", got " + Fmt.Int(currentToken.kind);
        return false;
    }

    expose func setError(msg: String) {
        hasError = true;
        error = msg;
    }

    expose func currentKind() -> Integer {
        return currentToken.kind;
    }

    expose func currentText() -> String {
        return currentToken.text;
    }

    //=========================================================================
    // EXPRESSION PARSING
    //=========================================================================

    expose func parsePrimaryExpr() -> Expr {
        var kind = currentToken.kind;

        // Integer literal
        if kind == TK_INTEGER {
            var text = currentToken.text;
            advance();
            var intVal = stringToInt(text);
            return exprInt(intVal);
        }

        // Real/float literal
        if kind == TK_NUMBER {
            var text = currentToken.text;
            advance();
            var floatVal = stringToNumber(text);
            return exprReal(floatVal, text);
        }

        // String literal
        if kind == TK_STRING {
            var text = currentToken.text;
            advance();
            return exprText(text);
        }

        // NULL
        if kind == TK_NULL {
            advance();
            return exprNull();
        }

        // Boolean literals
        if kind == TK_TRUE {
            advance();
            return exprLiteral(sqlBoolean(true));
        }
        if kind == TK_FALSE {
            advance();
            return exprLiteral(sqlBoolean(false));
        }

        // CASE expression
        if kind == TK_CASE {
            advance();
            return parseCaseExpr();
        }

        // CAST(expr AS type)
        if kind == TK_CAST {
            advance();
            if currentToken.kind != TK_LPAREN {
                setError("Expected '(' after CAST");
                return exprNull();
            }
            advance();
            var castArg = parseExpr();
            if hasError { return exprNull(); }
            if currentToken.kind != TK_AS {
                setError("Expected AS in CAST expression");
                return exprNull();
            }
            advance();
            // Parse target type keyword
            var typeName = String.ToUpper(currentToken.text);
            advance();
            if currentToken.kind != TK_RPAREN {
                setError("Expected ')' after CAST type");
                return exprNull();
            }
            advance();
            // Represent as function: CAST_INTEGER, CAST_REAL, CAST_TEXT
            var castFunc = exprFunction("CAST_" + typeName);
            castFunc.args.add(castArg);
            return castFunc;
        }

        // Keywords that can be used as function names: LEFT(), RIGHT(), CURRENT_DATE, etc.
        if (kind == TK_LEFT || kind == TK_RIGHT || kind == TK_CURRENT || kind == TK_ROW || kind == TK_DATE_TYPE || kind == TK_TIMESTAMP_TYPE) && currentToken.kind != TK_EOF {
            var kwName = String.ToUpper(currentToken.text);
            advance();
            // If followed by '(', parse as function call
            if currentToken.kind == TK_LPAREN {
                advance();
                var funcExpr = exprFunction(kwName);
                while currentToken.kind != TK_RPAREN && hasError == false {
                    if currentToken.kind == TK_STAR {
                        funcExpr.args.add(exprStar());
                        advance();
                    } else {
                        var argExpr = parseExpr();
                        funcExpr.args.add(argExpr);
                    }
                    if currentToken.kind == TK_COMMA {
                        advance();
                    }
                }
                if currentToken.kind == TK_RPAREN {
                    advance();
                }
                // Check for OVER clause (window function)
                if currentToken.kind == TK_OVER {
                    return parseWindowOver(funcExpr);
                }
                return funcExpr;
            }
            // Otherwise treat as column name
            if currentToken.kind == TK_DOT {
                advance();
                if currentToken.kind != TK_IDENTIFIER {
                    setError("Expected column name after dot");
                    return exprNull();
                }
                var colName = currentToken.text;
                advance();
                return exprTableColumn(kwName, colName);
            }
            return exprColumn(kwName);
        }

        // Identifier (column ref or function call)
        if kind == TK_IDENTIFIER {
            var name = currentToken.text;
            advance();

            // SQL date/time keywords that act as zero-arg functions (no parentheses)
            var upperName = String.ToUpper(name);
            if upperName == "CURRENT_DATE" || upperName == "CURRENT_TIME" || upperName == "CURRENT_TIMESTAMP" {
                return exprFunction(upperName);
            }

            // Check for function call
            if currentToken.kind == TK_LPAREN {
                advance();

                // Check for DISTINCT inside function (e.g., COUNT(DISTINCT col))
                var funcName = name;
                if currentToken.kind == TK_DISTINCT {
                    var upperName = String.ToUpper(name);
                    if upperName == "COUNT" {
                        funcName = "COUNT_DISTINCT";
                    }
                    advance();
                }

                var funcExpr = exprFunction(funcName);

                // Parse arguments - handle full expressions
                while currentToken.kind != TK_RPAREN && hasError == false {
                    if currentToken.kind == TK_STAR {
                        funcExpr.args.add(exprStar());
                        advance();
                    } else {
                        // Parse full expression as argument
                        var argExpr = parseExpr();
                        funcExpr.args.add(argExpr);
                    }

                    if currentToken.kind == TK_COMMA {
                        advance();
                    }
                }

                if currentToken.kind == TK_RPAREN {
                    advance();
                }

                // Check for OVER clause (window function)
                if currentToken.kind == TK_OVER {
                    return parseWindowOver(funcExpr);
                }

                return funcExpr;
            }

            // Check for table.column
            if currentToken.kind == TK_DOT {
                advance();
                if currentToken.kind != TK_IDENTIFIER {
                    setError("Expected column name after dot");
                    return exprNull();
                }
                var colName = currentToken.text;
                advance();
                return exprTableColumn(name, colName);
            }

            return exprColumn(name);
        }

        // Star (*)
        if kind == TK_STAR {
            advance();
            return exprStar();
        }

        // Parenthesized expression or subquery
        if kind == TK_LPAREN {
            advance();

            // Check for subquery
            if currentToken.kind == TK_SELECT {
                var subquerySql = "SELECT";
                advance();
                var depth = 1;

                while depth > 0 && hasError == false {
                    if currentToken.kind == TK_LPAREN {
                        depth = depth + 1;
                        subquerySql = subquerySql + " (";
                    } else if currentToken.kind == TK_RPAREN {
                        depth = depth - 1;
                        if depth > 0 {
                            subquerySql = subquerySql + ")";
                        }
                    } else if currentToken.kind == TK_EOF {
                        setError("Unexpected end of input in subquery");
                        return exprNull();
                    } else if currentToken.kind == TK_STRING {
                        // Re-add quotes around string literals
                        subquerySql = subquerySql + " '" + currentToken.text + "'";
                    } else {
                        subquerySql = subquerySql + " " + currentToken.text;
                    }
                    advance();
                }

                return exprSubquery(subquerySql);
            }

            // Regular parenthesized expression
            var inner = parseExpr();
            if currentToken.kind == TK_RPAREN {
                advance();
            } else {
                setError("Expected ) after parenthesized expression");
            }
            return inner;
        }

        // EXISTS (SELECT ...)
        if kind == TK_EXISTS {
            advance();
            if currentToken.kind != TK_LPAREN {
                setError("Expected '(' after EXISTS");
                return exprNull();
            }
            advance();
            if currentToken.kind != TK_SELECT {
                setError("Expected SELECT after EXISTS (");
                return exprNull();
            }
            var existsSql = "SELECT";
            advance();
            var depth = 1;
            while depth > 0 && hasError == false {
                if currentToken.kind == TK_LPAREN {
                    depth = depth + 1;
                    existsSql = existsSql + " (";
                } else if currentToken.kind == TK_RPAREN {
                    depth = depth - 1;
                    if depth > 0 {
                        existsSql = existsSql + ")";
                    }
                } else if currentToken.kind == TK_EOF {
                    setError("Unexpected end of input in EXISTS subquery");
                    return exprNull();
                } else if currentToken.kind == TK_STRING {
                    existsSql = existsSql + " '" + currentToken.text + "'";
                } else {
                    existsSql = existsSql + " " + currentToken.text;
                }
                advance();
            }
            var existsExpr = new Expr();
            existsExpr.init();
            existsExpr.initExists(existsSql);
            return existsExpr;
        }

        setError("Unexpected token in expression");
        return exprNull();
    }

    expose func parseUnaryExpr() -> Expr {
        if currentToken.kind == TK_MINUS {
            advance();
            var operand = parseUnaryExpr();
            return exprUnary(OP_NEG, operand);
        }
        return parsePrimaryExpr();
    }

    expose func parseMulExpr() -> Expr {
        var left = parseUnaryExpr();
        while currentToken.kind == TK_STAR || currentToken.kind == TK_SLASH {
            var op = currentToken.kind;
            advance();
            var right = parseUnaryExpr();
            if op == TK_STAR {
                left = exprBinary(OP_MUL, left, right);
            } else {
                left = exprBinary(OP_DIV, left, right);
            }
        }
        return left;
    }

    expose func parseAddExpr() -> Expr {
        var left = parseMulExpr();
        while currentToken.kind == TK_PLUS || currentToken.kind == TK_MINUS || currentToken.kind == TK_CONCAT {
            var op = currentToken.kind;
            advance();
            var right = parseMulExpr();
            if op == TK_PLUS {
                left = exprBinary(OP_ADD, left, right);
            } else if op == TK_CONCAT {
                left = exprBinary(OP_CONCAT, left, right);
            } else {
                left = exprBinary(OP_SUB, left, right);
            }
        }
        return left;
    }

    expose func parseCompExpr() -> Expr {
        var left = parseAddExpr();
        var kind = currentToken.kind;

        if kind == TK_EQ {
            advance();
            return exprBinary(OP_EQ, left, parseAddExpr());
        }
        if kind == TK_NE {
            advance();
            return exprBinary(OP_NE, left, parseAddExpr());
        }
        if kind == TK_LT {
            advance();
            return exprBinary(OP_LT, left, parseAddExpr());
        }
        if kind == TK_LE {
            advance();
            return exprBinary(OP_LE, left, parseAddExpr());
        }
        if kind == TK_GT {
            advance();
            return exprBinary(OP_GT, left, parseAddExpr());
        }
        if kind == TK_GE {
            advance();
            return exprBinary(OP_GE, left, parseAddExpr());
        }

        // BETWEEN low AND high
        if kind == TK_BETWEEN {
            advance();
            var low = parseAddExpr();
            if currentToken.kind != TK_AND {
                setError("Expected AND in BETWEEN expression");
                return left;
            }
            advance();
            var high = parseAddExpr();
            var geExpr = exprBinary(OP_GE, left, low);
            var leExpr = exprBinary(OP_LE, left, high);
            return exprBinary(OP_AND, geExpr, leExpr);
        }

        // LIKE pattern
        if kind == TK_LIKE {
            advance();
            var pattern = parseAddExpr();
            return exprBinary(OP_LIKE, left, pattern);
        }

        // IS NULL / IS NOT NULL / IS TRUE / IS FALSE / IS NOT TRUE / IS NOT FALSE
        if kind == TK_IS {
            advance();
            if currentToken.kind == TK_NOT {
                advance();
                if currentToken.kind == TK_NULL {
                    advance();
                    return exprBinary(OP_IS, left, exprInt(1));
                }
                if currentToken.kind == TK_TRUE {
                    advance();
                    return exprBinary(OP_IS, left, exprInt(3));
                }
                if currentToken.kind == TK_FALSE {
                    advance();
                    return exprBinary(OP_IS, left, exprInt(4));
                }
                setError("Expected NULL, TRUE, or FALSE after IS NOT");
                return left;
            }
            if currentToken.kind == TK_NULL {
                advance();
                return exprBinary(OP_IS, left, exprNull());
            }
            if currentToken.kind == TK_TRUE {
                advance();
                return exprBinary(OP_IS, left, exprInt(5));
            }
            if currentToken.kind == TK_FALSE {
                advance();
                return exprBinary(OP_IS, left, exprInt(6));
            }
            setError("Expected NULL, TRUE, or FALSE after IS");
            return left;
        }

        // NOT BETWEEN / NOT LIKE / NOT IN
        if kind == TK_NOT {
            if currentToken.kind == TK_NOT {
                advance();
                if currentToken.kind == TK_BETWEEN {
                    advance();
                    var low = parseAddExpr();
                    if currentToken.kind != TK_AND {
                        setError("Expected AND in NOT BETWEEN expression");
                        return left;
                    }
                    advance();
                    var high = parseAddExpr();
                    var geExpr = exprBinary(OP_GE, left, low);
                    var leExpr = exprBinary(OP_LE, left, high);
                    return exprUnary(OP_NOT, exprBinary(OP_AND, geExpr, leExpr));
                }
                if currentToken.kind == TK_LIKE {
                    advance();
                    var pattern = parseAddExpr();
                    return exprUnary(OP_NOT, exprBinary(OP_LIKE, left, pattern));
                }
                if currentToken.kind == TK_IN {
                    advance();
                    if currentToken.kind != TK_LPAREN {
                        setError("Expected '(' after NOT IN");
                        return left;
                    }
                    advance();
                    var inExpr = parseInList(left);
                    return exprUnary(OP_NOT, inExpr);
                }
            }
        }

        // IN (value-list) or IN (subquery)
        if kind == TK_IN {
            advance();
            if currentToken.kind != TK_LPAREN {
                setError("Expected '(' after IN");
                return left;
            }
            advance();
            return parseInList(left);
        }

        return left;
    }

    // Parse IN value list or subquery after '(' has been consumed
    hide func parseInList(left: Expr) -> Expr {
        // Check for subquery
        if currentToken.kind == TK_SELECT {
            var subquerySql = "SELECT";
            advance();
            var depth = 1;
            while depth > 0 && hasError == false {
                if currentToken.kind == TK_LPAREN {
                    depth = depth + 1;
                    subquerySql = subquerySql + " (";
                } else if currentToken.kind == TK_RPAREN {
                    depth = depth - 1;
                    if depth > 0 {
                        subquerySql = subquerySql + ")";
                    }
                } else if currentToken.kind == TK_EOF {
                    setError("Unexpected end of input in subquery");
                    return left;
                } else if currentToken.kind == TK_STRING {
                    subquerySql = subquerySql + " '" + currentToken.text + "'";
                } else {
                    subquerySql = subquerySql + " " + currentToken.text;
                }
                advance();
            }
            return exprBinary(OP_IN, left, exprSubquery(subquerySql));
        }

        // Value list: IN (val1, val2, ...)
        var listExpr = exprFunction("__IN_LIST__");
        while hasError == false {
            var val = parseExpr();
            if hasError { return left; }
            listExpr.args.add(val);
            if currentToken.kind == TK_COMMA {
                advance();
            } else {
                break;
            }
        }
        if currentToken.kind != TK_RPAREN {
            setError("Expected ) after IN list");
            return left;
        }
        advance();
        return exprBinary(OP_IN, left, listExpr);
    }

    expose func parseNotExpr() -> Expr {
        if currentToken.kind == TK_NOT {
            advance();
            var operand = parseNotExpr();
            return exprUnary(OP_NOT, operand);
        }
        return parseCompExpr();
    }

    expose func parseAndExpr() -> Expr {
        var left = parseNotExpr();
        while currentToken.kind == TK_AND {
            advance();
            var right = parseNotExpr();
            left = exprBinary(OP_AND, left, right);
        }
        return left;
    }

    expose func parseOrExpr() -> Expr {
        var left = parseAndExpr();
        while currentToken.kind == TK_OR {
            advance();
            var right = parseAndExpr();
            left = exprBinary(OP_OR, left, right);
        }
        return left;
    }

    expose func parseExpr() -> Expr {
        return parseOrExpr();
    }

    // Parse OVER (...) clause for window functions
    // Converts a function expression into a window expression
    hide func parseWindowOver(funcExpr: Expr) -> Expr {
        // Skip OVER
        advance();

        var winExpr = new Expr();
        winExpr.init();
        winExpr.initWindow(funcExpr.funcName);
        // Copy function args to window expr
        var ai = 0;
        while ai < funcExpr.args.count() {
            winExpr.args.add(funcExpr.args.get(ai));
            ai = ai + 1;
        }

        // Expect (
        if currentToken.kind != TK_LPAREN {
            setError("Expected '(' after OVER");
            return exprNull();
        }
        advance();

        // Parse PARTITION BY (optional)
        if currentToken.kind == TK_PARTITION {
            advance();
            if currentToken.kind != TK_BY {
                setError("Expected BY after PARTITION");
                return exprNull();
            }
            advance();
            // Parse partition expressions
            var parsePartition = true;
            while parsePartition && hasError == false {
                var pExpr = parseExpr();
                winExpr.partitionBy.add(pExpr);
                if currentToken.kind == TK_COMMA {
                    advance();
                } else {
                    parsePartition = false;
                }
            }
        }

        // Parse ORDER BY (optional)
        if currentToken.kind == TK_ORDER {
            advance();
            if currentToken.kind != TK_BY {
                setError("Expected BY after ORDER");
                return exprNull();
            }
            advance();
            // Parse order expressions
            var parseOrder = true;
            while parseOrder && hasError == false {
                var oExpr = parseExpr();
                winExpr.windowOrderBy.add(oExpr);
                var dir = 0;  // ASC
                if currentToken.kind == TK_ASC {
                    advance();
                } else if currentToken.kind == TK_DESC {
                    dir = 1;
                    advance();
                }
                winExpr.windowOrderDir.add(dir);
                if currentToken.kind == TK_COMMA {
                    advance();
                } else {
                    parseOrder = false;
                }
            }
        }

        // Expect )
        if currentToken.kind != TK_RPAREN {
            setError("Expected ')' to close OVER clause");
            return exprNull();
        }
        advance();

        return winExpr;
    }

    // Parse CASE WHEN ... THEN ... ELSE ... END expression
    expose func parseCaseExpr() -> Expr {
        var expr = new Expr();
        expr.init();
        expr.initCase();

        // Parse WHEN ... THEN ... clauses
        while currentToken.kind == TK_WHEN {
            advance();  // consume WHEN

            var condition = parseExpr();

            if currentToken.kind != TK_THEN {
                setError("Expected THEN after WHEN condition");
                return exprNull();
            }
            advance();  // consume THEN

            var result = parseExpr();
            expr.addCaseWhen(condition, result);
        }

        // Parse optional ELSE clause
        if currentToken.kind == TK_ELSE {
            advance();  // consume ELSE
            var elseExpr = parseExpr();
            expr.setCaseElse(elseExpr);
        }

        // Expect END
        if currentToken.kind != TK_END {
            setError("Expected END to close CASE expression");
            return exprNull();
        }
        advance();  // consume END

        return expr;
    }

    //=========================================================================
    // COLUMN DEFINITION PARSING
    //=========================================================================

    expose func parseColumnDef() -> Column {
        var col = new Column();
        col.init();

        if currentToken.kind != TK_IDENTIFIER {
            setError("Expected column name");
            return col;
        }
        col.name = currentToken.text;
        advance();

        // Data type
        if currentToken.kind == TK_INTEGER_TYPE {
            col.typeCode = SQL_INTEGER;
            advance();
        } else if currentToken.kind == TK_INT {
            col.typeCode = SQL_INTEGER;
            advance();
        } else if currentToken.kind == TK_TEXT {
            col.typeCode = SQL_TEXT;
            advance();
        } else if currentToken.kind == TK_VARCHAR {
            col.typeCode = SQL_TEXT;
            advance();
        } else if currentToken.kind == TK_REAL {
            col.typeCode = SQL_REAL;
            advance();
        } else if currentToken.kind == TK_BLOB {
            col.typeCode = SQL_BLOB;
            advance();
        } else if currentToken.kind == TK_BOOLEAN {
            col.typeCode = SQL_BOOLEAN;
            advance();
        } else if currentToken.kind == TK_DATE_TYPE {
            col.typeCode = SQL_DATE;
            advance();
        } else if currentToken.kind == TK_TIMESTAMP_TYPE {
            col.typeCode = SQL_TIMESTAMP;
            advance();
        } else {
            setError("Expected data type");
            return col;
        }

        // Optional constraints
        while hasError == false {
            if currentToken.kind == TK_PRIMARY {
                advance();
                if expect(TK_KEY) == false {
                    return col;
                }
                col.primaryKey = true;
            } else if currentToken.kind == TK_AUTOINCREMENT {
                advance();
                col.autoIncrement = true;
            } else if currentToken.kind == TK_NOT {
                advance();
                if expect(TK_NULL) == false {
                    return col;
                }
                col.notNull = true;
            } else if currentToken.kind == TK_UNIQUE {
                advance();
                col.unique = true;
            } else if currentToken.kind == TK_DEFAULT {
                advance();
                if currentToken.kind == TK_NUMBER {
                    var defVal = new SqlValue();
                    var numText = currentToken.text;
                    defVal.initReal(0.0, numText);
                    col.setDefault(defVal);
                    advance();
                } else if currentToken.kind == TK_INTEGER {
                    var defVal = new SqlValue();
                    var numText = currentToken.text;
                    var intVal = stringToInt(numText);
                    defVal.initInteger(intVal);
                    col.setDefault(defVal);
                    advance();
                } else if currentToken.kind == TK_STRING {
                    var defVal = new SqlValue();
                    defVal.initText(currentToken.text);
                    col.setDefault(defVal);
                    advance();
                } else if currentToken.kind == TK_NULL {
                    var defVal = new SqlValue();
                    defVal.initNull();
                    col.setDefault(defVal);
                    advance();
                } else if currentToken.kind == TK_TRUE {
                    var defVal = new SqlValue();
                    defVal.initBoolean(true);
                    col.setDefault(defVal);
                    advance();
                } else if currentToken.kind == TK_FALSE {
                    var defVal = new SqlValue();
                    defVal.initBoolean(false);
                    col.setDefault(defVal);
                    advance();
                } else {
                    setError("Expected default value");
                    return col;
                }
            } else if currentToken.kind == TK_FOREIGN {
                advance();
                if currentToken.kind == TK_KEY {
                    advance();
                }
                if currentToken.kind != TK_REFERENCES {
                    setError("Expected REFERENCES after FOREIGN KEY");
                    return col;
                }
                // Fall through to REFERENCES handling below
                advance();
                if currentToken.kind != TK_IDENTIFIER {
                    setError("Expected referenced table name");
                    return col;
                }
                col.refTableName = currentToken.text;
                col.isForeignKey = true;
                advance();
                if currentToken.kind != TK_LPAREN {
                    setError("Expected ( after table name");
                    return col;
                }
                advance();
                if currentToken.kind != TK_IDENTIFIER {
                    setError("Expected referenced column name");
                    return col;
                }
                col.refColumnName = currentToken.text;
                advance();
                if currentToken.kind != TK_RPAREN {
                    setError("Expected ) after column name");
                    return col;
                }
                advance();
                // Parse optional ON DELETE / ON UPDATE actions
                parseForeignKeyActions(col);
            } else if currentToken.kind == TK_REFERENCES {
                advance();
                if currentToken.kind != TK_IDENTIFIER {
                    setError("Expected referenced table name");
                    return col;
                }
                col.refTableName = currentToken.text;
                col.isForeignKey = true;
                advance();
                if currentToken.kind != TK_LPAREN {
                    setError("Expected ( after table name");
                    return col;
                }
                advance();
                if currentToken.kind != TK_IDENTIFIER {
                    setError("Expected referenced column name");
                    return col;
                }
                col.refColumnName = currentToken.text;
                advance();
                if currentToken.kind != TK_RPAREN {
                    setError("Expected ) after column name");
                    return col;
                }
                advance();
                // Parse optional ON DELETE / ON UPDATE actions
                parseForeignKeyActions(col);
            } else if currentToken.kind == TK_CHECK {
                advance();
                if currentToken.kind != TK_LPAREN {
                    setError("Expected '(' after CHECK");
                    return col;
                }
                advance();
                // Capture CHECK expression as SQL text
                var checkSql = "";
                var depth = 1;
                while depth > 0 && hasError == false {
                    if currentToken.kind == TK_LPAREN {
                        depth = depth + 1;
                        checkSql = checkSql + "(";
                    } else if currentToken.kind == TK_RPAREN {
                        depth = depth - 1;
                        if depth > 0 {
                            checkSql = checkSql + ")";
                        }
                    } else if currentToken.kind == TK_EOF {
                        setError("Unexpected end of input in CHECK expression");
                        return col;
                    } else if currentToken.kind == TK_STRING {
                        checkSql = checkSql + "'" + currentToken.text + "'";
                    } else {
                        if checkSql != "" {
                            checkSql = checkSql + " ";
                        }
                        checkSql = checkSql + currentToken.text;
                    }
                    advance();
                }
                col.checkExprSQL = checkSql;
            } else {
                break;
            }
        }

        return col;
    }

    // Parse optional ON DELETE / ON UPDATE actions for foreign keys
    hide func parseForeignKeyActions(col: Column) {
        // Look for ON DELETE or ON UPDATE (can have both in any order)
        var maxActions = 2;
        var parsed = 0;
        while parsed < maxActions && currentToken.kind == TK_ON {
            advance();
            if currentToken.kind == TK_DELETE {
                advance();
                col.onDeleteAction = parseFkAction();
            } else if currentToken.kind == TK_UPDATE {
                advance();
                col.onUpdateAction = parseFkAction();
            } else {
                break;
            }
            parsed = parsed + 1;
        }
    }

    // Parse a single FK action keyword: CASCADE, RESTRICT, SET NULL, NO ACTION
    hide func parseFkAction() -> Integer {
        if currentToken.kind == TK_CASCADE {
            advance();
            return FK_CASCADE;
        }
        if currentToken.kind == TK_RESTRICT {
            advance();
            return FK_RESTRICT;
        }
        // SET NULL
        if currentToken.kind == TK_SET {
            advance();
            if currentToken.kind == TK_NULL {
                advance();
                return FK_SET_NULL;
            }
            return FK_NO_ACTION;
        }
        // NO ACTION (NO is just an identifier, not a keyword)
        if currentToken.kind == TK_IDENTIFIER && String.ToUpper(currentToken.text) == "NO" {
            advance();
            if currentToken.kind == TK_ACTION {
                advance();
            }
            return FK_NO_ACTION;
        }
        return FK_NO_ACTION;
    }

    //=========================================================================
    // STATEMENT PARSING
    //=========================================================================

    expose func parseCreateTableStmt() -> CreateTableStmt {
        var stmt = new CreateTableStmt();
        stmt.init();

        // Check for TEMPORARY/TEMP flag (already consumed by caller)
        // The TABLE token is still expected next
        if expect(TK_TABLE) == false {
            return stmt;
        }

        if currentToken.kind != TK_IDENTIFIER {
            setError("Expected table name");
            return stmt;
        }
        stmt.tableName = currentToken.text;
        advance();

        if expect(TK_LPAREN) == false {
            return stmt;
        }

        while hasError == false {
            var col = parseColumnDef();
            if hasError {
                return stmt;
            }
            stmt.addColumn(col);

            if currentToken.kind == TK_COMMA {
                advance();
            } else {
                break;
            }
        }

        if expect(TK_RPAREN) == false {
            return stmt;
        }

        matchToken(TK_SEMICOLON);
        return stmt;
    }

    expose func parseInsertStmt() -> InsertStmt {
        var stmt = new InsertStmt();
        stmt.init();

        if expect(TK_INTO) == false {
            return stmt;
        }

        if currentToken.kind != TK_IDENTIFIER {
            setError("Expected table name");
            return stmt;
        }
        stmt.tableName = currentToken.text;
        advance();

        // Optional column list
        if currentToken.kind == TK_LPAREN {
            advance();
            while hasError == false {
                if currentToken.kind != TK_IDENTIFIER {
                    setError("Expected column name");
                    return stmt;
                }
                stmt.addColumnName(currentToken.text);
                advance();

                if currentToken.kind == TK_COMMA {
                    advance();
                } else {
                    break;
                }
            }
            if expect(TK_RPAREN) == false {
                return stmt;
            }
        }

        // Check for INSERT...SELECT vs INSERT...VALUES
        if currentToken.kind == TK_SELECT {
            // INSERT INTO table [(cols)] SELECT ...
            // Capture SELECT statement as SQL text (same pattern as subquery capture)
            stmt.hasSelect = true;
            var selectSql = "SELECT";
            advance();
            var depth = 0;
            while currentToken.kind != TK_EOF && hasError == false {
                if currentToken.kind == TK_SEMICOLON {
                    break;
                }
                if currentToken.kind == TK_LPAREN {
                    depth = depth + 1;
                    selectSql = selectSql + " (";
                } else if currentToken.kind == TK_RPAREN {
                    if depth > 0 {
                        depth = depth - 1;
                        selectSql = selectSql + ")";
                    } else {
                        break;
                    }
                } else if currentToken.kind == TK_STRING {
                    selectSql = selectSql + " '" + currentToken.text + "'";
                } else {
                    selectSql = selectSql + " " + currentToken.text;
                }
                advance();
            }
            stmt.selectSQL = selectSql;
            matchToken(TK_SEMICOLON);
            return stmt;
        }

        if expect(TK_VALUES) == false {
            return stmt;
        }

        // Value rows
        while hasError == false {
            if expect(TK_LPAREN) == false {
                return stmt;
            }

            stmt.addValueRow();
            var rowIdx = stmt.rowCount() - 1;

            while hasError == false {
                var val = parseExpr();
                if hasError {
                    return stmt;
                }
                stmt.addValue(rowIdx, val);

                if currentToken.kind == TK_COMMA {
                    advance();
                } else {
                    break;
                }
            }

            if expect(TK_RPAREN) == false {
                return stmt;
            }

            if currentToken.kind == TK_COMMA {
                advance();
            } else {
                break;
            }
        }

        matchToken(TK_SEMICOLON);
        return stmt;
    }

    expose func parseSelectStmt() -> SelectStmt {
        var stmt = new SelectStmt();
        stmt.init();

        // Check for DISTINCT
        if currentToken.kind == TK_DISTINCT {
            stmt.isDistinct = true;
            advance();
        }

        // Check for * or column list
        if currentToken.kind == TK_STAR {
            stmt.selectAll = true;
            advance();
        } else {
            // Parse column list
            while hasError == false {
                var col = parseExpr();
                if hasError {
                    return stmt;
                }

                // Handle column alias
                var colAlias = "";
                if currentToken.kind == TK_AS {
                    advance();
                    if currentToken.kind == TK_IDENTIFIER {
                        colAlias = currentToken.text;
                        advance();
                    }
                } else if currentToken.kind == TK_IDENTIFIER {
                    var maybeAlias = currentToken.text;
                    var upperAlias = String.ToUpper(maybeAlias);
                    if upperAlias != "FROM" && upperAlias != "WHERE" && upperAlias != "GROUP" && upperAlias != "ORDER" && upperAlias != "LIMIT" && upperAlias != "HAVING" {
                        colAlias = maybeAlias;
                        advance();
                    }
                }

                stmt.addColumnWithAlias(col, colAlias);

                if currentToken.kind == TK_COMMA {
                    advance();
                } else {
                    break;
                }
            }
        }

        // FROM clause (optional for expressions like SELECT 1+1, SELECT EXISTS(...))
        if currentToken.kind != TK_FROM {
            // No FROM clause — expression-only SELECT
            matchToken(TK_SEMICOLON);
            return stmt;
        }
        advance();

        // Check for derived table: FROM (SELECT ...) AS alias
        if currentToken.kind == TK_LPAREN {
            advance();
            if currentToken.kind == TK_SELECT {
                // Capture subquery SQL
                var derivedSql = "SELECT";
                advance();
                var depth = 1;
                while depth > 0 && hasError == false {
                    if currentToken.kind == TK_LPAREN {
                        depth = depth + 1;
                        derivedSql = derivedSql + " (";
                    } else if currentToken.kind == TK_RPAREN {
                        depth = depth - 1;
                        if depth > 0 {
                            derivedSql = derivedSql + ")";
                        }
                    } else if currentToken.kind == TK_EOF {
                        setError("Unexpected end of input in derived table");
                        return stmt;
                    } else if currentToken.kind == TK_STRING {
                        derivedSql = derivedSql + " '" + currentToken.text + "'";
                    } else {
                        derivedSql = derivedSql + " " + currentToken.text;
                    }
                    advance();
                }
                stmt.derivedTableSQL = derivedSql;
                stmt.hasDerivedTable = true;

                // Parse optional alias: AS alias or just alias
                if currentToken.kind == TK_AS {
                    advance();
                }
                if currentToken.kind == TK_IDENTIFIER {
                    stmt.derivedTableAlias = currentToken.text;
                    stmt.tableName = currentToken.text;
                    stmt.tableAlias = currentToken.text;
                    advance();
                } else {
                    stmt.derivedTableAlias = "_derived";
                    stmt.tableName = "_derived";
                }

                stmt.addTable(stmt.tableName, stmt.tableAlias);

                // Skip ahead to WHERE/ORDER BY/etc. parsing
                // (derived tables don't support JOINs for now)
            } else {
                setError("Expected SELECT in derived table subquery");
                return stmt;
            }
        } else {

        // Parse table name
        if currentToken.kind != TK_IDENTIFIER {
            setError("Expected table name");
            return stmt;
        }
        var firstTableName = currentToken.text;
        var firstTableAlias = "";
        advance();
        // Support dotted table names: schema.table (e.g., information_schema.tables, sys.databases)
        if currentToken.kind == TK_DOT {
            advance();
            // Accept any token after dot — keywords like DATABASES are valid here
            if currentToken.kind != TK_EOF && currentToken.kind != TK_SEMICOLON {
                firstTableName = firstTableName + "." + currentToken.text;
                advance();
            }
        }
        stmt.tableName = firstTableName;

        // Optional table alias
        if currentToken.kind == TK_AS {
            advance();
            if currentToken.kind == TK_IDENTIFIER {
                firstTableAlias = currentToken.text;
                stmt.tableAlias = firstTableAlias;
                advance();
            }
        } else if currentToken.kind == TK_IDENTIFIER {
            var aliasText = currentToken.text;
            var upperAlias = String.ToUpper(aliasText);
            if upperAlias != "WHERE" && upperAlias != "GROUP" && upperAlias != "ORDER" && upperAlias != "LIMIT" && upperAlias != "HAVING" && upperAlias != "JOIN" && upperAlias != "INNER" && upperAlias != "LEFT" && upperAlias != "RIGHT" && upperAlias != "FULL" && upperAlias != "CROSS" {
                firstTableAlias = aliasText;
                stmt.tableAlias = firstTableAlias;
                advance();
            }
        }

        stmt.addTable(firstTableName, firstTableAlias);

        // Parse comma-separated tables (implicit cross join: FROM a, b, c)
        while currentToken.kind == TK_COMMA {
            advance();
            if currentToken.kind != TK_IDENTIFIER {
                setError("Expected table name after comma");
                return stmt;
            }
            var extraTableName = currentToken.text;
            var extraTableAlias = "";
            advance();

            // Optional alias
            if currentToken.kind == TK_AS {
                advance();
                if currentToken.kind == TK_IDENTIFIER {
                    extraTableAlias = currentToken.text;
                    advance();
                }
            } else if currentToken.kind == TK_IDENTIFIER {
                var maybeAlias = currentToken.text;
                var upperAlias = String.ToUpper(maybeAlias);
                if upperAlias != "WHERE" && upperAlias != "GROUP" && upperAlias != "ORDER" && upperAlias != "LIMIT" && upperAlias != "HAVING" && upperAlias != "JOIN" && upperAlias != "INNER" && upperAlias != "LEFT" && upperAlias != "RIGHT" && upperAlias != "FULL" && upperAlias != "CROSS" {
                    extraTableAlias = maybeAlias;
                    advance();
                }
            }

            stmt.addJoin(extraTableName, extraTableAlias, 0, null);
        }

        // Parse JOINs
        while currentToken.kind == TK_JOIN || currentToken.kind == TK_INNER || currentToken.kind == TK_LEFT || currentToken.kind == TK_RIGHT || currentToken.kind == TK_FULL || currentToken.kind == TK_CROSS {
            var joinType = 1;  // Default INNER

            if currentToken.kind == TK_INNER {
                joinType = 1;
                advance();
                if currentToken.kind != TK_JOIN {
                    setError("Expected JOIN after INNER");
                    return stmt;
                }
                advance();
            } else if currentToken.kind == TK_LEFT {
                joinType = 2;
                advance();
                if currentToken.kind == TK_OUTER { advance(); }
                if currentToken.kind != TK_JOIN {
                    setError("Expected JOIN after LEFT");
                    return stmt;
                }
                advance();
            } else if currentToken.kind == TK_RIGHT {
                joinType = 3;
                advance();
                if currentToken.kind == TK_OUTER { advance(); }
                if currentToken.kind != TK_JOIN {
                    setError("Expected JOIN after RIGHT");
                    return stmt;
                }
                advance();
            } else if currentToken.kind == TK_FULL {
                joinType = 4;
                advance();
                if currentToken.kind == TK_OUTER { advance(); }
                if currentToken.kind != TK_JOIN {
                    setError("Expected JOIN after FULL");
                    return stmt;
                }
                advance();
            } else if currentToken.kind == TK_CROSS {
                joinType = 0;
                advance();
                if currentToken.kind != TK_JOIN {
                    setError("Expected JOIN after CROSS");
                    return stmt;
                }
                advance();
            } else if currentToken.kind == TK_JOIN {
                joinType = 1;
                advance();
            }

            if currentToken.kind != TK_IDENTIFIER {
                setError("Expected table name after JOIN");
                return stmt;
            }
            var joinTableName = currentToken.text;
            var joinTableAlias = "";
            advance();

            // Optional alias
            if currentToken.kind == TK_AS {
                advance();
                if currentToken.kind == TK_IDENTIFIER {
                    joinTableAlias = currentToken.text;
                    advance();
                }
            } else if currentToken.kind == TK_IDENTIFIER {
                var maybeAlias = currentToken.text;
                var upperAlias = String.ToUpper(maybeAlias);
                if upperAlias != "ON" && upperAlias != "WHERE" && upperAlias != "GROUP" && upperAlias != "ORDER" && upperAlias != "LIMIT" && upperAlias != "JOIN" {
                    joinTableAlias = maybeAlias;
                    advance();
                }
            }

            // ON clause
            var joinCondition: Expr? = null;
            if currentToken.kind == TK_ON {
                advance();
                joinCondition = parseExpr();
            } else if joinType != 0 {
                setError("Expected ON clause for JOIN");
                return stmt;
            }

            stmt.addJoin(joinTableName, joinTableAlias, joinType, joinCondition);
        }

        } // end else (non-derived table FROM clause)

        // Optional WHERE
        if currentToken.kind == TK_WHERE {
            advance();
            stmt.whereClause = parseExpr();
        }

        // Optional GROUP BY
        if currentToken.kind == TK_GROUP {
            advance();
            if expect(TK_BY) == false {
                return stmt;
            }
            while hasError == false {
                var groupExpr = parseExpr();
                if hasError { return stmt; }
                stmt.addGroupBy(groupExpr);
                if currentToken.kind == TK_COMMA {
                    advance();
                } else {
                    break;
                }
            }
        }

        // Optional HAVING
        if currentToken.kind == TK_HAVING {
            advance();
            stmt.havingClause = parseExpr();
        }

        // Optional ORDER BY
        if currentToken.kind == TK_ORDER {
            advance();
            if expect(TK_BY) == false {
                return stmt;
            }
            while hasError == false {
                var orderExpr = parseExpr();
                if hasError { return stmt; }
                var isDesc = 0;
                if currentToken.kind == TK_DESC {
                    isDesc = 1;
                    advance();
                } else if currentToken.kind == TK_ASC {
                    advance();
                }
                stmt.addOrderBy(orderExpr, isDesc);
                if currentToken.kind == TK_COMMA {
                    advance();
                } else {
                    break;
                }
            }
        }

        // Optional LIMIT
        if currentToken.kind == TK_LIMIT {
            advance();
            if currentToken.kind == TK_INTEGER {
                stmt.limitValue = stringToInt(currentToken.text);
                advance();
            } else {
                setError("Expected integer after LIMIT");
                return stmt;
            }
            // Optional OFFSET
            if currentToken.kind == TK_OFFSET {
                advance();
                if currentToken.kind == TK_INTEGER {
                    stmt.offsetValue = stringToInt(currentToken.text);
                    advance();
                } else {
                    setError("Expected integer after OFFSET");
                    return stmt;
                }
            }
        }

        matchToken(TK_SEMICOLON);
        return stmt;
    }

    expose func parseUpdateStmt() -> UpdateStmt {
        var stmt = new UpdateStmt();
        stmt.init();

        if currentToken.kind != TK_IDENTIFIER {
            setError("Expected table name");
            return stmt;
        }
        stmt.tableName = currentToken.text;
        advance();

        if expect(TK_SET) == false {
            return stmt;
        }

        while hasError == false {
            if currentToken.kind != TK_IDENTIFIER {
                setError("Expected column name");
                return stmt;
            }
            var colName = currentToken.text;
            advance();

            if expect(TK_EQ) == false {
                return stmt;
            }

            var val = parseExpr();
            if hasError { return stmt; }

            stmt.addSet(colName, val);

            if currentToken.kind == TK_COMMA {
                advance();
            } else {
                break;
            }
        }

        // Parse optional FROM clause (UPDATE...FROM syntax)
        if currentToken.kind == TK_FROM {
            advance();
            if currentToken.kind == TK_IDENTIFIER {
                stmt.fromTableName = currentToken.text;
                stmt.hasFrom = true;
                advance();
                // Optional alias
                if currentToken.kind == TK_AS {
                    advance();
                    if currentToken.kind == TK_IDENTIFIER {
                        stmt.fromTableAlias = currentToken.text;
                        advance();
                    }
                } else if currentToken.kind == TK_IDENTIFIER && currentToken.kind != TK_WHERE && currentToken.kind != TK_SET {
                    stmt.fromTableAlias = currentToken.text;
                    advance();
                }
                if stmt.fromTableAlias == "" {
                    stmt.fromTableAlias = stmt.fromTableName;
                }
            }
        }

        if currentToken.kind == TK_WHERE {
            advance();
            stmt.whereClause = parseExpr();
        }

        matchToken(TK_SEMICOLON);
        return stmt;
    }

    expose func parseDeleteStmt() -> DeleteStmt {
        var stmt = new DeleteStmt();
        stmt.init();

        if expect(TK_FROM) == false {
            return stmt;
        }

        if currentToken.kind != TK_IDENTIFIER {
            setError("Expected table name");
            return stmt;
        }
        stmt.tableName = currentToken.text;
        advance();

        // Parse optional USING clause (DELETE...USING syntax)
        if currentToken.kind == TK_USING {
            advance();
            if currentToken.kind == TK_IDENTIFIER {
                stmt.usingTableName = currentToken.text;
                stmt.hasUsing = true;
                advance();
                // Optional alias
                if currentToken.kind == TK_AS {
                    advance();
                    if currentToken.kind == TK_IDENTIFIER {
                        stmt.usingTableAlias = currentToken.text;
                        advance();
                    }
                } else if currentToken.kind == TK_IDENTIFIER && currentToken.kind != TK_WHERE {
                    stmt.usingTableAlias = currentToken.text;
                    advance();
                }
                if stmt.usingTableAlias == "" {
                    stmt.usingTableAlias = stmt.usingTableName;
                }
            }
        }

        if currentToken.kind == TK_WHERE {
            advance();
            stmt.whereClause = parseExpr();
        }

        matchToken(TK_SEMICOLON);
        return stmt;
    }

    expose func parseCreateIndexStmt() -> CreateIndexStmt {
        var stmt = new CreateIndexStmt();
        stmt.init();

        if currentToken.kind == TK_UNIQUE {
            stmt.isUnique = true;
            advance();
        }

        if expect(TK_INDEX) == false {
            return stmt;
        }

        if currentToken.kind != TK_IDENTIFIER {
            setError("Expected index name");
            return stmt;
        }
        stmt.indexName = currentToken.text;
        advance();

        if expect(TK_ON) == false {
            return stmt;
        }

        if currentToken.kind != TK_IDENTIFIER {
            setError("Expected table name");
            return stmt;
        }
        stmt.tableName = currentToken.text;
        advance();

        if expect(TK_LPAREN) == false {
            return stmt;
        }

        while currentToken.kind != TK_RPAREN && hasError == false {
            if currentToken.kind != TK_IDENTIFIER {
                setError("Expected column name in index");
                return stmt;
            }
            stmt.addColumn(currentToken.text);
            advance();

            if currentToken.kind == TK_ASC || currentToken.kind == TK_DESC {
                advance();
            }

            if currentToken.kind == TK_COMMA {
                advance();
            } else {
                break;
            }
        }

        if expect(TK_RPAREN) == false {
            return stmt;
        }

        matchToken(TK_SEMICOLON);
        return stmt;
    }

    expose func parseDropIndexStmt() -> DropIndexStmt {
        var stmt = new DropIndexStmt();
        stmt.init();

        if expect(TK_INDEX) == false {
            return stmt;
        }

        if currentToken.kind != TK_IDENTIFIER {
            setError("Expected index name");
            return stmt;
        }
        stmt.indexName = currentToken.text;
        advance();

        matchToken(TK_SEMICOLON);
        return stmt;
    }
}
