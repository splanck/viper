// optimizer.zia - Query Optimizer (Simplified)
// Part of ViperSQL - Phase 7: Query Optimizer
//
// Provides basic cost-based query optimization including:
// - Table statistics (row counts)
// - Cost estimation
// - Access path selection

module optimizer;

bind "../types";
bind "../schema";
bind "../table";
bind "../index";

//=============================================================================
// OPTIMIZER CONSTANTS (costs scaled by 100 for precision)
//=============================================================================

final COST_TABLE_SCAN_PER_ROW = 100;      // 1.00 per row for table scan
final COST_INDEX_SCAN_PER_ROW = 30;       // 0.30 per row for index lookup
final COST_INDEX_SEEK = 100;              // 1.00 fixed cost for index seek

// Selectivity as percentage (e.g., 10 = 10%)
final DEFAULT_SELECTIVITY = 10;           // 10% default
final EQUALITY_SELECTIVITY = 1;           // 1% for equality
final RANGE_SELECTIVITY = 30;             // 30% for ranges

//=============================================================================
// ACCESS PATH TYPES
//=============================================================================

final ACCESS_TABLE_SCAN = 1;
final ACCESS_INDEX_SCAN = 2;
final ACCESS_INDEX_SEEK = 3;

//=============================================================================
// JOIN TYPES
//=============================================================================

final JOIN_NESTED_LOOP = 1;
final JOIN_HASH = 2;
final JOIN_MERGE = 3;

//=============================================================================
// TABLE STATISTICS
//=============================================================================

entity TableStats {
    expose String tableName;
    expose Integer rowCount;
    expose Integer distinctValues;  // Estimate of distinct values per column

    expose func init() {
        tableName = "";
        rowCount = 0;
        distinctValues = 0;
    }

    expose func initWithName(name: String) {
        tableName = name;
        rowCount = 0;
        distinctValues = 0;
    }

    expose func setRowCount(count: Integer) {
        rowCount = count;
        // Estimate distinct values as sqrt of row count
        if count > 0 {
            distinctValues = estimateSqrt(count);
        }
    }

    // Simple integer square root estimation
    hide func estimateSqrt(n: Integer) -> Integer {
        if n <= 1 {
            return n;
        }
        var x = n / 2;
        var i = 0;
        while i < 10 {
            var nextX = (x + n / x) / 2;
            if nextX >= x {
                return x;
            }
            x = nextX;
            i = i + 1;
        }
        return x;
    }

    // Equality selectivity as percentage
    expose func equalitySelectivityPct() -> Integer {
        if distinctValues > 0 {
            var sel = 100 / distinctValues;
            if sel < 1 {
                sel = 1;
            }
            return sel;
        }
        return EQUALITY_SELECTIVITY;
    }
}

//=============================================================================
// ACCESS PATH
//=============================================================================

entity AccessPath {
    expose Integer pathType;
    expose String tableName;
    expose String indexName;
    expose Integer estimatedCost;
    expose Integer estimatedRows;

    expose func init() {
        pathType = ACCESS_TABLE_SCAN;
        tableName = "";
        indexName = "";
        estimatedCost = 0;
        estimatedRows = 0;
    }

    expose func initTableScan(table: String, rows: Integer) {
        pathType = ACCESS_TABLE_SCAN;
        tableName = table;
        indexName = "";
        estimatedRows = rows;
        estimatedCost = rows * COST_TABLE_SCAN_PER_ROW;
    }

    expose func initIndexSeek(table: String, idx: String, rows: Integer) {
        pathType = ACCESS_INDEX_SEEK;
        tableName = table;
        indexName = idx;
        estimatedRows = rows;
        estimatedCost = COST_INDEX_SEEK + (rows * COST_INDEX_SCAN_PER_ROW);
    }

    expose func initIndexScan(table: String, idx: String, rows: Integer) {
        pathType = ACCESS_INDEX_SCAN;
        tableName = table;
        indexName = idx;
        estimatedRows = rows;
        estimatedCost = rows * COST_INDEX_SCAN_PER_ROW;
    }

    expose func getCostDisplay() -> String {
        var wholePart = estimatedCost / 100;
        var fracPart = estimatedCost % 100;
        if fracPart < 10 {
            return Viper.Fmt.Int(wholePart) + ".0" + Viper.Fmt.Int(fracPart);
        }
        return Viper.Fmt.Int(wholePart) + "." + Viper.Fmt.Int(fracPart);
    }

    expose func toString() -> String {
        if pathType == ACCESS_TABLE_SCAN {
            return "TableScan(" + tableName + ", cost=" + getCostDisplay() + ")";
        }
        if pathType == ACCESS_INDEX_SEEK {
            return "IndexSeek(" + indexName + " on " + tableName + ", cost=" + getCostDisplay() + ")";
        }
        if pathType == ACCESS_INDEX_SCAN {
            return "IndexScan(" + indexName + " on " + tableName + ", cost=" + getCostDisplay() + ")";
        }
        return "UnknownPath";
    }
}

//=============================================================================
// QUERY PLAN
//=============================================================================

entity QueryPlan {
    expose List[AccessPath] accessPaths;
    expose Integer joinType;
    expose List[String] joinOrder;
    expose Integer totalCost;
    expose String description;

    expose func init() {
        accessPaths = [];
        joinType = JOIN_NESTED_LOOP;
        joinOrder = [];
        totalCost = 0;
        description = "";
    }

    expose func addAccessPath(path: AccessPath) {
        accessPaths.add(path);
        totalCost = totalCost + path.estimatedCost;
    }

    expose func setJoinOrder(order: List[String]) {
        joinOrder = order;
    }

    expose func setJoinType(jType: Integer) {
        joinType = jType;
    }

    expose func getCostDisplay() -> String {
        var wholePart = totalCost / 100;
        var fracPart = totalCost % 100;
        if fracPart < 10 {
            return Viper.Fmt.Int(wholePart) + ".0" + Viper.Fmt.Int(fracPart);
        }
        return Viper.Fmt.Int(wholePart) + "." + Viper.Fmt.Int(fracPart);
    }

    expose func toString() -> String {
        var result = "QueryPlan (total cost: " + getCostDisplay() + ")\n";

        var i = 0;
        while i < accessPaths.count() {
            var path = accessPaths.get(i);
            result = result + "  " + path.toString() + "\n";
            i = i + 1;
        }

        if joinOrder.count() > 1 {
            result = result + "  Join: ";
            if joinType == JOIN_NESTED_LOOP {
                result = result + "NestedLoop";
            } else if joinType == JOIN_HASH {
                result = result + "Hash";
            } else if joinType == JOIN_MERGE {
                result = result + "Merge";
            }
            result = result + " [";
            i = 0;
            while i < joinOrder.count() {
                if i > 0 {
                    result = result + " -> ";
                }
                result = result + joinOrder.get(i);
                i = i + 1;
            }
            result = result + "]\n";
        }

        if description != "" {
            result = result + "  Note: " + description + "\n";
        }

        return result;
    }
}

//=============================================================================
// STATISTICS MANAGER
//=============================================================================

entity StatsManager {
    expose List[String] tableNames;
    expose List[Integer] rowCounts;

    expose func init() {
        tableNames = [];
        rowCounts = [];
    }

    expose func getRowCount(tableName: String) -> Integer {
        var i = 0;
        while i < tableNames.count() {
            if tableNames.get(i) == tableName {
                return rowCounts.get(i);
            }
            i = i + 1;
        }
        return 0;
    }

    expose func setRowCount(tableName: String, count: Integer) {
        var i = 0;
        while i < tableNames.count() {
            if tableNames.get(i) == tableName {
                rowCounts.set(i, count);
                return;
            }
            i = i + 1;
        }
        tableNames.add(tableName);
        rowCounts.add(count);
    }

    expose func analyzeTable(table: Table) {
        setRowCount(table.name, table.rowCount());
    }
}

//=============================================================================
// QUERY OPTIMIZER
//=============================================================================

entity QueryOptimizer {
    expose StatsManager stats;

    expose func init() {
        stats = new StatsManager();
        stats.init();
    }

    // Create a table scan access path
    expose func createTableScan(tableName: String) -> AccessPath {
        var rowCount = stats.getRowCount(tableName);
        if rowCount == 0 {
            rowCount = 100;  // Default for unknown tables
        }
        var path = new AccessPath();
        path.initTableScan(tableName, rowCount);
        return path;
    }

    // Create an index seek access path
    expose func createIndexSeek(tableName: String, indexName: String, selectivityPct: Integer) -> AccessPath {
        var rowCount = stats.getRowCount(tableName);
        if rowCount == 0 {
            rowCount = 100;
        }
        var estimatedRows = (rowCount * selectivityPct) / 100;
        if estimatedRows < 1 {
            estimatedRows = 1;
        }
        var path = new AccessPath();
        path.initIndexSeek(tableName, indexName, estimatedRows);
        return path;
    }

    // Create a simple query plan with table scan
    expose func createSimplePlan(tableName: String) -> QueryPlan {
        var plan = new QueryPlan();
        plan.init();

        var path = createTableScan(tableName);
        plan.addAccessPath(path);

        return plan;
    }

    // Create a join plan
    expose func createJoinPlan(table1: String, table2: String) -> QueryPlan {
        var plan = new QueryPlan();
        plan.init();

        var path1 = createTableScan(table1);
        var path2 = createTableScan(table2);
        plan.addAccessPath(path1);
        plan.addAccessPath(path2);

        // Order smaller table first
        var rows1 = stats.getRowCount(table1);
        var rows2 = stats.getRowCount(table2);
        if rows1 == 0 { rows1 = 100; }
        if rows2 == 0 { rows2 = 100; }

        var order: List[String] = [];
        if rows1 <= rows2 {
            order.add(table1);
            order.add(table2);
        } else {
            order.add(table2);
            order.add(table1);
        }
        plan.setJoinOrder(order);

        // Use nested loop for small tables, hash for larger
        var totalRows = rows1 + rows2;
        if totalRows > 1000 {
            plan.setJoinType(JOIN_HASH);
        } else {
            plan.setJoinType(JOIN_NESTED_LOOP);
        }

        return plan;
    }

    // Estimate cost of a query plan
    expose func estimateCost(plan: QueryPlan) -> Integer {
        return plan.totalCost;
    }

    // Estimate selectivity (percentage 0-100)
    expose func estimateSelectivityPct(hasEqualityCondition: Boolean) -> Integer {
        if hasEqualityCondition {
            return EQUALITY_SELECTIVITY;
        }
        return DEFAULT_SELECTIVITY;
    }

    // Estimate rows with a given selectivity
    expose func estimateRows(tableName: String, selectivityPct: Integer) -> Integer {
        var rowCount = stats.getRowCount(tableName);
        if rowCount == 0 {
            rowCount = 100;
        }
        var estimated = (rowCount * selectivityPct) / 100;
        if estimated < 1 {
            estimated = 1;
        }
        return estimated;
    }

    // Generate EXPLAIN output
    expose func explainPlan(plan: QueryPlan) -> String {
        return plan.toString();
    }
}
