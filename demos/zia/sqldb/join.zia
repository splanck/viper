// join.zia — Multi-Table JOIN Engine
// Part of ViperSQL

module join;

bind String = Viper.String;
bind Fmt = Viper.Fmt;

bind "./types";
bind "./schema";
bind "./table";
bind "./expr";
bind "./stmt";
bind "./result";
bind "./database";
bind "./index";
bind "./executor";

//=============================================================================
// JOIN ENGINE ENTITY
//=============================================================================

entity JoinEngine {
    expose Executor exec;

    expose func init(executor: Executor) {
        exec = executor;
    }

    // Create a row with a specific number of NULL values
    hide func makeJoinRow(numCols: Integer) -> Row {
        var row = new Row();
        row.init();
        var i = 0;
        while i < numCols {
            row.addValue(sqlNull());
            i = i + 1;
        }
        return row;
    }

    // Find column value in a combined row for JOIN queries
    hide func findJoinColumnValue(tableName: String, columnName: String,
                                   tables: List[Table], aliases: List[String],
                                   combinedRow: Row, colOffsets: List[Integer]) -> SqlValue {
        var ti = 0;
        while ti < tables.count() {
            var tbl = tables.get(ti);
            var alias = aliases.get(ti);

            // Check if this table matches the requested table name or alias
            if tableName == alias || tableName == tbl.name || tableName == "" {
                var colIdx = tbl.findColumnIndex(columnName);
                if colIdx >= 0 {
                    var offset = colOffsets.get(ti);
                    return combinedRow.getValue(offset + colIdx);
                }
            }
            ti = ti + 1;
        }
        return sqlNull();
    }

    // Evaluate expression in JOIN context
    hide func evalJoinExpr(expr: Expr, tables: List[Table], aliases: List[String],
                           combinedRow: Row, colOffsets: List[Integer]) -> SqlValue {
        if expr.kind == EXPR_LITERAL {
            return expr.literalValue;
        }

        if expr.kind == EXPR_COLUMN {
            return findJoinColumnValue(expr.tableName, expr.columnName,
                                       tables, aliases, combinedRow, colOffsets);
        }

        if expr.kind == EXPR_BINARY {
            var left = evalJoinExpr(expr.getLeft(), tables, aliases, combinedRow, colOffsets);
            var right = evalJoinExpr(expr.getRight(), tables, aliases, combinedRow, colOffsets);
            var op = expr.op;

            // Comparison operators (handle NULL: compare returns 2)
            if op == OP_EQ {
                var cmp = left.compare(right);
                if cmp == 2 { return sqlInteger(0); }
                if cmp == 0 { return sqlInteger(1); }
                return sqlInteger(0);
            }
            if op == OP_NE {
                var cmp = left.compare(right);
                if cmp == 2 { return sqlInteger(0); }
                if cmp != 0 { return sqlInteger(1); }
                return sqlInteger(0);
            }
            if op == OP_LT {
                var cmp = left.compare(right);
                if cmp == 2 { return sqlInteger(0); }
                if cmp < 0 { return sqlInteger(1); }
                return sqlInteger(0);
            }
            if op == OP_LE {
                var cmp = left.compare(right);
                if cmp == 2 { return sqlInteger(0); }
                if cmp <= 0 { return sqlInteger(1); }
                return sqlInteger(0);
            }
            if op == OP_GT {
                var cmp = left.compare(right);
                if cmp == 2 { return sqlInteger(0); }
                if cmp > 0 { return sqlInteger(1); }
                return sqlInteger(0);
            }
            if op == OP_GE {
                var cmp = left.compare(right);
                if cmp == 2 { return sqlInteger(0); }
                if cmp >= 0 { return sqlInteger(1); }
                return sqlInteger(0);
            }

            // Logical operators
            if op == OP_AND {
                if left.intValue != 0 && right.intValue != 0 { return sqlInteger(1); }
                return sqlInteger(0);
            }
            if op == OP_OR {
                if left.intValue != 0 || right.intValue != 0 { return sqlInteger(1); }
                return sqlInteger(0);
            }

            // Arithmetic operators
            if op == OP_ADD { return sqlInteger(left.intValue + right.intValue); }
            if op == OP_SUB { return sqlInteger(left.intValue - right.intValue); }
            if op == OP_MUL { return sqlInteger(left.intValue * right.intValue); }
            if op == OP_DIV {
                if right.intValue != 0 {
                    return sqlInteger(left.intValue / right.intValue);
                }
                return sqlNull();
            }
        }

        return sqlNull();
    }

    // Execute a multi-table JOIN query
    expose func executeCrossJoin(stmt: SelectStmt) -> QueryResult {
        var result = new QueryResult();
        result.init();

        // Load all tables
        var tables = new List[Table]();
        var aliases = new List[String]();
        var colOffsets = new List[Integer]();
        var totalCols = 0;

        var ti = 0;
        while ti < stmt.tableNames.count() {
            var tblName = stmt.tableNames.get(ti);
            var maybeTable = exec.db.findTable(tblName);
            if maybeTable == null {
                result.setError("Table '" + tblName + "' does not exist");
                return result;
            }
            var tbl = maybeTable;
            tables.add(tbl);

            var alias = stmt.tableAliases.get(ti);
            if alias == "" {
                alias = tblName;
            }
            aliases.add(alias);

            colOffsets.add(totalCols);
            totalCols = totalCols + tbl.columnCount();
            ti = ti + 1;
        }

        // Build column names for result
        if stmt.selectAll {
            ti = 0;
            while ti < tables.count() {
                var tbl = tables.get(ti);
                var alias = aliases.get(ti);
                var c = 0;
                while c < tbl.columnCount() {
                    var maybeCol = tbl.getColumn(c);
                    if maybeCol != null {
                        var col = maybeCol;
                        result.addColumnName(alias + "." + col.name);
                    }
                    c = c + 1;
                }
                ti = ti + 1;
            }
        } else {
            var c = 0;
            while c < stmt.columns.count() {
                // Check for column alias first
                var alias = "";
                if c < stmt.columnAliases.count() {
                    alias = stmt.columnAliases.get(c);
                }
                if alias != "" {
                    result.addColumnName(alias);
                } else {
                    var colExpr = stmt.columns.get(c);
                    if colExpr.kind == EXPR_COLUMN {
                        if colExpr.tableName != "" {
                            result.addColumnName(colExpr.tableName + "." + colExpr.columnName);
                        } else {
                            result.addColumnName(colExpr.columnName);
                        }
                    } else if colExpr.kind == EXPR_FUNCTION {
                        var displayName = colExpr.funcName;
                        if displayName == "COUNT_DISTINCT" {
                            displayName = "COUNT";
                        }
                        result.addColumnName(displayName);
                    } else {
                        result.addColumnName("expr" + Fmt.Int(c));
                    }
                }
                c = c + 1;
            }
        }

        // Build cartesian product starting with first table
        var combinedRows = new List[Row]();

        if tables.count() > 0 {
            var firstTable = tables.get(0);
            var r = 0;
            while r < firstTable.rowCount() {
                var maybeRow = firstTable.getRow(r);
                if maybeRow != null {
                    var srcRow = maybeRow;
                    if srcRow.deleted == false {
                        var newRow = makeJoinRow(totalCols);
                        var c = 0;
                        while c < firstTable.columnCount() {
                            newRow.setValue(c, srcRow.getValue(c));
                            c = c + 1;
                        }
                        combinedRows.add(newRow);
                    }
                }
                r = r + 1;
            }
        }

        // Extend with each additional table
        ti = 1;
        while ti < tables.count() {
            var tbl = tables.get(ti);
            var offset = colOffsets.get(ti);
            var newCombined = new List[Row]();

            // Get join type (0=CROSS, 1=INNER, 2=LEFT, 3=RIGHT, 4=FULL)
            var joinType = 0;
            if ti - 1 < stmt.joinTypes.count() {
                joinType = stmt.joinTypes.get(ti - 1);
            }

            // Check if we have a join condition
            var hasJoinCond = ti - 1 < stmt.joinConditions.count();

            // For RIGHT/FULL JOIN: track matched right rows
            var rightMatched = new List[Integer]();
            if joinType == 3 || joinType == 4 {
                var rInit = 0;
                while rInit < tbl.rowCount() {
                    rightMatched.add(0);
                    rInit = rInit + 1;
                }
            }

            var ci = 0;
            while ci < combinedRows.count() {
                var existing = combinedRows.get(ci);
                var foundMatch = false;

                var r = 0;
                while r < tbl.rowCount() {
                    var maybeRow = tbl.getRow(r);
                    if maybeRow != null {
                        var srcRow = maybeRow;
                        if srcRow.deleted == false {
                            // Create combined row
                            var newRow = makeJoinRow(totalCols);
                            var c = 0;
                            while c < offset {
                                newRow.setValue(c, existing.getValue(c));
                                c = c + 1;
                            }
                            c = 0;
                            while c < tbl.columnCount() {
                                newRow.setValue(offset + c, srcRow.getValue(c));
                                c = c + 1;
                            }

                            // Check join condition for non-CROSS joins
                            var includeRow = true;
                            if hasJoinCond && (joinType == 1 || joinType == 2 || joinType == 3 || joinType == 4) {
                                var joinCond = stmt.joinConditions.get(ti - 1);
                                var joinResult = evalJoinExpr(joinCond, tables, aliases, newRow, colOffsets);
                                if joinResult.intValue == 0 {
                                    includeRow = false;
                                }
                            }

                            if includeRow {
                                newCombined.add(newRow);
                                foundMatch = true;
                                if joinType == 3 || joinType == 4 {
                                    rightMatched.set(r, 1);
                                }
                            }
                        }
                    }
                    r = r + 1;
                }

                // LEFT/FULL JOIN: add NULL row if no match
                if (joinType == 2 || joinType == 4) && foundMatch == false {
                    var nullRow = makeJoinRow(totalCols);
                    var c = 0;
                    while c < offset {
                        nullRow.setValue(c, existing.getValue(c));
                        c = c + 1;
                    }
                    newCombined.add(nullRow);
                }

                ci = ci + 1;
            }

            // RIGHT/FULL JOIN: add unmatched right rows
            if joinType == 3 || joinType == 4 {
                var rCheck = 0;
                while rCheck < tbl.rowCount() {
                    if rightMatched.get(rCheck) == 0 {
                        var maybeRightRow = tbl.getRow(rCheck);
                        if maybeRightRow != null {
                            var rightRow = maybeRightRow;
                            if rightRow.deleted == false {
                                var nullRow = makeJoinRow(totalCols);
                                var c = 0;
                                while c < tbl.columnCount() {
                                    nullRow.setValue(offset + c, rightRow.getValue(c));
                                    c = c + 1;
                                }
                                newCombined.add(nullRow);
                            }
                        }
                    }
                    rCheck = rCheck + 1;
                }
            }

            combinedRows = newCombined;
            ti = ti + 1;
        }

        // Apply WHERE clause
        var filteredRows = new List[Row]();
        var ri = 0;
        while ri < combinedRows.count() {
            var row = combinedRows.get(ri);
            var includeRow = true;

            if stmt.whereClause != null {
                var wc = stmt.whereClause;
                var whereResult = evalJoinExpr(wc, tables, aliases, row, colOffsets);
                if whereResult.intValue == 0 {
                    includeRow = false;
                }
            }

            if includeRow {
                filteredRows.add(row);
            }
            ri = ri + 1;
        }

        // Check for GROUP BY / aggregates on JOIN results
        var isAggregate = exec.hasAggregates(stmt);

        if isAggregate || stmt.groupByExprs.count() > 0 {
            // GROUP BY on JOIN results
            executeJoinGroupBy(stmt, filteredRows, tables, aliases, colOffsets, totalCols, result);
        } else {
            // Build result rows (regular non-aggregate query)
            ri = 0;
            while ri < filteredRows.count() {
                var combinedRow = filteredRows.get(ri);
                var resultRow = new Row();
                resultRow.init();

                if stmt.selectAll {
                    var c = 0;
                    while c < totalCols {
                        resultRow.addValue(exec.cloneValue(combinedRow.getValue(c)));
                        c = c + 1;
                    }
                } else {
                    var c = 0;
                    while c < stmt.columns.count() {
                        var colExpr = stmt.columns.get(c);
                        var val = evalJoinExpr(colExpr, tables, aliases, combinedRow, colOffsets);
                        resultRow.addValue(exec.cloneValue(val));
                        c = c + 1;
                    }
                }

                result.addRow(resultRow);
                ri = ri + 1;
            }
        }

        // Apply DISTINCT
        if stmt.isDistinct {
            exec.applyDistinct(result);
        }

        // Apply ORDER BY on JOIN results
        if stmt.orderByExprs.count() > 0 {
            sortJoinResults(result, stmt);
        }

        // Apply LIMIT/OFFSET
        if stmt.limitValue >= 0 || stmt.offsetValue > 0 {
            exec.applyLimitOffset(result, stmt.limitValue, stmt.offsetValue);
        }

        return result;
    }

    // Execute GROUP BY on JOIN results
    hide func executeJoinGroupBy(stmt: SelectStmt, filteredRows: List[Row],
                                  tables: List[Table], aliases: List[String],
                                  colOffsets: List[Integer], totalCols: Integer,
                                  result: QueryResult) {
        var groupKeys = new List[String]();
        var groupRowLists = new List[List[Row]]();

        if stmt.groupByExprs.count() > 0 {
            var i = 0;
            while i < filteredRows.count() {
                var row = filteredRows.get(i);
                var key = "";
                var g = 0;
                while g < stmt.groupByExprs.count() {
                    var groupExpr = stmt.groupByExprs.get(g);
                    var val = evalJoinExpr(groupExpr, tables, aliases, row, colOffsets);
                    if g > 0 { key = key + "|"; }
                    key = key + val.toString();
                    g = g + 1;
                }

                var groupIdx = -1;
                var k = 0;
                while k < groupKeys.count() {
                    if groupKeys.get(k) == key {
                        groupIdx = k;
                        k = groupKeys.count();
                    }
                    k = k + 1;
                }

                if groupIdx < 0 {
                    groupKeys.add(key);
                    var newList = new List[Row]();
                    newList.add(row);
                    groupRowLists.add(newList);
                } else {
                    groupRowLists.get(groupIdx).add(row);
                }
                i = i + 1;
            }
        } else {
            // No GROUP BY but has aggregates — treat all rows as one group
            groupKeys.add("");
            groupRowLists.add(filteredRows);
        }

        // Build result rows from groups
        var g = 0;
        while g < groupKeys.count() {
            var groupRows = groupRowLists.get(g);
            var resultRow = new Row();
            resultRow.init();

            var firstRow = groupRows.get(0);

            var c = 0;
            while c < stmt.columns.count() {
                var colExpr = stmt.columns.get(c);
                if exec.isAggregateExpr(colExpr) {
                    var val = evalJoinAggregate(colExpr, groupRows, tables, aliases, colOffsets);
                    resultRow.addValue(exec.cloneValue(val));
                } else {
                    var val = evalJoinExpr(colExpr, tables, aliases, firstRow, colOffsets);
                    resultRow.addValue(exec.cloneValue(val));
                }
                c = c + 1;
            }

            // Check HAVING condition
            if stmt.havingClause != null {
                var hc = stmt.havingClause;
                if evalJoinHaving(hc, groupRows, tables, aliases, colOffsets) == false {
                    g = g + 1;
                    continue;
                }
            }

            result.addRow(resultRow);
            g = g + 1;
        }
    }

    // Evaluate aggregate function over JOIN group rows
    hide func evalJoinAggregate(expr: Expr, groupRows: List[Row],
                                 tables: List[Table], aliases: List[String],
                                 colOffsets: List[Integer]) -> SqlValue {
        var funcName = String.ToUpper(expr.funcName);
        var hasArg = expr.args.count() > 0;

        // COUNT(*)
        if funcName == "COUNT" && hasArg {
            var arg0 = expr.args.get(0);
            if arg0.kind == EXPR_STAR {
                return sqlInteger(groupRows.count());
            }
        }

        // COUNT_DISTINCT
        if funcName == "COUNT_DISTINCT" && hasArg {
            var seen = new List[String]();
            var i = 0;
            while i < groupRows.count() {
                var row = groupRows.get(i);
                var val = evalJoinExpr(expr.args.get(0), tables, aliases, row, colOffsets);
                if val.kind != SQL_NULL {
                    var valStr = val.toString();
                    var found = false;
                    var k = 0;
                    while k < seen.count() {
                        if seen.get(k) == valStr { found = true; k = seen.count(); }
                        k = k + 1;
                    }
                    if found == false { seen.add(valStr); }
                }
                i = i + 1;
            }
            return sqlInteger(seen.count());
        }

        // COUNT(column)
        if funcName == "COUNT" {
            var count = 0;
            var i = 0;
            while i < groupRows.count() {
                var row = groupRows.get(i);
                if hasArg {
                    var val = evalJoinExpr(expr.args.get(0), tables, aliases, row, colOffsets);
                    if val.kind != SQL_NULL { count = count + 1; }
                }
                i = i + 1;
            }
            return sqlInteger(count);
        }

        // SUM
        if funcName == "SUM" {
            var sumInt = 0;
            var sumReal = 0.0;
            var hasValue = false;
            var hasReal = false;
            var i = 0;
            while i < groupRows.count() {
                var row = groupRows.get(i);
                if hasArg {
                    var val = evalJoinExpr(expr.args.get(0), tables, aliases, row, colOffsets);
                    if val.kind == SQL_INTEGER { sumInt = sumInt + val.intValue; hasValue = true; }
                    else if val.kind == SQL_REAL { sumReal = sumReal + val.realValue; hasValue = true; hasReal = true; }
                }
                i = i + 1;
            }
            if hasValue == false { return sqlNull(); }
            if hasReal {
                var total = sumReal + sumInt * 1.0;
                return sqlReal(total, Fmt.Num(total));
            }
            return sqlInteger(sumInt);
        }

        // AVG
        if funcName == "AVG" {
            var sumInt = 0;
            var sumReal = 0.0;
            var count = 0;
            var hasReal = false;
            var i = 0;
            while i < groupRows.count() {
                var row = groupRows.get(i);
                if hasArg {
                    var val = evalJoinExpr(expr.args.get(0), tables, aliases, row, colOffsets);
                    if val.kind == SQL_INTEGER { sumInt = sumInt + val.intValue; count = count + 1; }
                    else if val.kind == SQL_REAL { sumReal = sumReal + val.realValue; count = count + 1; hasReal = true; }
                }
                i = i + 1;
            }
            if count == 0 { return sqlNull(); }
            var total = sumReal + sumInt * 1.0;
            var avg = total / count;
            return sqlReal(avg, Fmt.Num(avg));
        }

        // MIN
        if funcName == "MIN" {
            var hasMin = false;
            var minResult = sqlNull();
            var i = 0;
            while i < groupRows.count() {
                var row = groupRows.get(i);
                if hasArg {
                    var val = evalJoinExpr(expr.args.get(0), tables, aliases, row, colOffsets);
                    if val.kind != SQL_NULL {
                        if hasMin == false { minResult = val; hasMin = true; }
                        else if val.compare(minResult) < 0 { minResult = val; }
                    }
                }
                i = i + 1;
            }
            return minResult;
        }

        // MAX
        if funcName == "MAX" {
            var hasMax = false;
            var maxResult = sqlNull();
            var i = 0;
            while i < groupRows.count() {
                var row = groupRows.get(i);
                if hasArg {
                    var val = evalJoinExpr(expr.args.get(0), tables, aliases, row, colOffsets);
                    if val.kind != SQL_NULL {
                        if hasMax == false { maxResult = val; hasMax = true; }
                        else if val.compare(maxResult) > 0 { maxResult = val; }
                    }
                }
                i = i + 1;
            }
            return maxResult;
        }

        return sqlNull();
    }

    // Evaluate HAVING expression for JOIN groups
    hide func evalJoinHaving(expr: Expr, groupRows: List[Row],
                              tables: List[Table], aliases: List[String],
                              colOffsets: List[Integer]) -> Boolean {
        if expr.kind == EXPR_BINARY {
            var left = expr.getLeft();
            var right = expr.getRight();
            var op = expr.op;

            if op == OP_AND {
                return evalJoinHaving(left, groupRows, tables, aliases, colOffsets) && evalJoinHaving(right, groupRows, tables, aliases, colOffsets);
            }
            if op == OP_OR {
                return evalJoinHaving(left, groupRows, tables, aliases, colOffsets) || evalJoinHaving(right, groupRows, tables, aliases, colOffsets);
            }

            var leftVal = evalJoinHavingValue(left, groupRows, tables, aliases, colOffsets);
            var rightVal = evalJoinHavingValue(right, groupRows, tables, aliases, colOffsets);

            var cmp = leftVal.compare(rightVal);
            if cmp == 2 { return false; }
            if op == OP_EQ { return cmp == 0; }
            if op == OP_NE { return cmp != 0; }
            if op == OP_LT { return cmp < 0; }
            if op == OP_LE { return cmp <= 0; }
            if op == OP_GT { return cmp > 0; }
            if op == OP_GE { return cmp >= 0; }
        }
        return false;
    }

    // Evaluate a value in JOIN HAVING context
    hide func evalJoinHavingValue(expr: Expr, groupRows: List[Row],
                                    tables: List[Table], aliases: List[String],
                                    colOffsets: List[Integer]) -> SqlValue {
        if expr.kind == EXPR_FUNCTION && exec.isAggregateExpr(expr) {
            return evalJoinAggregate(expr, groupRows, tables, aliases, colOffsets);
        }
        if expr.kind == EXPR_LITERAL {
            return expr.literalValue;
        }
        if expr.kind == EXPR_COLUMN && groupRows.count() > 0 {
            var firstRow = groupRows.get(0);
            return evalJoinExpr(expr, tables, aliases, firstRow, colOffsets);
        }
        return sqlNull();
    }

    // Sort JOIN results using result column name resolution
    hide func sortJoinResults(result: QueryResult, stmt: SelectStmt) {
        // Pre-compute column index mappings to avoid repeated string
        // operations inside the sort loop (causes native codegen crash)
        var colMappings = new List[Integer]();
        var e = 0;
        while e < stmt.orderByExprs.count() {
            colMappings.add(findResultColumnIndex(result, stmt.orderByExprs.get(e)));
            e = e + 1;
        }

        var n = result.rowCount();
        var i = 0;
        while i < n - 1 {
            var j = 0;
            while j < n - i - 1 {
                var row1 = result.getRow(j);
                var row2 = result.getRow(j + 1);
                if row1 != null && row2 != null {
                    var r1 = row1;
                    var r2 = row2;
                    var shouldSwap = false;

                    e = 0;
                    while e < stmt.orderByExprs.count() {
                        var isDesc = stmt.orderByDir.get(e);
                        var colIdx = colMappings.get(e);

                        if colIdx >= 0 {
                            var val1 = r1.getValue(colIdx);
                            var val2 = r2.getValue(colIdx);
                            var cmp = val1.compare(val2);

                            if cmp == 2 {
                                if val1.kind == SQL_NULL && val2.kind != SQL_NULL {
                                    shouldSwap = isDesc == 1;
                                } else if val1.kind != SQL_NULL && val2.kind == SQL_NULL {
                                    shouldSwap = isDesc == 0;
                                }
                                break;
                            }
                            if cmp != 0 {
                                if isDesc == 1 { shouldSwap = cmp < 0; }
                                else { shouldSwap = cmp > 0; }
                                break;
                            }
                        }
                        e = e + 1;
                    }

                    if shouldSwap {
                        result.swapRows(j, j + 1);
                    }
                }
                j = j + 1;
            }
            i = i + 1;
        }
    }

    // Find column index in result for ORDER BY expression
    hide func findResultColumnIndex(result: QueryResult, expr: Expr) -> Integer {
        if expr.kind == EXPR_COLUMN {
            var searchName = expr.columnName;
            var searchTable = expr.tableName;

            var i = 0;
            while i < result.columnNames.count() {
                var colName = result.columnNames.get(i);

                // Try qualified match (e.g., "o.amount")
                if searchTable != "" {
                    if colName == searchTable + "." + searchName {
                        return i;
                    }
                }

                // Try exact name match
                if colName == searchName {
                    return i;
                }

                // Try suffix match (e.g., column named "orders.amount" matches "amount")
                var suffix = "." + searchName;
                var suffixLen = String.Length(suffix);
                var colLen = String.Length(colName);
                if colLen > suffixLen {
                    if String.Substring(colName, colLen - suffixLen, suffixLen) == suffix {
                        return i;
                    }
                }
                i = i + 1;
            }
        }
        if expr.kind == EXPR_FUNCTION {
            var funcName = expr.funcName;
            var i = 0;
            while i < result.columnNames.count() {
                if result.columnNames.get(i) == funcName {
                    return i;
                }
                i = i + 1;
            }
        }
        return -1;
    }
}
