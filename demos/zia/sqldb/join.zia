// join.zia — Multi-Table JOIN Engine
// Part of ViperSQL

module join;

bind String = Viper.String;
bind Fmt = Viper.Fmt;

bind "./types";
bind "./schema";
bind "./table";
bind "./expr";
bind "./stmt";
bind "./result";
bind "./database";
bind "./index";
bind "./executor";

//=============================================================================
// JOIN ENGINE ENTITY
//=============================================================================

entity JoinEngine {
    expose Executor exec;

    expose func init(executor: Executor) {
        exec = executor;
    }

    // Create a row with a specific number of NULL values
    hide func makeJoinRow(numCols: Integer) -> Row {
        var row = new Row();
        row.init();
        var i = 0;
        while i < numCols {
            row.addValue(sqlNull());
            i = i + 1;
        }
        return row;
    }

    //=========================================================================
    // HASH JOIN SUPPORT
    //=========================================================================

    // Check if a join condition is a simple equi-join (table1.col = table2.col)
    hide func isEquiJoin(cond: Expr) -> Boolean {
        if cond.kind != EXPR_BINARY || cond.op != OP_EQ {
            return false;
        }
        var left = cond.getLeft();
        var right = cond.getRight();
        return left.kind == EXPR_COLUMN && right.kind == EXPR_COLUMN;
    }

    // Extract the column index from a join table for the equi-join condition
    hide func getJoinColumnIndex(cond: Expr, tbl: Table, tblAlias: String, isLeft: Boolean) -> Integer {
        var colExpr = cond.getLeft();
        if isLeft == false {
            colExpr = cond.getRight();
        }
        if colExpr.kind == EXPR_COLUMN {
            // Check if table name matches
            if colExpr.tableName == tblAlias || colExpr.tableName == tbl.name || colExpr.tableName == "" {
                return tbl.findColumnIndex(colExpr.columnName);
            }
        }
        return -1;
    }

    // Execute hash join for a single pair of tables (INNER JOIN with equi-condition)
    // Returns the combined rows using hash-based matching instead of nested loop
    hide func executeHashJoinStep(existing: List[Row], rightTable: Table,
                                   leftTable: Table, leftAlias: String, rightAlias: String,
                                   joinCond: Expr, colOffsets: List[Integer],
                                   leftTableIdx: Integer, rightTableIdx: Integer,
                                   totalCols: Integer, tables: List[Table],
                                   aliases: List[String]) -> List[Row] {
        var result = new List[Row]();
        var rightOffset = colOffsets.get(rightTableIdx);

        // Determine which side of the equi-join refers to which table
        var leftJoinCol = getJoinColumnIndex(joinCond, leftTable, leftAlias, true);
        var rightJoinCol = getJoinColumnIndex(joinCond, rightTable, rightAlias, false);

        // If left side refers to right table, swap
        if leftJoinCol < 0 {
            leftJoinCol = getJoinColumnIndex(joinCond, leftTable, leftAlias, false);
            rightJoinCol = getJoinColumnIndex(joinCond, rightTable, rightAlias, true);
        }

        if leftJoinCol < 0 || rightJoinCol < 0 {
            return result;
        }

        // Build hash table on right table: hash(key) -> list of row indices
        var numBuckets = 64;
        var bucketKeys = new List[List[String]]();
        var bucketIndices = new List[List[Integer]]();
        var bi = 0;
        while bi < numBuckets {
            bucketKeys.add(new List[String]());
            bucketIndices.add(new List[Integer]());
            bi = bi + 1;
        }

        var ri = 0;
        while ri < rightTable.rowCount() {
            var maybeRow = rightTable.getRow(ri);
            if maybeRow != null {
                var row = maybeRow;
                if row.deleted == false {
                    var keyVal = row.getValue(rightJoinCol);
                    var keyStr = keyVal.toString();
                    var rawHash = exec.computeKeyHash(keyStr);
                    var h = rawHash % numBuckets;
                    if h >= 0 && h < numBuckets {
                        bucketKeys.get(h).add(keyStr);
                        bucketIndices.get(h).add(ri);
                    }
                }
            }
            ri = ri + 1;
        }

        // Probe: for each existing (left) row, find matching right rows via hash
        var li = 0;
        while li < existing.count() {
            var leftRow = existing.get(li);
            var leftOffset = colOffsets.get(leftTableIdx);
            var leftKeyVal = leftRow.getValue(leftOffset + leftJoinCol);
            var leftKeyStr = leftKeyVal.toString();
            var rawHash = exec.computeKeyHash(leftKeyStr);
            var h = rawHash % numBuckets;

            if h >= 0 && h < numBuckets {
                var bKeys = bucketKeys.get(h);
                var bIndices = bucketIndices.get(h);
                var bj = 0;
                while bj < bKeys.count() {
                    if bKeys.get(bj) == leftKeyStr {
                        var rightRowIdx = bIndices.get(bj);
                        var maybeRightRow = rightTable.getRow(rightRowIdx);
                        if maybeRightRow != null {
                            var rightRow = maybeRightRow;
                            var newRow = makeJoinRow(totalCols);
                            var c = 0;
                            while c < rightOffset {
                                newRow.setValue(c, leftRow.getValue(c));
                                c = c + 1;
                            }
                            c = 0;
                            while c < rightTable.columnCount() {
                                newRow.setValue(rightOffset + c, rightRow.getValue(c));
                                c = c + 1;
                            }
                            result.add(newRow);
                        }
                    }
                    bj = bj + 1;
                }
            }
            li = li + 1;
        }
        return result;
    }

    //=========================================================================
    // JOIN COLUMN LOOKUPS
    //=========================================================================

    // Find column value in a combined row for JOIN queries
    hide func findJoinColumnValue(tableName: String, columnName: String,
                                   tables: List[Table], aliases: List[String],
                                   combinedRow: Row, colOffsets: List[Integer]) -> SqlValue {
        var ti = 0;
        while ti < tables.count() {
            var tbl = tables.get(ti);
            var alias = aliases.get(ti);

            // Check if this table matches the requested table name or alias
            if tableName == alias || tableName == tbl.name || tableName == "" {
                var colIdx = tbl.findColumnIndex(columnName);
                if colIdx >= 0 {
                    var offset = colOffsets.get(ti);
                    return combinedRow.getValue(offset + colIdx);
                }
            }
            ti = ti + 1;
        }
        return sqlNull();
    }

    // Evaluate expression in JOIN context
    hide func evalJoinExpr(expr: Expr, tables: List[Table], aliases: List[String],
                           combinedRow: Row, colOffsets: List[Integer]) -> SqlValue {
        if expr.kind == EXPR_LITERAL {
            return expr.literalValue;
        }

        if expr.kind == EXPR_COLUMN {
            return findJoinColumnValue(expr.tableName, expr.columnName,
                                       tables, aliases, combinedRow, colOffsets);
        }

        if expr.kind == EXPR_BINARY {
            var left = evalJoinExpr(expr.getLeft(), tables, aliases, combinedRow, colOffsets);
            var right = evalJoinExpr(expr.getRight(), tables, aliases, combinedRow, colOffsets);
            var op = expr.op;

            // Comparison operators (handle NULL: compare returns 2)
            if op == OP_EQ {
                var cmp = left.compare(right);
                if cmp == 2 { return sqlInteger(0); }
                if cmp == 0 { return sqlInteger(1); }
                return sqlInteger(0);
            }
            if op == OP_NE {
                var cmp = left.compare(right);
                if cmp == 2 { return sqlInteger(0); }
                if cmp != 0 { return sqlInteger(1); }
                return sqlInteger(0);
            }
            if op == OP_LT {
                var cmp = left.compare(right);
                if cmp == 2 { return sqlInteger(0); }
                if cmp < 0 { return sqlInteger(1); }
                return sqlInteger(0);
            }
            if op == OP_LE {
                var cmp = left.compare(right);
                if cmp == 2 { return sqlInteger(0); }
                if cmp <= 0 { return sqlInteger(1); }
                return sqlInteger(0);
            }
            if op == OP_GT {
                var cmp = left.compare(right);
                if cmp == 2 { return sqlInteger(0); }
                if cmp > 0 { return sqlInteger(1); }
                return sqlInteger(0);
            }
            if op == OP_GE {
                var cmp = left.compare(right);
                if cmp == 2 { return sqlInteger(0); }
                if cmp >= 0 { return sqlInteger(1); }
                return sqlInteger(0);
            }

            // Logical operators
            if op == OP_AND {
                if left.intValue != 0 && right.intValue != 0 { return sqlInteger(1); }
                return sqlInteger(0);
            }
            if op == OP_OR {
                if left.intValue != 0 || right.intValue != 0 { return sqlInteger(1); }
                return sqlInteger(0);
            }

            // Arithmetic operators
            if op == OP_ADD { return sqlInteger(left.intValue + right.intValue); }
            if op == OP_SUB { return sqlInteger(left.intValue - right.intValue); }
            if op == OP_MUL { return sqlInteger(left.intValue * right.intValue); }
            if op == OP_DIV {
                if right.intValue != 0 {
                    return sqlInteger(left.intValue / right.intValue);
                }
                return sqlNull();
            }
        }

        return sqlNull();
    }

    //=========================================================================
    // JOIN ORDERING OPTIMIZATION
    //=========================================================================

    // Check if a join condition references a specific table (by alias or name)
    hide func condReferencesTable(cond: Expr, tbl: Table, alias: String) -> Boolean {
        if cond.kind == EXPR_COLUMN {
            return cond.tableName == alias || cond.tableName == tbl.name;
        }
        if cond.kind == EXPR_BINARY {
            if condReferencesTable(cond.getLeft(), tbl, alias) {
                return true;
            }
            return condReferencesTable(cond.getRight(), tbl, alias);
        }
        return false;
    }

    // Find a join condition that connects a candidate table to any already-joined table.
    // Returns the index into joinConditions, or -1 if none found.
    hide func findConditionForTable(joinConditions: List[Expr],
                                     condUsed: List[Integer],
                                     candTable: Table, candAlias: String,
                                     joinedTables: List[Table],
                                     joinedAliases: List[String]) -> Integer {
        var ci = 0;
        while ci < joinConditions.count() {
            if condUsed.get(ci) == 0 {
                var cond = joinConditions.get(ci);
                // Check if this condition references the candidate table
                if condReferencesTable(cond, candTable, candAlias) {
                    // Check if it also references any already-joined table
                    var ji = 0;
                    while ji < joinedTables.count() {
                        if condReferencesTable(cond, joinedTables.get(ji), joinedAliases.get(ji)) {
                            return ci;
                        }
                        ji = ji + 1;
                    }
                }
            }
            ci = ci + 1;
        }
        return -1;
    }

    // Reorder tables for all-INNER-JOIN queries by row count (smallest first).
    // Returns true if reordering was applied.
    // Modifies tables, aliases in-place and populates reorderedConds.
    hide func reorderInnerJoinTables(tables: List[Table], aliases: List[String],
                                      joinConditions: List[Expr],
                                      reorderedConds: List[Expr]) -> Boolean {
        if tables.count() < 3 {
            return false;
        }

        // Find the smallest table to start with
        var bestIdx = 0;
        var bestRows = tables.get(0).rowCount();
        var i = 1;
        while i < tables.count() {
            var rc = tables.get(i).rowCount();
            if rc < bestRows {
                bestRows = rc;
                bestIdx = i;
            }
            i = i + 1;
        }

        // Build reordered lists using greedy smallest-first
        var newTables = new List[Table]();
        var newAliases = new List[String]();
        var used = new List[Integer]();
        var condUsed = new List[Integer]();
        i = 0;
        while i < tables.count() {
            used.add(0);
            i = i + 1;
        }
        i = 0;
        while i < joinConditions.count() {
            condUsed.add(0);
            i = i + 1;
        }

        // Start with the smallest table
        newTables.add(tables.get(bestIdx));
        newAliases.add(aliases.get(bestIdx));
        used.set(bestIdx, 1);

        // Greedily add remaining tables, preferring smallest with a condition
        var added = 1;
        while added < tables.count() {
            var nextIdx = -1;
            var nextRows = -1;
            var nextCondIdx = -1;

            // Pass 1: find smallest unused table that has a condition to joined tables
            i = 0;
            while i < tables.count() {
                if used.get(i) == 0 {
                    var condIdx = findConditionForTable(joinConditions, condUsed,
                        tables.get(i), aliases.get(i), newTables, newAliases);
                    if condIdx >= 0 {
                        var rc = tables.get(i).rowCount();
                        if nextIdx < 0 || rc < nextRows {
                            nextIdx = i;
                            nextRows = rc;
                            nextCondIdx = condIdx;
                        }
                    }
                }
                i = i + 1;
            }

            // Pass 2: if no condition-connected table, pick smallest unused
            if nextIdx < 0 {
                i = 0;
                while i < tables.count() {
                    if used.get(i) == 0 {
                        var rc = tables.get(i).rowCount();
                        if nextIdx < 0 || rc < nextRows {
                            nextIdx = i;
                            nextRows = rc;
                        }
                    }
                    i = i + 1;
                }
            }

            if nextIdx >= 0 {
                newTables.add(tables.get(nextIdx));
                newAliases.add(aliases.get(nextIdx));
                used.set(nextIdx, 1);
                if nextCondIdx >= 0 {
                    reorderedConds.add(joinConditions.get(nextCondIdx));
                    condUsed.set(nextCondIdx, 1);
                } else {
                    // No condition — create a dummy null condition
                    reorderedConds.add(null);
                }
                added = added + 1;
            }
        }

        // Check if order actually changed
        var changed = false;
        i = 0;
        while i < tables.count() {
            if newTables.get(i) != tables.get(i) {
                changed = true;
            }
            i = i + 1;
        }

        if changed {
            // Replace tables and aliases in-place
            i = 0;
            while i < tables.count() {
                tables.set(i, newTables.get(i));
                aliases.set(i, newAliases.get(i));
                i = i + 1;
            }
        }

        return changed;
    }

    // Execute a multi-table JOIN query
    expose func executeCrossJoin(stmt: SelectStmt) -> QueryResult {
        var result = new QueryResult();
        result.init();

        // Load all tables
        var tables = new List[Table]();
        var aliases = new List[String]();
        var colOffsets = new List[Integer]();
        var totalCols = 0;

        var ti = 0;
        while ti < stmt.tableNames.count() {
            var tblName = stmt.tableNames.get(ti);
            var maybeTable = exec.findTable(tblName);
            if maybeTable == null {
                result.setError("Table '" + tblName + "' does not exist");
                return result;
            }
            var tbl = maybeTable;
            tables.add(tbl);

            var alias = stmt.tableAliases.get(ti);
            if alias == "" {
                alias = tblName;
            }
            aliases.add(alias);

            colOffsets.add(totalCols);
            totalCols = totalCols + tbl.columnCount();
            ti = ti + 1;
        }

        // Join ordering optimization: for all-INNER-JOIN queries with 3+ tables,
        // reorder tables by row count (smallest first) to minimize intermediate
        // result sizes. Only applies when ALL joins are INNER (type 1).
        var reorderedConds = new List[Expr]();
        var didReorder = false;
        if tables.count() >= 3 && stmt.joinTypes.count() >= 2 {
            var allInner = true;
            var jt = 0;
            while jt < stmt.joinTypes.count() {
                if stmt.joinTypes.get(jt) != 1 {
                    allInner = false;
                }
                jt = jt + 1;
            }
            if allInner {
                didReorder = reorderInnerJoinTables(tables, aliases,
                    stmt.joinConditions, reorderedConds);
                if didReorder {
                    // Rebuild colOffsets for reordered tables
                    colOffsets = new List[Integer]();
                    totalCols = 0;
                    ti = 0;
                    while ti < tables.count() {
                        colOffsets.add(totalCols);
                        totalCols = totalCols + tables.get(ti).columnCount();
                        ti = ti + 1;
                    }
                }
            }
        }

        // Build column names for result
        if stmt.selectAll {
            ti = 0;
            while ti < tables.count() {
                var tbl = tables.get(ti);
                var alias = aliases.get(ti);
                var c = 0;
                while c < tbl.columnCount() {
                    var maybeCol = tbl.getColumn(c);
                    if maybeCol != null {
                        var col = maybeCol;
                        result.addColumnName(alias + "." + col.name);
                    }
                    c = c + 1;
                }
                ti = ti + 1;
            }
        } else {
            var c = 0;
            while c < stmt.columns.count() {
                // Check for column alias first
                var alias = "";
                if c < stmt.columnAliases.count() {
                    alias = stmt.columnAliases.get(c);
                }
                if alias != "" {
                    result.addColumnName(alias);
                } else {
                    var colExpr = stmt.columns.get(c);
                    if colExpr.kind == EXPR_COLUMN {
                        if colExpr.tableName != "" {
                            result.addColumnName(colExpr.tableName + "." + colExpr.columnName);
                        } else {
                            result.addColumnName(colExpr.columnName);
                        }
                    } else if colExpr.kind == EXPR_FUNCTION {
                        var displayName = colExpr.funcName;
                        if displayName == "COUNT_DISTINCT" {
                            displayName = "COUNT";
                        }
                        result.addColumnName(displayName);
                    } else {
                        result.addColumnName("expr" + Fmt.Int(c));
                    }
                }
                c = c + 1;
            }
        }

        // Build cartesian product starting with first table
        var combinedRows = new List[Row]();

        if tables.count() > 0 {
            var firstTable = tables.get(0);
            var r = 0;
            while r < firstTable.rowCount() {
                var maybeRow = firstTable.getRow(r);
                if maybeRow != null {
                    var srcRow = maybeRow;
                    if srcRow.deleted == false {
                        var newRow = makeJoinRow(totalCols);
                        var c = 0;
                        while c < firstTable.columnCount() {
                            newRow.setValue(c, srcRow.getValue(c));
                            c = c + 1;
                        }
                        combinedRows.add(newRow);
                    }
                }
                r = r + 1;
            }
        }

        // Extend with each additional table
        ti = 1;
        while ti < tables.count() {
            var tbl = tables.get(ti);
            var offset = colOffsets.get(ti);
            var newCombined = new List[Row]();

            // Get join type and condition, accounting for possible reordering
            var joinType = 0;
            var hasJoinCond = false;
            var joinCond: Expr = null;

            if didReorder {
                // Reordered: all joins are INNER, conditions from reorderedConds
                joinType = 1;
                if ti - 1 < reorderedConds.count() {
                    joinCond = reorderedConds.get(ti - 1);
                    hasJoinCond = joinCond != null;
                }
            } else {
                // Original order: use stmt's join types and conditions
                if ti - 1 < stmt.joinTypes.count() {
                    joinType = stmt.joinTypes.get(ti - 1);
                }
                if ti - 1 < stmt.joinConditions.count() {
                    joinCond = stmt.joinConditions.get(ti - 1);
                    hasJoinCond = true;
                }
            }

            // Try hash join for INNER JOIN with equi-condition
            var usedHashJoin = false;
            if joinType == 1 && hasJoinCond {
                if isEquiJoin(joinCond) {
                    // Find which previously-joined table the condition references
                    var leftTableIdx = 0;
                    if ti > 1 {
                        var lti = 0;
                        while lti < ti {
                            if condReferencesTable(joinCond, tables.get(lti), aliases.get(lti)) {
                                leftTableIdx = lti;
                                lti = ti;
                            }
                            lti = lti + 1;
                        }
                    }
                    var leftTable = tables.get(leftTableIdx);
                    var hashResult = executeHashJoinStep(
                        combinedRows, tbl,
                        leftTable, aliases.get(leftTableIdx), aliases.get(ti),
                        joinCond, colOffsets, leftTableIdx, ti, totalCols, tables, aliases);
                    combinedRows = hashResult;
                    usedHashJoin = true;
                }
            }

            if usedHashJoin {
                ti = ti + 1;
            }

            if usedHashJoin == false {

            // For RIGHT/FULL JOIN: track matched right rows
            var rightMatched = new List[Integer]();
            if joinType == 3 || joinType == 4 {
                var rInit = 0;
                while rInit < tbl.rowCount() {
                    rightMatched.add(0);
                    rInit = rInit + 1;
                }
            }

            var ci = 0;
            while ci < combinedRows.count() {
                var existing = combinedRows.get(ci);
                var foundMatch = false;

                var r = 0;
                while r < tbl.rowCount() {
                    var maybeRow = tbl.getRow(r);
                    if maybeRow != null {
                        var srcRow = maybeRow;
                        if srcRow.deleted == false {
                            // Create combined row
                            var newRow = makeJoinRow(totalCols);
                            var c = 0;
                            while c < offset {
                                newRow.setValue(c, existing.getValue(c));
                                c = c + 1;
                            }
                            c = 0;
                            while c < tbl.columnCount() {
                                newRow.setValue(offset + c, srcRow.getValue(c));
                                c = c + 1;
                            }

                            // Check join condition for non-CROSS joins
                            var includeRow = true;
                            if hasJoinCond && (joinType == 1 || joinType == 2 || joinType == 3 || joinType == 4) {
                                var joinResult = evalJoinExpr(joinCond, tables, aliases, newRow, colOffsets);
                                if joinResult.intValue == 0 {
                                    includeRow = false;
                                }
                            }

                            if includeRow {
                                newCombined.add(newRow);
                                foundMatch = true;
                                if joinType == 3 || joinType == 4 {
                                    rightMatched.set(r, 1);
                                }
                            }
                        }
                    }
                    r = r + 1;
                }

                // LEFT/FULL JOIN: add NULL row if no match
                if (joinType == 2 || joinType == 4) && foundMatch == false {
                    var nullRow = makeJoinRow(totalCols);
                    var c = 0;
                    while c < offset {
                        nullRow.setValue(c, existing.getValue(c));
                        c = c + 1;
                    }
                    newCombined.add(nullRow);
                }

                ci = ci + 1;
            }

            // RIGHT/FULL JOIN: add unmatched right rows
            if joinType == 3 || joinType == 4 {
                var rCheck = 0;
                while rCheck < tbl.rowCount() {
                    if rightMatched.get(rCheck) == 0 {
                        var maybeRightRow = tbl.getRow(rCheck);
                        if maybeRightRow != null {
                            var rightRow = maybeRightRow;
                            if rightRow.deleted == false {
                                var nullRow = makeJoinRow(totalCols);
                                var c = 0;
                                while c < tbl.columnCount() {
                                    nullRow.setValue(offset + c, rightRow.getValue(c));
                                    c = c + 1;
                                }
                                newCombined.add(nullRow);
                            }
                        }
                    }
                    rCheck = rCheck + 1;
                }
            }

            combinedRows = newCombined;
            ti = ti + 1;

            } // end if usedHashJoin == false
        }

        // Apply WHERE clause
        var filteredRows = new List[Row]();
        var ri = 0;
        while ri < combinedRows.count() {
            var row = combinedRows.get(ri);
            var includeRow = true;

            if stmt.whereClause != null {
                var wc = stmt.whereClause;
                var whereResult = evalJoinExpr(wc, tables, aliases, row, colOffsets);
                if whereResult.intValue == 0 {
                    includeRow = false;
                }
            }

            if includeRow {
                filteredRows.add(row);
            }
            ri = ri + 1;
        }

        // Check for GROUP BY / aggregates on JOIN results
        var isAggregate = exec.hasAggregates(stmt);

        if isAggregate || stmt.groupByExprs.count() > 0 {
            // GROUP BY on JOIN results
            executeJoinGroupBy(stmt, filteredRows, tables, aliases, colOffsets, totalCols, result);
        } else {
            // Build result rows (regular non-aggregate query)
            ri = 0;
            while ri < filteredRows.count() {
                var combinedRow = filteredRows.get(ri);
                var resultRow = new Row();
                resultRow.init();

                if stmt.selectAll {
                    var c = 0;
                    while c < totalCols {
                        resultRow.addValue(exec.cloneValue(combinedRow.getValue(c)));
                        c = c + 1;
                    }
                } else {
                    var c = 0;
                    while c < stmt.columns.count() {
                        var colExpr = stmt.columns.get(c);
                        var val = evalJoinExpr(colExpr, tables, aliases, combinedRow, colOffsets);
                        resultRow.addValue(exec.cloneValue(val));
                        c = c + 1;
                    }
                }

                result.addRow(resultRow);
                ri = ri + 1;
            }
        }

        // Apply DISTINCT
        if stmt.isDistinct {
            exec.applyDistinct(result);
        }

        // Apply ORDER BY on JOIN results
        if stmt.orderByExprs.count() > 0 {
            sortJoinResults(result, stmt);
        }

        // Apply LIMIT/OFFSET
        if stmt.limitValue >= 0 || stmt.offsetValue > 0 {
            exec.applyLimitOffset(result, stmt.limitValue, stmt.offsetValue);
        }

        return result;
    }

    // Execute GROUP BY on JOIN results
    hide func executeJoinGroupBy(stmt: SelectStmt, filteredRows: List[Row],
                                  tables: List[Table], aliases: List[String],
                                  colOffsets: List[Integer], totalCols: Integer,
                                  result: QueryResult) {
        var groupKeys = new List[String]();
        var groupRowLists = new List[List[Row]]();

        if stmt.groupByExprs.count() > 0 {
            var i = 0;
            while i < filteredRows.count() {
                var row = filteredRows.get(i);
                var key = "";
                var g = 0;
                while g < stmt.groupByExprs.count() {
                    var groupExpr = stmt.groupByExprs.get(g);
                    var val = evalJoinExpr(groupExpr, tables, aliases, row, colOffsets);
                    if g > 0 { key = key + "|"; }
                    key = key + val.toString();
                    g = g + 1;
                }

                var groupIdx = -1;
                var k = 0;
                while k < groupKeys.count() {
                    if groupKeys.get(k) == key {
                        groupIdx = k;
                        k = groupKeys.count();
                    }
                    k = k + 1;
                }

                if groupIdx < 0 {
                    groupKeys.add(key);
                    var newList = new List[Row]();
                    newList.add(row);
                    groupRowLists.add(newList);
                } else {
                    groupRowLists.get(groupIdx).add(row);
                }
                i = i + 1;
            }
        } else {
            // No GROUP BY but has aggregates — treat all rows as one group
            groupKeys.add("");
            groupRowLists.add(filteredRows);
        }

        // Build result rows from groups
        var g = 0;
        while g < groupKeys.count() {
            var groupRows = groupRowLists.get(g);
            var resultRow = new Row();
            resultRow.init();

            var firstRow = groupRows.get(0);

            var c = 0;
            while c < stmt.columns.count() {
                var colExpr = stmt.columns.get(c);
                if exec.isAggregateExpr(colExpr) {
                    var val = evalJoinAggregate(colExpr, groupRows, tables, aliases, colOffsets);
                    resultRow.addValue(exec.cloneValue(val));
                } else {
                    var val = evalJoinExpr(colExpr, tables, aliases, firstRow, colOffsets);
                    resultRow.addValue(exec.cloneValue(val));
                }
                c = c + 1;
            }

            // Check HAVING condition
            if stmt.havingClause != null {
                var hc = stmt.havingClause;
                if evalJoinHaving(hc, groupRows, tables, aliases, colOffsets) == false {
                    g = g + 1;
                    continue;
                }
            }

            result.addRow(resultRow);
            g = g + 1;
        }
    }

    // Evaluate aggregate function over JOIN group rows
    hide func evalJoinAggregate(expr: Expr, groupRows: List[Row],
                                 tables: List[Table], aliases: List[String],
                                 colOffsets: List[Integer]) -> SqlValue {
        var funcName = String.ToUpper(expr.funcName);
        var hasArg = expr.args.count() > 0;

        // COUNT(*)
        if funcName == "COUNT" && hasArg {
            var arg0 = expr.args.get(0);
            if arg0.kind == EXPR_STAR {
                return sqlInteger(groupRows.count());
            }
        }

        // COUNT_DISTINCT
        if funcName == "COUNT_DISTINCT" && hasArg {
            var seen = new List[String]();
            var i = 0;
            while i < groupRows.count() {
                var row = groupRows.get(i);
                var val = evalJoinExpr(expr.args.get(0), tables, aliases, row, colOffsets);
                if val.kind != SQL_NULL {
                    var valStr = val.toString();
                    var found = false;
                    var k = 0;
                    while k < seen.count() {
                        if seen.get(k) == valStr { found = true; k = seen.count(); }
                        k = k + 1;
                    }
                    if found == false { seen.add(valStr); }
                }
                i = i + 1;
            }
            return sqlInteger(seen.count());
        }

        // COUNT(column)
        if funcName == "COUNT" {
            var count = 0;
            var i = 0;
            while i < groupRows.count() {
                var row = groupRows.get(i);
                if hasArg {
                    var val = evalJoinExpr(expr.args.get(0), tables, aliases, row, colOffsets);
                    if val.kind != SQL_NULL { count = count + 1; }
                }
                i = i + 1;
            }
            return sqlInteger(count);
        }

        // SUM
        if funcName == "SUM" {
            var sumInt = 0;
            var sumReal = 0.0;
            var hasValue = false;
            var hasReal = false;
            var i = 0;
            while i < groupRows.count() {
                var row = groupRows.get(i);
                if hasArg {
                    var val = evalJoinExpr(expr.args.get(0), tables, aliases, row, colOffsets);
                    if val.kind == SQL_INTEGER { sumInt = sumInt + val.intValue; hasValue = true; }
                    else if val.kind == SQL_REAL { sumReal = sumReal + val.realValue; hasValue = true; hasReal = true; }
                }
                i = i + 1;
            }
            if hasValue == false { return sqlNull(); }
            if hasReal {
                var total = sumReal + sumInt * 1.0;
                return sqlReal(total, Fmt.Num(total));
            }
            return sqlInteger(sumInt);
        }

        // AVG
        if funcName == "AVG" {
            var sumInt = 0;
            var sumReal = 0.0;
            var count = 0;
            var hasReal = false;
            var i = 0;
            while i < groupRows.count() {
                var row = groupRows.get(i);
                if hasArg {
                    var val = evalJoinExpr(expr.args.get(0), tables, aliases, row, colOffsets);
                    if val.kind == SQL_INTEGER { sumInt = sumInt + val.intValue; count = count + 1; }
                    else if val.kind == SQL_REAL { sumReal = sumReal + val.realValue; count = count + 1; hasReal = true; }
                }
                i = i + 1;
            }
            if count == 0 { return sqlNull(); }
            var total = sumReal + sumInt * 1.0;
            var avg = total / count;
            return sqlReal(avg, Fmt.Num(avg));
        }

        // MIN
        if funcName == "MIN" {
            var hasMin = false;
            var minResult = sqlNull();
            var i = 0;
            while i < groupRows.count() {
                var row = groupRows.get(i);
                if hasArg {
                    var val = evalJoinExpr(expr.args.get(0), tables, aliases, row, colOffsets);
                    if val.kind != SQL_NULL {
                        if hasMin == false { minResult = val; hasMin = true; }
                        else if val.compare(minResult) < 0 { minResult = val; }
                    }
                }
                i = i + 1;
            }
            return minResult;
        }

        // MAX
        if funcName == "MAX" {
            var hasMax = false;
            var maxResult = sqlNull();
            var i = 0;
            while i < groupRows.count() {
                var row = groupRows.get(i);
                if hasArg {
                    var val = evalJoinExpr(expr.args.get(0), tables, aliases, row, colOffsets);
                    if val.kind != SQL_NULL {
                        if hasMax == false { maxResult = val; hasMax = true; }
                        else if val.compare(maxResult) > 0 { maxResult = val; }
                    }
                }
                i = i + 1;
            }
            return maxResult;
        }

        return sqlNull();
    }

    // Evaluate HAVING expression for JOIN groups
    hide func evalJoinHaving(expr: Expr, groupRows: List[Row],
                              tables: List[Table], aliases: List[String],
                              colOffsets: List[Integer]) -> Boolean {
        if expr.kind == EXPR_BINARY {
            var left = expr.getLeft();
            var right = expr.getRight();
            var op = expr.op;

            if op == OP_AND {
                return evalJoinHaving(left, groupRows, tables, aliases, colOffsets) && evalJoinHaving(right, groupRows, tables, aliases, colOffsets);
            }
            if op == OP_OR {
                return evalJoinHaving(left, groupRows, tables, aliases, colOffsets) || evalJoinHaving(right, groupRows, tables, aliases, colOffsets);
            }

            var leftVal = evalJoinHavingValue(left, groupRows, tables, aliases, colOffsets);
            var rightVal = evalJoinHavingValue(right, groupRows, tables, aliases, colOffsets);

            var cmp = leftVal.compare(rightVal);
            if cmp == 2 { return false; }
            if op == OP_EQ { return cmp == 0; }
            if op == OP_NE { return cmp != 0; }
            if op == OP_LT { return cmp < 0; }
            if op == OP_LE { return cmp <= 0; }
            if op == OP_GT { return cmp > 0; }
            if op == OP_GE { return cmp >= 0; }
        }
        return false;
    }

    // Evaluate a value in JOIN HAVING context
    hide func evalJoinHavingValue(expr: Expr, groupRows: List[Row],
                                    tables: List[Table], aliases: List[String],
                                    colOffsets: List[Integer]) -> SqlValue {
        if expr.kind == EXPR_FUNCTION && exec.isAggregateExpr(expr) {
            return evalJoinAggregate(expr, groupRows, tables, aliases, colOffsets);
        }
        if expr.kind == EXPR_LITERAL {
            return expr.literalValue;
        }
        if expr.kind == EXPR_COLUMN && groupRows.count() > 0 {
            var firstRow = groupRows.get(0);
            return evalJoinExpr(expr, tables, aliases, firstRow, colOffsets);
        }
        return sqlNull();
    }

    // Sort JOIN results using result column name resolution
    // Compare two join result rows. Returns -1, 0, or 1.
    hide func compareJoinRows(r1: Row, r2: Row, orderExprs: List[Expr], orderDir: List[Integer], colMappings: List[Integer]) -> Integer {
        var e = 0;
        while e < orderExprs.count() {
            var isDesc = orderDir.get(e);
            var colIdx = colMappings.get(e);
            if colIdx >= 0 {
                var val1 = r1.getValue(colIdx);
                var val2 = r2.getValue(colIdx);
                var cmp = val1.compare(val2);
                if cmp == 2 {
                    if val1.kind == SQL_NULL && val2.kind != SQL_NULL {
                        if isDesc == 1 { return -1; } return 1;
                    } else if val1.kind != SQL_NULL && val2.kind == SQL_NULL {
                        if isDesc == 1 { return 1; } return -1;
                    }
                    return 0;
                }
                if cmp != 0 {
                    if isDesc == 1 { if cmp < 0 { return 1; } return -1; }
                    else { if cmp > 0 { return 1; } return -1; }
                }
            }
            e = e + 1;
        }
        return 0;
    }

    hide func sortJoinResults(result: QueryResult, stmt: SelectStmt) {
        // Pre-compute column index mappings
        var colMappings = new List[Integer]();
        var e = 0;
        while e < stmt.orderByExprs.count() {
            colMappings.add(findResultColumnIndex(result, stmt.orderByExprs.get(e)));
            e = e + 1;
        }

        var n = result.rowCount();
        if n <= 1 { return; }

        // Iterative quicksort
        var stackLo: List[Integer] = [];
        var stackHi: List[Integer] = [];
        stackLo.add(0);
        stackHi.add(n - 1);

        while stackLo.count() > 0 {
            var si = stackLo.count() - 1;
            var lo = stackLo.get(si);
            var hi = stackHi.get(si);
            stackLo.removeAt(si);
            stackHi.removeAt(si);

            if lo >= hi { continue; }

            // Median-of-three pivot
            var mid = lo + (hi - lo) / 2;
            var rowLo = result.getRow(lo);
            var rowMid = result.getRow(mid);
            var rowHi = result.getRow(hi);
            if rowLo != null && rowMid != null && rowHi != null {
                var rl = rowLo;
                var rm = rowMid;
                var rh = rowHi;
                if compareJoinRows(rl, rm, stmt.orderByExprs, stmt.orderByDir, colMappings) > 0 {
                    result.swapRows(lo, mid);
                }
                if compareJoinRows(rl, rh, stmt.orderByExprs, stmt.orderByDir, colMappings) > 0 {
                    result.swapRows(lo, hi);
                }
                if compareJoinRows(rm, rh, stmt.orderByExprs, stmt.orderByDir, colMappings) > 0 {
                    result.swapRows(mid, hi);
                }
            }

            result.swapRows(mid, hi);
            var pivotRow = result.getRow(hi);
            if pivotRow == null { continue; }
            var pivot = pivotRow;

            var i = lo;
            var j = hi - 1;
            var partitioning = true;
            while partitioning {
                while i <= j {
                    var ri = result.getRow(i);
                    if ri == null { break; }
                    var rir = ri;
                    if compareJoinRows(rir, pivot, stmt.orderByExprs, stmt.orderByDir, colMappings) >= 0 { break; }
                    i = i + 1;
                }
                while j >= i {
                    var rj = result.getRow(j);
                    if rj == null { break; }
                    var rjr = rj;
                    if compareJoinRows(rjr, pivot, stmt.orderByExprs, stmt.orderByDir, colMappings) <= 0 { break; }
                    j = j - 1;
                }
                if i >= j {
                    partitioning = false;
                } else {
                    result.swapRows(i, j);
                    i = i + 1;
                    j = j - 1;
                }
            }

            result.swapRows(i, hi);

            if i > lo + 1 { stackLo.add(lo); stackHi.add(i - 1); }
            if i + 1 < hi { stackLo.add(i + 1); stackHi.add(hi); }
        }
    }

    // Find column index in result for ORDER BY expression
    hide func findResultColumnIndex(result: QueryResult, expr: Expr) -> Integer {
        if expr.kind == EXPR_COLUMN {
            var searchName = expr.columnName;
            var searchTable = expr.tableName;

            var i = 0;
            while i < result.columnNames.count() {
                var colName = result.columnNames.get(i);

                // Try qualified match (e.g., "o.amount")
                if searchTable != "" {
                    if colName == searchTable + "." + searchName {
                        return i;
                    }
                }

                // Try exact name match
                if colName == searchName {
                    return i;
                }

                // Try suffix match (e.g., column named "orders.amount" matches "amount")
                var suffix = "." + searchName;
                var suffixLen = String.Length(suffix);
                var colLen = String.Length(colName);
                if colLen > suffixLen {
                    if String.Substring(colName, colLen - suffixLen, suffixLen) == suffix {
                        return i;
                    }
                }
                i = i + 1;
            }
        }
        if expr.kind == EXPR_FUNCTION {
            var funcName = expr.funcName;
            var i = 0;
            while i < result.columnNames.count() {
                if result.columnNames.get(i) == funcName {
                    return i;
                }
                i = i + 1;
            }
        }
        return -1;
    }
}
