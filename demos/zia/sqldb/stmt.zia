// stmt.zia â€” Statement AST Nodes
// Part of ViperSQL
//
// Defines typed AST nodes for each SQL statement kind: SelectStmt,
// InsertStmt, UpdateStmt, DeleteStmt, CreateTableStmt, and others.
// The parser produces these from the token stream; the executor
// dispatches on the statement type to execute the appropriate logic.
// Each statement carries its parsed components (table names, column
// lists, expressions, clauses) as structured fields.

module stmt;

bind "./types";
bind "./schema";
bind "./expr";

//=============================================================================
// STATEMENT KIND CONSTANTS
//=============================================================================

final STMT_CREATE_TABLE = 1;
final STMT_INSERT = 2;
final STMT_SELECT = 3;
final STMT_UPDATE = 4;
final STMT_DELETE = 5;
final STMT_DROP_TABLE = 6;

// Trigger timing constants
final TRIGGER_BEFORE = 1;
final TRIGGER_AFTER = 2;

// Trigger event constants
final TRIGGER_INSERT = 1;
final TRIGGER_UPDATE = 2;
final TRIGGER_DELETE = 3;

//=============================================================================
// CREATE TABLE STATEMENT
//=============================================================================

entity CreateTableStmt {
    expose String tableName;
    expose List[Column] columns;
    expose Boolean isTemporary;
    // Partition support (Phase 28)
    expose Integer partitionType;         // PARTITION_NONE/RANGE/LIST/HASH
    expose String partitionColumn;        // Column to partition by
    // PARTITION OF fields (child partition creation)
    expose Boolean isPartitionOf;
    expose String partitionParentName;
    expose String partRangeFrom;          // RANGE: FROM value
    expose String partRangeTo;            // RANGE: TO value
    expose List[String] partListValues;   // LIST: IN values
    expose Integer partHashModulus;       // HASH: WITH (modulus N, remainder R)
    expose Integer partHashRemainder;
    // Inheritance support (Phase 52)
    expose Boolean isInherits;            // CREATE TABLE ... INHERITS (parent)
    expose String inheritsParentName;     // Parent table name
    // Phase 65: IF NOT EXISTS
    expose Boolean ifNotExists;
    // Phase 68: composite PRIMARY KEY and named constraints
    expose List[String] compositePkColumns;
    expose List[String] tableCheckConstraints;
    expose List[String] tableCheckNames;

    expose func init() {
        tableName = "";
        columns = [];
        isTemporary = false;
        partitionType = 0;
        partitionColumn = "";
        isPartitionOf = false;
        partitionParentName = "";
        partRangeFrom = "";
        partRangeTo = "";
        partListValues = [];
        partHashModulus = 0;
        partHashRemainder = 0;
        isInherits = false;
        inheritsParentName = "";
        ifNotExists = false;
        compositePkColumns = [];
        tableCheckConstraints = [];
        tableCheckNames = [];
    }

    expose func addColumn(col: Column) {
        columns.add(col);
    }

    expose func getColumn(index: Integer) -> Column {
        return columns.get(index);
    }

    expose func columnCount() -> Integer {
        return columns.count();
    }

    expose func toString() -> String {
        var result = "CREATE TABLE " + tableName + " (\n";
        var i = 0;
        while i < columns.count() {
            if i > 0 {
                result = result + ",\n";
            }
            result = result + "  " + columns.get(i).toString();
            i = i + 1;
        }
        result = result + "\n);";
        return result;
    }
}

//=============================================================================
// INSERT STATEMENT
//=============================================================================

entity InsertStmt {
    expose String tableName;
    expose List[String] columnNames;  // Optional column list
    expose List[List[Expr]] valueRows;  // VALUES (...), (...)
    expose String selectSQL;  // For INSERT...SELECT
    expose Boolean hasSelect;  // True if INSERT...SELECT (not VALUES)
    // RETURNING clause
    expose List[Expr] returningExprs;
    expose List[String] returningAliases;
    expose Boolean hasReturning;
    // ON CONFLICT (upsert)
    expose List[String] conflictColumns;  // ON CONFLICT (col1, col2)
    expose Boolean hasOnConflict;
    expose Boolean onConflictDoNothing;   // DO NOTHING
    expose List[String] onConflictSetColumns;   // DO UPDATE SET col = val
    expose List[Expr] onConflictSetValues;
    expose Boolean hasDefaultValues;  // INSERT ... DEFAULT VALUES

    expose func init() {
        tableName = "";
        columnNames = [];
        valueRows = [];
        selectSQL = "";
        hasSelect = false;
        returningExprs = [];
        returningAliases = [];
        hasReturning = false;
        conflictColumns = [];
        hasOnConflict = false;
        onConflictDoNothing = false;
        onConflictSetColumns = [];
        onConflictSetValues = [];
        hasDefaultValues = false;
    }

    expose func addColumnName(name: String) {
        columnNames.add(name);
    }

    expose func addValueRow() {
        var row: List[Expr] = [];
        valueRows.add(row);
    }

    expose func addValue(rowIndex: Integer, val: Expr) {
        valueRows.get(rowIndex).add(val);
    }

    expose func rowCount() -> Integer {
        return valueRows.count();
    }

    expose func toString() -> String {
        var result = "INSERT INTO " + tableName;
        if columnNames.count() > 0 {
            result = result + " (";
            var i = 0;
            while i < columnNames.count() {
                if i > 0 {
                    result = result + ", ";
                }
                result = result + columnNames.get(i);
                i = i + 1;
            }
            result = result + ")";
        }
        result = result + " VALUES ";
        var r = 0;
        while r < valueRows.count() {
            if r > 0 {
                result = result + ", ";
            }
            result = result + "(";
            var row = valueRows.get(r);
            var v = 0;
            while v < row.count() {
                if v > 0 {
                    result = result + ", ";
                }
                result = result + row.get(v).toString();
                v = v + 1;
            }
            result = result + ")";
            r = r + 1;
        }
        result = result + ";";
        return result;
    }
}

//=============================================================================
// SELECT STATEMENT
//=============================================================================

entity SelectStmt {
    expose List[Expr] columns;      // SELECT columns (or * for all)
    expose List[String] columnAliases; // Column aliases (AS ...)
    expose String tableName;        // FROM table (for backwards compat)
    expose String tableAlias;       // Table alias (e.g., FROM users u)
    expose List[String] tableNames;    // Multiple tables for JOINs
    expose List[String] tableAliases;  // Aliases for each table
    expose List[Integer] joinTypes;    // 0=CROSS, 1=INNER, 2=LEFT, 3=RIGHT, 4=FULL
    expose List[Expr] joinConditions;  // ON conditions for each join (null for CROSS)
    expose Expr? whereClause;       // WHERE condition (optional)
    expose Boolean selectAll;       // True if SELECT *
    expose Boolean isDistinct;      // True if SELECT DISTINCT
    expose List[Expr] orderByExprs; // ORDER BY expressions
    expose List[Integer] orderByDir; // 0 = ASC, 1 = DESC for each ORDER BY
    expose List[Integer] orderByNulls; // 0 = default, 1 = NULLS FIRST, 2 = NULLS LAST
    expose Integer limitValue;      // LIMIT value (-1 = no limit)
    expose Integer offsetValue;     // OFFSET value (0 = no offset)
    expose List[Expr] groupByExprs; // GROUP BY expressions
    expose Expr? havingClause;      // HAVING clause (optional)
    // Derived tables (subqueries in FROM clause)
    expose String derivedTableSQL;   // SQL for the derived table
    expose String derivedTableAlias; // Alias for the derived table
    expose Boolean hasDerivedTable;  // True if FROM clause contains a subquery
    // Row-level locking (Phase 14)
    expose Integer lockMode;         // 0=none, 1=FOR SHARE, 2=FOR UPDATE
    expose Boolean lockNowait;       // True if NOWAIT specified
    expose Boolean lockSkipLocked;   // True if SKIP LOCKED specified
    // Table functions (Phase 29)
    expose Boolean hasTableFunction;
    expose List[Expr] tableFunctionArgs;
    // Table inheritance (Phase 52)
    expose Boolean onlyFlag;  // SELECT ... FROM ONLY parent (exclude children)
    // LATERAL joins (Phase 55)
    expose List[String] lateralSubquerySQL;  // Parallel to tableNames: non-empty = LATERAL subquery SQL
    // NATURAL JOIN and USING (Phase 56)
    expose List[Integer] joinNatural;       // Parallel to joinTypes: 1 = NATURAL, 0 = not
    expose List[String] joinUsingCols;      // Parallel to joinTypes: comma-separated USING columns (empty = not USING)
    // DISTINCT ON (Phase 60)
    expose List[Expr] distinctOnExprs;   // DISTINCT ON (expr1, expr2, ...) expressions
    // GROUPING SETS / ROLLUP / CUBE (Phase 59)
    // Each entry is a comma-separated list of groupByExprs indices for one grouping set.
    // Empty string = grand total (). If non-empty, overrides plain GROUP BY behavior.
    expose List[String] groupingSets;
    // Phase 69: LIMIT PERCENT and SELECT INTO
    expose Boolean isLimitPercent;     // True if LIMIT n PERCENT
    expose String selectIntoTable;     // Table name for SELECT INTO (empty = normal select)
    // Phase 70: TABLESAMPLE
    expose Integer tablesamplePercent; // -1 = no sampling, 0-100 = percentage
    // Phase 75: Named WINDOW definitions
    expose List[String] windowDefNames;  // WINDOW w1, w2, ...
    expose List[Expr] windowDefExprs;    // Corresponding window specs (EXPR_WINDOW)

    expose func init() {
        columns = [];
        columnAliases = [];
        tableName = "";
        tableAlias = "";
        tableNames = [];
        tableAliases = [];
        joinTypes = [];
        joinConditions = [];
        whereClause = null;
        selectAll = false;
        isDistinct = false;
        orderByExprs = [];
        orderByDir = [];
        orderByNulls = [];
        limitValue = -1;
        offsetValue = 0;
        groupByExprs = [];
        havingClause = null;
        derivedTableSQL = "";
        derivedTableAlias = "";
        hasDerivedTable = false;
        lockMode = 0;
        lockNowait = false;
        lockSkipLocked = false;
        hasTableFunction = false;
        tableFunctionArgs = [];
        onlyFlag = false;
        lateralSubquerySQL = [];
        joinNatural = [];
        joinUsingCols = [];
        distinctOnExprs = [];
        groupingSets = [];
        isLimitPercent = false;
        selectIntoTable = "";
        tablesamplePercent = -1;
        windowDefNames = [];
        windowDefExprs = [];
    }

    expose func addTable(name: String, alias: String) {
        tableNames.add(name);
        tableAliases.add(alias);
    }

    expose func addJoin(name: String, alias: String, joinType: Integer, condition: Expr?) {
        tableNames.add(name);
        tableAliases.add(alias);
        joinTypes.add(joinType);
        if condition != null {
            joinConditions.add(condition);
        }
    }

    expose func addGroupBy(expr: Expr) {
        groupByExprs.add(expr);
    }

    expose func addColumn(col: Expr) {
        columns.add(col);
        columnAliases.add("");
    }

    expose func addColumnWithAlias(col: Expr, alias: String) {
        columns.add(col);
        columnAliases.add(alias);
    }

    expose func addOrderBy(expr: Expr, isDesc: Integer) {
        orderByExprs.add(expr);
        orderByDir.add(isDesc);
        orderByNulls.add(0); // default
    }

    expose func addOrderByWithNulls(expr: Expr, isDesc: Integer, nullsMode: Integer) {
        orderByExprs.add(expr);
        orderByDir.add(isDesc);
        orderByNulls.add(nullsMode);
    }

    expose func toString() -> String {
        var result = "SELECT ";
        if selectAll == true {
            result = result + "* FROM " + tableName;
        } else {
            result = result + "... FROM " + tableName;
        }
        return result + ";";
    }
}

//=============================================================================
// UPDATE STATEMENT
//=============================================================================

entity UpdateStmt {
    expose String tableName;
    expose List[String] setColumns;     // Columns to update
    expose List[Expr] setValues;        // Values to set
    expose Expr? whereClause;           // WHERE condition (optional)
    // UPDATE...FROM support (Phase 4)
    expose String fromTableName;        // FROM table name
    expose String fromTableAlias;       // FROM table alias
    expose Boolean hasFrom;             // True if FROM clause present
    // RETURNING clause
    expose List[Expr] returningExprs;
    expose List[String] returningAliases;
    expose Boolean hasReturning;

    expose func init() {
        tableName = "";
        setColumns = [];
        setValues = [];
        whereClause = null;
        fromTableName = "";
        fromTableAlias = "";
        hasFrom = false;
        returningExprs = [];
        returningAliases = [];
        hasReturning = false;
    }

    expose func addSet(colName: String, val: Expr) {
        setColumns.add(colName);
        setValues.add(val);
    }

    expose func toString() -> String {
        var result = "UPDATE " + tableName + " SET ";
        var i = 0;
        while i < setColumns.count() {
            if i > 0 {
                result = result + ", ";
            }
            result = result + setColumns.get(i) + " = ";
            result = result + setValues.get(i).toString();
            i = i + 1;
        }
        if whereClause != null {
            result = result + " WHERE ...";
        }
        return result + ";";
    }
}

//=============================================================================
// DELETE STATEMENT
//=============================================================================

entity DeleteStmt {
    expose String tableName;
    expose Expr? whereClause;           // WHERE condition (optional)
    // DELETE...USING support (Phase 4)
    expose String usingTableName;       // USING table name
    expose String usingTableAlias;      // USING table alias
    expose Boolean hasUsing;            // True if USING clause present
    // RETURNING clause
    expose List[Expr] returningExprs;
    expose List[String] returningAliases;
    expose Boolean hasReturning;

    expose func init() {
        tableName = "";
        whereClause = null;
        usingTableName = "";
        usingTableAlias = "";
        hasUsing = false;
        returningExprs = [];
        returningAliases = [];
        hasReturning = false;
    }

    expose func toString() -> String {
        var result = "DELETE FROM " + tableName;
        if whereClause != null {
            result = result + " WHERE ...";
        }
        return result + ";";
    }
}

//=============================================================================
// MERGE STATEMENT (Phase 73)
//=============================================================================

entity MergeStmt {
    expose String targetTable;      // MERGE INTO target
    expose String targetAlias;      // optional alias for target
    expose String sourceTable;      // USING source
    expose String sourceAlias;      // optional alias for source
    expose Expr? onCondition;       // ON matching condition
    // WHEN MATCHED actions
    expose Boolean hasWhenMatched;
    expose Boolean whenMatchedIsDelete;  // True = DELETE, false = UPDATE SET
    expose List[String] updateColumns;   // SET column names
    expose List[Expr] updateValues;      // SET value expressions
    // WHEN NOT MATCHED action
    expose Boolean hasWhenNotMatched;
    expose List[String] insertColumns;   // INSERT column names
    expose List[Expr] insertValues;      // INSERT value expressions

    expose func init() {
        targetTable = "";
        targetAlias = "";
        sourceTable = "";
        sourceAlias = "";
        onCondition = null;
        hasWhenMatched = false;
        whenMatchedIsDelete = false;
        updateColumns = [];
        updateValues = [];
        hasWhenNotMatched = false;
        insertColumns = [];
        insertValues = [];
    }
}

//=============================================================================
// CREATE INDEX STATEMENT
//=============================================================================

entity CreateIndexStmt {
    expose String indexName;
    expose String tableName;
    expose List[String] columnNames;
    expose Boolean isUnique;
    expose Boolean ifNotExists;  // Phase 65
    expose Expr? whereClause;    // Phase 74: partial index predicate

    expose func init() {
        indexName = "";
        tableName = "";
        columnNames = [];
        isUnique = false;
        ifNotExists = false;
        whereClause = null;
    }

    expose func addColumn(colName: String) {
        columnNames.add(colName);
    }

    expose func columnCount() -> Integer {
        return columnNames.count();
    }

    expose func toString() -> String {
        var result = "";
        if isUnique {
            result = "UNIQUE ";
        }
        result = result + "CREATE INDEX " + indexName + " ON " + tableName + " (";
        var i = 0;
        while i < columnNames.count() {
            if i > 0 {
                result = result + ", ";
            }
            result = result + columnNames.get(i);
            i = i + 1;
        }
        result = result + ");";
        return result;
    }
}

//=============================================================================
// DROP INDEX STATEMENT
//=============================================================================

entity DropIndexStmt {
    expose String indexName;

    expose func init() {
        indexName = "";
    }

    expose func toString() -> String {
        return "DROP INDEX " + indexName + ";";
    }
}

//=============================================================================
// CREATE TRIGGER STATEMENT (Phase 17)
//=============================================================================

entity CreateTriggerStmt {
    expose String triggerName;
    expose Integer timing;          // TRIGGER_BEFORE or TRIGGER_AFTER
    expose Integer event;           // TRIGGER_INSERT, TRIGGER_UPDATE, TRIGGER_DELETE
    expose String tableName;
    expose Boolean forEachRow;      // FOR EACH ROW (vs FOR EACH STATEMENT)
    expose String bodySQL;          // SQL statement(s) to execute

    expose func init() {
        triggerName = "";
        timing = TRIGGER_BEFORE;
        event = TRIGGER_INSERT;
        tableName = "";
        forEachRow = true;
        bodySQL = "";
    }

    expose func timingName() -> String {
        if timing == TRIGGER_BEFORE { return "BEFORE"; }
        return "AFTER";
    }

    expose func eventName() -> String {
        if event == TRIGGER_INSERT { return "INSERT"; }
        if event == TRIGGER_UPDATE { return "UPDATE"; }
        return "DELETE";
    }

    expose func toString() -> String {
        var result = "CREATE TRIGGER " + triggerName + " " + timingName() + " " + eventName();
        result = result + " ON " + tableName;
        if forEachRow {
            result = result + " FOR EACH ROW";
        }
        result = result + " EXECUTE " + bodySQL;
        return result;
    }
}
