// database.zia â€” Database Container
// Part of ViperSQL
//
// A Database holds a collection of named tables and views. The
// DatabaseServer (server.zia) maintains one Database per named
// database (e.g., "main", user-created databases). Tables are
// stored in-memory; persistent storage is managed separately by
// the StorageEngine. Views are stored as (name, SQL) pairs and
// expanded inline by the executor at query time.

module database;

bind "./table";

//=============================================================================
// DATABASE ENTITY
//=============================================================================

entity Database {
    expose String name;
    expose List[Table] tables;
    expose List[String] viewNames;
    expose List[String] viewDefs;
    expose List[String] matViewNames;
    expose List[String] matViewDefs;

    expose func init() {
        name = "default";
        tables = [];
        viewNames = [];
        viewDefs = [];
        matViewNames = [];
        matViewDefs = [];
    }

    expose func initWithName(dbName: String) {
        name = dbName;
        tables = [];
        viewNames = [];
        viewDefs = [];
        matViewNames = [];
        matViewDefs = [];
    }

    expose func tableCount() -> Integer {
        return tables.count();
    }

    expose func getTable(index: Integer) -> Table? {
        if index < 0 || index >= tables.count() {
            return null;
        }
        return tables.get(index);
    }

    expose func findTable(tableName: String) -> Table? {
        var i = 0;
        while i < tables.count() {
            var t = tables.get(i);
            if t.name == tableName {
                return t;
            }
            i = i + 1;
        }
        return null;
    }

    expose func addTable(table: Table) {
        tables.add(table);
    }

    expose func dropTable(tableName: String) -> Boolean {
        var i = 0;
        while i < tables.count() {
            if tables.get(i).name == tableName {
                tables.removeAt(i);
                return true;
            }
            i = i + 1;
        }
        return false;
    }

    expose func addView(viewName: String, sql: String) {
        viewNames.add(viewName);
        viewDefs.add(sql);
    }

    expose func findView(viewName: String) -> String {
        var i = 0;
        while i < viewNames.count() {
            if viewNames.get(i) == viewName {
                return viewDefs.get(i);
            }
            i = i + 1;
        }
        return "";
    }

    expose func dropView(viewName: String) -> Boolean {
        var i = 0;
        while i < viewNames.count() {
            if viewNames.get(i) == viewName {
                viewNames.removeAt(i);
                viewDefs.removeAt(i);
                return true;
            }
            i = i + 1;
        }
        return false;
    }

    expose func isView(name: String) -> Boolean {
        var i = 0;
        while i < viewNames.count() {
            if viewNames.get(i) == name {
                return true;
            }
            i = i + 1;
        }
        return false;
    }

    // Materialized view management
    expose func addMatView(viewName: String, sql: String) {
        matViewNames.add(viewName);
        matViewDefs.add(sql);
    }

    expose func findMatView(viewName: String) -> String {
        var i = 0;
        while i < matViewNames.count() {
            if matViewNames.get(i) == viewName {
                return matViewDefs.get(i);
            }
            i = i + 1;
        }
        return "";
    }

    expose func dropMatView(viewName: String) -> Boolean {
        var i = 0;
        while i < matViewNames.count() {
            if matViewNames.get(i) == viewName {
                matViewNames.removeAt(i);
                matViewDefs.removeAt(i);
                return true;
            }
            i = i + 1;
        }
        return false;
    }

    expose func isMatView(name: String) -> Boolean {
        var i = 0;
        while i < matViewNames.count() {
            if matViewNames.get(i) == name {
                return true;
            }
            i = i + 1;
        }
        return false;
    }

    expose func listTables() -> String {
        var result = "";
        var i = 0;
        while i < tables.count() {
            if i > 0 {
                result = result + "\n";
            }
            result = result + tables.get(i).name;
            i = i + 1;
        }
        return result;
    }
}

// Factory function
func makeDatabase(name: String) -> Database {
    var db = new Database();
    db.initWithName(name);
    return db;
}
