module Main;

// Namespace bindings for cleaner code
bind Viper.String;
bind Viper.Terminal;
bind Viper.Fmt;
bind Viper.Time;

// Frogger - Classic Arcade Game

// ============================================
// CONFIGURATION
// ============================================
var GAME_WIDTH = 70;
var GAME_HEIGHT = 24;
var HOME_ROW = 2;
var RIVER_START = 4;
var RIVER_END = 8;
var MEDIAN_ROW = 10;
var ROAD_START = 12;
var ROAD_END = 16;
var START_ROW = 18;
var INITIAL_LIVES = 3;
var TICK_MS = 100;

// ============================================
// FROG - Player Character
// ============================================
entity Frog {
    expose Integer col;
    expose Integer row;
    expose Integer startCol;
    expose Integer startRow;
    expose Integer lives;
    expose Boolean alive;
    expose Integer score;
    expose Boolean onPlatform;
    expose Integer platformVel;

    expose func init(r: Integer, c: Integer) {
        row = r;
        col = c;
        startRow = r;
        startCol = c;
        lives = INITIAL_LIVES;
        alive = true;
        score = 0;
        onPlatform = false;
        platformVel = 0;
    }

    expose func moveUp() {
        if row > 1 {
            row = row - 1;
            score = score + 10;
        }
    }

    expose func moveDown() {
        if row < GAME_HEIGHT {
            row = row + 1;
        }
    }

    expose func moveLeft() {
        if col > 1 {
            col = col - 1;
        }
    }

    expose func moveRight() {
        if col < GAME_WIDTH {
            col = col + 1;
        }
    }

    expose func die() {
        lives = lives - 1;
        if lives <= 0 {
            alive = false;
        } else {
            self.reset();
        }
    }

    expose func reset() {
        row = startRow;
        col = startCol;
        onPlatform = false;
        platformVel = 0;
    }

    expose func addScore(pts: Integer) {
        score = score + pts;
    }

    expose func updatePlatform() {
        if onPlatform {
            col = col + platformVel;
            if col < 1 { col = 1; }
            if col > GAME_WIDTH { col = GAME_WIDTH; }
        }
    }
}

// ============================================
// VEHICLE - Cars/Trucks on Road
// ============================================
entity Vehicle {
    expose Integer col;
    expose Integer row;
    expose Integer speed;
    expose Integer dir;
    expose Integer width;
    expose String sym;

    expose func init(r: Integer, c: Integer, spd: Integer, d: Integer, w: Integer, s: String) {
        row = r;
        col = c;
        speed = spd;
        dir = d;
        width = w;
        sym = s;
    }

    expose func move() {
        col = col + (speed * dir);
        if col > GAME_WIDTH + 5 {
            col = 1 - width;
        }
        if col < (0 - width) {
            col = GAME_WIDTH + 5;
        }
    }

    expose func checkCollision(frogRow: Integer, frogCol: Integer) -> Boolean {
        if frogRow != row {
            return false;
        }
        var i = 0;
        while i < width {
            if frogCol == col + i {
                return true;
            }
            i = i + 1;
        }
        return false;
    }
}

// ============================================
// PLATFORM - Logs/Turtles in River
// ============================================
entity Platform {
    expose Integer col;
    expose Integer row;
    expose Integer speed;
    expose Integer dir;
    expose Integer width;
    expose String sym;
    expose Boolean diving;
    expose Integer diveTimer;

    expose func init(r: Integer, c: Integer, spd: Integer, d: Integer, w: Integer, s: String) {
        row = r;
        col = c;
        speed = spd;
        dir = d;
        width = w;
        sym = s;
        diving = false;
        diveTimer = 0;
    }

    expose func move() {
        col = col + (speed * dir);
        if col > GAME_WIDTH + 5 {
            col = 1 - width;
        }
        if col < (0 - width) {
            col = GAME_WIDTH + 5;
        }
        // Turtle diving
        if sym == "O" {
            diveTimer = diveTimer + 1;
            if diveTimer > 30 {
                if diving {
                    diving = false;
                } else {
                    diving = true;
                }
                diveTimer = 0;
            }
        }
    }

    expose func checkOnPlatform(frogRow: Integer, frogCol: Integer) -> Boolean {
        if frogRow != row {
            return false;
        }
        if diving {
            return false;
        }
        var i = 0;
        while i < width {
            if frogCol == col + i {
                return true;
            }
            i = i + 1;
        }
        return false;
    }

    expose func getVelocity() -> Integer {
        return speed * dir;
    }
}

// ============================================
// HOME - Goal Slots
// ============================================
entity Home {
    expose Integer col;
    expose Boolean filled;

    expose func init(c: Integer) {
        col = c;
        filled = false;
    }

    expose func fill() {
        filled = true;
    }

    expose func inRange(frogCol: Integer) -> Boolean {
        if frogCol >= col - 1 {
            if frogCol <= col + 1 {
                return true;
            }
        }
        return false;
    }
}

// ============================================
// ANSI RENDERING
// ============================================
var ESC: String;

func initRenderer() {
    ESC = Chr(27);
}

func clear() {
    Print(Concat(ESC, "[2J"));
    Print(Concat(ESC, "[H"));
}

func moveTo(r: Integer, c: Integer) {
    var seq = Concat(ESC, "[");
    seq = Concat(seq, Int(r));
    seq = Concat(seq, ";");
    seq = Concat(seq, Int(c));
    seq = Concat(seq, "H");
    Print(seq);
}

func setColor(fg: Integer) {
    var seq = Concat(ESC, "[");
    seq = Concat(seq, Int(30 + fg));
    seq = Concat(seq, "m");
    Print(seq);
}

func resetColor() {
    Print(Concat(ESC, "[0m"));
}

func hideCursor() {
    Print(Concat(ESC, "[?25l"));
}

func showCursor() {
    Print(Concat(ESC, "[?25h"));
}

func drawAt(r: Integer, c: Integer, color: Integer, text: String) {
    moveTo(r, c);
    setColor(color);
    Print(text);
    resetColor();
}

func drawLine(r: Integer, startC: Integer, endC: Integer, color: Integer, ch: String) {
    var c = startC;
    while c <= endC {
        drawAt(r, c, color, ch);
        c = c + 1;
    }
}

// ============================================
// GAME STATE Entity
// ============================================
entity GameState {
    expose Integer homesFilled;
    expose Boolean running;
    expose Boolean paused;

    expose func init() {
        homesFilled = 0;
        running = true;
        paused = false;
    }

    expose func stop() {
        running = false;
    }

    expose func togglePause() {
        if paused {
            paused = false;
        } else {
            paused = true;
        }
    }

    expose func filledHome() {
        homesFilled = homesFilled + 1;
    }
}

var frog: Frog;
var vehicles: List[Vehicle];
var platforms: List[Platform];
var homes: List[Home];
var game: GameState;

func initGame() {
    initRenderer();

    // Create game state
    game = new GameState();
    game.init();

    // Create frog
    frog = new Frog();
    frog.init(START_ROW, 35);

    // Create vehicles using typed List
    vehicles = [];
    var v1 = new Vehicle(); v1.init(12, 5, 1, 1, 4, "=");
    var v2 = new Vehicle(); v2.init(12, 35, 1, 1, 4, "=");
    var v3 = new Vehicle(); v3.init(13, 15, 1, 0-1, 6, "#");
    var v4 = new Vehicle(); v4.init(13, 50, 1, 0-1, 6, "#");
    var v5 = new Vehicle(); v5.init(14, 10, 2, 1, 4, "=");
    var v6 = new Vehicle(); v6.init(14, 45, 2, 1, 4, "=");
    var v7 = new Vehicle(); v7.init(15, 20, 1, 0-1, 6, "#");
    var v8 = new Vehicle(); v8.init(16, 8, 2, 1, 4, "=");
    var v9 = new Vehicle(); v9.init(16, 40, 2, 1, 4, "=");
    vehicles.add(v1);
    vehicles.add(v2);
    vehicles.add(v3);
    vehicles.add(v4);
    vehicles.add(v5);
    vehicles.add(v6);
    vehicles.add(v7);
    vehicles.add(v8);
    vehicles.add(v9);

    // Create platforms using typed List
    platforms = [];
    var p1 = new Platform(); p1.init(4, 5, 1, 1, 10, "=");
    var p2 = new Platform(); p2.init(4, 40, 1, 1, 10, "=");
    var p3 = new Platform(); p3.init(5, 15, 1, 0-1, 5, "O");
    var p4 = new Platform(); p4.init(5, 45, 1, 0-1, 5, "O");
    var p5 = new Platform(); p5.init(6, 10, 1, 1, 8, "=");
    var p6 = new Platform(); p6.init(6, 45, 1, 1, 8, "=");
    var p7 = new Platform(); p7.init(7, 20, 1, 0-1, 4, "O");
    var p8 = new Platform(); p8.init(7, 55, 1, 0-1, 4, "O");
    var p9 = new Platform(); p9.init(8, 12, 2, 1, 7, "=");
    var p10 = new Platform(); p10.init(8, 48, 2, 1, 7, "=");
    platforms.add(p1);
    platforms.add(p2);
    platforms.add(p3);
    platforms.add(p4);
    platforms.add(p5);
    platforms.add(p6);
    platforms.add(p7);
    platforms.add(p8);
    platforms.add(p9);
    platforms.add(p10);

    // Create homes using typed List
    homes = [];
    var h1 = new Home(); h1.init(8);
    var h2 = new Home(); h2.init(20);
    var h3 = new Home(); h3.init(32);
    var h4 = new Home(); h4.init(44);
    var h5 = new Home(); h5.init(56);
    homes.add(h1);
    homes.add(h2);
    homes.add(h3);
    homes.add(h4);
    homes.add(h5);
}

// ============================================
// UPDATE LOGIC
// ============================================
func updateVehicles() {
    var i = 0;
    var count = vehicles.size();
    while i < count {
        var v = vehicles.get(i);
        v.move();
        i = i + 1;
    }
}

func updatePlatforms() {
    var i = 0;
    var count = platforms.size();
    while i < count {
        var p = platforms.get(i);
        p.move();
        i = i + 1;
    }
}

func checkVehicleCollision() -> Boolean {
    var i = 0;
    var count = vehicles.size();
    var frogRow = frog.row;
    var frogCol = frog.col;
    while i < count {
        var v = vehicles.get(i);
        if frogRow == v.row {
            var j = 0;
            while j < v.width {
                if frogCol == v.col + j {
                    return true;
                }
                j = j + 1;
            }
        }
        i = i + 1;
    }
    return false;
}

func checkOnPlatform() -> Integer {
    var i = 0;
    var count = platforms.size();
    var frogRow = frog.row;
    var frogCol = frog.col;
    while i < count {
        var p = platforms.get(i);
        if frogRow == p.row {
            if p.diving == false {
                var j = 0;
                while j < p.width {
                    if frogCol == p.col + j {
                        return p.speed * p.dir;
                    }
                    j = j + 1;
                }
            }
        }
        i = i + 1;
    }
    return 999;  // Not on platform (sentinel)
}

func checkHomeReached() -> Boolean {
    var i = 0;
    var count = homes.size();
    var frogCol = frog.col;
    while i < count {
        var h = homes.get(i);
        // Check if frog is in home range
        if frogCol >= h.col - 1 {
            if frogCol <= h.col + 1 {
                if h.filled == false {
                    h.fill();
                    game.filledHome();
                    frog.addScore(200);
                    frog.reset();
                    return true;
                } else {
                    frog.die();
                    return false;
                }
            }
        }
        i = i + 1;
    }
    // Not in any home slot - die
    frog.die();
    return false;
}

func update() {
    if game.paused {
        return;
    }

    updateVehicles();
    updatePlatforms();

    var frogRow = frog.row;
    var frogCol = frog.col;

    // Check river
    if frogRow >= RIVER_START {
        if frogRow <= RIVER_END {
            var vel = checkOnPlatform();
            if vel == 999 {
                // Not on platform - drown
                frog.die();
                if frog.alive {
                    drawAt(12, 28, 1, "SPLASH!");
                    Viper.Time.SleepMs(800);
                }
            } else {
                frog.onPlatform = true;
                frog.platformVel = vel;
                frog.updatePlatform();
            }
        }
    }

    // Check road
    if frogRow >= ROAD_START {
        if frogRow <= ROAD_END {
            if checkVehicleCollision() {
                frog.die();
                if frog.alive {
                    drawAt(12, 28, 1, "SPLAT!");
                    Viper.Time.SleepMs(800);
                }
            }
        }
    }

    // Check home row
    if frogRow == HOME_ROW {
        checkHomeReached();
    }

    // Check win
    if game.homesFilled >= 5 {
        game.stop();
    }

    // Check death
    if frog.alive == false {
        game.stop();
    }

    // Off screen
    if frogCol < 1 {
        frog.die();
    }
    if frogCol > GAME_WIDTH {
        frog.die();
    }
}

// ============================================
// RENDERING
// ============================================
func drawGame() {
    // Header
    drawAt(1, 2, 7, "Lives:");
    drawAt(1, 8, 2, Int(frog.lives));
    drawAt(1, 25, 6, "*** FROGGER ***");
    drawAt(1, 50, 3, "Score:");
    drawAt(1, 57, 7, Int(frog.score));

    // Home row
    drawLine(HOME_ROW, 1, GAME_WIDTH, 4, "~");

    // Draw homes
    var i = 0;
    while i < 5 {
        var h = homes.get(i);
        if h.filled {
            drawAt(HOME_ROW, h.col - 1, 2, "[F]");
        } else {
            drawAt(HOME_ROW, h.col - 1, 7, "[ ]");
        }
        i = i + 1;
    }

    // River
    var row = RIVER_START;
    while row <= RIVER_END {
        drawLine(row, 1, GAME_WIDTH, 4, "~");
        row = row + 1;
    }

    // Platforms
    i = 0;
    var pcount = platforms.size();
    while i < pcount {
        var p = platforms.get(i);
        var color = 3;  // Yellow for logs
        if p.sym == "O" {
            color = 2;  // Green for turtles
        }
        if p.diving {
            color = 4;  // Blue for diving
        }
        var j = 0;
        while j < p.width {
            var drawCol = p.col + j;
            if drawCol >= 1 {
                if drawCol <= GAME_WIDTH {
                    drawAt(p.row, drawCol, color, p.sym);
                }
            }
            j = j + 1;
        }
        i = i + 1;
    }

    // Median
    drawLine(MEDIAN_ROW, 1, GAME_WIDTH, 2, "-");
    drawAt(MEDIAN_ROW, 28, 7, "SAFE ZONE");

    // Road
    row = ROAD_START;
    while row <= ROAD_END {
        drawLine(row, 1, GAME_WIDTH, 7, ".");
        row = row + 1;
    }

    // Vehicles
    i = 0;
    var vcount = vehicles.size();
    while i < vcount {
        var v = vehicles.get(i);
        var j = 0;
        while j < v.width {
            var drawCol = v.col + j;
            if drawCol >= 1 {
                if drawCol <= GAME_WIDTH {
                    drawAt(v.row, drawCol, 1, v.sym);
                }
            }
            j = j + 1;
        }
        i = i + 1;
    }

    // Start zone
    drawLine(START_ROW, 1, GAME_WIDTH, 2, "-");
    drawAt(START_ROW, 30, 7, "START");

    // Frog
    drawAt(frog.row, frog.col, 2, "@");

    // Instructions
    drawAt(20, 2, 7, "WASD=Move  P=Pause  Q=Quit  Goal: Fill all 5 homes!");

    // Pause overlay
    if game.paused {
        drawAt(12, 28, 3, "*** PAUSED ***");
        drawAt(13, 23, 7, "Press P to resume");
    }
}

// ============================================
// INPUT
// ============================================
func handleInput() {
    var key = InKey();
    var keyLen = Length(key);

    if keyLen > 0 {
        if key == "w" {
            frog.moveUp();
        }
        if key == "W" {
            frog.moveUp();
        }
        if key == "s" {
            frog.moveDown();
        }
        if key == "S" {
            frog.moveDown();
        }
        if key == "a" {
            frog.moveLeft();
        }
        if key == "A" {
            frog.moveLeft();
        }
        if key == "d" {
            frog.moveRight();
        }
        if key == "D" {
            frog.moveRight();
        }
        if key == "p" {
            game.togglePause();
        }
        if key == "P" {
            game.togglePause();
        }
        if key == "q" {
            game.stop();
        }
        if key == "Q" {
            game.stop();
        }
    }
}

// ============================================
// MAIN
// ============================================
func start() {
    Say("Starting Frogger...");

    initGame();

    clear();
    hideCursor();

    while game.running {
        drawGame();
        handleInput();
        if game.paused == false {
            update();
        }
        Viper.Time.SleepMs(TICK_MS);
    }

    showCursor();
    clear();

    // Game over screen
    if game.homesFilled >= 5 {
        Say("*** CONGRATULATIONS! YOU WIN! ***");
    } else {
        Say("*** GAME OVER ***");
    }
    Say(Concat("Final Score: ", Int(frog.score)));
    Say(Concat("Homes Filled: ", Int(game.homesFilled)));
    Say("");
    Say("Thanks for playing Frogger!");
}
