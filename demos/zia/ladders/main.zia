// main.viper - Entry point for Ladders game
// A Mr. Robot style platform/ladder climbing game
module main;

bind "./config";
bind "./colors";
bind "./player";
bind "./level";
bind "./menu";
bind "./scoreboard";

// Game state
var gameState: Integer;
var menuSelection: Integer;
var pauseSelection: Integer;
var gameOverSelection: Integer;

// Current game objects
var currentPlayer: player.Player;
var currentLevel: level.Level;
var currentLadderIndex: Integer;

// Animation and timing
var frameCount: Integer;
var lastKeyTime: Integer;

// Level score tracking
var levelStartScore: Integer;

// Initialize game
func initGame() {
    colors.initColors();
    scoreboard.initScoreboard();

    gameState = config.STATE_MENU;
    menuSelection = 0;
    pauseSelection = 0;
    gameOverSelection = 0;
    frameCount = 0;
    lastKeyTime = 0;
    currentLadderIndex = -1;

    currentPlayer = new player.Player();
    currentLevel = level.getLevel(1);

    currentPlayer.init(currentLevel.playerStartX, currentLevel.playerStartY);
    currentPlayer.setRespawn(currentLevel.playerStartX, currentLevel.playerStartY);

    levelStartScore = 0;
}

// Start a new game
func startNewGame() {
    scoreboard.resetScore();
    currentLevel = level.getLevel(1);
    currentPlayer.init(currentLevel.playerStartX, currentLevel.playerStartY);
    currentPlayer.setRespawn(currentLevel.playerStartX, currentLevel.playerStartY);
    currentPlayer.lives = config.INITIAL_LIVES;
    levelStartScore = 0;
    gameState = config.STATE_PLAYING;
}

// Load next level
func loadNextLevel() {
    var nextLevelNum = currentLevel.levelNum + 1;
    scoreboard.addLevelBonus();
    currentLevel = level.getLevel(nextLevelNum);
    scoreboard.setLevel(nextLevelNum);

    currentPlayer.x = currentLevel.playerStartX;
    currentPlayer.y = currentLevel.playerStartY;
    currentPlayer.setRespawn(currentLevel.playerStartX, currentLevel.playerStartY);
    currentPlayer.onLadder = 0;
    currentPlayer.falling = 0;
    currentLadderIndex = -1;
    levelStartScore = scoreboard.getScore();

    gameState = config.STATE_PLAYING;
}

// Handle player death
func handlePlayerDeath() {
    if currentPlayer.lives <= 0 {
        // Game over
        gameState = config.STATE_GAMEOVER;
        gameOverSelection = 0;
    } else {
        // Respawn
        currentPlayer.respawn();
        currentLadderIndex = -1;
    }
}

// Update game logic
func updateGame(canvas: Viper.Graphics.Canvas) {
    // Update player invincibility
    currentPlayer.updateInvincibility();

    // Handle input
    var movingHorizontal = 0;
    var tryClimbUp = 0;
    var tryClimbDown = 0;

    if canvas.KeyHeld(config.KEY_LEFT) != 0 {
        if currentPlayer.onLadder == 0 {
            currentPlayer.moveLeft();
            movingHorizontal = 1;
        }
    }

    if canvas.KeyHeld(config.KEY_RIGHT) != 0 {
        if currentPlayer.onLadder == 0 {
            currentPlayer.moveRight();
            movingHorizontal = 1;
        }
    }

    if canvas.KeyHeld(config.KEY_UP) != 0 {
        tryClimbUp = 1;
    }

    if canvas.KeyHeld(config.KEY_DOWN) != 0 {
        tryClimbDown = 1;
    }

    // Clamp player to screen bounds
    currentPlayer.clampToScreen();

    // Handle ladder climbing
    if currentPlayer.onLadder == 1 {
        // Already on ladder - handle climbing
        if tryClimbUp == 1 {
            currentPlayer.climbUp();
            // Check if at top of ladder
            if currentLevel.isAtLadderTop(currentLadderIndex, currentPlayer.y, currentPlayer.height) == 1 {
                // Step off ladder onto platform above
                var ladderY = currentLevel.getLadderY(currentLadderIndex);
                currentPlayer.y = ladderY - currentPlayer.height;
                currentPlayer.releaseLadder();
                currentLadderIndex = -1;
            }
        }

        if tryClimbDown == 1 {
            currentPlayer.climbDown();
            // Check if at bottom of ladder
            if currentLevel.isAtLadderBottom(currentLadderIndex, currentPlayer.y, currentPlayer.height) == 1 {
                // Step off ladder onto platform below
                currentPlayer.releaseLadder();
                currentLadderIndex = -1;
            }
        }
    } else {
        // Not on ladder - check if can grab one
        if tryClimbUp == 1 or tryClimbDown == 1 {
            var ladderIdx = currentLevel.canGrabLadder(currentPlayer.x, currentPlayer.y, currentPlayer.width, currentPlayer.height);
            if ladderIdx >= 0 {
                var ladderCenterX = currentLevel.getLadderCenterX(ladderIdx);
                currentPlayer.grabLadder(ladderCenterX);
                currentLadderIndex = ladderIdx;
            }
        }

        // Check if standing on platform
        var platformY = currentLevel.getStandingPlatformY(currentPlayer.x, currentPlayer.y, currentPlayer.width, currentPlayer.height);
        if platformY >= 0 {
            currentPlayer.landOnPlatform(platformY);
        } else {
            // Not on platform - start falling
            currentPlayer.startFalling();
        }

        // Apply gravity
        currentPlayer.applyGravity();

        // Check if fell below screen
        if currentPlayer.y > config.SCREEN_HEIGHT {
            currentPlayer.die();
            handlePlayerDeath();
            return;
        }
    }

    // Update level (enemies, collectibles)
    currentLevel.updateEnemies();
    currentLevel.updateCollectibles();

    // Check enemy collision
    if currentPlayer.invincible == 0 {
        if currentLevel.checkEnemyCollision(currentPlayer.x, currentPlayer.y, currentPlayer.width, currentPlayer.height) == 1 {
            currentPlayer.die();
            handlePlayerDeath();
            return;
        }
    }

    // Collect items
    var collectedScore = currentLevel.collectItems(currentPlayer.x, currentPlayer.y, currentPlayer.width, currentPlayer.height);
    if collectedScore > 0 {
        scoreboard.addScore(collectedScore);
    }

    // Update scoreboard
    scoreboard.setLives(currentPlayer.lives);
    scoreboard.setCollectiblesRemaining(currentLevel.getRemainingCollectibles());

    // Check exit
    if currentLevel.checkExit(currentPlayer.x, currentPlayer.y, currentPlayer.width, currentPlayer.height) == 1 {
        gameState = config.STATE_LEVELCOMPLETE;
    }
}

// Handle menu input
func handleMenuInput(canvas: Viper.Graphics.Canvas) -> Integer {
    // Debounce key presses
    frameCount = frameCount + 1;
    if frameCount - lastKeyTime < 10 {
        return 0;
    }

    if canvas.KeyHeld(config.KEY_UP) != 0 {
        menuSelection = menuSelection - 1;
        if menuSelection < 0 {
            menuSelection = 3;
        }
        lastKeyTime = frameCount;
    }

    if canvas.KeyHeld(config.KEY_DOWN) != 0 {
        menuSelection = menuSelection + 1;
        if menuSelection > 3 {
            menuSelection = 0;
        }
        lastKeyTime = frameCount;
    }

    if canvas.KeyHeld(config.KEY_ENTER) != 0 or canvas.KeyHeld(config.KEY_SPACE) != 0 {
        lastKeyTime = frameCount;
        return menuSelection + 1;  // Return 1-4 for menu items
    }

    return 0;
}

// Handle pause menu input
func handlePauseInput(canvas: Viper.Graphics.Canvas) -> Integer {
    frameCount = frameCount + 1;
    if frameCount - lastKeyTime < 10 {
        return 0;
    }

    if canvas.KeyHeld(config.KEY_UP) != 0 {
        pauseSelection = pauseSelection - 1;
        if pauseSelection < 0 {
            pauseSelection = 2;
        }
        lastKeyTime = frameCount;
    }

    if canvas.KeyHeld(config.KEY_DOWN) != 0 {
        pauseSelection = pauseSelection + 1;
        if pauseSelection > 2 {
            pauseSelection = 0;
        }
        lastKeyTime = frameCount;
    }

    if canvas.KeyHeld(config.KEY_ENTER) != 0 or canvas.KeyHeld(config.KEY_SPACE) != 0 {
        lastKeyTime = frameCount;
        return pauseSelection + 1;
    }

    // Also handle P to unpause
    if canvas.KeyHeld(config.KEY_P) != 0 {
        lastKeyTime = frameCount;
        return 1;  // Resume
    }

    return 0;
}

// Handle game over input
func handleGameOverInput(canvas: Viper.Graphics.Canvas) -> Integer {
    frameCount = frameCount + 1;
    if frameCount - lastKeyTime < 10 {
        return 0;
    }

    if canvas.KeyHeld(config.KEY_UP) != 0 {
        gameOverSelection = gameOverSelection - 1;
        if gameOverSelection < 0 {
            gameOverSelection = 1;
        }
        lastKeyTime = frameCount;
    }

    if canvas.KeyHeld(config.KEY_DOWN) != 0 {
        gameOverSelection = gameOverSelection + 1;
        if gameOverSelection > 1 {
            gameOverSelection = 0;
        }
        lastKeyTime = frameCount;
    }

    if canvas.KeyHeld(config.KEY_ENTER) != 0 or canvas.KeyHeld(config.KEY_SPACE) != 0 {
        lastKeyTime = frameCount;
        return gameOverSelection + 1;
    }

    return 0;
}

// Draw gameplay
func drawGame(canvas: Viper.Graphics.Canvas) {
    // Clear background
    canvas.Clear(colors.BACKGROUND_COLOR);

    // Draw level (platforms, ladders, collectibles, enemies)
    currentLevel.draw(canvas);

    // Draw player
    currentPlayer.draw(canvas);

    // Draw HUD
    scoreboard.drawHUD(canvas);
}

// Main entry point
func main() {
    // Create window
    var canvas = new Viper.Graphics.Canvas(config.TITLE, config.SCREEN_WIDTH, config.SCREEN_HEIGHT);

    // Initialize game
    initGame();

    // Main loop
    var running = 1;
    var showControls = 0;
    var showHighScores = 0;

    while running == 1 {
        // Poll events
        canvas.Poll();

        // Check for window close
        if canvas.ShouldClose != 0 {
            running = 0;
        }

        // Handle escape key globally
        if canvas.KeyHeld(config.KEY_ESCAPE) != 0 {
            if gameState == config.STATE_PLAYING {
                gameState = config.STATE_PAUSED;
                pauseSelection = 0;
                Viper.Time.SleepMs(200);  // Debounce
            } else if gameState == config.STATE_PAUSED {
                gameState = config.STATE_MENU;
                menuSelection = 0;
            } else if gameState == config.STATE_MENU {
                if showControls == 1 {
                    showControls = 0;
                } else if showHighScores == 1 {
                    showHighScores = 0;
                } else {
                    running = 0;
                }
            }
        }

        // State machine
        if gameState == config.STATE_MENU {
            if showControls == 1 {
                // Controls screen
                menu.drawControlsScreen(canvas);
                if canvas.KeyHeld(config.KEY_ENTER) != 0 {
                    showControls = 0;
                    Viper.Time.SleepMs(200);
                }
            } else if showHighScores == 1 {
                // High scores screen
                scoreboard.drawHighScores(canvas);
                if canvas.KeyHeld(config.KEY_ENTER) != 0 {
                    showHighScores = 0;
                    Viper.Time.SleepMs(200);
                }
            } else {
                // Main menu
                menu.drawTitleScreen(canvas, menuSelection, frameCount);

                var menuAction = handleMenuInput(canvas);
                if menuAction == 1 {
                    // Start game
                    startNewGame();
                } else if menuAction == 2 {
                    // High scores
                    showHighScores = 1;
                } else if menuAction == 3 {
                    // Controls
                    showControls = 1;
                } else if menuAction == 4 {
                    // Quit
                    running = 0;
                }
            }

        } else if gameState == config.STATE_PLAYING {
            // Handle pause
            if canvas.KeyHeld(config.KEY_P) != 0 {
                gameState = config.STATE_PAUSED;
                pauseSelection = 0;
                Viper.Time.SleepMs(200);
            } else {
                // Update and draw game
                updateGame(canvas);
                drawGame(canvas);
            }

        } else if gameState == config.STATE_PAUSED {
            // Draw game in background
            drawGame(canvas);
            // Draw pause overlay
            menu.drawPauseMenu(canvas, pauseSelection);

            var pauseAction = handlePauseInput(canvas);
            if pauseAction == 1 {
                // Resume
                gameState = config.STATE_PLAYING;
            } else if pauseAction == 2 {
                // Restart
                startNewGame();
            } else if pauseAction == 3 {
                // Quit to menu
                gameState = config.STATE_MENU;
                menuSelection = 0;
            }

        } else if gameState == config.STATE_GAMEOVER {
            // Draw game over screen
            menu.drawGameOver(canvas, scoreboard.getScore(), scoreboard.getHighScore(), scoreboard.getLevel(), gameOverSelection);

            var goAction = handleGameOverInput(canvas);
            if goAction == 1 {
                // Play again
                startNewGame();
            } else if goAction == 2 {
                // Main menu
                gameState = config.STATE_MENU;
                menuSelection = 0;
            }

        } else if gameState == config.STATE_LEVELCOMPLETE {
            // Draw level complete
            var levelScore = scoreboard.getScore() - levelStartScore;
            menu.drawLevelComplete(canvas, currentLevel.levelNum, levelScore, scoreboard.getScore() + config.SCORE_PER_LEVEL);

            // Wait for enter to continue
            if canvas.KeyHeld(config.KEY_ENTER) != 0 {
                loadNextLevel();
                Viper.Time.SleepMs(200);
            }
        }

        // Present frame
        canvas.Flip();

        // Frame timing
        Viper.Time.SleepMs(config.FRAME_TIME_MS);
        frameCount = frameCount + 1;
    }
}
