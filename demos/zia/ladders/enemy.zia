// enemy.viper - Enemy entity for Ladders game
// Enemies patrol platforms and chase the player
module enemy;

bind Viper.Graphics;

bind "./config";
bind "./colors";

// Enemy states
final ENEMY_PATROL = 0;      // Walking back and forth on platform
final ENEMY_CHASE = 1;       // Moving toward player
final ENEMY_CLIMBING = 2;    // On a ladder

// Enemy entity
entity Enemy {
    expose Integer x;           // Current x position
    expose Integer y;           // Current y position
    expose Integer width;       // Enemy width
    expose Integer height;      // Enemy height
    expose Integer state;       // Current state
    expose Integer direction;   // Movement direction
    expose Integer animFrame;   // Current animation frame
    expose Integer animTimer;   // Animation timer
    expose Integer onLadder;    // 1 if currently on a ladder
    expose Integer patrolLeft;  // Left patrol boundary
    expose Integer patrolRight; // Right patrol boundary
    expose Integer active;      // 1 if enemy is active
    expose Integer speed;       // Movement speed

    // Initialize enemy at spawn position with patrol area
    expose func init(spawnX: Integer, spawnY: Integer, left: Integer, right: Integer) {
        x = spawnX;
        y = spawnY;
        width = config.ENEMY_WIDTH;
        height = config.ENEMY_HEIGHT;
        state = ENEMY_PATROL;
        direction = config.DIR_RIGHT;
        animFrame = 0;
        animTimer = 0;
        onLadder = 0;
        patrolLeft = left;
        patrolRight = right;
        active = 1;
        speed = config.ENEMY_SPEED;
    }

    // Update enemy movement (patrol behavior)
    expose func updatePatrol() {
        if active == 0 {
            return;
        }
        if onLadder == 1 {
            return;  // Don't patrol while on ladder
        }

        // Move in current direction
        if direction == config.DIR_RIGHT {
            x = x + speed;
            if x >= patrolRight - width {
                x = patrolRight - width;
                direction = config.DIR_LEFT;
            }
        } else {
            x = x - speed;
            if x <= patrolLeft {
                x = patrolLeft;
                direction = config.DIR_RIGHT;
            }
        }

        updateAnimation();
    }

    // Update enemy to chase toward player
    expose func updateChase(playerX: Integer, playerY: Integer) {
        if active == 0 {
            return;
        }
        if onLadder == 1 {
            return;  // Different behavior on ladder
        }

        // Move toward player horizontally
        if playerX < x {
            x = x - speed;
            direction = config.DIR_LEFT;
            if x < patrolLeft {
                x = patrolLeft;
            }
        } else if playerX > x + width {
            x = x + speed;
            direction = config.DIR_RIGHT;
            if x > patrolRight - width {
                x = patrolRight - width;
            }
        }

        updateAnimation();
    }

    // Climb up
    expose func climbUp() {
        if onLadder == 1 {
            y = y - config.ENEMY_CLIMB_SPEED;
            updateAnimation();
        }
    }

    // Climb down
    expose func climbDown() {
        if onLadder == 1 {
            y = y + config.ENEMY_CLIMB_SPEED;
            updateAnimation();
        }
    }

    // Start climbing (grab ladder)
    expose func grabLadder(ladderCenterX: Integer) {
        onLadder = 1;
        state = ENEMY_CLIMBING;
        x = ladderCenterX - width / 2;
    }

    // Stop climbing (release ladder)
    expose func releaseLadder() {
        onLadder = 0;
        state = ENEMY_PATROL;
    }

    // Set standing position on platform
    expose func landOnPlatform(platformY: Integer) {
        y = platformY - height;
    }

    // Update animation frame
    expose func updateAnimation() {
        animTimer = animTimer + 1;
        if animTimer >= 10 {
            animTimer = 0;
            animFrame = animFrame + 1;
            if animFrame >= 4 {
                animFrame = 0;
            }
        }
    }

    // Check collision with rectangle
    expose func collidesWith(ox: Integer, oy: Integer, ow: Integer, oh: Integer) -> Integer {
        if active == 0 {
            return 0;
        }
        // AABB collision
        if x + width <= ox {
            return 0;
        }
        if x >= ox + ow {
            return 0;
        }
        if y + height <= oy {
            return 0;
        }
        if y >= oy + oh {
            return 0;
        }
        return 1;
    }

    // Get center X
    expose func getCenterX() -> Integer {
        return x + width / 2;
    }

    // Get center Y
    expose func getCenterY() -> Integer {
        return y + height / 2;
    }

    // Get bottom Y
    expose func getBottom() -> Integer {
        return y + height;
    }

    // Set patrol boundaries
    expose func setPatrolBounds(left: Integer, right: Integer) {
        patrolLeft = left;
        patrolRight = right;
    }

    // Draw the enemy
    expose func draw(canvas: Canvas) {
        if active == 0 {
            return;
        }

        var drawColor = colors.ENEMY_COLOR;

        // Draw body (simple rectangle)
        canvas.Box(x + 2, y + 4, width - 4, height - 4, drawColor);

        // Draw head with angry eyes
        canvas.Disc(x + width / 2, y + 4, 4, drawColor);

        // Draw eyes (white with black pupils)
        var eyeOffsetX = 0;
        if direction == config.DIR_RIGHT {
            eyeOffsetX = 1;
        } else {
            eyeOffsetX = -1;
        }
        canvas.Plot(x + width / 2 - 2 + eyeOffsetX, y + 3, colors.WHITE);
        canvas.Plot(x + width / 2 + 2 + eyeOffsetX, y + 3, colors.WHITE);

        // Draw legs based on animation frame
        if onLadder == 1 {
            // Climbing animation
            if animFrame % 2 == 0 {
                canvas.Line(x + 3, y + height - 4, x + 1, y + height, colors.darken(drawColor, 30));
                canvas.Line(x + width - 3, y + height - 4, x + width - 1, y + height - 2, colors.darken(drawColor, 30));
            } else {
                canvas.Line(x + 3, y + height - 4, x + 1, y + height - 2, colors.darken(drawColor, 30));
                canvas.Line(x + width - 3, y + height - 4, x + width - 1, y + height, colors.darken(drawColor, 30));
            }
        } else {
            // Walking animation
            if animFrame == 0 or animFrame == 2 {
                canvas.Line(x + 4, y + height - 3, x + 3, y + height, colors.darken(drawColor, 30));
                canvas.Line(x + width - 4, y + height - 3, x + width - 3, y + height, colors.darken(drawColor, 30));
            } else if animFrame == 1 {
                canvas.Line(x + 4, y + height - 3, x + 1, y + height, colors.darken(drawColor, 30));
                canvas.Line(x + width - 4, y + height - 3, x + width - 1, y + height - 2, colors.darken(drawColor, 30));
            } else {
                canvas.Line(x + 4, y + height - 3, x + 1, y + height - 2, colors.darken(drawColor, 30));
                canvas.Line(x + width - 4, y + height - 3, x + width - 1, y + height, colors.darken(drawColor, 30));
            }
        }
    }
}
