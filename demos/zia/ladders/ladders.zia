// ladders.viper - A Mr. Robot style platform/ladder climbing game
// All entities and game logic in a single file for ViperLang compatibility
module main;

bind Viper.Graphics;
bind Viper.Graphics.Color;
bind Viper.Time;
bind Viper.Fmt;

// ===========================================================================
// CONFIGURATION CONSTANTS
// ===========================================================================

final SCREEN_WIDTH = 480;
final SCREEN_HEIGHT = 640;
final TITLE = "Viper Ladders";

final TILE_SIZE = 16;
final PLAYER_WIDTH = 14;
final PLAYER_HEIGHT = 16;
final PLAYER_SPEED = 2;
final PLAYER_CLIMB_SPEED = 2;

final ENEMY_WIDTH = 14;
final ENEMY_HEIGHT = 16;
final ENEMY_SPEED = 1;

final LADDER_WIDTH = 12;
final PLATFORM_HEIGHT = 8;
final COLLECTIBLE_SIZE = 10;

final SCORE_PER_COLLECTIBLE = 100;
final SCORE_PER_LEVEL = 500;
final INITIAL_LIVES = 3;

// Key codes (from vgfx.h)
final KEY_ESCAPE = 256;
final KEY_ENTER = 257;
final KEY_LEFT = 258;
final KEY_RIGHT = 259;
final KEY_UP = 260;
final KEY_DOWN = 261;
final KEY_SPACE = 32;
final KEY_P = 80;

// Game states
final STATE_MENU = 0;
final STATE_PLAYING = 1;
final STATE_PAUSED = 2;
final STATE_GAMEOVER = 3;
final STATE_LEVELCOMPLETE = 4;

// Direction constants
final DIR_NONE = 0;
final DIR_LEFT = 1;
final DIR_RIGHT = 2;

// Player states
final PSTATE_WALKING = 0;
final PSTATE_CLIMBING = 1;
final PSTATE_FALLING = 2;
final PSTATE_DEAD = 3;

// ===========================================================================
// Y COORDINATE FLIP (Viper.Graphics has Y=0 at bottom, we use Y=0 at top)
// ===========================================================================

func flipY(y: Integer) -> Integer {
    return SCREEN_HEIGHT - y;
}

// For drawing boxes/rects, we need to flip and adjust for height
func flipBoxY(y: Integer, h: Integer) -> Integer {
    return SCREEN_HEIGHT - y - h;
}

// Canvas reference (set in main)
var _canvas: Canvas;

// Wrapper drawing functions that handle Y-flip automatically
func drawBox(x: Integer, y: Integer, w: Integer, h: Integer, color: Integer) {
    _canvas.Box(x, flipBoxY(y, h), w, h, color);
}

func drawLine(x1: Integer, y1: Integer, x2: Integer, y2: Integer, color: Integer) {
    _canvas.Line(x1, flipY(y1), x2, flipY(y2), color);
}

func drawDisc(x: Integer, y: Integer, r: Integer, color: Integer) {
    _canvas.Disc(x, flipY(y), r, color);
}

func drawText(x: Integer, y: Integer, text: String, color: Integer) {
    _canvas.Text(x, flipY(y), text, color);
}

func drawFrame(x: Integer, y: Integer, w: Integer, h: Integer, color: Integer) {
    _canvas.Frame(x, flipBoxY(y, h), w, h, color);
}

// ===========================================================================
// COLOR CONSTANTS (initialized at startup)
// ===========================================================================

var COLOR_BLACK: Integer;
var COLOR_WHITE: Integer;
var COLOR_RED: Integer;
var COLOR_GREEN: Integer;
var COLOR_YELLOW: Integer;
var COLOR_GOLD: Integer;
var COLOR_DARK_GRAY: Integer;
var COLOR_LIGHT_GRAY: Integer;
var COLOR_BACKGROUND: Integer;
var COLOR_PLATFORM: Integer;
var COLOR_LADDER: Integer;
var COLOR_PLAYER: Integer;
var COLOR_ENEMY: Integer;
var COLOR_COLLECTIBLE: Integer;
var COLOR_MENU_BG: Integer;
var COLOR_MENU_HIGHLIGHT: Integer;

func initColors() {
    COLOR_BLACK = RGB(0, 0, 0);
    COLOR_WHITE = RGB(255, 255, 255);
    COLOR_RED = RGB(255, 0, 0);
    COLOR_GREEN = RGB(0, 255, 0);
    COLOR_YELLOW = RGB(255, 255, 0);
    COLOR_GOLD = RGB(255, 215, 0);
    COLOR_DARK_GRAY = RGB(64, 64, 64);
    COLOR_LIGHT_GRAY = RGB(192, 192, 192);
    COLOR_BACKGROUND = RGB(20, 20, 40);
    COLOR_PLATFORM = RGB(100, 80, 60);
    COLOR_LADDER = RGB(180, 140, 80);
    COLOR_PLAYER = RGB(100, 200, 255);
    COLOR_ENEMY = RGB(255, 80, 80);
    COLOR_COLLECTIBLE = RGB(255, 215, 0);
    COLOR_MENU_BG = RGB(30, 30, 60);
    COLOR_MENU_HIGHLIGHT = RGB(100, 100, 200);
}

// ===========================================================================
// PLATFORM ENTITY
// ===========================================================================

entity Platform {
    expose Integer x;
    expose Integer y;
    expose Integer width;
    expose Integer height;

    expose func init(px: Integer, py: Integer, pw: Integer, ph: Integer) {
        x = px;
        y = py;
        width = pw;
        height = ph;
    }

    expose func isOnTop(px: Integer, py: Integer, pw: Integer, ph: Integer) -> Integer {
        var entityBottom = py + ph;
        if px + pw <= x { return 0; }
        if px >= x + width { return 0; }
        if entityBottom >= y and entityBottom <= y + 4 { return 1; }
        return 0;
    }

    expose func draw(canvas: Canvas) {
        drawBox(x, y, width, height, COLOR_PLATFORM);
        // Top highlight
        drawLine(x, y, x + width - 1, y, RGB(140, 120, 100));
    }
}

// ===========================================================================
// LADDER ENTITY
// ===========================================================================

entity Ladder {
    expose Integer x;
    expose Integer y;
    expose Integer height;

    expose func init(px: Integer, py: Integer, ph: Integer) {
        x = px;
        y = py;
        height = ph;
    }

    expose func getLeft() -> Integer { return x - LADDER_WIDTH / 2; }
    expose func getRight() -> Integer { return x + LADDER_WIDTH / 2; }
    expose func getBottom() -> Integer { return y + height; }

    expose func canGrab(px: Integer, py: Integer, pw: Integer, ph: Integer) -> Integer {
        var entityCenterX = px + pw / 2;
        var ladderLeft = getLeft();
        var ladderRight = getRight();
        if entityCenterX < ladderLeft or entityCenterX > ladderRight { return 0; }
        var entityBottom = py + ph;
        if entityBottom < y or py > y + height { return 0; }
        return 1;
    }

    expose func isAtTop(py: Integer, ph: Integer) -> Integer {
        var entityBottom = py + ph;
        if entityBottom <= y + 8 and entityBottom >= y - 8 { return 1; }
        return 0;
    }

    expose func isAtBottom(py: Integer, ph: Integer) -> Integer {
        var entityBottom = py + ph;
        var ladderBottom = y + height;
        if entityBottom >= ladderBottom - 8 and entityBottom <= ladderBottom + 8 { return 1; }
        return 0;
    }

    expose func draw(canvas: Canvas) {
        var left = getLeft();
        var right = getRight() - 1;
        var bottom = getBottom();
        drawLine(left, y, left, bottom, COLOR_LADDER);
        drawLine(right, y, right, bottom, COLOR_LADDER);
        var rungY = y + 6;
        while rungY < bottom {
            drawLine(left + 1, rungY, right - 1, rungY, COLOR_LADDER);
            rungY = rungY + 12;
        }
    }
}

// ===========================================================================
// COLLECTIBLE ENTITY
// ===========================================================================

entity Collectible {
    expose Integer x;
    expose Integer y;
    expose Integer collected;
    expose Integer animTimer;

    expose func init(px: Integer, py: Integer) {
        x = px;
        y = py;
        collected = 0;
        animTimer = 0;
    }

    expose func update() {
        animTimer = animTimer + 1;
        if animTimer >= 60 { animTimer = 0; }
    }

    expose func draw(canvas: Canvas) {
        if collected == 1 { return; }
        var size = COLLECTIBLE_SIZE;
        var offset = (animTimer / 10) % 3;
        drawDisc(x + size / 2, y + size / 2 - offset, size / 2, COLOR_COLLECTIBLE);
        canvas.Plot(x + 3, y + 2, COLOR_WHITE);
    }

    expose func collidesWith(px: Integer, py: Integer, pw: Integer, ph: Integer) -> Integer {
        if collected == 1 { return 0; }
        var size = COLLECTIBLE_SIZE;
        if px + pw <= x { return 0; }
        if px >= x + size { return 0; }
        if py + ph <= y { return 0; }
        if py >= y + size { return 0; }
        return 1;
    }
}

// ===========================================================================
// ENEMY ENTITY
// ===========================================================================

entity Enemy {
    expose Integer x;
    expose Integer y;
    expose Integer direction;
    expose Integer patrolLeft;
    expose Integer patrolRight;
    expose Integer animFrame;
    expose Integer active;

    expose func init(px: Integer, py: Integer, left: Integer, right: Integer) {
        x = px;
        y = py;
        direction = DIR_RIGHT;
        patrolLeft = left;
        patrolRight = right;
        animFrame = 0;
        active = 1;
    }

    expose func update() {
        if active == 0 { return; }
        if direction == DIR_RIGHT {
            x = x + ENEMY_SPEED;
            if x >= patrolRight - ENEMY_WIDTH {
                x = patrolRight - ENEMY_WIDTH;
                direction = DIR_LEFT;
            }
        } else {
            x = x - ENEMY_SPEED;
            if x <= patrolLeft {
                x = patrolLeft;
                direction = DIR_RIGHT;
            }
        }
        animFrame = animFrame + 1;
        if animFrame >= 40 { animFrame = 0; }
    }

    expose func collidesWith(px: Integer, py: Integer, pw: Integer, ph: Integer) -> Integer {
        if active == 0 { return 0; }
        if px + pw <= x { return 0; }
        if px >= x + ENEMY_WIDTH { return 0; }
        if py + ph <= y { return 0; }
        if py >= y + ENEMY_HEIGHT { return 0; }
        return 1;
    }

    expose func draw(canvas: Canvas) {
        if active == 0 { return; }
        drawBox(x + 2, y + 4, ENEMY_WIDTH - 4, ENEMY_HEIGHT - 4, COLOR_ENEMY);
        drawDisc(x + ENEMY_WIDTH / 2, y + 4, 4, COLOR_ENEMY);
        // Eyes
        var eyeX = 0;
        if direction == DIR_RIGHT { eyeX = 1; } else { eyeX = -1; }
        canvas.Plot(x + ENEMY_WIDTH / 2 - 2 + eyeX, y + 3, COLOR_WHITE);
        canvas.Plot(x + ENEMY_WIDTH / 2 + 2 + eyeX, y + 3, COLOR_WHITE);
        // Legs animation
        var legOffset = (animFrame / 10) % 2;
        if legOffset == 0 {
            drawLine(x + 4, y + ENEMY_HEIGHT - 3, x + 2, y + ENEMY_HEIGHT, COLOR_RED);
            drawLine(x + ENEMY_WIDTH - 4, y + ENEMY_HEIGHT - 3, x + ENEMY_WIDTH - 2, y + ENEMY_HEIGHT, COLOR_RED);
        } else {
            drawLine(x + 4, y + ENEMY_HEIGHT - 3, x + 6, y + ENEMY_HEIGHT, COLOR_RED);
            drawLine(x + ENEMY_WIDTH - 4, y + ENEMY_HEIGHT - 3, x + ENEMY_WIDTH - 6, y + ENEMY_HEIGHT, COLOR_RED);
        }
    }
}

// ===========================================================================
// PLAYER ENTITY
// ===========================================================================

entity Player {
    expose Integer x;
    expose Integer y;
    expose Integer state;
    expose Integer direction;
    expose Integer onLadder;
    expose Integer animFrame;
    expose Integer lives;
    expose Integer invincible;
    expose Integer respawnX;
    expose Integer respawnY;

    expose func init(sx: Integer, sy: Integer) {
        x = sx;
        y = sy;
        state = PSTATE_WALKING;
        direction = DIR_RIGHT;
        onLadder = 0;
        animFrame = 0;
        lives = INITIAL_LIVES;
        invincible = 0;
        respawnX = sx;
        respawnY = sy;
    }

    expose func setRespawn(rx: Integer, ry: Integer) {
        respawnX = rx;
        respawnY = ry;
    }

    expose func moveLeft() {
        if state == PSTATE_DEAD { return; }
        if onLadder == 0 {
            x = x - PLAYER_SPEED;
            direction = DIR_LEFT;
            updateAnim();
        }
    }

    expose func moveRight() {
        if state == PSTATE_DEAD { return; }
        if onLadder == 0 {
            x = x + PLAYER_SPEED;
            direction = DIR_RIGHT;
            updateAnim();
        }
    }

    expose func climbUp() {
        if onLadder == 1 {
            y = y - PLAYER_CLIMB_SPEED;
            updateAnim();
        }
    }

    expose func climbDown() {
        if onLadder == 1 {
            y = y + PLAYER_CLIMB_SPEED;
            updateAnim();
        }
    }

    expose func grabLadder(ladderCenterX: Integer) {
        onLadder = 1;
        state = PSTATE_CLIMBING;
        x = ladderCenterX - PLAYER_WIDTH / 2;
    }

    expose func releaseLadder() {
        onLadder = 0;
        state = PSTATE_WALKING;
    }

    expose func landOnPlatform(platformY: Integer) {
        y = platformY - PLAYER_HEIGHT;
        state = PSTATE_WALKING;
    }

    expose func startFalling() {
        if onLadder == 0 and state != PSTATE_DEAD {
            state = PSTATE_FALLING;
        }
    }

    expose func applyGravity() {
        if state == PSTATE_FALLING {
            y = y + 3;
        }
    }

    expose func updateAnim() {
        animFrame = animFrame + 1;
        if animFrame >= 32 { animFrame = 0; }
    }

    expose func die() {
        if invincible > 0 { return; }
        state = PSTATE_DEAD;
        lives = lives - 1;
    }

    expose func respawn() {
        x = respawnX;
        y = respawnY;
        state = PSTATE_WALKING;
        onLadder = 0;
        invincible = 120;
    }

    expose func updateInvincibility() {
        if invincible > 0 { invincible = invincible - 1; }
    }

    expose func clampToScreen() {
        if x < 0 { x = 0; }
        if x > SCREEN_WIDTH - PLAYER_WIDTH { x = SCREEN_WIDTH - PLAYER_WIDTH; }
    }

    expose func draw(canvas: Canvas) {
        if state == PSTATE_DEAD { return; }
        if invincible > 0 {
            if (invincible / 4) % 2 == 0 { return; }
        }
        drawBox(x + 2, y + 4, PLAYER_WIDTH - 4, PLAYER_HEIGHT - 4, COLOR_PLAYER);
        drawDisc(x + PLAYER_WIDTH / 2, y + 4, 4, COLOR_PLAYER);
        // Direction indicator
        if direction == DIR_RIGHT {
            canvas.Plot(x + PLAYER_WIDTH - 3, y + 4, COLOR_WHITE);
        } else {
            canvas.Plot(x + 2, y + 4, COLOR_WHITE);
        }
        // Legs
        var legAnim = (animFrame / 8) % 2;
        if onLadder == 1 {
            if legAnim == 0 {
                drawLine(x + 4, y + PLAYER_HEIGHT - 3, x + 2, y + PLAYER_HEIGHT, RGB(70, 150, 200));
                drawLine(x + PLAYER_WIDTH - 4, y + PLAYER_HEIGHT - 3, x + PLAYER_WIDTH - 2, y + PLAYER_HEIGHT - 2, RGB(70, 150, 200));
            } else {
                drawLine(x + 4, y + PLAYER_HEIGHT - 3, x + 2, y + PLAYER_HEIGHT - 2, RGB(70, 150, 200));
                drawLine(x + PLAYER_WIDTH - 4, y + PLAYER_HEIGHT - 3, x + PLAYER_WIDTH - 2, y + PLAYER_HEIGHT, RGB(70, 150, 200));
            }
        } else {
            drawLine(x + 4, y + PLAYER_HEIGHT - 3, x + 3, y + PLAYER_HEIGHT, RGB(70, 150, 200));
            drawLine(x + PLAYER_WIDTH - 4, y + PLAYER_HEIGHT - 3, x + PLAYER_WIDTH - 3, y + PLAYER_HEIGHT, RGB(70, 150, 200));
        }
    }
}

// ===========================================================================
// GAME STATE (using parallel arrays instead of entity lists)
// ===========================================================================

// Platforms (max 20)
final MAX_PLATFORMS = 20;
var platformX: List[Integer];
var platformY: List[Integer];
var platformW: List[Integer];
var platformH: List[Integer];
var platformCount: Integer;

// Ladders (max 15)
final MAX_LADDERS = 15;
var ladderX: List[Integer];
var ladderY: List[Integer];
var ladderH: List[Integer];
var ladderCount: Integer;

// Enemies (max 10)
final MAX_ENEMIES = 10;
var enemyX: List[Integer];
var enemyY: List[Integer];
var enemyDir: List[Integer];
var enemyLeft: List[Integer];
var enemyRight: List[Integer];
var enemyAnim: List[Integer];
var enemyActive: List[Integer];
var enemyCount: Integer;

// Collectibles (max 15)
final MAX_COLLECTIBLES = 15;
var collectX: List[Integer];
var collectY: List[Integer];
var collectCollected: List[Integer];
var collectAnim: List[Integer];
var collectCount: Integer;

// Player state
var playerX: Integer;
var playerY: Integer;
var playerState: Integer;
var playerDir: Integer;
var playerOnLadder: Integer;
var playerAnim: Integer;
var playerLives: Integer;
var playerInvincible: Integer;
var playerRespawnX: Integer;
var playerRespawnY: Integer;
var currentLadderIdx: Integer;

// Level state
var currentLevel: Integer;
var exitX: Integer;
var exitY: Integer;
var totalCollectibles: Integer;
var collectedCount: Integer;

// Game state
var gameState: Integer;
var score: Integer;
var highScore: Integer;
var menuSelection: Integer;
var pauseSelection: Integer;
var gameOverSelection: Integer;
var frameCount: Integer;
var lastKeyTime: Integer;
var levelStartScore: Integer;

// ===========================================================================
// INITIALIZATION FUNCTIONS
// ===========================================================================

func initArrays() {
    platformX = [];
    platformY = [];
    platformW = [];
    platformH = [];
    ladderX = [];
    ladderY = [];
    ladderH = [];
    enemyX = [];
    enemyY = [];
    enemyDir = [];
    enemyLeft = [];
    enemyRight = [];
    enemyAnim = [];
    enemyActive = [];
    collectX = [];
    collectY = [];
    collectCollected = [];
    collectAnim = [];
}

func clearLevel() {
    platformCount = 0;
    ladderCount = 0;
    enemyCount = 0;
    collectCount = 0;
    collectedCount = 0;

    // Clear arrays
    var i = 0;
    while i < platformX.count() {
        platformX.removeAt(0);
        platformY.removeAt(0);
        platformW.removeAt(0);
        platformH.removeAt(0);
        i = i + 1;
    }
    platformX = [];
    platformY = [];
    platformW = [];
    platformH = [];

    ladderX = [];
    ladderY = [];
    ladderH = [];

    enemyX = [];
    enemyY = [];
    enemyDir = [];
    enemyLeft = [];
    enemyRight = [];
    enemyAnim = [];
    enemyActive = [];

    collectX = [];
    collectY = [];
    collectCollected = [];
    collectAnim = [];
}

func addPlatform(x: Integer, y: Integer, w: Integer, h: Integer) {
    platformX.add(x);
    platformY.add(y);
    platformW.add(w);
    platformH.add(h);
    platformCount = platformCount + 1;
}

func addLadder(x: Integer, y: Integer, h: Integer) {
    ladderX.add(x);
    ladderY.add(y);
    ladderH.add(h);
    ladderCount = ladderCount + 1;
}

func addEnemy(x: Integer, y: Integer, left: Integer, right: Integer) {
    enemyX.add(x);
    enemyY.add(y);
    enemyDir.add(DIR_RIGHT);
    enemyLeft.add(left);
    enemyRight.add(right);
    enemyAnim.add(0);
    enemyActive.add(1);
    enemyCount = enemyCount + 1;
}

func addCollectible(x: Integer, y: Integer) {
    collectX.add(x);
    collectY.add(y);
    collectCollected.add(0);
    collectAnim.add(0);
    collectCount = collectCount + 1;
    totalCollectibles = totalCollectibles + 1;
}

// ===========================================================================
// LEVEL BUILDING
// ===========================================================================

func buildLevel1() {
    clearLevel();
    totalCollectibles = 0;

    // Ground floor
    addPlatform(0, 460, 640, 20);
    // Second floor
    addPlatform(0, 380, 200, 8);
    addPlatform(280, 380, 360, 8);
    // Third floor
    addPlatform(80, 300, 200, 8);
    addPlatform(360, 300, 200, 8);
    // Fourth floor
    addPlatform(0, 220, 180, 8);
    addPlatform(260, 220, 380, 8);
    // Top floor
    addPlatform(100, 140, 440, 8);

    // Ladders
    addLadder(180, 388, 72);
    addLadder(320, 388, 72);
    addLadder(250, 308, 72);
    addLadder(420, 308, 72);
    addLadder(150, 228, 72);
    addLadder(500, 228, 72);
    addLadder(300, 148, 72);

    // Player start
    playerRespawnX = 50;
    playerRespawnY = 444;
    exitX = 500;
    exitY = 116;

    // Collectibles
    addCollectible(100, 445);
    addCollectible(400, 445);
    addCollectible(140, 365);
    addCollectible(450, 365);
    addCollectible(300, 285);
    addCollectible(100, 205);
    addCollectible(550, 205);
    addCollectible(250, 125);

    // Enemies
    addEnemy(400, 364, 280, 640);
    addEnemy(120, 284, 80, 280);
    addEnemy(300, 204, 260, 640);
}

func buildLevel2() {
    clearLevel();
    totalCollectibles = 0;

    // Ground
    addPlatform(0, 460, 640, 20);
    // Floating platforms
    addPlatform(50, 400, 100, 8);
    addPlatform(200, 360, 100, 8);
    addPlatform(350, 320, 100, 8);
    addPlatform(500, 280, 100, 8);
    addPlatform(350, 240, 100, 8);
    addPlatform(200, 200, 100, 8);
    addPlatform(50, 160, 100, 8);
    addPlatform(200, 120, 100, 8);
    addPlatform(350, 80, 200, 8);

    // Ladders
    addLadder(130, 408, 52);
    addLadder(280, 368, 52);
    addLadder(430, 328, 52);
    addLadder(580, 288, 52);
    addLadder(430, 248, 32);
    addLadder(280, 208, 32);
    addLadder(130, 168, 32);
    addLadder(280, 128, 32);

    playerRespawnX = 60;
    playerRespawnY = 444;
    exitX = 500;
    exitY = 56;

    // Collectibles
    addCollectible(80, 385);
    addCollectible(230, 345);
    addCollectible(380, 305);
    addCollectible(530, 265);
    addCollectible(380, 225);
    addCollectible(230, 185);
    addCollectible(80, 145);
    addCollectible(230, 105);
    addCollectible(420, 65);

    // Enemies
    addEnemy(60, 384, 50, 150);
    addEnemy(360, 304, 350, 450);
    addEnemy(510, 264, 500, 600);
    addEnemy(210, 184, 200, 300);
}

func buildLevel3() {
    clearLevel();
    totalCollectibles = 0;

    // Ground
    addPlatform(0, 460, 640, 20);
    // Tower
    addPlatform(270, 400, 100, 8);
    addPlatform(270, 340, 100, 8);
    addPlatform(270, 280, 100, 8);
    addPlatform(270, 220, 100, 8);
    addPlatform(270, 160, 100, 8);
    addPlatform(270, 100, 100, 8);
    // Side platforms
    addPlatform(50, 380, 150, 8);
    addPlatform(440, 380, 150, 8);
    addPlatform(50, 300, 150, 8);
    addPlatform(440, 300, 150, 8);
    addPlatform(50, 220, 150, 8);
    addPlatform(440, 220, 150, 8);

    // Central ladders
    addLadder(320, 408, 52);
    addLadder(320, 348, 52);
    addLadder(320, 288, 52);
    addLadder(320, 228, 52);
    addLadder(320, 168, 52);
    addLadder(320, 108, 52);
    // Side ladders
    addLadder(180, 388, 72);
    addLadder(460, 388, 72);
    addLadder(180, 308, 72);
    addLadder(460, 308, 72);

    playerRespawnX = 50;
    playerRespawnY = 444;
    exitX = 300;
    exitY = 76;

    addCollectible(300, 385);
    addCollectible(100, 365);
    addCollectible(500, 365);
    addCollectible(300, 265);
    addCollectible(100, 285);
    addCollectible(500, 285);
    addCollectible(300, 205);

    addEnemy(80, 364, 50, 200);
    addEnemy(470, 364, 440, 590);
    addEnemy(280, 324, 270, 370);
    addEnemy(80, 284, 50, 200);
    addEnemy(470, 284, 440, 590);
}

func loadLevel(num: Integer) {
    if num == 1 {
        buildLevel1();
    } else if num == 2 {
        buildLevel2();
    } else if num == 3 {
        buildLevel3();
    } else {
        buildLevel1();
    }
    currentLevel = num;
}

// ===========================================================================
// COLLISION DETECTION
// ===========================================================================

func getStandingPlatformY() -> Integer {
    var i = 0;
    while i < platformCount {
        var px = platformX.get(i);
        var py = platformY.get(i);
        var pw = platformW.get(i);
        // Check if player is on top
        var playerBottom = playerY + PLAYER_HEIGHT;
        if playerX + PLAYER_WIDTH > px and playerX < px + pw {
            if playerBottom >= py and playerBottom <= py + 4 {
                return py;
            }
        }
        i = i + 1;
    }
    return -1;
}

func canGrabLadderIdx() -> Integer {
    var playerCenterX = playerX + PLAYER_WIDTH / 2;
    var i = 0;
    while i < ladderCount {
        var lx = ladderX.get(i);
        var ly = ladderY.get(i);
        var lh = ladderH.get(i);
        var left = lx - LADDER_WIDTH / 2;
        var right = lx + LADDER_WIDTH / 2;
        if playerCenterX >= left and playerCenterX <= right {
            var playerBottom = playerY + PLAYER_HEIGHT;
            if playerBottom >= ly and playerY <= ly + lh {
                return i;
            }
        }
        i = i + 1;
    }
    return -1;
}

func isAtLadderTop(idx: Integer) -> Integer {
    if idx < 0 or idx >= ladderCount { return 0; }
    var ly = ladderY.get(idx);
    var playerBottom = playerY + PLAYER_HEIGHT;
    if playerBottom <= ly + 8 and playerBottom >= ly - 8 { return 1; }
    return 0;
}

func isAtLadderBottom(idx: Integer) -> Integer {
    if idx < 0 or idx >= ladderCount { return 0; }
    var ly = ladderY.get(idx);
    var lh = ladderH.get(idx);
    var ladderBottom = ly + lh;
    var playerBottom = playerY + PLAYER_HEIGHT;
    if playerBottom >= ladderBottom - 8 and playerBottom <= ladderBottom + 8 { return 1; }
    return 0;
}

func checkEnemyCollision() -> Integer {
    var i = 0;
    while i < enemyCount {
        if enemyActive.get(i) == 1 {
            var ex = enemyX.get(i);
            var ey = enemyY.get(i);
            if playerX + PLAYER_WIDTH > ex and playerX < ex + ENEMY_WIDTH {
                if playerY + PLAYER_HEIGHT > ey and playerY < ey + ENEMY_HEIGHT {
                    return 1;
                }
            }
        }
        i = i + 1;
    }
    return 0;
}

func collectItems() -> Integer {
    var earned = 0;
    var i = 0;
    while i < collectCount {
        if collectCollected.get(i) == 0 {
            var cx = collectX.get(i);
            var cy = collectY.get(i);
            if playerX + PLAYER_WIDTH > cx and playerX < cx + COLLECTIBLE_SIZE {
                if playerY + PLAYER_HEIGHT > cy and playerY < cy + COLLECTIBLE_SIZE {
                    collectCollected.set(i, 1);
                    collectedCount = collectedCount + 1;
                    earned = earned + SCORE_PER_COLLECTIBLE;
                }
            }
        }
        i = i + 1;
    }
    return earned;
}

func checkExit() -> Integer {
    if collectedCount < totalCollectibles { return 0; }
    if playerX + PLAYER_WIDTH > exitX and playerX < exitX + 20 {
        if playerY + PLAYER_HEIGHT > exitY and playerY < exitY + 24 {
            return 1;
        }
    }
    return 0;
}

// ===========================================================================
// UPDATE FUNCTIONS
// ===========================================================================

func updateEnemies() {
    var i = 0;
    while i < enemyCount {
        if enemyActive.get(i) == 1 {
            var ex = enemyX.get(i);
            var dir = enemyDir.get(i);
            var left = enemyLeft.get(i);
            var right = enemyRight.get(i);
            var anim = enemyAnim.get(i);

            if dir == DIR_RIGHT {
                ex = ex + ENEMY_SPEED;
                if ex >= right - ENEMY_WIDTH {
                    ex = right - ENEMY_WIDTH;
                    dir = DIR_LEFT;
                }
            } else {
                ex = ex - ENEMY_SPEED;
                if ex <= left {
                    ex = left;
                    dir = DIR_RIGHT;
                }
            }

            anim = anim + 1;
            if anim >= 40 { anim = 0; }

            enemyX.set(i, ex);
            enemyDir.set(i, dir);
            enemyAnim.set(i, anim);
        }
        i = i + 1;
    }
}

func updateCollectibles() {
    var i = 0;
    while i < collectCount {
        var anim = collectAnim.get(i);
        anim = anim + 1;
        if anim >= 60 { anim = 0; }
        collectAnim.set(i, anim);
        i = i + 1;
    }
}

func initPlayer() {
    playerX = playerRespawnX;
    playerY = playerRespawnY;
    playerState = PSTATE_WALKING;
    playerDir = DIR_RIGHT;
    playerOnLadder = 0;
    playerAnim = 0;
    playerInvincible = 0;
    currentLadderIdx = -1;
}

func respawnPlayer() {
    playerX = playerRespawnX;
    playerY = playerRespawnY;
    playerState = PSTATE_WALKING;
    playerOnLadder = 0;
    playerInvincible = 120;
    currentLadderIdx = -1;
}

// ===========================================================================
// DRAWING FUNCTIONS
// ===========================================================================

func drawPlatforms(canvas: Canvas) {
    var i = 0;
    while i < platformCount {
        var px = platformX.get(i);
        var py = platformY.get(i);
        var pw = platformW.get(i);
        var ph = platformH.get(i);
        drawBox(px, py, pw, ph, COLOR_PLATFORM);
        drawLine(px, py, px + pw - 1, py, RGB(140, 120, 100));
        i = i + 1;
    }
}

func drawLadders(canvas: Canvas) {
    var i = 0;
    while i < ladderCount {
        var lx = ladderX.get(i);
        var ly = ladderY.get(i);
        var lh = ladderH.get(i);
        var left = lx - LADDER_WIDTH / 2;
        var right = lx + LADDER_WIDTH / 2 - 1;
        var bottom = ly + lh;
        drawLine(left, ly, left, bottom, COLOR_LADDER);
        drawLine(right, ly, right, bottom, COLOR_LADDER);
        var rungY = ly + 6;
        while rungY < bottom {
            drawLine(left + 1, rungY, right - 1, rungY, COLOR_LADDER);
            rungY = rungY + 12;
        }
        i = i + 1;
    }
}

func drawCollectibles(canvas: Canvas) {
    var i = 0;
    while i < collectCount {
        if collectCollected.get(i) == 0 {
            var cx = collectX.get(i);
            var cy = collectY.get(i);
            var anim = collectAnim.get(i);
            var offset = (anim / 10) % 3;
            drawDisc(cx + COLLECTIBLE_SIZE / 2, cy + COLLECTIBLE_SIZE / 2 - offset, COLLECTIBLE_SIZE / 2, COLOR_COLLECTIBLE);
            canvas.Plot(cx + 3, cy + 2, COLOR_WHITE);
        }
        i = i + 1;
    }
}

func drawEnemies(canvas: Canvas) {
    var i = 0;
    while i < enemyCount {
        if enemyActive.get(i) == 1 {
            var ex = enemyX.get(i);
            var ey = enemyY.get(i);
            var dir = enemyDir.get(i);
            var anim = enemyAnim.get(i);
            drawBox(ex + 2, ey + 4, ENEMY_WIDTH - 4, ENEMY_HEIGHT - 4, COLOR_ENEMY);
            drawDisc(ex + ENEMY_WIDTH / 2, ey + 4, 4, COLOR_ENEMY);
            var eyeX = 0;
            if dir == DIR_RIGHT { eyeX = 1; } else { eyeX = -1; }
            canvas.Plot(ex + ENEMY_WIDTH / 2 - 2 + eyeX, ey + 3, COLOR_WHITE);
            canvas.Plot(ex + ENEMY_WIDTH / 2 + 2 + eyeX, ey + 3, COLOR_WHITE);
            var legOff = (anim / 10) % 2;
            if legOff == 0 {
                drawLine(ex + 4, ey + ENEMY_HEIGHT - 3, ex + 2, ey + ENEMY_HEIGHT, COLOR_RED);
                drawLine(ex + ENEMY_WIDTH - 4, ey + ENEMY_HEIGHT - 3, ex + ENEMY_WIDTH - 2, ey + ENEMY_HEIGHT, COLOR_RED);
            } else {
                drawLine(ex + 4, ey + ENEMY_HEIGHT - 3, ex + 6, ey + ENEMY_HEIGHT, COLOR_RED);
                drawLine(ex + ENEMY_WIDTH - 4, ey + ENEMY_HEIGHT - 3, ex + ENEMY_WIDTH - 6, ey + ENEMY_HEIGHT, COLOR_RED);
            }
        }
        i = i + 1;
    }
}

func drawPlayer(canvas: Canvas) {
    if playerState == PSTATE_DEAD { return; }
    if playerInvincible > 0 {
        if (playerInvincible / 4) % 2 == 0 { return; }
    }
    drawBox(playerX + 2, playerY + 4, PLAYER_WIDTH - 4, PLAYER_HEIGHT - 4, COLOR_PLAYER);
    drawDisc(playerX + PLAYER_WIDTH / 2, playerY + 4, 4, COLOR_PLAYER);
    if playerDir == DIR_RIGHT {
        canvas.Plot(playerX + PLAYER_WIDTH - 3, playerY + 4, COLOR_WHITE);
    } else {
        canvas.Plot(playerX + 2, playerY + 4, COLOR_WHITE);
    }
    var legColor = RGB(70, 150, 200);
    drawLine(playerX + 4, playerY + PLAYER_HEIGHT - 3, playerX + 3, playerY + PLAYER_HEIGHT, legColor);
    drawLine(playerX + PLAYER_WIDTH - 4, playerY + PLAYER_HEIGHT - 3, playerX + PLAYER_WIDTH - 3, playerY + PLAYER_HEIGHT, legColor);
}

func drawExit(canvas: Canvas) {
    if collectedCount >= totalCollectibles {
        drawBox(exitX, exitY, 20, 24, COLOR_GREEN);
        drawFrame(exitX, exitY, 20, 24, RGB(100, 255, 100));
        drawDisc(exitX + 15, exitY + 12, 2, COLOR_GOLD);
    } else {
        drawBox(exitX, exitY, 20, 24, COLOR_DARK_GRAY);
        drawFrame(exitX, exitY, 20, 24, COLOR_LIGHT_GRAY);
    }
}

func drawHUD(canvas: Canvas) {
    drawText(10, 10, "SCORE: " + Int(score), COLOR_YELLOW);
    drawText(SCREEN_WIDTH / 2 - 50, 10, "HIGH: " + Int(highScore), COLOR_GOLD);
    drawText(SCREEN_WIDTH - 100, 10, "LVL: " + Int(currentLevel), COLOR_WHITE);
    drawText(10, 30, "LIVES:", COLOR_GREEN);
    var i = 0;
    while i < playerLives {
        drawDisc(80 + i * 18, 34, 5, COLOR_RED);
        i = i + 1;
    }
    var remaining = totalCollectibles - collectedCount;
    if remaining > 0 {
        drawText(SCREEN_WIDTH - 120, 30, "ITEMS: " + Int(remaining), COLOR_COLLECTIBLE);
    } else {
        drawText(SCREEN_WIDTH - 120, 30, "EXIT OPEN!", COLOR_GREEN);
    }
}

func drawGame(canvas: Canvas) {
    canvas.Clear(COLOR_BACKGROUND);
    drawPlatforms(canvas);
    drawLadders(canvas);
    drawCollectibles(canvas);
    drawExit(canvas);
    drawEnemies(canvas);
    drawPlayer(canvas);
    drawHUD(canvas);
}

// ===========================================================================
// MENU SCREENS
// ===========================================================================

func drawTitleScreen(canvas: Canvas) {
    // Background gradient
    var y = 0;
    while y < SCREEN_HEIGHT {
        var shade = 20 + y / 20;
        if shade > 60 { shade = 60; }
        drawLine(0, y, SCREEN_WIDTH, y, RGB(shade / 3, shade / 3, shade));
        y = y + 1;
    }

    // Title
    drawText(SCREEN_WIDTH / 2 - 80, 80, "LADDERS", COLOR_GOLD);
    drawText(SCREEN_WIDTH / 2 - 100, 120, "A Platform Climbing Adventure", COLOR_LIGHT_GRAY);

    // Menu items
    var menuY = 200;
    var menuX = SCREEN_WIDTH / 2 - 50;

    if menuSelection == 0 {
        drawFrame(menuX - 10, menuY - 5, 140, 25, COLOR_MENU_HIGHLIGHT);
        drawText(menuX - 25, menuY, ">", COLOR_YELLOW);
    }
    drawText(menuX, menuY, "START GAME", COLOR_WHITE);

    menuY = menuY + 40;
    if menuSelection == 1 {
        drawFrame(menuX - 10, menuY - 5, 140, 25, COLOR_MENU_HIGHLIGHT);
        drawText(menuX - 25, menuY, ">", COLOR_YELLOW);
    }
    drawText(menuX, menuY, "CONTROLS", COLOR_WHITE);

    menuY = menuY + 40;
    if menuSelection == 2 {
        drawFrame(menuX - 10, menuY - 5, 140, 25, COLOR_MENU_HIGHLIGHT);
        drawText(menuX - 25, menuY, ">", COLOR_YELLOW);
    }
    drawText(menuX, menuY, "QUIT", COLOR_WHITE);

    drawText(SCREEN_WIDTH / 2 - 80, SCREEN_HEIGHT - 30, "Viper Ladders Demo 2025", COLOR_DARK_GRAY);
}

func drawControlsScreen(canvas: Canvas) {
    drawBox(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, COLOR_MENU_BG);
    drawText(SCREEN_WIDTH / 2 - 50, 50, "CONTROLS", COLOR_GOLD);

    var y = 120;
    drawText(180, y, "LEFT/RIGHT", COLOR_WHITE);
    drawText(350, y, "Move", COLOR_LIGHT_GRAY);
    y = y + 40;
    drawText(180, y, "UP", COLOR_WHITE);
    drawText(350, y, "Climb ladder", COLOR_LIGHT_GRAY);
    y = y + 40;
    drawText(180, y, "DOWN", COLOR_WHITE);
    drawText(350, y, "Descend ladder", COLOR_LIGHT_GRAY);
    y = y + 40;
    drawText(180, y, "P", COLOR_WHITE);
    drawText(350, y, "Pause", COLOR_LIGHT_GRAY);
    y = y + 40;
    drawText(180, y, "ESC", COLOR_WHITE);
    drawText(350, y, "Quit to menu", COLOR_LIGHT_GRAY);

    drawText(SCREEN_WIDTH / 2 - 100, SCREEN_HEIGHT - 60, "Press ENTER to return", COLOR_YELLOW);
}

func drawPauseMenu(canvas: Canvas) {
    drawBox(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, COLOR_DARK_GRAY);

    var boxX = SCREEN_WIDTH / 2 - 100;
    var boxY = SCREEN_HEIGHT / 2 - 80;
    drawBox(boxX, boxY, 200, 160, COLOR_MENU_BG);
    drawFrame(boxX, boxY, 200, 160, COLOR_WHITE);

    drawText(boxX + 70, boxY + 20, "PAUSED", COLOR_YELLOW);

    var menuX = boxX + 50;
    var menuY = boxY + 60;

    if pauseSelection == 0 {
        drawText(menuX - 15, menuY, ">", COLOR_YELLOW);
    }
    drawText(menuX, menuY, "RESUME", COLOR_WHITE);

    menuY = menuY + 35;
    if pauseSelection == 1 {
        drawText(menuX - 15, menuY, ">", COLOR_YELLOW);
    }
    drawText(menuX, menuY, "RESTART", COLOR_WHITE);

    menuY = menuY + 35;
    if pauseSelection == 2 {
        drawText(menuX - 15, menuY, ">", COLOR_YELLOW);
    }
    drawText(menuX, menuY, "QUIT", COLOR_WHITE);
}

func drawGameOver(canvas: Canvas) {
    drawBox(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, COLOR_DARK_GRAY);

    var boxX = SCREEN_WIDTH / 2 - 120;
    var boxY = SCREEN_HEIGHT / 2 - 100;
    drawBox(boxX, boxY, 240, 200, COLOR_MENU_BG);
    drawFrame(boxX, boxY, 240, 200, COLOR_RED);

    drawText(boxX + 70, boxY + 20, "GAME OVER", COLOR_RED);
    drawText(boxX + 30, boxY + 60, "Score: " + Int(score), COLOR_YELLOW);
    drawText(boxX + 30, boxY + 80, "Level: " + Int(currentLevel), COLOR_WHITE);
    drawText(boxX + 30, boxY + 100, "High: " + Int(highScore), COLOR_GOLD);

    var menuX = boxX + 60;
    var menuY = boxY + 140;

    if gameOverSelection == 0 {
        drawText(menuX - 15, menuY, ">", COLOR_YELLOW);
    }
    drawText(menuX, menuY, "PLAY AGAIN", COLOR_WHITE);

    menuY = menuY + 30;
    if gameOverSelection == 1 {
        drawText(menuX - 15, menuY, ">", COLOR_YELLOW);
    }
    drawText(menuX, menuY, "MAIN MENU", COLOR_WHITE);
}

func drawLevelComplete(canvas: Canvas) {
    drawBox(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, RGB(0, 50, 0));

    var boxX = SCREEN_WIDTH / 2 - 120;
    var boxY = SCREEN_HEIGHT / 2 - 80;
    drawBox(boxX, boxY, 240, 160, COLOR_MENU_BG);
    drawFrame(boxX, boxY, 240, 160, COLOR_GREEN);

    drawText(boxX + 30, boxY + 20, "LEVEL " + Int(currentLevel) + " COMPLETE!", COLOR_GREEN);

    var levelScore = score - levelStartScore;
    drawText(boxX + 30, boxY + 60, "Level Score: " + Int(levelScore), COLOR_YELLOW);
    drawText(boxX + 30, boxY + 80, "Bonus: " + Int(SCORE_PER_LEVEL), COLOR_GOLD);
    drawText(boxX + 30, boxY + 100, "Total: " + Int(score + SCORE_PER_LEVEL), COLOR_WHITE);

    drawText(boxX + 40, boxY + 130, "Press ENTER to continue", COLOR_LIGHT_GRAY);
}

// ===========================================================================
// GAME LOGIC
// ===========================================================================

func startNewGame() {
    score = 0;
    playerLives = INITIAL_LIVES;
    loadLevel(1);
    initPlayer();
    levelStartScore = 0;
    gameState = STATE_PLAYING;
}

func loadNextLevel() {
    score = score + SCORE_PER_LEVEL;
    if score > highScore { highScore = score; }
    var nextLevel = currentLevel + 1;
    if nextLevel > 3 { nextLevel = 1; }
    loadLevel(nextLevel);
    initPlayer();
    levelStartScore = score;
    gameState = STATE_PLAYING;
}

func handlePlayerDeath() {
    if playerLives <= 0 {
        gameState = STATE_GAMEOVER;
        gameOverSelection = 0;
        if score > highScore { highScore = score; }
    } else {
        respawnPlayer();
    }
}

func updateGameplay(canvas: Canvas) {
    // Update invincibility
    if playerInvincible > 0 { playerInvincible = playerInvincible - 1; }

    // Input
    var tryUp = 0;
    var tryDown = 0;

    if canvas.KeyHeld(KEY_LEFT) != 0 {
        if playerOnLadder == 0 {
            playerX = playerX - PLAYER_SPEED;
            playerDir = DIR_LEFT;
            playerAnim = playerAnim + 1;
        }
    }
    if canvas.KeyHeld(KEY_RIGHT) != 0 {
        if playerOnLadder == 0 {
            playerX = playerX + PLAYER_SPEED;
            playerDir = DIR_RIGHT;
            playerAnim = playerAnim + 1;
        }
    }
    if canvas.KeyHeld(KEY_UP) != 0 { tryUp = 1; }
    if canvas.KeyHeld(KEY_DOWN) != 0 { tryDown = 1; }

    // Clamp to screen
    if playerX < 0 { playerX = 0; }
    if playerX > SCREEN_WIDTH - PLAYER_WIDTH { playerX = SCREEN_WIDTH - PLAYER_WIDTH; }

    // Ladder logic
    if playerOnLadder == 1 {
        if tryUp == 1 {
            playerY = playerY - PLAYER_CLIMB_SPEED;
            playerAnim = playerAnim + 1;
            if isAtLadderTop(currentLadderIdx) == 1 {
                var ly = ladderY.get(currentLadderIdx);
                playerY = ly - PLAYER_HEIGHT;
                playerOnLadder = 0;
                playerState = PSTATE_WALKING;
                currentLadderIdx = -1;
            }
        }
        if tryDown == 1 {
            playerY = playerY + PLAYER_CLIMB_SPEED;
            playerAnim = playerAnim + 1;
            if isAtLadderBottom(currentLadderIdx) == 1 {
                playerOnLadder = 0;
                playerState = PSTATE_WALKING;
                currentLadderIdx = -1;
            }
        }
    } else {
        // Try to grab ladder
        if tryUp == 1 or tryDown == 1 {
            var ladderIdx = canGrabLadderIdx();
            if ladderIdx >= 0 {
                var lx = ladderX.get(ladderIdx);
                playerOnLadder = 1;
                playerState = PSTATE_CLIMBING;
                playerX = lx - PLAYER_WIDTH / 2;
                currentLadderIdx = ladderIdx;
            }
        }

        // Gravity and platform
        var platformY = getStandingPlatformY();
        if platformY >= 0 {
            playerY = platformY - PLAYER_HEIGHT;
            playerState = PSTATE_WALKING;
        } else {
            playerState = PSTATE_FALLING;
            playerY = playerY + 3;
        }

        // Fell off screen
        if playerY > SCREEN_HEIGHT {
            playerState = PSTATE_DEAD;
            playerLives = playerLives - 1;
            handlePlayerDeath();
            return;
        }
    }

    // Update level
    updateEnemies();
    updateCollectibles();

    // Enemy collision
    if playerInvincible == 0 {
        if checkEnemyCollision() == 1 {
            playerState = PSTATE_DEAD;
            playerLives = playerLives - 1;
            handlePlayerDeath();
            return;
        }
    }

    // Collect items
    var earned = collectItems();
    if earned > 0 {
        score = score + earned;
        if score > highScore { highScore = score; }
    }

    // Check exit
    if checkExit() == 1 {
        gameState = STATE_LEVELCOMPLETE;
    }
}

// ===========================================================================
// MAIN ENTRY POINT
// ===========================================================================

func main() {
    var canvas = new Canvas(TITLE, SCREEN_WIDTH, SCREEN_HEIGHT);
    _canvas = canvas;

    initColors();
    initArrays();

    gameState = STATE_MENU;
    menuSelection = 0;
    pauseSelection = 0;
    gameOverSelection = 0;
    frameCount = 0;
    lastKeyTime = 0;
    score = 0;
    highScore = 0;

    var running = 1;
    var showControls = 0;

    while running == 1 {
        canvas.Poll();

        if canvas.ShouldClose != 0 { running = 0; }

        // State machine
        if gameState == STATE_MENU {
            if showControls == 1 {
                drawControlsScreen(canvas);
                if canvas.KeyHeld(KEY_ENTER) != 0 {
                    showControls = 0;
                    Viper.Time.SleepMs(200);
                }
            } else {
                drawTitleScreen(canvas);

                // Menu navigation
                if canvas.KeyHeld(KEY_UP) != 0 and frameCount - lastKeyTime > 10 {
                    menuSelection = menuSelection - 1;
                    if menuSelection < 0 { menuSelection = 2; }
                    lastKeyTime = frameCount;
                }
                if canvas.KeyHeld(KEY_DOWN) != 0 and frameCount - lastKeyTime > 10 {
                    menuSelection = menuSelection + 1;
                    if menuSelection > 2 { menuSelection = 0; }
                    lastKeyTime = frameCount;
                }
                if canvas.KeyHeld(KEY_ENTER) != 0 or canvas.KeyHeld(KEY_SPACE) != 0 {
                    if menuSelection == 0 {
                        startNewGame();
                    } else if menuSelection == 1 {
                        showControls = 1;
                    } else if menuSelection == 2 {
                        running = 0;
                    }
                    Viper.Time.SleepMs(200);
                }
            }

        } else if gameState == STATE_PLAYING {
            if canvas.KeyHeld(KEY_P) != 0 {
                gameState = STATE_PAUSED;
                pauseSelection = 0;
                Viper.Time.SleepMs(200);
            } else if canvas.KeyHeld(KEY_ESCAPE) != 0 {
                gameState = STATE_PAUSED;
                pauseSelection = 0;
                Viper.Time.SleepMs(200);
            } else {
                updateGameplay(canvas);
                drawGame(canvas);
            }

        } else if gameState == STATE_PAUSED {
            drawGame(canvas);
            drawPauseMenu(canvas);

            if canvas.KeyHeld(KEY_UP) != 0 and frameCount - lastKeyTime > 10 {
                pauseSelection = pauseSelection - 1;
                if pauseSelection < 0 { pauseSelection = 2; }
                lastKeyTime = frameCount;
            }
            if canvas.KeyHeld(KEY_DOWN) != 0 and frameCount - lastKeyTime > 10 {
                pauseSelection = pauseSelection + 1;
                if pauseSelection > 2 { pauseSelection = 0; }
                lastKeyTime = frameCount;
            }
            if canvas.KeyHeld(KEY_ENTER) != 0 or canvas.KeyHeld(KEY_SPACE) != 0 {
                if pauseSelection == 0 {
                    gameState = STATE_PLAYING;
                } else if pauseSelection == 1 {
                    startNewGame();
                } else if pauseSelection == 2 {
                    gameState = STATE_MENU;
                    menuSelection = 0;
                }
                Viper.Time.SleepMs(200);
            }
            if canvas.KeyHeld(KEY_P) != 0 {
                gameState = STATE_PLAYING;
                Viper.Time.SleepMs(200);
            }

        } else if gameState == STATE_GAMEOVER {
            drawGameOver(canvas);

            if canvas.KeyHeld(KEY_UP) != 0 and frameCount - lastKeyTime > 10 {
                gameOverSelection = gameOverSelection - 1;
                if gameOverSelection < 0 { gameOverSelection = 1; }
                lastKeyTime = frameCount;
            }
            if canvas.KeyHeld(KEY_DOWN) != 0 and frameCount - lastKeyTime > 10 {
                gameOverSelection = gameOverSelection + 1;
                if gameOverSelection > 1 { gameOverSelection = 0; }
                lastKeyTime = frameCount;
            }
            if canvas.KeyHeld(KEY_ENTER) != 0 or canvas.KeyHeld(KEY_SPACE) != 0 {
                if gameOverSelection == 0 {
                    startNewGame();
                } else {
                    gameState = STATE_MENU;
                    menuSelection = 0;
                }
                Viper.Time.SleepMs(200);
            }

        } else if gameState == STATE_LEVELCOMPLETE {
            drawLevelComplete(canvas);
            if canvas.KeyHeld(KEY_ENTER) != 0 {
                loadNextLevel();
                Viper.Time.SleepMs(200);
            }
        }

        // TEST: Direct canvas text call to compare with wrapper
        canvas.Text(10, 460, "DIRECT TEST", COLOR_WHITE);

        canvas.Flip();
        Viper.Time.SleepMs(16);
        frameCount = frameCount + 1;
    }
}
