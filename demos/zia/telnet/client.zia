// Telnet Client - A simple telnet client
// Connects to a telnet server and provides interactive session
module main;

bind Viper.Terminal;
bind Viper.Network;
bind Viper.String;
bind Viper.Time;

// ============================================================================
// CONFIGURATION
// ============================================================================

final DEFAULT_HOST = "127.0.0.1";
final DEFAULT_PORT = 2323;
final MAX_BUFFER = 4096;
final VERSION = "1.0.0";

// ============================================================================
// MAIN CLIENT (Functional API style)
// ============================================================================

func main() {
    Terminal.Say("Viper Telnet Client v" + VERSION);
    Terminal.Say("================================");
    Terminal.Say("");

    var host = DEFAULT_HOST;
    var port = DEFAULT_PORT;

    Terminal.Print("Connecting to ");
    Terminal.Print(host);
    Terminal.Print(":");
    Terminal.PrintInt(port);
    Terminal.Say("...");

    // Connect to server
    var connection = Network.Tcp.Connect(host, port);

    if Network.Tcp.get_IsOpen(connection) == false {
        Terminal.Say("Failed to connect.");
        return;
    }

    Terminal.Say("Connected!");
    Terminal.Say("");

    // Give server time to send banner
    Time.SleepMs(100);

    // Read and display initial welcome message
    var welcome = receiveResponse(connection);
    Terminal.Print(welcome);

    // Interactive loop
    var connected = 1;
    while connected == 1 {
        // Check if connection is still open
        if Network.Tcp.get_IsOpen(connection) == false {
            Terminal.Say("");
            Terminal.Say("Connection closed by server.");
            connected = 0;
            break;
        }

        // Read user input
        var input = Terminal.ReadLine() ?? "";

        // Check for local exit command
        if input == "quit" || input == "exit" {
            sendCommand(connection, input);
            Time.SleepMs(100);
            var goodbye = readAvailable(connection);
            Terminal.Print(goodbye);
            connected = 0;
            break;
        }

        // Send command to server
        sendCommand(connection, input);

        // Read and display response
        var response = receiveResponse(connection);
        Terminal.Print(response);
    }

    // Clean up
    if Network.Tcp.get_IsOpen(connection) == true {
        Network.Tcp.Close(connection);
    }

    Terminal.Say("");
    Terminal.Say("Disconnected.");
}

// Send a command to the server
func sendCommand(conn: Ptr, cmd: String) {
    Network.Tcp.SendStr(conn, cmd + "\n");
}

// Receive response from server (read until prompt or timeout)
func receiveResponse(conn: Ptr) -> String {
    var response = "";
    var reading = 1;

    // Set a short timeout for reading
    Network.Tcp.SetRecvTimeout(conn, 100);

    while reading == 1 {
        // Check if there's data available
        var available = Network.Tcp.get_Available(conn);
        if available > 0 {
            var chunk = Network.Tcp.RecvStr(conn, MAX_BUFFER);
            response = response + chunk;

            // Check if we've received a prompt (ends with "$ ")
            if String.EndsWith(response, "$ ") == true {
                reading = 0;
            }
        } else {
            // Small delay before checking again
            Time.SleepMs(10);

            // If we have some response and no more data, we're done
            var respLen = String.Length(response);
            available = Network.Tcp.get_Available(conn);
            if respLen > 0 && available == 0 {
                reading = 0;
            }
        }
    }

    // Reset timeout
    Network.Tcp.SetRecvTimeout(conn, 0);

    return response;
}

// Read all available data (non-blocking style)
func readAvailable(conn: Ptr) -> String {
    var result = "";
    Network.Tcp.SetRecvTimeout(conn, 50);

    var available = Network.Tcp.get_Available(conn);
    while available > 0 {
        var chunk = Network.Tcp.RecvStr(conn, 1024);
        result = result + chunk;
        available = Network.Tcp.get_Available(conn);
    }

    return result;
}
