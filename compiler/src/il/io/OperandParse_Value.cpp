//===----------------------------------------------------------------------===//
//
// Part of the Viper project, under the GNU GPL v3.
// See LICENSE for license information.
//
//===----------------------------------------------------------------------===//
//
// File: src/il/io/OperandParse_Value.cpp
// Purpose: Provide the per-kind parser for IL value operands.
// Key invariants: Mirrors OperandParser::parseValueToken behaviour and emits
//                 diagnostics compatible with the historical parser.
// Ownership/Lifetime: Operates on parser-managed state without owning data or
//                     introducing new global resources.
// Links: docs/il-guide.md#reference and docs/il-reference.md#operands
//
//===----------------------------------------------------------------------===//

/// @file
/// @brief Implements the helper that parses general Value operands.
/// @details The implementation is a direct extraction of the legacy
///          OperandParser logic so diagnostics, whitespace handling, and literal
///          forms remain byte-for-byte compatible during the refactor.

#include "viper/il/io/OperandParse.hpp"

#include "il/core/Instr.hpp"
#include "il/core/Value.hpp"
#include "il/internal/io/ParserState.hpp"
#include "il/internal/io/ParserUtil.hpp"

#include <cctype>
#include <sstream>
#include <string>
#include <string_view>
#include <utility>

namespace viper::il::io
{
namespace
{
using ::il::core::Value;
using ::il::io::detail::ParserState;
using ::il::support::Expected;
using ::il::support::makeError;
using viper::parse::Cursor;

/// @brief Attach current line information to a diagnostic message.
/// @details Delegates to @ref ::il::io::formatLineDiag so all operand parsers
///          report errors with the same `line X: message` structure used by the
///          legacy implementation.
/// @param ctx Parser context carrying the current line number.
/// @param message Diagnostic text produced by the caller.
/// @return Message decorated with line information.
std::string formatLineMessage(Context &ctx, std::string message)
{
    return ::il::io::formatLineDiag(ctx.state.lineNo, std::move(message));
}

/// @brief Create an Expected error tagged with the parser's current location.
/// @details Value operand parsing frequently needs to propagate syntax failures
///          while still returning a value.  This helper produces an
///          `Expected<T>` error that mirrors the diagnostics generated by the
///          legacy parser so downstream tooling sees identical output.
/// @tparam T Expected value type required by the caller.
/// @param state Parser state describing the failing location.
/// @param message Human-readable diagnostic text.
/// @return Expected error populated with the formatted diagnostic.
template <class T> Expected<T> makeSyntaxError(ParserState &state, std::string message)
{
    return Expected<T>{::il::io::makeLineErrorDiag(state.curLoc, state.lineNo, std::move(message))};
}

/// @brief Convenience wrapper that packages a syntax error into ParseResult.
/// @details Matches the structure produced by other operand parsers by storing
///          the diagnostic inside @ref ParseResult::status.
/// @param ctx Parser context describing the error location.
/// @param message Diagnostic string emitted to users.
/// @return Parse result whose status contains the formatted error.
ParseResult syntaxError(Context &ctx, std::string message)
{
    ParseResult result;
    result.status = ::il::support::Expected<void>{
        ::il::io::makeLineErrorDiag(ctx.state.curLoc, ctx.state.lineNo, std::move(message))};
    return result;
}

/// @brief Drop leading ASCII whitespace from @p text.
/// @details Operand parsing frequently needs to peel off whitespace between
///          tokens without advancing the underlying cursor.  Mutating the
///          `std::string_view` keeps the helper allocation-free.
/// @param text View that will be advanced past any leading whitespace.
void skipSpace(std::string_view &text)
{
    size_t consumed = 0;
    while (consumed < text.size() && std::isspace(static_cast<unsigned char>(text[consumed])))
        ++consumed;
    text.remove_prefix(consumed);
}

} // namespace

Expected<size_t> parseValueTokenComponents(std::string_view &text, Value &out, Context &ctx);
Expected<Value> parseSymbolOperand(std::string_view &text, Context &ctx);

/// @brief Parse a general IL value operand from the cursor.
/// @details Handles symbol references (prefixed with '@') and literal tokens.
///          Symbol operands forward to @ref parseSymbolOperand, whereas literal
///          values reuse the shared token component parser.  Trailing whitespace
///          triggers diagnostics when extraneous characters remain so the parser
///          stays strict about operand boundaries.
/// @param cur Cursor describing the unparsed portion of the operand list.
/// @param ctx Parser context managing diagnostics and instruction state.
/// @return Parse result containing the resolved value or an error diagnostic.
ParseResult parseValueOperand(Cursor &cur, Context &ctx)
{
    std::string_view remaining = cur.remaining();
    skipSpace(remaining);
    if (remaining.empty())
        return syntaxError(ctx, "missing operand");

    if (remaining.front() == '@')
    {
        auto symbol = parseSymbolOperand(remaining, ctx);
        if (!symbol)
        {
            ParseResult result;
            result.status = ::il::support::Expected<void>(symbol.error());
            return result;
        }

        skipSpace(remaining);
        if (!remaining.empty())
            return syntaxError(ctx, "unexpected trailing characters");

        cur.consumeRest();
        ParseResult result;
        result.value = std::move(symbol.value());
        return result;
    }

    Value operand;
    auto consumed = parseValueTokenComponents(remaining, operand, ctx);
    if (!consumed)
    {
        ParseResult result;
        result.status = ::il::support::Expected<void>(consumed.error());
        return result;
    }

    skipSpace(remaining);
    if (!remaining.empty())
        return syntaxError(ctx, "unexpected trailing characters");

    cur.consumeRest();
    ParseResult result;
    result.value = std::move(operand);
    return result;
}

} // namespace viper::il::io
