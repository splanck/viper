#!/usr/bin/env python3
"""
File: scripts/gen_diagnostics.py
Purpose: Generate BASIC diagnostic catalog headers and sources from YAML specs.
Key invariants: Spec entries produce stable enum ordering and lookup tables.
Ownership/Lifetime: Reads YAML spec; writes generated C++ files in-tree.
Links: docs/codemap.md
"""

from __future__ import annotations

import argparse
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, List


@dataclass
class DiagnosticSpec:
    """Represents a single BASIC diagnostic entry parsed from YAML."""

    diag_id: str
    severity: str
    format_string: str


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Generate BASIC diagnostics catalog")
    parser.add_argument(
        "--spec",
        type=Path,
        default=None,
        help="Path to diagnostics YAML spec. Defaults to scripts/spec/diagnostics.yaml.",
    )
    parser.add_argument(
        "--header",
        type=Path,
        default=None,
        help=(
            "Path to output header. Defaults to include/viper/diag/BasicDiag.hpp relative to the repo root."
        ),
    )
    parser.add_argument(
        "--source",
        type=Path,
        default=None,
        help=(
            "Path to output source. Defaults to src/frontends/basic/diag/BasicDiag.cpp relative to the repo root."
        ),
    )
    return parser.parse_args()


def load_spec(path: Path) -> List[DiagnosticSpec]:
    """Parse the diagnostics YAML file into DiagnosticSpec entries."""

    if not path.exists():
        raise SystemExit(f"diagnostics spec not found: {path}")

    entries: List[DiagnosticSpec] = []
    current: dict[str, str] | None = None

    def flush_current() -> None:
        nonlocal current
        if current is None:
            return
        required = {"id", "severity", "format"}
        missing = required.difference(current)
        if missing:
            raise SystemExit(f"missing keys {sorted(missing)} in spec entry: {current}")
        entries.append(
            DiagnosticSpec(
                diag_id=current["id"],
                severity=current["severity"],
                format_string=current["format"],
            )
        )
        current = None

    for raw_line in path.read_text(encoding="utf-8").splitlines():
        line = raw_line.strip()
        if not line or line.startswith("#"):
            continue
        if line.startswith("- "):
            flush_current()
            current = {}
            remainder = line[2:].strip()
            if remainder:
                key, value = _parse_key_value(remainder)
                current[key] = value
            continue
        if current is None:
            raise SystemExit(f"Unexpected content outside of an entry: {raw_line}")
        key, value = _parse_key_value(line)
        current[key] = value
    flush_current()
    return entries


def _parse_key_value(line: str) -> tuple[str, str]:
    if ":" not in line:
        raise SystemExit(f"Invalid line in diagnostics spec: {line}")
    key, value = line.split(":", 1)
    key = key.strip()
    value = value.strip()
    if (value.startswith('"') and value.endswith('"')) or (value.startswith("'") and value.endswith("'")):
        value = value[1:-1]
    return key, value


def _escape_cpp_string(text: str) -> str:
    escaped = text.replace("\\", "\\\\").replace('"', '\\"')
    return f'"{escaped}"'


def write_header(path: Path, entries: Iterable[DiagnosticSpec]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    lines = [
        "//===----------------------------------------------------------------------===//",
        "//",
        "// Part of the Viper project, under the MIT License.",
        "// See LICENSE for license information.",
        "//",
        "//===----------------------------------------------------------------------===//",
        "// File: include/viper/diag/BasicDiag.hpp",
        "// Purpose: Auto-generated catalog of BASIC diagnostic identifiers and helpers.",
        "// Key invariants: Enum values and lookup functions stay in sync with diagnostics.yaml.",
        "// Ownership/Lifetime: Provides views over static tables.",
        "// Links: scripts/spec/diagnostics.yaml",
        "//",
        "// NOTE: This file is auto-generated by scripts/gen_diagnostics.py. Do not edit manually.",
        "#pragma once",
        "",
        "#include \"support/diagnostics.hpp\"",
        "#include <initializer_list>",
        "#include <string>",
        "#include <string_view>",
        "",
        "namespace il::frontends::basic::diag",
        "{",
        "",
        "enum class BasicDiagId",
        "{",
    ]

    enum_entries = [f"    {spec.diag_id}," for spec in entries]
    lines.extend(enum_entries)
    lines.append("    Count,")
    lines.append("};")
    lines.append("")
    lines.extend(
        [
            "struct Replacement",
            "{",
            "    std::string_view key;",
            "    std::string_view value;",
            "};",
            "",
            "std::string_view getFormat(BasicDiagId id);",
            "il::support::Severity getSeverity(BasicDiagId id);",
            "std::string formatMessage(BasicDiagId id, std::initializer_list<Replacement> replacements = {});",
            "",
            "} // namespace il::frontends::basic::diag",
            "",
        ]
    )
    path.write_text("\n".join(lines) + "\n", encoding="utf-8")


def write_source(path: Path, entries: List[DiagnosticSpec]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    severity_map = {
        "error": "il::support::Severity::Error",
        "warning": "il::support::Severity::Warning",
        "note": "il::support::Severity::Note",
    }
    lines = [
        "//===----------------------------------------------------------------------===//",
        "//",
        "// Part of the Viper project, under the MIT License.",
        "// See LICENSE for license information.",
        "//",
        "//===----------------------------------------------------------------------===//",
        "// File: src/frontends/basic/diag/BasicDiag.cpp",
        "// Purpose: Auto-generated lookup tables for BASIC diagnostics.",
        "// Key invariants: Table order matches BasicDiagId enum values.",
        "// Ownership/Lifetime: Stores static arrays for format/severity metadata.",
        "// Links: scripts/spec/diagnostics.yaml",
        "//",
        "// NOTE: This file is auto-generated by scripts/gen_diagnostics.py. Do not edit manually.",
        "",
        "#include \"viper/diag/BasicDiag.hpp\"",
        "",
        "#include <array>",
        "#include <cassert>",
        "#include <string>",
        "",
        "namespace il::frontends::basic::diag",
        "{",
        "",
        "namespace",
        "{",
        "    struct Entry",
        "    {",
        "        il::support::Severity severity;",
        "        std::string_view format;",
        "    };",
        "",
        "    constexpr std::array<Entry, static_cast<std::size_t>(BasicDiagId::Count)> kEntries = {",
    ]

    for spec in entries:
        sev = spec.severity.lower()
        if sev not in severity_map:
            raise SystemExit(f"Unsupported severity '{spec.severity}' in {spec.diag_id}")
        lines.append(
            f"        Entry{{{severity_map[sev]}, {_escape_cpp_string(spec.format_string)}}},"
        )

    lines.extend(
        [
            "    };",
            "",
            "} // namespace",
            "",
            "std::string_view getFormat(BasicDiagId id)",
            "{",
            "    const auto index = static_cast<std::size_t>(id);",
            "    assert(index < kEntries.size());",
            "    return kEntries[index].format;",
            "}",
            "",
            "il::support::Severity getSeverity(BasicDiagId id)",
            "{",
            "    const auto index = static_cast<std::size_t>(id);",
            "    assert(index < kEntries.size());",
            "    return kEntries[index].severity;",
            "}",
            "",
            "std::string formatMessage(BasicDiagId id, std::initializer_list<Replacement> replacements)",
            "{",
            "    std::string message(getFormat(id));",
            "    for (const auto &replacement : replacements)",
            "    {",
            '        const std::string placeholder = std::string("{") + std::string(replacement.key) + "}";',
            "        std::size_t pos = 0;",
            "        while ((pos = message.find(placeholder, pos)) != std::string::npos)",
            "        {",
            "            message.replace(pos, placeholder.size(), replacement.value);",
            "            pos += replacement.value.size();",
            "        }",
            "    }",
            "    return message;",
            "}",
            "",
            "} // namespace il::frontends::basic::diag",
            "",
        ]
    )
    path.write_text("\n".join(lines) + "\n", encoding="utf-8")


def main() -> None:
    args = parse_args()
    repo_root = Path(__file__).resolve().parent.parent
    spec_path = args.spec if args.spec is not None else repo_root / "scripts" / "spec" / "diagnostics.yaml"
    entries = load_spec(spec_path)
    if not entries:
        raise SystemExit(f"No diagnostics found in {spec_path}")

    header_path = args.header if args.header is not None else repo_root / "include" / "viper" / "diag" / "BasicDiag.hpp"
    source_path = args.source if args.source is not None else repo_root / "src" / "frontends" / "basic" / "diag" / "BasicDiag.cpp"

    write_header(header_path, entries)
    write_source(source_path, entries)


if __name__ == "__main__":
    main()
