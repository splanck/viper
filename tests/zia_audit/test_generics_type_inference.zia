module TestGenericTypeInference;

// Tests for generic function type inference (Phase 4)
// This tests calling generic functions without explicit type arguments

var passed: Integer = 0;
var failed: Integer = 0;

func check(name: String, actual: Integer, expected: Integer) {
    if (actual == expected) {
        passed = passed + 1;
    } else {
        failed = failed + 1;
        Viper.Terminal.Say("FAIL: " + name + " - expected " + Viper.String.FromInt(expected) + ", got " + Viper.String.FromInt(actual));
    }
}

func checkStr(name: String, actual: String, expected: String) {
    if (actual == expected) {
        passed = passed + 1;
    } else {
        failed = failed + 1;
        Viper.Terminal.Say("FAIL: " + name + " - expected '" + expected + "', got '" + actual + "'");
    }
}

func checkBool(name: String, actual: Boolean, expected: Boolean) {
    if (actual == expected) {
        passed = passed + 1;
    } else {
        failed = failed + 1;
        var actualStr: String = "false";
        var expectedStr: String = "false";
        if (actual) { actualStr = "true"; }
        if (expected) { expectedStr = "true"; }
        Viper.Terminal.Say("FAIL: " + name + " - expected " + expectedStr + ", got " + actualStr);
    }
}

// Generic identity function
func identity[T](x: T) -> T {
    return x;
}

// Generic wrap with local variable
func wrap[T](x: T) -> T {
    var y: T = x;
    return y;
}

// Generic pick with two params of same type
func pick[T](a: T, b: T) -> T {
    return a;
}

// Generic function calling another generic with explicit type
func doubleWrap[T](x: T) -> T {
    return wrap[T](x);
}

func start() {
    Viper.Terminal.Say("=== Generic Type Inference Tests ===");

    // Test type inference with Integer
    check("identity inferred Integer", identity(42), 42);
    check("wrap inferred Integer", wrap(100), 100);
    check("pick inferred Integer", pick(5, 10), 5);

    // Test type inference with String
    checkStr("identity inferred String", identity("hello"), "hello");
    checkStr("wrap inferred String", wrap("world"), "world");
    checkStr("pick inferred String", pick("first", "second"), "first");

    // Test type inference with Boolean
    checkBool("identity inferred true", identity(true), true);
    checkBool("identity inferred false", identity(false), false);
    checkBool("wrap inferred Boolean", wrap(true), true);

    // Test mixing inferred and explicit type arguments
    check("explicit after inferred", identity[Integer](7), 7);
    check("inferred after explicit", identity(8), 8);

    // Test complex patterns
    check("doubleWrap with explicit", doubleWrap[Integer](99), 99);

    // Report results
    Viper.Terminal.Say("=== Results ===");
    Viper.Terminal.Say("Passed: " + Viper.String.FromInt(passed));
    Viper.Terminal.Say("Failed: " + Viper.String.FromInt(failed));

    if (failed == 0) {
        Viper.Terminal.Say("RESULT: ok");
    } else {
        Viper.Terminal.Say("RESULT: fail");
    }
}
