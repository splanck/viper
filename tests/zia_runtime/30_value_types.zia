module RuntimeTest30;

bind "./_support";

// EXPECT_OUT: RESULT: ok

// Test: Value types (structs) vs reference types (entities)

//=============================================================================
// Value types (passed by value, copied on assignment)
//=============================================================================

value Point {
    expose Integer x;
    expose Integer y;

    expose func init(px: Integer, py: Integer) {
        x = px;
        y = py;
    }

    expose func magnitude() -> Integer {
        // Approximate magnitude using |x| + |y| (Manhattan distance from origin)
        var absX = x;
        var absY = y;
        if (absX < 0) { absX = -absX; }
        if (absY < 0) { absY = -absY; }
        return absX + absY;
    }

    expose func add(other: Point) -> Point {
        return new Point(x + other.x, y + other.y);
    }

    expose func scale(factor: Integer) -> Point {
        return new Point(x * factor, y * factor);
    }

    expose func toString() -> String {
        return "(" + toString(x) + ", " + toString(y) + ")";
    }
}

value Rectangle {
    expose Integer width;
    expose Integer height;

    expose func init(w: Integer, h: Integer) {
        width = w;
        height = h;
    }

    expose func area() -> Integer {
        return width * height;
    }

    expose func perimeter() -> Integer {
        return 2 * (width + height);
    }

    expose func isSquare() -> Boolean {
        return width == height;
    }

    expose func scaled(factor: Integer) -> Rectangle {
        return new Rectangle(width * factor, height * factor);
    }
}

value Color {
    expose Integer r;
    expose Integer g;
    expose Integer b;

    expose func init(red: Integer, green: Integer, blue: Integer) {
        r = red;
        g = green;
        b = blue;
    }

    expose func brightness() -> Integer {
        return (r + g + b) / 3;
    }

    expose func invert() -> Color {
        return new Color(255 - r, 255 - g, 255 - b);
    }

    expose func toHex() -> String {
        // Simplified hex representation
        return "rgb(" + toString(r) + "," + toString(g) + "," + toString(b) + ")";
    }
}

//=============================================================================
// Reference type for comparison
//=============================================================================

entity PointRef {
    expose Integer x;
    expose Integer y;

    expose func init(px: Integer, py: Integer) {
        x = px;
        y = py;
    }
}

//=============================================================================
// Functions using value types
//=============================================================================

func distance(p1: Point, p2: Point) -> Integer {
    var dx = p2.x - p1.x;
    var dy = p2.y - p1.y;
    if (dx < 0) { dx = -dx; }
    if (dy < 0) { dy = -dy; }
    return dx + dy;
}

func midpoint(p1: Point, p2: Point) -> Point {
    return new Point((p1.x + p2.x) / 2, (p1.y + p2.y) / 2);
}

func start() {
    //=========================================================================
    // Test 1: Basic value type creation
    //=========================================================================
    var p1 = new Point(3, 4);
    assertEqInt(p1.x, 3, "point_x");
    assertEqInt(p1.y, 4, "point_y");

    //=========================================================================
    // Test 2: Value type method calls
    //=========================================================================
    assertEqInt(p1.magnitude(), 7, "point_magnitude");
    assertEqStr(p1.toString(), "(3, 4)", "point_tostring");

    //=========================================================================
    // Test 3: Value type returning value type
    //=========================================================================
    var p2 = new Point(5, 6);
    var p3 = p1.add(p2);
    assertEqInt(p3.x, 8, "point_add_x");
    assertEqInt(p3.y, 10, "point_add_y");

    //=========================================================================
    // Test 4: Value type copy semantics
    //=========================================================================
    var original = new Point(10, 20);
    var copy = original;
    copy.x = 100;  // Modify copy
    assertEqInt(original.x, 10, "value_copy_original_unchanged");
    assertEqInt(copy.x, 100, "value_copy_modified");

    //=========================================================================
    // Test 5: Reference type comparison
    //=========================================================================
    var refOriginal = new PointRef(10, 20);
    var refAlias = refOriginal;
    refAlias.x = 100;  // Modify through alias
    assertEqInt(refOriginal.x, 100, "ref_alias_changes_original");

    //=========================================================================
    // Test 6: Rectangle value type
    //=========================================================================
    var rect = new Rectangle(4, 3);
    assertEqInt(rect.area(), 12, "rect_area");
    assertEqInt(rect.perimeter(), 14, "rect_perimeter");
    assertTrue(!rect.isSquare(), "rect_not_square");

    var square = new Rectangle(5, 5);
    assertTrue(square.isSquare(), "square_is_square");

    //=========================================================================
    // Test 7: Value type transformation
    //=========================================================================
    var scaled = rect.scaled(2);
    assertEqInt(scaled.width, 8, "scaled_width");
    assertEqInt(scaled.height, 6, "scaled_height");
    assertEqInt(scaled.area(), 48, "scaled_area");

    // Original unchanged
    assertEqInt(rect.width, 4, "original_rect_unchanged");

    //=========================================================================
    // Test 8: Color value type
    //=========================================================================
    var red = new Color(255, 0, 0);
    assertEqInt(red.r, 255, "color_red_r");
    assertEqInt(red.g, 0, "color_red_g");
    assertEqInt(red.b, 0, "color_red_b");
    assertEqInt(red.brightness(), 85, "color_brightness");

    //=========================================================================
    // Test 9: Color inversion
    //=========================================================================
    var inverted = red.invert();
    assertEqInt(inverted.r, 0, "inverted_r");
    assertEqInt(inverted.g, 255, "inverted_g");
    assertEqInt(inverted.b, 255, "inverted_b");

    //=========================================================================
    // Test 10: Value types in functions
    //=========================================================================
    var pa = new Point(0, 0);
    var pb = new Point(3, 4);
    assertEqInt(distance(pa, pb), 7, "distance_func");

    //=========================================================================
    // Test 11: Function returning value type
    //=========================================================================
    var mid = midpoint(pa, pb);
    assertEqInt(mid.x, 1, "midpoint_x");
    assertEqInt(mid.y, 2, "midpoint_y");

    //=========================================================================
    // Test 12: Chained value type operations
    //=========================================================================
    var origin = new Point(0, 0);
    var result = origin.add(new Point(5, 5)).scale(2);
    assertEqInt(result.x, 10, "chained_x");
    assertEqInt(result.y, 10, "chained_y");

    //=========================================================================
    // Test 13: Multiple value types
    //=========================================================================
    var white = new Color(255, 255, 255);
    var black = new Color(0, 0, 0);
    assertEqInt(white.brightness(), 255, "white_brightness");
    assertEqInt(black.brightness(), 0, "black_brightness");

    //=========================================================================
    // Test 14: Value types in Lists
    //=========================================================================
    var points = new List[Point]();
    points.Add(new Point(1, 2));
    points.Add(new Point(3, 4));
    assertEqInt(points.Length(), 2, "list_length");

    var p0: Point = points.Get(0);
    assertEqInt(p0.x, 1, "list_point_x");
    assertEqInt(p0.y, 2, "list_point_y");

    var p1: Point = points.Get(1);
    assertEqInt(p1.x, 3, "list_point_1_x");
    assertEqInt(p1.y, 4, "list_point_1_y");

    //=========================================================================
    // Test 15: Value types in Lists - copy semantics
    //=========================================================================
    // Modifying retrieved value doesn't affect list
    p0.x = 100;
    var p0Again: Point = points.Get(0);
    assertEqInt(p0Again.x, 1, "list_point_copy_unchanged");

    //=========================================================================
    // Test 16: Value types in List literal
    //=========================================================================
    var rectList = [new Rectangle(2, 3), new Rectangle(4, 5)];
    var r0: Rectangle = rectList.Get(0);
    var r1: Rectangle = rectList.Get(1);
    assertEqInt(r0.area(), 6, "rect_list_0_area");
    assertEqInt(r1.area(), 20, "rect_list_1_area");

    report();
}
