module TestBytesNullByte;

bind "./_support";

// EXPECT_OUT: RESULT: ok
// COVER: Viper.Collections.Bytes.FromStr
// COVER: Viper.Collections.Bytes.ToStr
// COVER: Viper.Collections.Bytes.get_Len
// COVER: Viper.Collections.Bytes.Get

// Verify that Bytes.ToStr/FromStr preserve embedded null bytes (BUG-IO-001).
// Before the fix, rt_bytes_from_str used strlen() which truncated at the first
// null byte; it now uses rt_str_len() (the stored byte count) instead.

func testNullByteRoundtrip() {
    setTest("NullByteRoundtrip");

    // Build bytes: [65, 0, 67] = 'A', NUL, 'C'
    var b = Viper.Collections.Bytes.New(3);
    Viper.Collections.Bytes.Set(b, 0, 65);  // 'A'
    Viper.Collections.Bytes.Set(b, 1, 0);   // NUL
    Viper.Collections.Bytes.Set(b, 2, 67);  // 'C'

    // Convert to Viper string (length-prefixed, can embed nulls) then back.
    var s = Viper.Collections.Bytes.ToStr(b);
    var b2 = Viper.Collections.Bytes.FromStr(s);

    // All 3 bytes must be preserved, including the embedded null at index 1.
    assertEqInt(Viper.Collections.Bytes.get_Len(b2), 3, "null byte preserved in length");
    assertEqInt(Viper.Collections.Bytes.Get(b2, 0), 65, "byte[0] = 'A'");
    assertEqInt(Viper.Collections.Bytes.Get(b2, 1), 0,  "byte[1] = NUL preserved");
    assertEqInt(Viper.Collections.Bytes.Get(b2, 2), 67, "byte[2] = 'C' after NUL");
}

func testMultipleNullBytes() {
    setTest("MultipleNullBytes");

    // Build bytes: [0, 0, 65, 0, 0] â€” nulls at start, middle, end
    var b = Viper.Collections.Bytes.New(5);
    Viper.Collections.Bytes.Set(b, 0, 0);
    Viper.Collections.Bytes.Set(b, 1, 0);
    Viper.Collections.Bytes.Set(b, 2, 65);
    Viper.Collections.Bytes.Set(b, 3, 0);
    Viper.Collections.Bytes.Set(b, 4, 0);

    var s = Viper.Collections.Bytes.ToStr(b);
    var b2 = Viper.Collections.Bytes.FromStr(s);

    assertEqInt(Viper.Collections.Bytes.get_Len(b2), 5, "5 bytes preserved");
    assertEqInt(Viper.Collections.Bytes.Get(b2, 0), 0,  "byte[0] = NUL");
    assertEqInt(Viper.Collections.Bytes.Get(b2, 1), 0,  "byte[1] = NUL");
    assertEqInt(Viper.Collections.Bytes.Get(b2, 2), 65, "byte[2] = 'A'");
    assertEqInt(Viper.Collections.Bytes.Get(b2, 3), 0,  "byte[3] = NUL");
    assertEqInt(Viper.Collections.Bytes.Get(b2, 4), 0,  "byte[4] = NUL");
}

func testNonNullBytesUnaffected() {
    setTest("NonNullBytesUnaffected");

    // Ensure the fix doesn't affect normal ASCII strings.
    var b = Viper.Collections.Bytes.FromStr("Hello");
    assertEqInt(Viper.Collections.Bytes.get_Len(b), 5, "hello is 5 bytes");
    assertEqInt(Viper.Collections.Bytes.Get(b, 0), 72,  "H");
    assertEqInt(Viper.Collections.Bytes.Get(b, 4), 111, "o");
}

func start() {
    testNullByteRoundtrip();
    testMultipleNullBytes();
    testNonNullBytesUnaffected();
    report();
}
