module Support;

// Test tracking counters
var failures: Integer = 0;
var passes: Integer = 0;
var testName: String = "";

// Set current test name for reporting
func setTest(name: String) {
    testName = name;
}

// Record a passed test
func pass() {
    passes = passes + 1;
}

// Record a failed test with message
func fail(msg: String) {
    failures = failures + 1;
    if (testName == "") {
        Viper.Terminal.Say("FAIL: " + msg);
    } else {
        Viper.Terminal.Say("FAIL [" + testName + "]: " + msg);
    }
}

// Assert that condition is true
func assertTrue(cond: Boolean, msg: String) {
    if (cond) {
        pass();
    } else {
        fail(msg);
    }
}

// Assert that condition is false
func assertFalse(cond: Boolean, msg: String) {
    assertTrue(!cond, msg);
}

// Assert two integers are equal
func assertEqInt(actual: Integer, expected: Integer, msg: String) {
    if (actual == expected) {
        pass();
    } else {
        fail(msg + " (got " + toString(actual) + ", want " + toString(expected) + ")");
    }
}

// Assert two integers are not equal
func assertNeqInt(actual: Integer, expected: Integer, msg: String) {
    if (actual != expected) {
        pass();
    } else {
        fail(msg + " (both are " + toString(actual) + ")");
    }
}

// Assert integer is greater than expected
func assertGtInt(actual: Integer, expected: Integer, msg: String) {
    if (actual > expected) {
        pass();
    } else {
        fail(msg + " (got " + toString(actual) + ", expected > " + toString(expected) + ")");
    }
}

// Assert integer is less than expected
func assertLtInt(actual: Integer, expected: Integer, msg: String) {
    if (actual < expected) {
        pass();
    } else {
        fail(msg + " (got " + toString(actual) + ", expected < " + toString(expected) + ")");
    }
}

// Assert integer is greater than or equal to expected
func assertGteInt(actual: Integer, expected: Integer, msg: String) {
    if (actual >= expected) {
        pass();
    } else {
        fail(msg + " (got " + toString(actual) + ", expected >= " + toString(expected) + ")");
    }
}

// Assert integer is less than or equal to expected
func assertLteInt(actual: Integer, expected: Integer, msg: String) {
    if (actual <= expected) {
        pass();
    } else {
        fail(msg + " (got " + toString(actual) + ", expected <= " + toString(expected) + ")");
    }
}

// Assert two strings are equal
func assertEqStr(actual: String, expected: String, msg: String) {
    if (actual == expected) {
        pass();
    } else {
        fail(msg + " (got \"" + actual + "\", want \"" + expected + "\")");
    }
}

// Assert two strings are not equal
func assertNeqStr(actual: String, expected: String, msg: String) {
    if (actual != expected) {
        pass();
    } else {
        fail(msg + " (both are \"" + actual + "\")");
    }
}

// Assert string is not empty
func assertNotEmpty(actual: String, msg: String) {
    if (actual != "") {
        pass();
    } else {
        fail(msg + " (string is empty)");
    }
}

// Assert string is empty
func assertEmpty(actual: String, msg: String) {
    if (actual == "") {
        pass();
    } else {
        fail(msg + " (got \"" + actual + "\", expected empty)");
    }
}

// Assert string contains substring
func assertContains(haystack: String, needle: String, msg: String) {
    if (Viper.String.Has(haystack, needle)) {
        pass();
    } else {
        fail(msg + " (\"" + haystack + "\" does not contain \"" + needle + "\")");
    }
}

// Assert string starts with prefix
func assertStartsWith(str: String, prefix: String, msg: String) {
    if (Viper.String.StartsWith(str, prefix)) {
        pass();
    } else {
        fail(msg + " (\"" + str + "\" does not start with \"" + prefix + "\")");
    }
}

// Assert string ends with suffix
func assertEndsWith(str: String, suffix: String, msg: String) {
    if (Viper.String.EndsWith(str, suffix)) {
        pass();
    } else {
        fail(msg + " (\"" + str + "\" does not end with \"" + suffix + "\")");
    }
}

// Assert two numbers are approximately equal (within epsilon)
func assertApprox(actual: Number, expected: Number, eps: Number, msg: String) {
    if (Viper.Math.Abs(actual - expected) <= eps) {
        pass();
    } else {
        fail(msg + " (got " + toString(actual) + ", want " + toString(expected) + " +/- " + toString(eps) + ")");
    }
}

// Assert number is within range [min, max]
func assertInRange(actual: Number, min: Number, max: Number, msg: String) {
    if (actual >= min && actual <= max) {
        pass();
    } else {
        fail(msg + " (got " + toString(actual) + ", expected in [" + toString(min) + ", " + toString(max) + "])");
    }
}

// Print final test results and return exit status
func report() {
    var total = passes + failures;
    Viper.Terminal.Say("Tests: " + toString(total) + " | Passed: " + toString(passes) + " | Failed: " + toString(failures));
    if (failures == 0) {
        Viper.Terminal.Say("RESULT: ok");
    } else {
        Viper.Terminal.Say("RESULT: fail " + toString(failures));
    }
}

// Reset counters for a new test suite
func reset() {
    failures = 0;
    passes = 0;
    testName = "";
}
