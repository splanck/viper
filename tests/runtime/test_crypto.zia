module TestCrypto;

bind "./_support";

// EXPECT_OUT: RESULT: ok
// COVER: Viper.Crypto.Hash.MD5
// COVER: Viper.Crypto.Hash.SHA1
// COVER: Viper.Crypto.Hash.SHA256
// COVER: Viper.Crypto.Hash.CRC32
// COVER: Viper.Crypto.Hash.HmacMD5
// COVER: Viper.Crypto.Hash.HmacSHA1
// COVER: Viper.Crypto.Hash.HmacSHA256
// COVER: Viper.Crypto.Rand.Int
// COVER: Viper.Crypto.Rand.Bytes
// COVER: Viper.Crypto.Aes.EncryptStr
// COVER: Viper.Crypto.Aes.DecryptStr

func testAES() {
    setTest("AES");

    // Test basic string encryption/decryption
    var plaintext = "Hello, World! This is a test.";
    var password = "MySecretPassword123";

    var encrypted = Viper.Crypto.Aes.EncryptStr(plaintext, password);
    var decrypted = Viper.Crypto.Aes.DecryptStr(encrypted, password);
    assertEqStr(decrypted, plaintext, "aes roundtrip");

    // Test empty string
    var emptyPlain = "";
    var emptyEnc = Viper.Crypto.Aes.EncryptStr(emptyPlain, password);
    var emptyDec = Viper.Crypto.Aes.DecryptStr(emptyEnc, password);
    assertEqStr(emptyDec, emptyPlain, "aes empty string");

    // Test different passwords work independently
    var enc1 = Viper.Crypto.Aes.EncryptStr(plaintext, "password1");
    var enc2 = Viper.Crypto.Aes.EncryptStr(plaintext, "password2");
    var dec1 = Viper.Crypto.Aes.DecryptStr(enc1, "password1");
    var dec2 = Viper.Crypto.Aes.DecryptStr(enc2, "password2");
    assertEqStr(dec1, plaintext, "aes password1");
    assertEqStr(dec2, plaintext, "aes password2");

    // Test long text (multi-block)
    var longPlain = "";
    for (var i = 0; i < 50; i = i + 1) {
        longPlain = Viper.String.Concat(longPlain, "ABCDEFGHIJ");
    }
    var longEnc = Viper.Crypto.Aes.EncryptStr(longPlain, password);
    var longDec = Viper.Crypto.Aes.DecryptStr(longEnc, password);
    assertEqStr(longDec, longPlain, "aes long text");
}

func testMD5() {
    setTest("MD5");

    // Known MD5 hashes
    var hash1 = Viper.Crypto.Hash.MD5("");
    assertEqStr(hash1, "d41d8cd98f00b204e9800998ecf8427e", "md5 empty string");

    var hash2 = Viper.Crypto.Hash.MD5("hello");
    assertEqStr(hash2, "5d41402abc4b2a76b9719d911017c592", "md5 'hello'");

    var hash3 = Viper.Crypto.Hash.MD5("Hello, World!");
    assertEqStr(hash3, "65a8e27d8879283831b664bd8b7f0ad4", "md5 'Hello, World!'");
}

func testSHA1() {
    setTest("SHA1");

    // Known SHA1 hashes
    var hash1 = Viper.Crypto.Hash.SHA1("");
    assertEqStr(hash1, "da39a3ee5e6b4b0d3255bfef95601890afd80709", "sha1 empty string");

    var hash2 = Viper.Crypto.Hash.SHA1("hello");
    assertEqStr(hash2, "aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d", "sha1 'hello'");
}

func testSHA256() {
    setTest("SHA256");

    // Known SHA256 hashes
    var hash1 = Viper.Crypto.Hash.SHA256("");
    assertEqStr(hash1, "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855", "sha256 empty string");

    var hash2 = Viper.Crypto.Hash.SHA256("hello");
    assertEqStr(hash2, "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824", "sha256 'hello'");
}

func testCRC32() {
    setTest("CRC32");

    // CRC32 of known strings
    var crc1 = Viper.Crypto.Hash.CRC32("hello");
    assertEqInt(crc1, 0x3610a686, "crc32 'hello'");

    var crc2 = Viper.Crypto.Hash.CRC32("");
    assertEqInt(crc2, 0, "crc32 empty string");
}

func testHMAC() {
    setTest("HMAC");

    var key = "secret";
    var msg = "message";

    // HMAC-MD5
    var hmacMd5 = Viper.Crypto.Hash.HmacMD5(key, msg);
    assertEqInt(Viper.String.Length(hmacMd5), 32, "hmac-md5 length");

    // HMAC-SHA1
    var hmacSha1 = Viper.Crypto.Hash.HmacSHA1(key, msg);
    assertEqInt(Viper.String.Length(hmacSha1), 40, "hmac-sha1 length");

    // HMAC-SHA256
    var hmacSha256 = Viper.Crypto.Hash.HmacSHA256(key, msg);
    assertEqInt(Viper.String.Length(hmacSha256), 64, "hmac-sha256 length");
}

func testCryptoRandInt() {
    setTest("CryptoRandInt");

    // Test range - both min and max are inclusive [min, max]
    for (var i = 0; i < 50; i = i + 1) {
        var n = Viper.Crypto.Rand.Int(10, 100);
        assertGteInt(n, 10, "crypto rand >= min");
        assertLteInt(n, 100, "crypto rand <= max");
    }
}

// Note: testCryptoRandBytes removed - Viper.Collections.Bytes not available in Zia
// Rand.Bytes() works but cannot verify length/contents without Bytes API

func testHashDeterminism() {
    setTest("HashDeterminism");

    // Same input should always produce same hash
    var input = "test string for hashing";

    var md5_1 = Viper.Crypto.Hash.MD5(input);
    var md5_2 = Viper.Crypto.Hash.MD5(input);
    assertEqStr(md5_1, md5_2, "md5 deterministic");

    var sha256_1 = Viper.Crypto.Hash.SHA256(input);
    var sha256_2 = Viper.Crypto.Hash.SHA256(input);
    assertEqStr(sha256_1, sha256_2, "sha256 deterministic");
}

func testHashLength() {
    setTest("HashLength");

    var input = "test";

    // MD5 produces 32 hex chars (128 bits)
    assertEqInt(Viper.String.Length(Viper.Crypto.Hash.MD5(input)), 32, "md5 length");

    // SHA1 produces 40 hex chars (160 bits)
    assertEqInt(Viper.String.Length(Viper.Crypto.Hash.SHA1(input)), 40, "sha1 length");

    // SHA256 produces 64 hex chars (256 bits)
    assertEqInt(Viper.String.Length(Viper.Crypto.Hash.SHA256(input)), 64, "sha256 length");
}

func start() {
    testAES();
    testMD5();
    testSHA1();
    testSHA256();
    testCRC32();
    testHMAC();
    testCryptoRandInt();
    // testCryptoRandBytes removed - Bytes API not available in Zia
    testHashDeterminism();
    testHashLength();

    report();
}
