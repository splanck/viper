# Viper BASIC Bug Report - December 5, 2025

## Summary

Systematic testing of the ARM64 native backend revealed several bugs, both in the VM/frontend and specific to the ARM64
codegen.

### Fix Status (Updated December 5, 2025)

| Bug     | Status    | Description                                          |
|---------|-----------|------------------------------------------------------|
| BUG-001 | **FIXED** | Module-level 2D arrays                               |
| BUG-002 | **FIXED** | CONST not accessible in class methods                |
| BUG-003 | **FIXED** | ARM64 garbage values with CONST (symptom of BUG-002) |
| BUG-004 | **FIXED** | Chained method calls on nested objects               |
| BUG-005 | **FIXED** | ARM64 BYREF parameters not working                   |
| BUG-006 | **FIXED** | ARM64 multiple BYREF parameters crash                |
| BUG-007 | **FIXED** | ARM64 floating-point arithmetic returns zero         |
| BUG-008 | **FIXED** | VM LONG array arithmetic overflow                    |
| BUG-009 | **FIXED** | SINGLE arrays broken (requires runtime changes)      |
| BUG-010 | **FIXED** | Class SINGLE fields broken in ARM64                  |

---

## BUG-001: Module-Level 2D Arrays Fail in VM

**Severity**: High
**Affects**: VM (not ARM64-specific)
**Status**: FIXED

**Fix**: Used alloca to store running product across basic blocks in multi-dimensional array lowering. The previous code
failed because values from predecessor blocks aren't accessible without explicit block parameters.

**Description**: Declaring a 2D array at module level causes an IL verification error.

**Reproduction**:

```basic
DIM grid(3, 3) AS INTEGER
DIM i AS INTEGER
DIM j AS INTEGER
FOR i = 0 TO 2
    FOR j = 0 TO 2
        grid(i, j) = i * 3 + j
    NEXT j
NEXT i
```

**Error**:

```
error: main:dim_len_cont1: %9 = imul.ovf %t4 %t6: unknown temp %4; use before def of %4
```

**Workaround**: Use 2D arrays inside CLASS definitions instead - those work correctly.

---

## BUG-002: CONST Not Accessible in Class Methods (VM)

**Severity**: High
**Affects**: VM (not ARM64-specific)
**Status**: FIXED

**Fix**: Removed the exception in `shouldAllocateSlot` that allowed local slot allocation for module-level constants.
Constants now correctly resolve to module-level storage via `rt_modvar_addr_*`. The semantic analyzer already prevents
shadowing of constants, so the previous exception was unnecessary.

**Description**: Constants defined at module level are not accessible inside class methods. The value is always 0
instead of the defined constant value.

**Reproduction**:

```basic
CONST VAL = 5

CLASS MyClass
    PUBLIC x AS INTEGER

    SUB SetVal()
        ME.x = VAL
    END SUB
END CLASS

DIM obj AS MyClass = NEW MyClass()
obj.SetVal()
PRINT obj.x   ' Prints 0, should print 5
```

**Expected**: `5`
**Actual**: `0`

**Workaround**: Use literal values instead of constants inside class methods, or pass constants as parameters.

---

## BUG-003: ARM64 Garbage Values with CONST in Class Array Methods

**Severity**: Critical
**Affects**: ARM64 Native Backend
**Status**: FIXED

**Fix**: This was a symptom of BUG-002. Once constants correctly resolve to module-level storage, the ARM64 native code
correctly loads the initialized constant value.

**Description**: When a CONST is used inside a class method that operates on arrays, the ARM64 native binary produces
garbage values while the VM produces 0 (due to BUG-002). This is an ARM64-specific codegen bug on top of the VM bug.

**Reproduction**:

```basic
CONST VAL = 1

CLASS MyClass
    DIM arr(3) AS INTEGER

    SUB SetVal(i AS INTEGER)
        ME.arr(i) = VAL
    END SUB

    FUNCTION GetVal(i AS INTEGER) AS INTEGER
        RETURN ME.arr(i)
    END FUNCTION
END CLASS

DIM obj AS MyClass = NEW MyClass()
obj.SetVal(0)
PRINT obj.GetVal(0)
```

**VM Output**: `0` (wrong due to BUG-002)
**Native Output**: `3165928` (garbage - ARM64 bug)

**Workaround**: Avoid CONST inside class methods. Use literal values or pass values as parameters.

---

## BUG-004: Chained Method Calls on Nested Objects Fail

**Severity**: Medium
**Affects**: VM (not ARM64-specific)
**Status**: FIXED

**Fix**: The parser's namespace check for qualified procedure calls was case-sensitive. When checking if the first
identifier is a known namespace (to distinguish `Namespace.Func()` from `obj.Method()`), it used exact string matching.
Since BASIC is case-insensitive, expressions like `obj.field.Method()` would pass the check incorrectly if the head
wasn't a known namespace - but this was actually causing it to be parsed as a qualified call instead of a member access.
Fixed by using `string_utils::iequals` for case-insensitive namespace matching.

**Description**: Calling a method on a nested object field directly (e.g., `outer.inner.Method()`) fails with "unknown
procedure" error.

**Reproduction**:

```basic
CLASS Inner
    FUNCTION Get() AS INTEGER
        RETURN 42
    END FUNCTION
END CLASS

CLASS Outer
    PUBLIC inner AS Inner
END CLASS

DIM o AS Outer = NEW Outer()
o.inner = NEW Inner()
PRINT o.inner.Get()   ' Error: unknown procedure 'o.inner.get'
```

**Workaround**: Use a temporary variable:

```basic
DIM tmp AS Inner = o.inner
PRINT tmp.Get()
```

---

## BUG-005: ARM64 BYREF Parameters Not Working

**Severity**: Critical
**Affects**: ARM64 Native Backend
**Status**: FIXED

**Fix**: Mismatch in vreg IDs between entry block parameter spilling and cross-block reload. In `LowerILToMIR.cpp`, the
entry block used `fb.ensureSpill(50000 + pi)` (parameter INDEX), but `LivenessAnalysis.cpp` used
`fb.ensureSpill(50000 + tempId)` (parameter ID). When param.id != pi, they allocated different spill slots. Fixed by
using `param.id` consistently in both places.

**Description**: BYREF parameters do not modify the original variable in ARM64 native code. The value passed remains
unchanged after the call.

**Reproduction**:

```basic
SUB Double(BYREF x AS INTEGER)
    x = x * 2
END SUB

DIM n AS INTEGER = 5
Double(n)
PRINT n
```

**VM Output**: `10` (correct)
**Native Output**: `5` (wrong - value not modified)

**Also affects**: BYREF with SINGLE/DOUBLE types.

**Workaround**: Use return values from functions instead of BYREF output parameters.

---

## BUG-006: ARM64 Multiple BYREF Parameters Crash

**Severity**: Critical
**Affects**: ARM64 Native Backend
**Status**: FIXED

**Fix**: Same root cause as BUG-005. The parameter spill slot ID mismatch caused multiple BYREF parameters to use
wrong/overlapping stack locations, leading to memory corruption and SIGSEGV. Fixed by the same change to use `param.id`
instead of `pi` (parameter index).

**Description**: Using multiple BYREF parameters in a single SUB causes the native binary to crash (SIGSEGV).

**Reproduction**:

```basic
SUB DivMod(a AS INTEGER, b AS INTEGER, BYREF q AS INTEGER, BYREF r AS INTEGER)
    q = a \ b
    r = a MOD b
END SUB

DIM quot AS INTEGER
DIM remain AS INTEGER
DivMod(17, 5, quot, remain)
PRINT quot
PRINT remain
```

**VM Output**: `3` and `2` (correct)
**Native Output**: CRASH (exit 139 - SIGSEGV)

**Workaround**: Use separate function calls with return values instead.

---

## BUG-007: ARM64 Floating-Point Arithmetic Results Are Zero

**Severity**: Critical
**Affects**: ARM64 Native Backend
**Status**: FIXED

**Fix**: In `lowerFpArithmetic` and `lowerFpCompare`, integer operands (like `2` in `fmul %t4, 2`) were being loaded
into GPR registers but used as FPR registers. Fixed by checking the returned register class from
`materializeValueToVReg` and emitting `SCvtF` (signed convert to float) instructions when operands are GPR instead of
FPR.

**Description**: Floating-point arithmetic (SINGLE or DOUBLE) produces 0 when the result is used (stored to a variable
or directly printed via expression). Literal assignments work correctly.

**Reproduction**:

```basic
DIM d AS DOUBLE = 10.0
DIM result AS DOUBLE = d * 2.0   ' Storing computed result
PRINT result
```

**VM Output**: `20` (correct)
**Native Output**: `0` (wrong)

**What works**:

- `DIM d AS DOUBLE = 3.14` then `PRINT d` - works (literal)
- `d = 6.0` (reassigning literal) - works

**What fails**:

- `DIM b AS DOUBLE = a * 2.0` - fails (computed result stored)
- `PRINT a * 2.0` - fails (computed result used directly)
- Same issue with SINGLE type

**Workaround**: Perform floating-point calculations in the VM, not native code.

---

## BUG-008: VM LONG Array Arithmetic Overflow

**Severity**: Medium
**Affects**: VM (not ARM64-specific)
**Status**: FIXED

**Fix**: Created new `rt_arr_i64_*` runtime functions for 64-bit integer arrays and updated all frontend code to use
these instead of `rt_arr_i32_*` for integer arrays. This includes:

- New runtime files: `rt_array_i64.c/h` with i64 element storage
- Updated frontend lowering (DIM, REDIM, array get/set, len, retain/release)
- Added VM runtime descriptors, signatures, and handlers for the new functions
- Updated golden tests to expect `rt_arr_i64_*` extern declarations

**Description**: LONG arithmetic involving arrays overflows in VM as if using 32-bit integers, while ARM64 native
correctly uses 64-bit.

**Reproduction**:

```basic
DIM arr(5) AS LONG
arr(0) = 1000000000
arr(1) = 2000000000
arr(2) = arr(0) + arr(1)
PRINT arr(2)
```

**VM Output**: `-1294967296` (wrong - 32-bit overflow)
**Native Output**: `3000000000` (correct)

**Note**: This is the opposite of most bugs - VM is wrong, Native is correct!

---

## BUG-009: SINGLE Arrays Broken (VM + ARM64)

**Severity**: Critical
**Affects**: Both VM and ARM64 Native
**Status**: FIXED

**Fix**: Created new `rt_arr_f64_*` runtime functions (rt_arr_f64_new, rt_arr_f64_get, rt_arr_f64_set, etc.) for 64-bit
float arrays. Updated frontend lowering to detect float array types (SINGLE/DOUBLE) and use the f64 array functions
instead of i64. Also updated `rt_arr_i64_len`, `rt_arr_i64_retain`, and `rt_arr_i64_release` to accept both I64 and F64
element kinds via a relaxed assertion, since len/retain/release operations don't depend on element type.

**Description**: Arrays of SINGLE type produce wrong values in VM and crash in ARM64 native.

**Reproduction**:

```basic
DIM arr(3) AS SINGLE
arr(0) = 1.5
arr(1) = 2.5
arr(2) = 3.5
PRINT arr(0)
PRINT arr(1)
PRINT arr(2)
```

**Expected**: `1.5`, `2.5`, `3.5`
**VM Output**: `2`, `2`, `4` (completely wrong)
**Native Output**: CRASH (exit 139 - SIGSEGV)

---

## BUG-010: Class SINGLE Fields Broken in ARM64

**Severity**: High
**Affects**: ARM64 Native Backend
**Status**: FIXED

**Fix**: Added new MIR opcodes `LdrFprBaseImm` and `StrFprBaseImm` for loading/storing floats from arbitrary base
registers (heap/global). Updated the Store/Load handlers in `OpcodeDispatch.cpp` to detect F64 types and use the FPR
variants instead of GPR variants. The existing code used `LdrRegBaseImm`/`StrRegBaseImm` (which emit `ldr xN`/`str xN`)
for all base-register accesses regardless of type, causing float values to be stored/loaded as integers.

**Description**: SINGLE fields in classes produce 0 or wrong values in ARM64 native. The VM works correctly for simple
cases but arithmetic in methods fails.

**Reproduction**:

```basic
CLASS Data
    PUBLIC value AS SINGLE
END CLASS

DIM d AS Data = NEW Data()
d.value = 3.14
PRINT d.value
```

**VM Output**: `3.14` (correct)
**Native Output**: `0` (wrong)

---

## Tests That Pass (ARM64 Backend Working)

The following features were tested and work correctly in both VM and ARM64 native:

| Feature                                                | Test Status                             |
|--------------------------------------------------------|-----------------------------------------|
| Basic PRINT                                            | PASS                                    |
| Integer variables                                      | PASS                                    |
| Arithmetic (+, -, *, /)                                | PASS                                    |
| IF/ELSE                                                | PASS                                    |
| FOR loops                                              | PASS                                    |
| WHILE loops                                            | PASS                                    |
| 1D arrays                                              | PASS                                    |
| Arrays with loops                                      | PASS                                    |
| Simple functions                                       | PASS                                    |
| SUB procedures                                         | PASS                                    |
| Recursion (factorial)                                  | PASS                                    |
| Strings and LEN()                                      | PASS                                    |
| Simple classes                                         | PASS                                    |
| Classes with constructors                              | PASS                                    |
| Classes with methods                                   | PASS                                    |
| Arrays of objects                                      | PASS                                    |
| Nested loops                                           | PASS                                    |
| 2D arrays INSIDE classes                               | PASS                                    |
| SELECT CASE                                            | PASS                                    |
| Floating point literals                                | PASS                                    |
| Floating point arithmetic                              | PASS (BUG-007 fixed)                    |
| String concatenation                                   | PASS                                    |
| Object passing to functions                            | PASS                                    |
| Function returning objects                             | PASS                                    |
| Object references (linked list)                        | PASS                                    |
| Board-like structures (1D array of objects)            | PASS                                    |
| Array passing to functions                             | PASS                                    |
| Modifying arrays in functions                          | PASS                                    |
| String comparison                                      | PASS                                    |
| CHR$()                                                 | PASS                                    |
| COLOR statement                                        | PASS                                    |
| Module-level variables                                 | PASS                                    |
| MOD operation                                          | PASS                                    |
| Math functions (ABS, SQR, INT)                         | PASS                                    |
| String functions (LEFT$, RIGHT$, MID$, UCASE$, LCASE$) | PASS                                    |
| Nested classes with object fields                      | PASS                                    |
| Direct nested method calls (ME.field.Method())         | PASS                                    |
| RND() and RANDOMIZE                                    | PASS                                    |
| DO WHILE / DO UNTIL loops                              | PASS                                    |
| EXIT FOR                                               | PASS                                    |
| Boolean operations (AND, OR, NOT)                      | PASS                                    |
| String comparison (<, >, =, <>)                        | PASS                                    |
| INSTR()                                                | PASS                                    |
| Nested function calls                                  | PASS                                    |
| Complex expression precedence                          | PASS                                    |
| Negative numbers and ABS()                             | PASS                                    |
| Integer division (\ and MOD)                           | PASS                                    |
| Counter class pattern                                  | PASS                                    |
| Deep recursion (Fibonacci)                             | PASS                                    |
| LONG integer type                                      | PASS                                    |
| Multiple classes interacting                           | PASS                                    |
| BYREF parameters                                       | PASS (BUG-005, BUG-006 fixed)           |
| BYVAL parameters (default)                             | PASS                                    |
| Simple DOUBLE/SINGLE variables                         | PASS                                    |

---

## Chess/vTris Demo Status

All demos were affected by CONST-in-class-methods bugs. Both BUG-002 and BUG-003 have been fixed.

**frogger**: Works as native
**chess**: Works as native (BUG-002/BUG-003 fixed)
**vTris**: Works as native (BUG-002/BUG-003 fixed)

---

## Recommendations

All 10 bugs documented in this report have been fixed. No open recommendations remain from this session.

See `viper_bugs.md` for the current list of open issues.

---

## Root Cause Analysis

### BUG-001: Module-Level 2D Arrays

**Location**: Frontend IL generation
**Root Cause**: The IL verifier reports "use before def of %4" in `dim_len_cont1`. The 2D array dimension calculation
uses `%t4` and `%t6` in `imul.ovf %t4 %t6`, but `%t4` is defined in a different basic block (`dim_len_cont`) and not
visible from `dim_len_cont1`. This is a phi-elimination or block-ordering issue in the frontend's 2D array lowering.

### BUG-002: CONST in Class Methods

**Location**: Frontend constant lookup
**Root Cause**: In class method `MYCLASS.SETVAL`, the IL shows:

```
%t2 = alloca 8           ; Fresh local variable
%t3 = load i64, %t2      ; Load UNINITIALIZED memory
store i64, %t5, %t3      ; Store garbage to field
```

The constant `VAL` lookup creates a new alloca instead of returning the constant value `5`. The constant symbol table
scope doesn't include class method contexts.

### BUG-003: CONST Garbage in ARM64

**Location**: ARM64 codegen + Frontend
**Root Cause**: Combination of BUG-002 (constant lookup fails) and ARM64's handling of uninitialized stack slots. The
alloca memory contains random stack values that differ between runs.

### BUG-005/006: BYREF Parameters

**Location**: ARM64 register allocator (`RegAllocLinear.cpp`)
**Root Cause**: The ptr parameter is stored at the wrong stack offset:

```asm
str x0, [x29, #-16]      ; Store pointer arg at offset -16
ldr x10, [x29, #-8]      ; BUG! Load from offset -8 (WRONG!)
ldr x11, [x29, #-8]      ; Same wrong offset
```

The register allocator assigns incorrect stack slots for ptr-type parameters. The stored location (`-16`) doesn't match
the loaded location (`-8`).

### BUG-007: Float Arithmetic Returns Zero

**Location**: ARM64 instruction selection (`OpcodeDispatch.cpp` or `InstrLowering.cpp`)
**Root Cause**: Integer literals used in float operations are loaded into integer registers instead of being converted:

```asm
ldr d9, [x29, #-16]      ; Load 10.0 into d9 (correct)
mov x11, #2              ; Load 2 into INTEGER register x11
fmul d10, d9, d11        ; BUG! d11 is UNINITIALIZED (x11 â‰  d11)
```

The codegen doesn't convert integer literals to float before `fmul`. It should use `scvtf d11, x11` or load a float
constant directly.

### BUG-008: LONG Array Overflow in VM

**Location**: Frontend array type selection
**Root Cause**: LONG arrays use `rt_arr_i32_*` runtime functions instead of `rt_arr_i64_*`:

```
extern @rt_arr_i32_new(i64) -> ptr   ; Should be rt_arr_i64_new!
call @rt_arr_i32_set(%t6, 0, 1000000000)
```

The frontend selects i32 array functions for LONG type instead of i64.

### BUG-009: SINGLE Arrays

**Location**: Frontend type lowering
**Root Cause**: SINGLE arrays are lowered to i32 arrays with float-to-int conversion:

```
extern @rt_arr_i32_new(i64) -> ptr   ; Wrong! Should be f32 array
%t14 = cast.fp_to_si.rte.chk 1.5     ; Converting 1.5 to int before storing!
call @rt_arr_i32_set(%t6, 0, %t14)
```

The frontend converts SINGLE values to integers before storing. There's no `rt_arr_f32_*` runtime functions being used.

### BUG-010: Class SINGLE Fields in ARM64

**Location**: ARM64 float register handling
**Root Cause**: Float values are stored/loaded using integer registers:

```asm
fmov d8, x23             ; Float 3.14 loaded into d8 (correct)
str x24, [x22, #0]       ; BUG! Storing x24 (UNINITIALIZED) instead of d8!
...
ldr x27, [x26, #0]       ; Loading as INTEGER instead of float
mov x0, x27              ; Passing in x0, but rt_print_f64 expects d0!
```

The codegen uses `str xN` for float stores (should be `str dN`) and `ldr xN` for float loads (should be `ldr dN`).

---

## Code Locations for Fixes

| Bug         | Component                           | File(s)                                  |
|-------------|-------------------------------------|------------------------------------------|
| BUG-001     | Frontend 2D array lowering          | `src/frontends/basic/lower/`             |
| BUG-002     | Constant scope resolution           | `src/frontends/basic/lower/`             |
| BUG-005/006 | Register allocator ptr handling     | `src/codegen/aarch64/RegAllocLinear.cpp` |
| BUG-007     | Float literal instruction selection | `src/codegen/aarch64/OpcodeDispatch.cpp` |
| BUG-008     | Array type selection                | `src/frontends/basic/lower/`             |
| BUG-009     | SINGLE array type lowering          | `src/frontends/basic/lower/`             |
| BUG-010     | Float store/load emission           | `src/codegen/aarch64/AsmEmitter.cpp`     |

---

## Test Environment

- Platform: macOS ARM64 (Darwin 25.1.0)
- Compiler: Apple Clang
- Date: December 5, 2025
