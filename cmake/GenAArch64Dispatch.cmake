#
# Generate AArch64 OpcodeDispatch.inc from JSON spec using CMake's JSON support.
# Inputs (passed via -D):
#   SPEC_FILE   - path to tools/spec/aarch64_encodings.json
#   OUTPUT_FILE - path to write generated OpcodeDispatch.inc
#

if(NOT DEFINED SPEC_FILE)
  message(FATAL_ERROR "GenAArch64Dispatch.cmake: SPEC_FILE is not set")
endif()
if(NOT DEFINED OUTPUT_FILE)
  message(FATAL_ERROR "GenAArch64Dispatch.cmake: OUTPUT_FILE is not set")
endif()

file(READ "${SPEC_FILE}" _JSON_TEXT)

function(_append var text)
  set(${var} "${${var}}${text}\n" PARENT_SCOPE)
endfunction()

set(_out "")
_append(_out "//===----------------------------------------------------------------------===//")
_append(_out "//")
_append(_out "// Part of the Viper project, under the GNU GPL v3.")
_append(_out "// See LICENSE for license information.")
_append(_out "//")
_append(_out "//===----------------------------------------------------------------------===//")
_append(_out "//")
_append(_out "// IMPORTANT: This file is auto-generated. Do not edit manually.")
_append(_out "//")
_append(_out "// File: codegen/aarch64/generated/OpcodeDispatch.inc")
_append(_out "// Purpose: Opcode dispatch switch logic for AArch64 instruction emission.")
_append(_out "//")
_append(_out "// Generator: cmake/GenAArch64Dispatch.cmake")
_append(_out "// Source: tools/spec/aarch64_encodings.json")
_append(_out "// Regenerate: cmake --build build (automatic on spec change)")
_append(_out "//")
_append(_out "// Description: Contains the switch statement body that maps MOpcode enum")
_append(_out "//              values to their corresponding emit* function calls.")
_append(_out "//")
_append(_out "// Links: docs/il-guide.md#reference, codegen/aarch64/AsmEmitter.cpp")
_append(_out "//")
_append(_out "//===----------------------------------------------------------------------===//")
_append(_out "")
_append(_out "using K = MOpcode;")
_append(_out "auto reg = [](const MOperand &op)")
_append(_out "{")
_append(_out "    assert(op.kind == MOperand::Kind::Reg && \"expected reg operand\");")
_append(_out "    assert(op.reg.isPhys && \"unallocated vreg reached emitter\");")
_append(_out "    return static_cast<PhysReg>(op.reg.idOrPhys);")
_append(_out "};")
_append(_out "auto imm = [](const MOperand &op) { return op.imm; };")
_append(_out "")
_append(_out "switch (mi.opc)")
_append(_out "{")

string(JSON _NOPS LENGTH "${_JSON_TEXT}" opcodes)
math(EXPR _LAST "${_NOPS} - 1")
foreach(_i RANGE 0 ${_LAST})
  string(JSON _OP GET "${_JSON_TEXT}" opcodes ${_i})
  string(JSON _ENUM GET "${_OP}" enum)

  # Special cases
  if(_ENUM STREQUAL "MovRI")
    _append(_out "    case K::${_ENUM}:")
    _append(_out "    {")
    _append(_out "        const long long v = imm(mi.ops[1]);")
    _append(_out "        if (v >= 0 && v <= 65535)")
    _append(_out "            emitMovRI(os, reg(mi.ops[0]), v);")
    _append(_out "        else")
    _append(_out "            emitMovImm64(os, reg(mi.ops[0]), static_cast<unsigned long long>(v));")
    _append(_out "        break;")
    _append(_out "    }")
    continue()
  elseif(_ENUM STREQUAL "FMovRI")
    _append(_out "    case K::${_ENUM}:")
    _append(_out "    {")
    _append(_out "        const long long bits = imm(mi.ops[1]);")
    _append(_out "        double dv;")
    _append(_out "        static_assert(sizeof(long long) == sizeof(double), \"size\");")
    _append(_out "        std::memcpy(&dv, &bits, sizeof(double));")
    _append(_out "        emitFMovRI(os, reg(mi.ops[0]), dv);")
    _append(_out "        break;")
    _append(_out "    }")
    continue()
  elseif(_ENUM STREQUAL "Br")
    _append(_out "    case K::${_ENUM}:")
    _append(_out "        os << \"  b \" << mi.ops[0].label << \"\\n\";")
    _append(_out "        break;")
    continue()
  elseif(_ENUM STREQUAL "BCond")
    _append(_out "    case K::${_ENUM}:")
    _append(_out "        os << \"  b.\" << mi.ops[0].cond << \" \" << mi.ops[1].label << \"\\n\";")
    _append(_out "        break;")
    continue()
  elseif(_ENUM STREQUAL "Bl")
    _append(_out "    case K::${_ENUM}:")
    _append(_out "        os << \"  bl \" << mangleCallTarget(mi.ops[0].label) << \"\\n\";")
    _append(_out "        break;")
    continue()
  elseif(_ENUM STREQUAL "AdrPage")
    _append(_out "    case K::${_ENUM}:")
    _append(_out "        os << \"  adrp \" << rn(reg(mi.ops[0])) << \", \" << mangleSymbol(mi.ops[1].label) << \"@PAGE\\n\";")
    _append(_out "        break;")
    continue()
  elseif(_ENUM STREQUAL "AddPageOff")
    _append(_out "    case K::${_ENUM}:")
    _append(_out "        os << \"  add \" << rn(reg(mi.ops[0])) << \", \" << rn(reg(mi.ops[1])) << \", \"")
    _append(_out "           << mangleSymbol(mi.ops[2].label) << \"@PAGEOFF\\n\";")
    _append(_out "        break;")
    continue()
  elseif(_ENUM STREQUAL "Cset")
    _append(_out "    case K::${_ENUM}:")
    _append(_out "        emitCset(os, reg(mi.ops[0]), mi.ops[1].cond);")
    _append(_out "        break;")
    continue()
  endif()

  # Default: emitX(...) pattern with type-aware arg extraction.
  set(_BASE "${_ENUM}")
  if(_ENUM STREQUAL "SubSpImm")
    set(_BASE "SubSp")
  elseif(_ENUM STREQUAL "AddSpImm")
    set(_BASE "AddSp")
  elseif(_ENUM STREQUAL "StrRegSpImm")
    set(_BASE "StrToSp")
  elseif(_ENUM STREQUAL "StrFprSpImm")
    set(_BASE "StrFprToSp")
  elseif(_ENUM STREQUAL "LdrRegFpImm")
    set(_BASE "LdrFromFp")
  elseif(_ENUM STREQUAL "StrRegFpImm")
    set(_BASE "StrToFp")
  elseif(_ENUM STREQUAL "LdrFprFpImm")
    set(_BASE "LdrFprFromFp")
  elseif(_ENUM STREQUAL "StrFprFpImm")
    set(_BASE "StrFprToFp")
  elseif(_ENUM STREQUAL "LdrRegBaseImm")
    set(_BASE "LdrFromBase")
  elseif(_ENUM STREQUAL "StrRegBaseImm")
    set(_BASE "StrToBase")
  endif()

  string(JSON _OPLEN LENGTH "${_OP}" operands)
  set(_ARGS "")
  if(_OPLEN GREATER 0)
    math(EXPR _OLAST "${_OPLEN} - 1")
    foreach(_j RANGE 0 ${_OLAST})
      string(JSON _SPEC GET "${_OP}" operands ${_j})
      # _SPEC is like "dst:reg"; extract type after colon
      string(REGEX REPLACE "^[^:]*:" "" _TYPE "${_SPEC}")
      if(_TYPE STREQUAL "reg" OR _TYPE STREQUAL "gpr" OR _TYPE STREQUAL "fpr")
        list(APPEND _ARGS "reg(mi.ops[${_j}])")
      elseif(_TYPE STREQUAL "imm" OR _TYPE STREQUAL "f64")
        list(APPEND _ARGS "imm(mi.ops[${_j}])")
      elseif(_TYPE STREQUAL "cond")
        list(APPEND _ARGS "mi.ops[${_j}].cond")
      elseif(_TYPE STREQUAL "label")
        list(APPEND _ARGS "mi.ops[${_j}].label")
      else()
        # Default fallback: pass as immediate
        list(APPEND _ARGS "imm(mi.ops[${_j}])")
      endif()
    endforeach()
    list(JOIN _ARGS ", " _ARG_STR)
  else()
    set(_ARG_STR "")
  endif()

  _append(_out "    case K::${_ENUM}:")
  if(_ARG_STR STREQUAL "")
    _append(_out "        emit${_BASE}(os);")
  else()
    _append(_out "        emit${_BASE}(os, ${_ARG_STR});")
  endif()
  _append(_out "        break;")
endforeach()

_append(_out "    default:")
_append(_out "        os << \"  # <unknown opcode>\\n\";")
_append(_out "        break;")
_append(_out "}")

get_filename_component(_OUT_DIR "${OUTPUT_FILE}" DIRECTORY)
file(MAKE_DIRECTORY "${_OUT_DIR}")
file(WRITE "${OUTPUT_FILE}" "${_out}")

