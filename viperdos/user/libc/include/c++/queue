// -*- C++ -*-
// ViperDOS C++ Standard Library - queue and priority_queue
// Container adapters providing queue and priority queue functionality

#ifndef _VIPER_QUEUE
#define _VIPER_QUEUE

#include "algorithm"
#include "deque"
#include "functional"
#include "initializer_list"
#include "vector"

namespace std {

// =============================================================================
// queue - FIFO queue adapter
// =============================================================================

template <typename T, typename Container = deque<T>> class queue {
  public:
    using container_type = Container;
    using value_type = typename Container::value_type;
    using size_type = typename Container::size_type;
    using reference = typename Container::reference;
    using const_reference = typename Container::const_reference;

  protected:
    Container c;

  public:
    // Constructors
    queue() : c() {}

    explicit queue(const Container &cont) : c(cont) {}

    explicit queue(Container &&cont) : c(std::move(cont)) {}

    queue(const queue &other) : c(other.c) {}

    queue(queue &&other) noexcept : c(std::move(other.c)) {}

    template <typename InputIt> queue(InputIt first, InputIt last) : c(first, last) {}

    // Assignment
    queue &operator=(const queue &other) {
        c = other.c;
        return *this;
    }

    queue &operator=(queue &&other) noexcept {
        c = std::move(other.c);
        return *this;
    }

    // Element access
    reference front() {
        return c.front();
    }

    const_reference front() const {
        return c.front();
    }

    reference back() {
        return c.back();
    }

    const_reference back() const {
        return c.back();
    }

    // Capacity
    bool empty() const {
        return c.empty();
    }

    size_type size() const {
        return c.size();
    }

    // Modifiers
    void push(const value_type &value) {
        c.push_back(value);
    }

    void push(value_type &&value) {
        c.push_back(std::move(value));
    }

    template <typename... Args> decltype(auto) emplace(Args &&...args) {
        return c.emplace_back(std::forward<Args>(args)...);
    }

    void pop() {
        c.pop_front();
    }

    void swap(queue &other) noexcept {
        using std::swap;
        swap(c, other.c);
    }

    // Comparison operators need access to c
    template <typename T2, typename C2>
    friend bool operator==(const queue<T2, C2> &, const queue<T2, C2> &);

    template <typename T2, typename C2>
    friend bool operator<(const queue<T2, C2> &, const queue<T2, C2> &);
};

// Comparison operators
template <typename T, typename Container>
bool operator==(const queue<T, Container> &lhs, const queue<T, Container> &rhs) {
    return lhs.c == rhs.c;
}

template <typename T, typename Container>
bool operator!=(const queue<T, Container> &lhs, const queue<T, Container> &rhs) {
    return !(lhs == rhs);
}

template <typename T, typename Container>
bool operator<(const queue<T, Container> &lhs, const queue<T, Container> &rhs) {
    return lhs.c < rhs.c;
}

template <typename T, typename Container>
bool operator<=(const queue<T, Container> &lhs, const queue<T, Container> &rhs) {
    return !(rhs < lhs);
}

template <typename T, typename Container>
bool operator>(const queue<T, Container> &lhs, const queue<T, Container> &rhs) {
    return rhs < lhs;
}

template <typename T, typename Container>
bool operator>=(const queue<T, Container> &lhs, const queue<T, Container> &rhs) {
    return !(lhs < rhs);
}

template <typename T, typename Container>
void swap(queue<T, Container> &lhs, queue<T, Container> &rhs) noexcept {
    lhs.swap(rhs);
}

// =============================================================================
// priority_queue - heap-based priority queue
// =============================================================================

template <typename T,
          typename Container = vector<T>,
          typename Compare = less<typename Container::value_type>>
class priority_queue {
  public:
    using container_type = Container;
    using value_compare = Compare;
    using value_type = typename Container::value_type;
    using size_type = typename Container::size_type;
    using reference = typename Container::reference;
    using const_reference = typename Container::const_reference;

  protected:
    Container c;
    Compare comp;

    // Heap operations
    void sift_up(size_type index) {
        while (index > 0) {
            size_type parent = (index - 1) / 2;
            if (!comp(c[parent], c[index]))
                break;
            std::swap(c[parent], c[index]);
            index = parent;
        }
    }

    void sift_down(size_type index) {
        size_type size = c.size();
        while (true) {
            size_type largest = index;
            size_type left = 2 * index + 1;
            size_type right = 2 * index + 2;

            if (left < size && comp(c[largest], c[left]))
                largest = left;
            if (right < size && comp(c[largest], c[right]))
                largest = right;

            if (largest == index)
                break;

            std::swap(c[index], c[largest]);
            index = largest;
        }
    }

    void heapify() {
        if (c.size() < 2)
            return;
        for (size_type i = c.size() / 2; i-- > 0;) {
            sift_down(i);
        }
    }

  public:
    // Constructors
    priority_queue() : c(), comp() {}

    explicit priority_queue(const Compare &compare) : c(), comp(compare) {}

    priority_queue(const Compare &compare, const Container &cont) : c(cont), comp(compare) {
        heapify();
    }

    priority_queue(const Compare &compare, Container &&cont) : c(std::move(cont)), comp(compare) {
        heapify();
    }

    priority_queue(const priority_queue &other) : c(other.c), comp(other.comp) {}

    priority_queue(priority_queue &&other) noexcept
        : c(std::move(other.c)), comp(std::move(other.comp)) {}

    template <typename InputIt>
    priority_queue(InputIt first, InputIt last, const Compare &compare = Compare())
        : c(first, last), comp(compare) {
        heapify();
    }

    template <typename InputIt>
    priority_queue(InputIt first, InputIt last, const Compare &compare, const Container &cont)
        : c(cont), comp(compare) {
        c.insert(c.end(), first, last);
        heapify();
    }

    template <typename InputIt>
    priority_queue(InputIt first, InputIt last, const Compare &compare, Container &&cont)
        : c(std::move(cont)), comp(compare) {
        c.insert(c.end(), first, last);
        heapify();
    }

    // Assignment
    priority_queue &operator=(const priority_queue &other) {
        c = other.c;
        comp = other.comp;
        return *this;
    }

    priority_queue &operator=(priority_queue &&other) noexcept {
        c = std::move(other.c);
        comp = std::move(other.comp);
        return *this;
    }

    // Element access
    const_reference top() const {
        return c.front();
    }

    // Capacity
    bool empty() const {
        return c.empty();
    }

    size_type size() const {
        return c.size();
    }

    // Modifiers
    void push(const value_type &value) {
        c.push_back(value);
        sift_up(c.size() - 1);
    }

    void push(value_type &&value) {
        c.push_back(std::move(value));
        sift_up(c.size() - 1);
    }

    template <typename... Args> void emplace(Args &&...args) {
        c.emplace_back(std::forward<Args>(args)...);
        sift_up(c.size() - 1);
    }

    void pop() {
        if (c.empty())
            return;
        c[0] = std::move(c.back());
        c.pop_back();
        if (!c.empty()) {
            sift_down(0);
        }
    }

    void swap(priority_queue &other) noexcept {
        using std::swap;
        swap(c, other.c);
        swap(comp, other.comp);
    }
};

template <typename T, typename Container, typename Compare>
void swap(priority_queue<T, Container, Compare> &lhs,
          priority_queue<T, Container, Compare> &rhs) noexcept {
    lhs.swap(rhs);
}

// Deduction guides (C++17)
template <typename Container> queue(Container) -> queue<typename Container::value_type, Container>;

template <typename Container, typename Compare>
priority_queue(Compare, Container)
    -> priority_queue<typename Container::value_type, Container, Compare>;

} // namespace std

#endif // _VIPER_QUEUE
