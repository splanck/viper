/*
 * ViperDOS C++ Standard Library - map
 * Sorted associative container using key-value pairs
 */

#ifndef _LIBCPP_MAP
#define _LIBCPP_MAP

#include "functional"
#include "initializer_list"
#include "iterator"
#include "memory"
#include "utility"

namespace std {

/* Red-black tree node colors */
namespace detail {

enum class rb_color { red, black };

/* Red-black tree node */
template <class Key, class Value> struct rb_node {
    pair<const Key, Value> data;
    rb_node *parent;
    rb_node *left;
    rb_node *right;
    rb_color color;

    template <class... Args>
    rb_node(Args &&...args)
        : data(forward<Args>(args)...), parent(nullptr), left(nullptr), right(nullptr),
          color(rb_color::red) {}
};

/* Red-black tree implementation */
template <class Key, class Value, class Compare, class Allocator> class rb_tree {
  public:
    using key_type = Key;
    using mapped_type = Value;
    using value_type = pair<const Key, Value>;
    using key_compare = Compare;
    using allocator_type = Allocator;
    using node_type = rb_node<Key, Value>;
    using size_type = unsigned long;

  private:
    using node_allocator = typename allocator_traits<Allocator>::template rebind_alloc<node_type>;

    node_type *root_;
    node_type *nil_; /* Sentinel node */
    size_type size_;
    Compare comp_;
    node_allocator alloc_;

    /* Create sentinel node */
    void init_nil() {
        /* Allocate without constructing pair */
        nil_ = static_cast<node_type *>(::operator new(sizeof(node_type)));
        nil_->parent = nil_;
        nil_->left = nil_;
        nil_->right = nil_;
        nil_->color = rb_color::black;
        root_ = nil_;
    }

    /* Destroy sentinel */
    void destroy_nil() {
        ::operator delete(nil_);
        nil_ = nullptr;
    }

    /* Left rotation */
    void rotate_left(node_type *x) {
        node_type *y = x->right;
        x->right = y->left;
        if (y->left != nil_) {
            y->left->parent = x;
        }
        y->parent = x->parent;
        if (x->parent == nil_) {
            root_ = y;
        } else if (x == x->parent->left) {
            x->parent->left = y;
        } else {
            x->parent->right = y;
        }
        y->left = x;
        x->parent = y;
    }

    /* Right rotation */
    void rotate_right(node_type *x) {
        node_type *y = x->left;
        x->left = y->right;
        if (y->right != nil_) {
            y->right->parent = x;
        }
        y->parent = x->parent;
        if (x->parent == nil_) {
            root_ = y;
        } else if (x == x->parent->right) {
            x->parent->right = y;
        } else {
            x->parent->left = y;
        }
        y->right = x;
        x->parent = y;
    }

    /* Fix tree after insertion */
    void insert_fixup(node_type *z) {
        while (z->parent->color == rb_color::red) {
            if (z->parent == z->parent->parent->left) {
                node_type *y = z->parent->parent->right;
                if (y->color == rb_color::red) {
                    z->parent->color = rb_color::black;
                    y->color = rb_color::black;
                    z->parent->parent->color = rb_color::red;
                    z = z->parent->parent;
                } else {
                    if (z == z->parent->right) {
                        z = z->parent;
                        rotate_left(z);
                    }
                    z->parent->color = rb_color::black;
                    z->parent->parent->color = rb_color::red;
                    rotate_right(z->parent->parent);
                }
            } else {
                node_type *y = z->parent->parent->left;
                if (y->color == rb_color::red) {
                    z->parent->color = rb_color::black;
                    y->color = rb_color::black;
                    z->parent->parent->color = rb_color::red;
                    z = z->parent->parent;
                } else {
                    if (z == z->parent->left) {
                        z = z->parent;
                        rotate_right(z);
                    }
                    z->parent->color = rb_color::black;
                    z->parent->parent->color = rb_color::red;
                    rotate_left(z->parent->parent);
                }
            }
        }
        root_->color = rb_color::black;
    }

    /* Transplant subtree */
    void transplant(node_type *u, node_type *v) {
        if (u->parent == nil_) {
            root_ = v;
        } else if (u == u->parent->left) {
            u->parent->left = v;
        } else {
            u->parent->right = v;
        }
        v->parent = u->parent;
    }

    /* Fix tree after deletion */
    void delete_fixup(node_type *x) {
        while (x != root_ && x->color == rb_color::black) {
            if (x == x->parent->left) {
                node_type *w = x->parent->right;
                if (w->color == rb_color::red) {
                    w->color = rb_color::black;
                    x->parent->color = rb_color::red;
                    rotate_left(x->parent);
                    w = x->parent->right;
                }
                if (w->left->color == rb_color::black && w->right->color == rb_color::black) {
                    w->color = rb_color::red;
                    x = x->parent;
                } else {
                    if (w->right->color == rb_color::black) {
                        w->left->color = rb_color::black;
                        w->color = rb_color::red;
                        rotate_right(w);
                        w = x->parent->right;
                    }
                    w->color = x->parent->color;
                    x->parent->color = rb_color::black;
                    w->right->color = rb_color::black;
                    rotate_left(x->parent);
                    x = root_;
                }
            } else {
                node_type *w = x->parent->left;
                if (w->color == rb_color::red) {
                    w->color = rb_color::black;
                    x->parent->color = rb_color::red;
                    rotate_right(x->parent);
                    w = x->parent->left;
                }
                if (w->right->color == rb_color::black && w->left->color == rb_color::black) {
                    w->color = rb_color::red;
                    x = x->parent;
                } else {
                    if (w->left->color == rb_color::black) {
                        w->right->color = rb_color::black;
                        w->color = rb_color::red;
                        rotate_left(w);
                        w = x->parent->left;
                    }
                    w->color = x->parent->color;
                    x->parent->color = rb_color::black;
                    w->left->color = rb_color::black;
                    rotate_right(x->parent);
                    x = root_;
                }
            }
        }
        x->color = rb_color::black;
    }

    /* Find minimum in subtree */
    node_type *minimum(node_type *x) const {
        while (x->left != nil_) {
            x = x->left;
        }
        return x;
    }

    /* Find maximum in subtree */
    node_type *maximum(node_type *x) const {
        while (x->right != nil_) {
            x = x->right;
        }
        return x;
    }

    /* Destroy subtree */
    void destroy_tree(node_type *node) {
        if (node != nil_) {
            destroy_tree(node->left);
            destroy_tree(node->right);
            allocator_traits<node_allocator>::destroy(alloc_, node);
            allocator_traits<node_allocator>::deallocate(alloc_, node, 1);
        }
    }

    /* Copy subtree */
    node_type *copy_tree(node_type *src, node_type *src_nil, node_type *parent) {
        if (src == src_nil) {
            return nil_;
        }
        node_type *node = allocator_traits<node_allocator>::allocate(alloc_, 1);
        allocator_traits<node_allocator>::construct(alloc_, node, src->data);
        node->color = src->color;
        node->parent = parent;
        node->left = copy_tree(src->left, src_nil, node);
        node->right = copy_tree(src->right, src_nil, node);
        return node;
    }

  public:
    rb_tree() : root_(nullptr), nil_(nullptr), size_(0), comp_(), alloc_() {
        init_nil();
    }

    explicit rb_tree(const Compare &comp, const Allocator &alloc = Allocator())
        : root_(nullptr), nil_(nullptr), size_(0), comp_(comp), alloc_(alloc) {
        init_nil();
    }

    rb_tree(const rb_tree &other)
        : root_(nullptr), nil_(nullptr), size_(0), comp_(other.comp_), alloc_(other.alloc_) {
        init_nil();
        if (other.root_ != other.nil_) {
            root_ = copy_tree(other.root_, other.nil_, nil_);
            size_ = other.size_;
        }
    }

    rb_tree(rb_tree &&other) noexcept
        : root_(other.root_), nil_(other.nil_), size_(other.size_), comp_(move(other.comp_)),
          alloc_(move(other.alloc_)) {
        other.root_ = nullptr;
        other.nil_ = nullptr;
        other.size_ = 0;
        other.init_nil();
    }

    ~rb_tree() {
        clear();
        destroy_nil();
    }

    rb_tree &operator=(const rb_tree &other) {
        if (this != &other) {
            clear();
            comp_ = other.comp_;
            if (other.root_ != other.nil_) {
                root_ = copy_tree(other.root_, other.nil_, nil_);
                size_ = other.size_;
            }
        }
        return *this;
    }

    rb_tree &operator=(rb_tree &&other) noexcept {
        if (this != &other) {
            clear();
            destroy_nil();
            root_ = other.root_;
            nil_ = other.nil_;
            size_ = other.size_;
            comp_ = move(other.comp_);
            alloc_ = move(other.alloc_);
            other.root_ = nullptr;
            other.nil_ = nullptr;
            other.size_ = 0;
            other.init_nil();
        }
        return *this;
    }

    /* Insert a node */
    pair<node_type *, bool> insert(const value_type &value) {
        return insert_impl(value);
    }

    pair<node_type *, bool> insert(value_type &&value) {
        return insert_impl(move(value));
    }

    template <class P> pair<node_type *, bool> insert_impl(P &&value) {
        node_type *y = nil_;
        node_type *x = root_;

        while (x != nil_) {
            y = x;
            if (comp_(value.first, x->data.first)) {
                x = x->left;
            } else if (comp_(x->data.first, value.first)) {
                x = x->right;
            } else {
                /* Key already exists */
                return {x, false};
            }
        }

        node_type *z = allocator_traits<node_allocator>::allocate(alloc_, 1);
        allocator_traits<node_allocator>::construct(alloc_, z, forward<P>(value));
        z->parent = y;
        z->left = nil_;
        z->right = nil_;
        z->color = rb_color::red;

        if (y == nil_) {
            root_ = z;
        } else if (comp_(z->data.first, y->data.first)) {
            y->left = z;
        } else {
            y->right = z;
        }

        insert_fixup(z);
        ++size_;
        return {z, true};
    }

    /* Emplace a node */
    template <class... Args> pair<node_type *, bool> emplace(Args &&...args) {
        /* Create temporary pair to extract key */
        value_type temp(forward<Args>(args)...);
        return insert(move(temp));
    }

    /* Find a node by key */
    node_type *find(const Key &key) const {
        node_type *x = root_;
        while (x != nil_) {
            if (comp_(key, x->data.first)) {
                x = x->left;
            } else if (comp_(x->data.first, key)) {
                x = x->right;
            } else {
                return x;
            }
        }
        return nil_;
    }

    /* Erase a node */
    void erase(node_type *z) {
        if (z == nil_)
            return;

        node_type *y = z;
        node_type *x;
        rb_color y_original_color = y->color;

        if (z->left == nil_) {
            x = z->right;
            transplant(z, z->right);
        } else if (z->right == nil_) {
            x = z->left;
            transplant(z, z->left);
        } else {
            y = minimum(z->right);
            y_original_color = y->color;
            x = y->right;
            if (y->parent == z) {
                x->parent = y;
            } else {
                transplant(y, y->right);
                y->right = z->right;
                y->right->parent = y;
            }
            transplant(z, y);
            y->left = z->left;
            y->left->parent = y;
            y->color = z->color;
        }

        allocator_traits<node_allocator>::destroy(alloc_, z);
        allocator_traits<node_allocator>::deallocate(alloc_, z, 1);
        --size_;

        if (y_original_color == rb_color::black) {
            delete_fixup(x);
        }
    }

    /* Lower bound */
    node_type *lower_bound(const Key &key) const {
        node_type *x = root_;
        node_type *result = nil_;
        while (x != nil_) {
            if (!comp_(x->data.first, key)) {
                result = x;
                x = x->left;
            } else {
                x = x->right;
            }
        }
        return result;
    }

    /* Upper bound */
    node_type *upper_bound(const Key &key) const {
        node_type *x = root_;
        node_type *result = nil_;
        while (x != nil_) {
            if (comp_(key, x->data.first)) {
                result = x;
                x = x->left;
            } else {
                x = x->right;
            }
        }
        return result;
    }

    /* Clear all nodes */
    void clear() {
        destroy_tree(root_);
        root_ = nil_;
        size_ = 0;
    }

    /* Accessors */
    size_type size() const {
        return size_;
    }

    bool empty() const {
        return size_ == 0;
    }

    node_type *begin_node() const {
        return size_ == 0 ? nil_ : minimum(root_);
    }

    node_type *end_node() const {
        return nil_;
    }

    node_type *nil_node() const {
        return nil_;
    }

    /* Successor */
    node_type *successor(node_type *x) const {
        if (x->right != nil_) {
            return minimum(x->right);
        }
        node_type *y = x->parent;
        while (y != nil_ && x == y->right) {
            x = y;
            y = y->parent;
        }
        return y;
    }

    /* Predecessor */
    node_type *predecessor(node_type *x) const {
        if (x->left != nil_) {
            return maximum(x->left);
        }
        node_type *y = x->parent;
        while (y != nil_ && x == y->left) {
            x = y;
            y = y->parent;
        }
        return y;
    }

    void swap(rb_tree &other) noexcept {
        std::swap(root_, other.root_);
        std::swap(nil_, other.nil_);
        std::swap(size_, other.size_);
        std::swap(comp_, other.comp_);
        std::swap(alloc_, other.alloc_);
    }

    key_compare key_comp() const {
        return comp_;
    }

    allocator_type get_allocator() const {
        return allocator_type(alloc_);
    }
};

} // namespace detail

/* map class */
template <class Key,
          class T,
          class Compare = less<Key>,
          class Allocator = allocator<pair<const Key, T>>>
class map {
  public:
    using key_type = Key;
    using mapped_type = T;
    using value_type = pair<const Key, T>;
    using size_type = unsigned long;
    using difference_type = long;
    using key_compare = Compare;
    using allocator_type = Allocator;
    using reference = value_type &;
    using const_reference = const value_type &;
    using pointer = value_type *;
    using const_pointer = const value_type *;

  private:
    using tree_type = detail::rb_tree<Key, T, Compare, Allocator>;
    using node_type = typename tree_type::node_type;

    tree_type tree_;

  public:
    /* value_compare class */
    class value_compare {
        friend class map;

      protected:
        Compare comp;

        value_compare(Compare c) : comp(c) {}

      public:
        bool operator()(const value_type &lhs, const value_type &rhs) const {
            return comp(lhs.first, rhs.first);
        }
    };

    /* Iterator */
    class iterator {
        friend class map;
        node_type *node_;
        const tree_type *tree_;

        iterator(node_type *node, const tree_type *tree) : node_(node), tree_(tree) {}

      public:
        using iterator_category = bidirectional_iterator_tag;
        using value_type = pair<const Key, T>;
        using difference_type = long;
        using pointer = value_type *;
        using reference = value_type &;

        iterator() : node_(nullptr), tree_(nullptr) {}

        reference operator*() const {
            return node_->data;
        }

        pointer operator->() const {
            return &node_->data;
        }

        iterator &operator++() {
            node_ = tree_->successor(node_);
            return *this;
        }

        iterator operator++(int) {
            iterator tmp = *this;
            ++*this;
            return tmp;
        }

        iterator &operator--() {
            if (node_ == tree_->nil_node()) {
                /* End iterator - go to last element */
                node_ = tree_->end_node();
                if (node_ != tree_->nil_node()) {
                    while (node_->right != tree_->nil_node()) {
                        node_ = node_->right;
                    }
                }
            } else {
                node_ = tree_->predecessor(node_);
            }
            return *this;
        }

        iterator operator--(int) {
            iterator tmp = *this;
            --*this;
            return tmp;
        }

        bool operator==(const iterator &other) const {
            return node_ == other.node_;
        }

        bool operator!=(const iterator &other) const {
            return node_ != other.node_;
        }
    };

    /* const_iterator */
    class const_iterator {
        friend class map;
        const node_type *node_;
        const tree_type *tree_;

        const_iterator(const node_type *node, const tree_type *tree) : node_(node), tree_(tree) {}

      public:
        using iterator_category = bidirectional_iterator_tag;
        using value_type = pair<const Key, T>;
        using difference_type = long;
        using pointer = const value_type *;
        using reference = const value_type &;

        const_iterator() : node_(nullptr), tree_(nullptr) {}

        const_iterator(const iterator &it) : node_(it.node_), tree_(it.tree_) {}

        reference operator*() const {
            return node_->data;
        }

        pointer operator->() const {
            return &node_->data;
        }

        const_iterator &operator++() {
            node_ = tree_->successor(const_cast<node_type *>(node_));
            return *this;
        }

        const_iterator operator++(int) {
            const_iterator tmp = *this;
            ++*this;
            return tmp;
        }

        const_iterator &operator--() {
            node_ = tree_->predecessor(const_cast<node_type *>(node_));
            return *this;
        }

        const_iterator operator--(int) {
            const_iterator tmp = *this;
            --*this;
            return tmp;
        }

        bool operator==(const const_iterator &other) const {
            return node_ == other.node_;
        }

        bool operator!=(const const_iterator &other) const {
            return node_ != other.node_;
        }
    };

    using reverse_iterator = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;

    /* Constructors */
    map() : tree_() {}

    explicit map(const Compare &comp, const Allocator &alloc = Allocator()) : tree_(comp, alloc) {}

    explicit map(const Allocator &alloc) : tree_(Compare(), alloc) {}

    template <class InputIt>
    map(InputIt first,
        InputIt last,
        const Compare &comp = Compare(),
        const Allocator &alloc = Allocator())
        : tree_(comp, alloc) {
        for (; first != last; ++first) {
            insert(*first);
        }
    }

    map(const map &other) : tree_(other.tree_) {}

    map(map &&other) noexcept : tree_(move(other.tree_)) {}

    map(initializer_list<value_type> init,
        const Compare &comp = Compare(),
        const Allocator &alloc = Allocator())
        : tree_(comp, alloc) {
        for (const auto &v : init) {
            insert(v);
        }
    }

    ~map() = default;

    map &operator=(const map &other) {
        tree_ = other.tree_;
        return *this;
    }

    map &operator=(map &&other) noexcept {
        tree_ = move(other.tree_);
        return *this;
    }

    map &operator=(initializer_list<value_type> init) {
        clear();
        for (const auto &v : init) {
            insert(v);
        }
        return *this;
    }

    allocator_type get_allocator() const {
        return tree_.get_allocator();
    }

    /* Element access */
    T &at(const Key &key) {
        auto *node = tree_.find(key);
        /* Note: Would throw out_of_range in standard library */
        return node->data.second;
    }

    const T &at(const Key &key) const {
        auto *node = tree_.find(key);
        return node->data.second;
    }

    T &operator[](const Key &key) {
        auto result = tree_.insert(value_type(key, T()));
        return result.first->data.second;
    }

    T &operator[](Key &&key) {
        auto result = tree_.insert(value_type(move(key), T()));
        return result.first->data.second;
    }

    /* Iterators */
    iterator begin() {
        return iterator(tree_.begin_node(), &tree_);
    }

    const_iterator begin() const {
        return const_iterator(tree_.begin_node(), &tree_);
    }

    const_iterator cbegin() const {
        return const_iterator(tree_.begin_node(), &tree_);
    }

    iterator end() {
        return iterator(tree_.end_node(), &tree_);
    }

    const_iterator end() const {
        return const_iterator(tree_.end_node(), &tree_);
    }

    const_iterator cend() const {
        return const_iterator(tree_.end_node(), &tree_);
    }

    reverse_iterator rbegin() {
        return reverse_iterator(end());
    }

    const_reverse_iterator rbegin() const {
        return const_reverse_iterator(end());
    }

    const_reverse_iterator crbegin() const {
        return const_reverse_iterator(cend());
    }

    reverse_iterator rend() {
        return reverse_iterator(begin());
    }

    const_reverse_iterator rend() const {
        return const_reverse_iterator(begin());
    }

    const_reverse_iterator crend() const {
        return const_reverse_iterator(cbegin());
    }

    /* Capacity */
    bool empty() const {
        return tree_.empty();
    }

    size_type size() const {
        return tree_.size();
    }

    size_type max_size() const {
        return static_cast<size_type>(-1) / sizeof(node_type);
    }

    /* Modifiers */
    void clear() {
        tree_.clear();
    }

    pair<iterator, bool> insert(const value_type &value) {
        auto result = tree_.insert(value);
        return {iterator(result.first, &tree_), result.second};
    }

    pair<iterator, bool> insert(value_type &&value) {
        auto result = tree_.insert(move(value));
        return {iterator(result.first, &tree_), result.second};
    }

    template <class P> pair<iterator, bool> insert(P &&value) {
        return insert(value_type(forward<P>(value)));
    }

    iterator insert(const_iterator hint, const value_type &value) {
        (void)hint; /* Hint not used in this implementation */
        return insert(value).first;
    }

    template <class InputIt> void insert(InputIt first, InputIt last) {
        for (; first != last; ++first) {
            insert(*first);
        }
    }

    void insert(initializer_list<value_type> ilist) {
        for (const auto &v : ilist) {
            insert(v);
        }
    }

    template <class... Args> pair<iterator, bool> emplace(Args &&...args) {
        auto result = tree_.emplace(forward<Args>(args)...);
        return {iterator(result.first, &tree_), result.second};
    }

    template <class... Args> iterator emplace_hint(const_iterator hint, Args &&...args) {
        (void)hint;
        return emplace(forward<Args>(args)...).first;
    }

    template <class... Args> pair<iterator, bool> try_emplace(const Key &key, Args &&...args) {
        auto *node = tree_.find(key);
        if (node != tree_.nil_node()) {
            return {iterator(node, &tree_), false};
        }
        return emplace(
            piecewise_construct, forward_as_tuple(key), forward_as_tuple(forward<Args>(args)...));
    }

    template <class... Args> pair<iterator, bool> try_emplace(Key &&key, Args &&...args) {
        auto *node = tree_.find(key);
        if (node != tree_.nil_node()) {
            return {iterator(node, &tree_), false};
        }
        return emplace(piecewise_construct,
                       forward_as_tuple(move(key)),
                       forward_as_tuple(forward<Args>(args)...));
    }

    iterator erase(const_iterator pos) {
        auto *node = const_cast<node_type *>(pos.node_);
        auto next = iterator(tree_.successor(node), &tree_);
        tree_.erase(node);
        return next;
    }

    iterator erase(const_iterator first, const_iterator last) {
        while (first != last) {
            first = erase(first);
        }
        return iterator(const_cast<node_type *>(first.node_), &tree_);
    }

    size_type erase(const Key &key) {
        auto *node = tree_.find(key);
        if (node == tree_.nil_node()) {
            return 0;
        }
        tree_.erase(node);
        return 1;
    }

    void swap(map &other) noexcept {
        tree_.swap(other.tree_);
    }

    /* Lookup */
    size_type count(const Key &key) const {
        return tree_.find(key) != tree_.nil_node() ? 1 : 0;
    }

    iterator find(const Key &key) {
        return iterator(tree_.find(key), &tree_);
    }

    const_iterator find(const Key &key) const {
        return const_iterator(tree_.find(key), &tree_);
    }

    bool contains(const Key &key) const {
        return tree_.find(key) != tree_.nil_node();
    }

    pair<iterator, iterator> equal_range(const Key &key) {
        return {lower_bound(key), upper_bound(key)};
    }

    pair<const_iterator, const_iterator> equal_range(const Key &key) const {
        return {lower_bound(key), upper_bound(key)};
    }

    iterator lower_bound(const Key &key) {
        return iterator(tree_.lower_bound(key), &tree_);
    }

    const_iterator lower_bound(const Key &key) const {
        return const_iterator(tree_.lower_bound(key), &tree_);
    }

    iterator upper_bound(const Key &key) {
        return iterator(tree_.upper_bound(key), &tree_);
    }

    const_iterator upper_bound(const Key &key) const {
        return const_iterator(tree_.upper_bound(key), &tree_);
    }

    /* Observers */
    key_compare key_comp() const {
        return tree_.key_comp();
    }

    value_compare value_comp() const {
        return value_compare(tree_.key_comp());
    }
};

/* Non-member functions */
template <class Key, class T, class Compare, class Alloc>
bool operator==(const map<Key, T, Compare, Alloc> &lhs, const map<Key, T, Compare, Alloc> &rhs) {
    if (lhs.size() != rhs.size())
        return false;
    auto it1 = lhs.begin();
    auto it2 = rhs.begin();
    for (; it1 != lhs.end(); ++it1, ++it2) {
        if (*it1 != *it2)
            return false;
    }
    return true;
}

template <class Key, class T, class Compare, class Alloc>
bool operator!=(const map<Key, T, Compare, Alloc> &lhs, const map<Key, T, Compare, Alloc> &rhs) {
    return !(lhs == rhs);
}

template <class Key, class T, class Compare, class Alloc>
bool operator<(const map<Key, T, Compare, Alloc> &lhs, const map<Key, T, Compare, Alloc> &rhs) {
    return lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end());
}

template <class Key, class T, class Compare, class Alloc>
bool operator<=(const map<Key, T, Compare, Alloc> &lhs, const map<Key, T, Compare, Alloc> &rhs) {
    return !(rhs < lhs);
}

template <class Key, class T, class Compare, class Alloc>
bool operator>(const map<Key, T, Compare, Alloc> &lhs, const map<Key, T, Compare, Alloc> &rhs) {
    return rhs < lhs;
}

template <class Key, class T, class Compare, class Alloc>
bool operator>=(const map<Key, T, Compare, Alloc> &lhs, const map<Key, T, Compare, Alloc> &rhs) {
    return !(lhs < rhs);
}

template <class Key, class T, class Compare, class Alloc>
void swap(map<Key, T, Compare, Alloc> &lhs, map<Key, T, Compare, Alloc> &rhs) noexcept {
    lhs.swap(rhs);
}

/* erase_if (C++20) */
template <class Key, class T, class Compare, class Alloc, class Pred>
typename map<Key, T, Compare, Alloc>::size_type erase_if(map<Key, T, Compare, Alloc> &c,
                                                         Pred pred) {
    auto old_size = c.size();
    for (auto it = c.begin(); it != c.end();) {
        if (pred(*it)) {
            it = c.erase(it);
        } else {
            ++it;
        }
    }
    return old_size - c.size();
}

/* multimap - allows duplicate keys */
template <class Key,
          class T,
          class Compare = less<Key>,
          class Allocator = allocator<pair<const Key, T>>>
class multimap {
    /* Similar to map but allows duplicate keys */
    /* Simplified implementation - would need modifications to rb_tree */
  public:
    using key_type = Key;
    using mapped_type = T;
    using value_type = pair<const Key, T>;
    using size_type = unsigned long;
    using key_compare = Compare;
    using allocator_type = Allocator;

    /* Basic multimap uses map internally but allows duplicates */
    /* Full implementation would require modifications to the tree */

    multimap() = default;

    explicit multimap(const Compare &comp, const Allocator &alloc = Allocator()) {}

    size_type size() const {
        return 0;
    }

    bool empty() const {
        return true;
    }

    void clear() {}
};

/* piecewise_construct for emplace */
struct piecewise_construct_t {
    explicit piecewise_construct_t() = default;
};

inline constexpr piecewise_construct_t piecewise_construct{};

} // namespace std

#endif /* _LIBCPP_MAP */
