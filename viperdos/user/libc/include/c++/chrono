/*
 * ViperDOS C++ Standard Library - chrono
 * Time utilities
 */

#ifndef _LIBCPP_CHRONO
#define _LIBCPP_CHRONO

#include "limits"
#include "ratio"
#include "type_traits"

/* For clock implementation */
extern "C"
{
    long clock_gettime(int clock_id, struct timespec *tp);
}

namespace std
{
namespace chrono
{

/* Forward declarations */
template <class Rep, class Period = ratio<1>> class duration;

template <class Clock, class Duration = typename Clock::duration> class time_point;

/* Duration traits */
template <class Rep> struct treat_as_floating_point : is_floating_point<Rep>
{
};

template <class Rep>
inline constexpr bool treat_as_floating_point_v = treat_as_floating_point<Rep>::value;

template <class Rep> struct duration_values
{
    static constexpr Rep zero() noexcept
    {
        return Rep(0);
    }

    static constexpr Rep min() noexcept
    {
        return numeric_limits<Rep>::lowest();
    }

    static constexpr Rep max() noexcept
    {
        return numeric_limits<Rep>::max();
    }
};

/* Common type for duration - helper */
namespace detail
{

template <class T> struct is_duration : false_type
{
};

template <class Rep, class Period> struct is_duration<duration<Rep, Period>> : true_type
{
};

template <class T> inline constexpr bool is_duration_v = is_duration<T>::value;

} // namespace detail

/* duration class template */
template <class Rep, class Period> class duration
{
  public:
    using rep = Rep;
    using period = typename Period::type;

  private:
    rep rep_;

  public:
    /* Constructors */
    constexpr duration() = default;

    template <class Rep2,
              class = typename enable_if<is_convertible<const Rep2 &, rep>::value &&
                                         (treat_as_floating_point_v<rep> ||
                                          !treat_as_floating_point_v<Rep2>)>::type>
    constexpr explicit duration(const Rep2 &r) : rep_(static_cast<rep>(r))
    {
    }

    template <class Rep2,
              class Period2,
              class = typename enable_if<treat_as_floating_point_v<rep> ||
                                         (ratio_divide<Period2, period>::type::den == 1 &&
                                          !treat_as_floating_point_v<Rep2>)>::type>
    constexpr duration(const duration<Rep2, Period2> &d) : rep_(duration_cast<duration>(d).count())
    {
    }

    duration(const duration &) = default;
    duration &operator=(const duration &) = default;

    /* Observer */
    constexpr rep count() const
    {
        return rep_;
    }

    /* Arithmetic */
    constexpr duration operator+() const
    {
        return *this;
    }

    constexpr duration operator-() const
    {
        return duration(-rep_);
    }

    constexpr duration &operator++()
    {
        ++rep_;
        return *this;
    }

    constexpr duration operator++(int)
    {
        return duration(rep_++);
    }

    constexpr duration &operator--()
    {
        --rep_;
        return *this;
    }

    constexpr duration operator--(int)
    {
        return duration(rep_--);
    }

    constexpr duration &operator+=(const duration &d)
    {
        rep_ += d.count();
        return *this;
    }

    constexpr duration &operator-=(const duration &d)
    {
        rep_ -= d.count();
        return *this;
    }

    constexpr duration &operator*=(const rep &rhs)
    {
        rep_ *= rhs;
        return *this;
    }

    constexpr duration &operator/=(const rep &rhs)
    {
        rep_ /= rhs;
        return *this;
    }

    constexpr duration &operator%=(const rep &rhs)
    {
        rep_ %= rhs;
        return *this;
    }

    constexpr duration &operator%=(const duration &d)
    {
        rep_ %= d.count();
        return *this;
    }

    /* Special values */
    static constexpr duration zero() noexcept
    {
        return duration(duration_values<rep>::zero());
    }

    static constexpr duration min() noexcept
    {
        return duration(duration_values<rep>::min());
    }

    static constexpr duration max() noexcept
    {
        return duration(duration_values<rep>::max());
    }
};

/* Duration arithmetic operators */
template <class Rep1, class Period1, class Rep2, class Period2>
constexpr auto operator+(const duration<Rep1, Period1> &lhs, const duration<Rep2, Period2> &rhs)
{
    using common_type_t =
        duration<decltype(declval<Rep1>() + declval<Rep2>()),
                 typename ratio_divide<typename ratio_multiply<Period1, ratio<Period2::den>>::type,
                                       ratio<detail::gcd_v<Period1::den, Period2::den>>>::type>;
    return common_type_t(common_type_t(lhs).count() + common_type_t(rhs).count());
}

template <class Rep1, class Period1, class Rep2, class Period2>
constexpr auto operator-(const duration<Rep1, Period1> &lhs, const duration<Rep2, Period2> &rhs)
{
    using common_type_t =
        duration<decltype(declval<Rep1>() - declval<Rep2>()),
                 typename ratio_divide<typename ratio_multiply<Period1, ratio<Period2::den>>::type,
                                       ratio<detail::gcd_v<Period1::den, Period2::den>>>::type>;
    return common_type_t(common_type_t(lhs).count() - common_type_t(rhs).count());
}

template <class Rep1, class Period, class Rep2>
constexpr auto operator*(const duration<Rep1, Period> &d, const Rep2 &s)
{
    using result_rep = decltype(declval<Rep1>() * declval<Rep2>());
    return duration<result_rep, Period>(d.count() * s);
}

template <class Rep1, class Rep2, class Period>
constexpr auto operator*(const Rep1 &s, const duration<Rep2, Period> &d)
{
    return d * s;
}

template <class Rep1, class Period, class Rep2>
constexpr auto operator/(const duration<Rep1, Period> &d, const Rep2 &s)
{
    using result_rep = decltype(declval<Rep1>() / declval<Rep2>());
    return duration<result_rep, Period>(d.count() / s);
}

template <class Rep1, class Period1, class Rep2, class Period2>
constexpr auto operator/(const duration<Rep1, Period1> &lhs, const duration<Rep2, Period2> &rhs)
{
    using cd = duration<long long, ratio<1>>;
    return cd(lhs).count() / cd(rhs).count();
}

template <class Rep1, class Period, class Rep2>
constexpr auto operator%(const duration<Rep1, Period> &d, const Rep2 &s)
{
    using result_rep = decltype(declval<Rep1>() % declval<Rep2>());
    return duration<result_rep, Period>(d.count() % s);
}

template <class Rep1, class Period1, class Rep2, class Period2>
constexpr auto operator%(const duration<Rep1, Period1> &lhs, const duration<Rep2, Period2> &rhs)
{
    using cd = duration<long long, ratio<1>>;
    return cd(cd(lhs).count() % cd(rhs).count());
}

/* Duration comparisons */
template <class Rep1, class Period1, class Rep2, class Period2>
constexpr bool operator==(const duration<Rep1, Period1> &lhs, const duration<Rep2, Period2> &rhs)
{
    using cd = duration<long long, ratio<1, 1000000000>>;
    return cd(lhs).count() == cd(rhs).count();
}

template <class Rep1, class Period1, class Rep2, class Period2>
constexpr bool operator!=(const duration<Rep1, Period1> &lhs, const duration<Rep2, Period2> &rhs)
{
    return !(lhs == rhs);
}

template <class Rep1, class Period1, class Rep2, class Period2>
constexpr bool operator<(const duration<Rep1, Period1> &lhs, const duration<Rep2, Period2> &rhs)
{
    using cd = duration<long long, ratio<1, 1000000000>>;
    return cd(lhs).count() < cd(rhs).count();
}

template <class Rep1, class Period1, class Rep2, class Period2>
constexpr bool operator<=(const duration<Rep1, Period1> &lhs, const duration<Rep2, Period2> &rhs)
{
    return !(rhs < lhs);
}

template <class Rep1, class Period1, class Rep2, class Period2>
constexpr bool operator>(const duration<Rep1, Period1> &lhs, const duration<Rep2, Period2> &rhs)
{
    return rhs < lhs;
}

template <class Rep1, class Period1, class Rep2, class Period2>
constexpr bool operator>=(const duration<Rep1, Period1> &lhs, const duration<Rep2, Period2> &rhs)
{
    return !(lhs < rhs);
}

/* duration_cast */
template <class ToDuration, class Rep, class Period>
constexpr ToDuration duration_cast(const duration<Rep, Period> &d)
{
    using cf = ratio_divide<Period, typename ToDuration::period>;
    using cr = typename ToDuration::rep;

    return ToDuration(static_cast<cr>(static_cast<cr>(d.count()) * static_cast<cr>(cf::num) /
                                      static_cast<cr>(cf::den)));
}

/* floor, ceil, round, abs for duration */
template <class ToDuration, class Rep, class Period>
constexpr ToDuration floor(const duration<Rep, Period> &d)
{
    ToDuration t = duration_cast<ToDuration>(d);
    if (t > d)
    {
        return t - ToDuration(1);
    }
    return t;
}

template <class ToDuration, class Rep, class Period>
constexpr ToDuration ceil(const duration<Rep, Period> &d)
{
    ToDuration t = duration_cast<ToDuration>(d);
    if (t < d)
    {
        return t + ToDuration(1);
    }
    return t;
}

template <class ToDuration, class Rep, class Period>
constexpr ToDuration round(const duration<Rep, Period> &d)
{
    ToDuration t0 = floor<ToDuration>(d);
    ToDuration t1 = t0 + ToDuration(1);

    auto diff0 = d - t0;
    auto diff1 = t1 - d;

    if (diff0 == diff1)
    {
        if (t0.count() & 1)
            return t1;
        return t0;
    }
    else if (diff0 < diff1)
    {
        return t0;
    }
    return t1;
}

template <class Rep, class Period> constexpr duration<Rep, Period> abs(duration<Rep, Period> d)
{
    return d >= d.zero() ? d : -d;
}

/* Standard duration typedefs */
using nanoseconds = duration<long long, nano>;
using microseconds = duration<long long, micro>;
using milliseconds = duration<long long, milli>;
using seconds = duration<long long>;
using minutes = duration<long long, ratio<60>>;
using hours = duration<long long, ratio<3600>>;
using days = duration<long long, ratio<86400>>;
using weeks = duration<long long, ratio<604800>>;
using months = duration<long long, ratio<2629746>>; /* Average month */
using years = duration<long long, ratio<31556952>>; /* Average year */

/* time_point class template */
template <class Clock, class Duration> class time_point
{
  public:
    using clock = Clock;
    using duration = Duration;
    using rep = typename duration::rep;
    using period = typename duration::period;

  private:
    duration d_;

  public:
    /* Constructors */
    constexpr time_point() : d_(duration::zero()) {}

    constexpr explicit time_point(const duration &d) : d_(d) {}

    template <class Duration2>
    constexpr time_point(const time_point<clock, Duration2> &t) : d_(t.time_since_epoch())
    {
    }

    /* Observer */
    constexpr duration time_since_epoch() const
    {
        return d_;
    }

    /* Arithmetic */
    constexpr time_point &operator+=(const duration &d)
    {
        d_ += d;
        return *this;
    }

    constexpr time_point &operator-=(const duration &d)
    {
        d_ -= d;
        return *this;
    }

    /* Special values */
    static constexpr time_point min() noexcept
    {
        return time_point(duration::min());
    }

    static constexpr time_point max() noexcept
    {
        return time_point(duration::max());
    }
};

/* time_point arithmetic */
template <class Clock, class Duration1, class Rep2, class Period2>
constexpr time_point<Clock, Duration1> operator+(const time_point<Clock, Duration1> &lhs,
                                                 const duration<Rep2, Period2> &rhs)
{
    return time_point<Clock, Duration1>(lhs.time_since_epoch() + rhs);
}

template <class Rep1, class Period1, class Clock, class Duration2>
constexpr time_point<Clock, Duration2> operator+(const duration<Rep1, Period1> &lhs,
                                                 const time_point<Clock, Duration2> &rhs)
{
    return rhs + lhs;
}

template <class Clock, class Duration1, class Rep2, class Period2>
constexpr time_point<Clock, Duration1> operator-(const time_point<Clock, Duration1> &lhs,
                                                 const duration<Rep2, Period2> &rhs)
{
    return lhs + (-rhs);
}

template <class Clock, class Duration1, class Duration2>
constexpr auto operator-(const time_point<Clock, Duration1> &lhs,
                         const time_point<Clock, Duration2> &rhs)
{
    return lhs.time_since_epoch() - rhs.time_since_epoch();
}

/* time_point comparisons */
template <class Clock, class Duration1, class Duration2>
constexpr bool operator==(const time_point<Clock, Duration1> &lhs,
                          const time_point<Clock, Duration2> &rhs)
{
    return lhs.time_since_epoch() == rhs.time_since_epoch();
}

template <class Clock, class Duration1, class Duration2>
constexpr bool operator!=(const time_point<Clock, Duration1> &lhs,
                          const time_point<Clock, Duration2> &rhs)
{
    return !(lhs == rhs);
}

template <class Clock, class Duration1, class Duration2>
constexpr bool operator<(const time_point<Clock, Duration1> &lhs,
                         const time_point<Clock, Duration2> &rhs)
{
    return lhs.time_since_epoch() < rhs.time_since_epoch();
}

template <class Clock, class Duration1, class Duration2>
constexpr bool operator<=(const time_point<Clock, Duration1> &lhs,
                          const time_point<Clock, Duration2> &rhs)
{
    return !(rhs < lhs);
}

template <class Clock, class Duration1, class Duration2>
constexpr bool operator>(const time_point<Clock, Duration1> &lhs,
                         const time_point<Clock, Duration2> &rhs)
{
    return rhs < lhs;
}

template <class Clock, class Duration1, class Duration2>
constexpr bool operator>=(const time_point<Clock, Duration1> &lhs,
                          const time_point<Clock, Duration2> &rhs)
{
    return !(lhs < rhs);
}

/* time_point_cast */
template <class ToDuration, class Clock, class Duration>
constexpr time_point<Clock, ToDuration> time_point_cast(const time_point<Clock, Duration> &t)
{
    return time_point<Clock, ToDuration>(duration_cast<ToDuration>(t.time_since_epoch()));
}

/* floor, ceil, round for time_point */
template <class ToDuration, class Clock, class Duration>
constexpr time_point<Clock, ToDuration> floor(const time_point<Clock, Duration> &tp)
{
    return time_point<Clock, ToDuration>(floor<ToDuration>(tp.time_since_epoch()));
}

template <class ToDuration, class Clock, class Duration>
constexpr time_point<Clock, ToDuration> ceil(const time_point<Clock, Duration> &tp)
{
    return time_point<Clock, ToDuration>(ceil<ToDuration>(tp.time_since_epoch()));
}

template <class ToDuration, class Clock, class Duration>
constexpr time_point<Clock, ToDuration> round(const time_point<Clock, Duration> &tp)
{
    return time_point<Clock, ToDuration>(round<ToDuration>(tp.time_since_epoch()));
}

/* Clocks */

/* system_clock - wall clock time */
struct system_clock
{
    using rep = long long;
    using period = nano;
    using duration = chrono::duration<rep, period>;
    using time_point = chrono::time_point<system_clock>;

    static constexpr bool is_steady = false;

    static time_point now() noexcept
    {
        struct timespec ts;
        clock_gettime(0 /* CLOCK_REALTIME */, &ts);
        return time_point(duration(static_cast<rep>(ts.tv_sec) * 1000000000LL + ts.tv_nsec));
    }

    /* Convert to/from time_t */
    static long long to_time_t(const time_point &t) noexcept
    {
        return duration_cast<seconds>(t.time_since_epoch()).count();
    }

    static time_point from_time_t(long long t) noexcept
    {
        return time_point(seconds(t));
    }
};

/* steady_clock - monotonic clock */
struct steady_clock
{
    using rep = long long;
    using period = nano;
    using duration = chrono::duration<rep, period>;
    using time_point = chrono::time_point<steady_clock>;

    static constexpr bool is_steady = true;

    static time_point now() noexcept
    {
        struct timespec ts;
        clock_gettime(1 /* CLOCK_MONOTONIC */, &ts);
        return time_point(duration(static_cast<rep>(ts.tv_sec) * 1000000000LL + ts.tv_nsec));
    }
};

/* high_resolution_clock - alias for the most precise clock */
using high_resolution_clock = steady_clock;

} // namespace chrono

/* User-defined literals for duration */
inline namespace literals
{
inline namespace chrono_literals
{

constexpr chrono::hours operator""_h(unsigned long long h)
{
    return chrono::hours(static_cast<chrono::hours::rep>(h));
}

constexpr chrono::duration<long double, ratio<3600>> operator""_h(long double h)
{
    return chrono::duration<long double, ratio<3600>>(h);
}

constexpr chrono::minutes operator""_min(unsigned long long m)
{
    return chrono::minutes(static_cast<chrono::minutes::rep>(m));
}

constexpr chrono::duration<long double, ratio<60>> operator""_min(long double m)
{
    return chrono::duration<long double, ratio<60>>(m);
}

constexpr chrono::seconds operator""_s(unsigned long long s)
{
    return chrono::seconds(static_cast<chrono::seconds::rep>(s));
}

constexpr chrono::duration<long double> operator""_s(long double s)
{
    return chrono::duration<long double>(s);
}

constexpr chrono::milliseconds operator""_ms(unsigned long long ms)
{
    return chrono::milliseconds(static_cast<chrono::milliseconds::rep>(ms));
}

constexpr chrono::duration<long double, milli> operator""_ms(long double ms)
{
    return chrono::duration<long double, milli>(ms);
}

constexpr chrono::microseconds operator""_us(unsigned long long us)
{
    return chrono::microseconds(static_cast<chrono::microseconds::rep>(us));
}

constexpr chrono::duration<long double, micro> operator""_us(long double us)
{
    return chrono::duration<long double, micro>(us);
}

constexpr chrono::nanoseconds operator""_ns(unsigned long long ns)
{
    return chrono::nanoseconds(static_cast<chrono::nanoseconds::rep>(ns));
}

constexpr chrono::duration<long double, nano> operator""_ns(long double ns)
{
    return chrono::duration<long double, nano>(ns);
}

} // namespace chrono_literals
} // namespace literals

/* Bring chrono_literals into std::chrono */
namespace chrono
{
using namespace literals::chrono_literals;
}

} // namespace std

#endif /* _LIBCPP_CHRONO */
