/*
 * ViperDOS C++ Standard Library - ratio
 * Compile-time rational arithmetic
 */

#ifndef _LIBCPP_RATIO
#define _LIBCPP_RATIO

#include "type_traits"

namespace std {

/* Greatest common divisor (compile-time) */
namespace detail {

template <long long A, long long B> struct gcd_impl {
    static constexpr long long value = gcd_impl<B, A % B>::value;
};

template <long long A> struct gcd_impl<A, 0> {
    static constexpr long long value = A;
};

template <long long A, long long B>
constexpr long long gcd_v = gcd_impl<(A >= 0 ? A : -A), (B >= 0 ? B : -B)>::value;

/* Least common multiple (compile-time) */
template <long long A, long long B> constexpr long long lcm_v = (A / gcd_v<A, B>)*B;

/* Sign of ratio */
template <long long N, long long D>
constexpr long long ratio_sign = ((N >= 0) == (D >= 0)) ? 1 : -1;

/* Absolute value */
template <long long N> constexpr long long ratio_abs = N >= 0 ? N : -N;

} // namespace detail

/* ratio class template */
template <long long Num, long long Den = 1> struct ratio {
    static_assert(Den != 0, "ratio denominator cannot be zero");

    static constexpr long long num =
        detail::ratio_sign<Num, Den> * detail::ratio_abs<Num> / detail::gcd_v<Num, Den>;

    static constexpr long long den = detail::ratio_abs<Den> / detail::gcd_v<Num, Den>;

    using type = ratio<num, den>;
};

/* Ratio arithmetic */

/* ratio_add */
template <class R1, class R2> struct ratio_add {
  private:
    static constexpr long long gcd_d = detail::gcd_v<R1::den, R2::den>;
    static constexpr long long num = R1::num * (R2::den / gcd_d) + R2::num * (R1::den / gcd_d);
    static constexpr long long den = R1::den * (R2::den / gcd_d);
    static constexpr long long gcd_nd = detail::gcd_v<num, den>;

  public:
    using type = ratio<num / gcd_nd, den / gcd_nd>;
};

template <class R1, class R2> using ratio_add_t = typename ratio_add<R1, R2>::type;

/* ratio_subtract */
template <class R1, class R2> struct ratio_subtract {
    using type = typename ratio_add<R1, ratio<-R2::num, R2::den>>::type;
};

template <class R1, class R2> using ratio_subtract_t = typename ratio_subtract<R1, R2>::type;

/* ratio_multiply */
template <class R1, class R2> struct ratio_multiply {
  private:
    static constexpr long long gcd_1 = detail::gcd_v<R1::num, R2::den>;
    static constexpr long long gcd_2 = detail::gcd_v<R2::num, R1::den>;
    static constexpr long long num = (R1::num / gcd_1) * (R2::num / gcd_2);
    static constexpr long long den = (R1::den / gcd_2) * (R2::den / gcd_1);

  public:
    using type = ratio<num, den>;
};

template <class R1, class R2> using ratio_multiply_t = typename ratio_multiply<R1, R2>::type;

/* ratio_divide */
template <class R1, class R2> struct ratio_divide {
    static_assert(R2::num != 0, "division by zero");
    using type = typename ratio_multiply<R1, ratio<R2::den, R2::num>>::type;
};

template <class R1, class R2> using ratio_divide_t = typename ratio_divide<R1, R2>::type;

/* Ratio comparison */

/* ratio_equal */
template <class R1, class R2>
struct ratio_equal : bool_constant<R1::num == R2::num && R1::den == R2::den> {};

template <class R1, class R2> inline constexpr bool ratio_equal_v = ratio_equal<R1, R2>::value;

/* ratio_not_equal */
template <class R1, class R2> struct ratio_not_equal : bool_constant<!ratio_equal_v<R1, R2>> {};

template <class R1, class R2>
inline constexpr bool ratio_not_equal_v = ratio_not_equal<R1, R2>::value;

/* ratio_less - more careful implementation to avoid overflow */
template <class R1, class R2> struct ratio_less {
  private:
    /* Compare R1::num / R1::den < R2::num / R2::den */
    /* Cross multiply: R1::num * R2::den < R2::num * R1::den */
    /* Need to handle signs and potential overflow */

    static constexpr long long q1 = R1::num / R1::den;
    static constexpr long long r1 = R1::num % R1::den;
    static constexpr long long q2 = R2::num / R2::den;
    static constexpr long long r2 = R2::num % R2::den;

    /* If integer parts differ, that determines the result */
    static constexpr bool value = (q1 != q2) ? (q1 < q2) :
                                             /* Integer parts equal, compare remainders */
                                      (r1 * R2::den < r2 * R1::den);

  public:
    static constexpr bool value_v = value;
};

template <class R1, class R2> inline constexpr bool ratio_less_v = ratio_less<R1, R2>::value;

/* ratio_less_equal */
template <class R1, class R2> struct ratio_less_equal : bool_constant<!ratio_less_v<R2, R1>> {};

template <class R1, class R2>
inline constexpr bool ratio_less_equal_v = ratio_less_equal<R1, R2>::value;

/* ratio_greater */
template <class R1, class R2> struct ratio_greater : bool_constant<ratio_less_v<R2, R1>> {};

template <class R1, class R2> inline constexpr bool ratio_greater_v = ratio_greater<R1, R2>::value;

/* ratio_greater_equal */
template <class R1, class R2> struct ratio_greater_equal : bool_constant<!ratio_less_v<R1, R2>> {};

template <class R1, class R2>
inline constexpr bool ratio_greater_equal_v = ratio_greater_equal<R1, R2>::value;

/* SI unit typedefs */
using atto = ratio<1, 1000000000000000000LL>;
using femto = ratio<1, 1000000000000000LL>;
using pico = ratio<1, 1000000000000LL>;
using nano = ratio<1, 1000000000LL>;
using micro = ratio<1, 1000000LL>;
using milli = ratio<1, 1000LL>;
using centi = ratio<1, 100LL>;
using deci = ratio<1, 10LL>;
using deca = ratio<10LL, 1>;
using hecto = ratio<100LL, 1>;
using kilo = ratio<1000LL, 1>;
using mega = ratio<1000000LL, 1>;
using giga = ratio<1000000000LL, 1>;
using tera = ratio<1000000000000LL, 1>;
using peta = ratio<1000000000000000LL, 1>;
using exa = ratio<1000000000000000000LL, 1>;

} // namespace std

#endif /* _LIBCPP_RATIO */
