/*
 * ViperDOS C++ Standard Library - deque
 * Double-ended queue with efficient insertion at both ends
 */

#ifndef _LIBCPP_DEQUE
#define _LIBCPP_DEQUE

#include "algorithm"
#include "initializer_list"
#include "iterator"
#include "memory"

namespace std {

/* Deque block size calculation */
namespace detail {

template <class T> struct deque_block_size {
    static constexpr unsigned long value = sizeof(T) < 256 ? (4096 / sizeof(T)) : 16;
};

} // namespace detail

/* deque class */
template <class T, class Allocator = allocator<T>> class deque {
  public:
    using value_type = T;
    using allocator_type = Allocator;
    using size_type = unsigned long;
    using difference_type = long;
    using reference = T &;
    using const_reference = const T &;
    using pointer = T *;
    using const_pointer = const T *;

  private:
    static constexpr size_type BLOCK_SIZE = detail::deque_block_size<T>::value;

    using map_allocator = typename allocator_traits<Allocator>::template rebind_alloc<T *>;

    T **map_;                /* Array of pointers to blocks */
    size_type map_size_;     /* Number of slots in map */
    size_type start_block_;  /* Index of first block with data */
    size_type start_offset_; /* Offset within first block */
    size_type size_;         /* Number of elements */

    Allocator alloc_;
    map_allocator map_alloc_;

    /* Calculate block and offset for logical index */
    void get_location(size_type index, size_type &block, size_type &offset) const {
        size_type adjusted = start_offset_ + index;
        block = start_block_ + adjusted / BLOCK_SIZE;
        offset = adjusted % BLOCK_SIZE;
    }

    /* Allocate a new block */
    T *allocate_block() {
        return allocator_traits<Allocator>::allocate(alloc_, BLOCK_SIZE);
    }

    /* Deallocate a block */
    void deallocate_block(T *block) {
        allocator_traits<Allocator>::deallocate(alloc_, block, BLOCK_SIZE);
    }

    /* Reallocate the map with more slots */
    void reallocate_map(size_type new_blocks_needed, bool add_at_front) {
        size_type old_num_blocks = (size_ + start_offset_ + BLOCK_SIZE - 1) / BLOCK_SIZE;
        size_type new_num_blocks = old_num_blocks + new_blocks_needed;

        T **new_map;
        size_type new_map_size = map_size_ * 2;
        while (new_map_size < new_num_blocks + 2) {
            new_map_size *= 2;
        }

        new_map = allocator_traits<map_allocator>::allocate(map_alloc_, new_map_size);
        for (size_type i = 0; i < new_map_size; ++i) {
            new_map[i] = nullptr;
        }

        /* Calculate new start position (center the data) */
        size_type new_start = (new_map_size - new_num_blocks) / 2;
        if (add_at_front) {
            new_start += new_blocks_needed;
        }

        /* Copy existing block pointers */
        for (size_type i = 0; i < old_num_blocks; ++i) {
            new_map[new_start + i] = map_[start_block_ + i];
        }

        /* Free old map */
        if (map_) {
            allocator_traits<map_allocator>::deallocate(map_alloc_, map_, map_size_);
        }

        map_ = new_map;
        map_size_ = new_map_size;
        start_block_ = new_start;
    }

    /* Ensure space at front */
    void reserve_map_at_front(size_type nodes_to_add = 1) {
        if (start_block_ < nodes_to_add) {
            reallocate_map(nodes_to_add, true);
        }
    }

    /* Ensure space at back */
    void reserve_map_at_back(size_type nodes_to_add = 1) {
        size_type current_blocks = (size_ + start_offset_ + BLOCK_SIZE - 1) / BLOCK_SIZE;
        size_type end_block = start_block_ + current_blocks;
        if (end_block + nodes_to_add > map_size_) {
            reallocate_map(nodes_to_add, false);
        }
    }

  public:
    /* Iterator */
    class iterator {
        friend class deque;
        T *cur_;
        T *first_;
        T *last_;
        T **node_;

        void set_node(T **new_node) {
            node_ = new_node;
            first_ = *new_node;
            last_ = first_ + BLOCK_SIZE;
        }

      public:
        using iterator_category = random_access_iterator_tag;
        using value_type = T;
        using difference_type = long;
        using pointer = T *;
        using reference = T &;

        iterator() : cur_(nullptr), first_(nullptr), last_(nullptr), node_(nullptr) {}

        iterator(T *cur, T **node) : cur_(cur), node_(node) {
            if (node_) {
                first_ = *node_;
                last_ = first_ + BLOCK_SIZE;
            } else {
                first_ = last_ = nullptr;
            }
        }

        reference operator*() const {
            return *cur_;
        }

        pointer operator->() const {
            return cur_;
        }

        iterator &operator++() {
            ++cur_;
            if (cur_ == last_) {
                set_node(node_ + 1);
                cur_ = first_;
            }
            return *this;
        }

        iterator operator++(int) {
            iterator tmp = *this;
            ++*this;
            return tmp;
        }

        iterator &operator--() {
            if (cur_ == first_) {
                set_node(node_ - 1);
                cur_ = last_;
            }
            --cur_;
            return *this;
        }

        iterator operator--(int) {
            iterator tmp = *this;
            --*this;
            return tmp;
        }

        iterator &operator+=(difference_type n) {
            difference_type offset = n + (cur_ - first_);
            if (offset >= 0 && offset < static_cast<difference_type>(BLOCK_SIZE)) {
                cur_ += n;
            } else {
                difference_type node_offset =
                    offset > 0 ? offset / static_cast<difference_type>(BLOCK_SIZE)
                               : -static_cast<difference_type>((-offset - 1) / BLOCK_SIZE) - 1;
                set_node(node_ + node_offset);
                cur_ = first_ + (offset - node_offset * static_cast<difference_type>(BLOCK_SIZE));
            }
            return *this;
        }

        iterator operator+(difference_type n) const {
            iterator tmp = *this;
            return tmp += n;
        }

        iterator &operator-=(difference_type n) {
            return *this += -n;
        }

        iterator operator-(difference_type n) const {
            iterator tmp = *this;
            return tmp -= n;
        }

        difference_type operator-(const iterator &other) const {
            return static_cast<difference_type>(BLOCK_SIZE) * (node_ - other.node_ - 1) +
                   (cur_ - first_) + (other.last_ - other.cur_);
        }

        reference operator[](difference_type n) const {
            return *(*this + n);
        }

        bool operator==(const iterator &other) const {
            return cur_ == other.cur_;
        }

        bool operator!=(const iterator &other) const {
            return cur_ != other.cur_;
        }

        bool operator<(const iterator &other) const {
            return node_ == other.node_ ? cur_ < other.cur_ : node_ < other.node_;
        }

        bool operator>(const iterator &other) const {
            return other < *this;
        }

        bool operator<=(const iterator &other) const {
            return !(other < *this);
        }

        bool operator>=(const iterator &other) const {
            return !(*this < other);
        }
    };

    /* const_iterator */
    class const_iterator {
        friend class deque;
        const T *cur_;
        const T *first_;
        const T *last_;
        T *const *node_;

        void set_node(T *const *new_node) {
            node_ = new_node;
            first_ = *new_node;
            last_ = first_ + BLOCK_SIZE;
        }

      public:
        using iterator_category = random_access_iterator_tag;
        using value_type = T;
        using difference_type = long;
        using pointer = const T *;
        using reference = const T &;

        const_iterator() : cur_(nullptr), first_(nullptr), last_(nullptr), node_(nullptr) {}

        const_iterator(const iterator &it)
            : cur_(it.cur_), first_(it.first_), last_(it.last_), node_(it.node_) {}

        const_iterator(const T *cur, T *const *node) : cur_(cur), node_(node) {
            if (node_) {
                first_ = *node_;
                last_ = first_ + BLOCK_SIZE;
            } else {
                first_ = last_ = nullptr;
            }
        }

        reference operator*() const {
            return *cur_;
        }

        pointer operator->() const {
            return cur_;
        }

        const_iterator &operator++() {
            ++cur_;
            if (cur_ == last_) {
                set_node(node_ + 1);
                cur_ = first_;
            }
            return *this;
        }

        const_iterator operator++(int) {
            const_iterator tmp = *this;
            ++*this;
            return tmp;
        }

        const_iterator &operator--() {
            if (cur_ == first_) {
                set_node(node_ - 1);
                cur_ = last_;
            }
            --cur_;
            return *this;
        }

        const_iterator operator--(int) {
            const_iterator tmp = *this;
            --*this;
            return tmp;
        }

        const_iterator &operator+=(difference_type n) {
            difference_type offset = n + (cur_ - first_);
            if (offset >= 0 && offset < static_cast<difference_type>(BLOCK_SIZE)) {
                cur_ += n;
            } else {
                difference_type node_offset =
                    offset > 0 ? offset / static_cast<difference_type>(BLOCK_SIZE)
                               : -static_cast<difference_type>((-offset - 1) / BLOCK_SIZE) - 1;
                set_node(node_ + node_offset);
                cur_ = first_ + (offset - node_offset * static_cast<difference_type>(BLOCK_SIZE));
            }
            return *this;
        }

        const_iterator operator+(difference_type n) const {
            const_iterator tmp = *this;
            return tmp += n;
        }

        const_iterator &operator-=(difference_type n) {
            return *this += -n;
        }

        const_iterator operator-(difference_type n) const {
            const_iterator tmp = *this;
            return tmp -= n;
        }

        difference_type operator-(const const_iterator &other) const {
            return static_cast<difference_type>(BLOCK_SIZE) * (node_ - other.node_ - 1) +
                   (cur_ - first_) + (other.last_ - other.cur_);
        }

        reference operator[](difference_type n) const {
            return *(*this + n);
        }

        bool operator==(const const_iterator &other) const {
            return cur_ == other.cur_;
        }

        bool operator!=(const const_iterator &other) const {
            return cur_ != other.cur_;
        }

        bool operator<(const const_iterator &other) const {
            return node_ == other.node_ ? cur_ < other.cur_ : node_ < other.node_;
        }

        bool operator>(const const_iterator &other) const {
            return other < *this;
        }

        bool operator<=(const const_iterator &other) const {
            return !(other < *this);
        }

        bool operator>=(const const_iterator &other) const {
            return !(*this < other);
        }
    };

    using reverse_iterator = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;

    /* Constructors */
    deque() : map_(nullptr), map_size_(0), start_block_(0), start_offset_(0), size_(0) {
        map_size_ = 8;
        map_ = allocator_traits<map_allocator>::allocate(map_alloc_, map_size_);
        for (size_type i = 0; i < map_size_; ++i) {
            map_[i] = nullptr;
        }
        start_block_ = map_size_ / 2;
        start_offset_ = 0;
    }

    explicit deque(const Allocator &alloc)
        : map_(nullptr), map_size_(0), start_block_(0), start_offset_(0), size_(0), alloc_(alloc),
          map_alloc_(alloc) {
        map_size_ = 8;
        map_ = allocator_traits<map_allocator>::allocate(map_alloc_, map_size_);
        for (size_type i = 0; i < map_size_; ++i) {
            map_[i] = nullptr;
        }
        start_block_ = map_size_ / 2;
    }

    explicit deque(size_type count, const T &value = T(), const Allocator &alloc = Allocator())
        : deque(alloc) {
        for (size_type i = 0; i < count; ++i) {
            push_back(value);
        }
    }

    template <class InputIt>
    deque(InputIt first, InputIt last, const Allocator &alloc = Allocator()) : deque(alloc) {
        for (; first != last; ++first) {
            push_back(*first);
        }
    }

    deque(const deque &other) : deque(other.alloc_) {
        for (const auto &v : other) {
            push_back(v);
        }
    }

    deque(deque &&other) noexcept
        : map_(other.map_), map_size_(other.map_size_), start_block_(other.start_block_),
          start_offset_(other.start_offset_), size_(other.size_), alloc_(move(other.alloc_)),
          map_alloc_(move(other.map_alloc_)) {
        other.map_ = nullptr;
        other.map_size_ = 0;
        other.start_block_ = 0;
        other.start_offset_ = 0;
        other.size_ = 0;
    }

    deque(initializer_list<T> init, const Allocator &alloc = Allocator()) : deque(alloc) {
        for (const auto &v : init) {
            push_back(v);
        }
    }

    ~deque() {
        clear();
        if (map_) {
            allocator_traits<map_allocator>::deallocate(map_alloc_, map_, map_size_);
        }
    }

    deque &operator=(const deque &other) {
        if (this != &other) {
            clear();
            for (const auto &v : other) {
                push_back(v);
            }
        }
        return *this;
    }

    deque &operator=(deque &&other) noexcept {
        if (this != &other) {
            clear();
            if (map_) {
                allocator_traits<map_allocator>::deallocate(map_alloc_, map_, map_size_);
            }
            map_ = other.map_;
            map_size_ = other.map_size_;
            start_block_ = other.start_block_;
            start_offset_ = other.start_offset_;
            size_ = other.size_;
            alloc_ = move(other.alloc_);
            map_alloc_ = move(other.map_alloc_);
            other.map_ = nullptr;
            other.map_size_ = 0;
            other.size_ = 0;
        }
        return *this;
    }

    deque &operator=(initializer_list<T> init) {
        clear();
        for (const auto &v : init) {
            push_back(v);
        }
        return *this;
    }

    void assign(size_type count, const T &value) {
        clear();
        for (size_type i = 0; i < count; ++i) {
            push_back(value);
        }
    }

    template <class InputIt> void assign(InputIt first, InputIt last) {
        clear();
        for (; first != last; ++first) {
            push_back(*first);
        }
    }

    void assign(initializer_list<T> init) {
        clear();
        for (const auto &v : init) {
            push_back(v);
        }
    }

    allocator_type get_allocator() const {
        return alloc_;
    }

    /* Element access */
    reference at(size_type pos) {
        return (*this)[pos];
    }

    const_reference at(size_type pos) const {
        return (*this)[pos];
    }

    reference operator[](size_type pos) {
        size_type block, offset;
        get_location(pos, block, offset);
        return map_[block][offset];
    }

    const_reference operator[](size_type pos) const {
        size_type block, offset;
        get_location(pos, block, offset);
        return map_[block][offset];
    }

    reference front() {
        return (*this)[0];
    }

    const_reference front() const {
        return (*this)[0];
    }

    reference back() {
        return (*this)[size_ - 1];
    }

    const_reference back() const {
        return (*this)[size_ - 1];
    }

    /* Iterators */
    iterator begin() {
        if (size_ == 0)
            return end();
        return iterator(map_[start_block_] + start_offset_, map_ + start_block_);
    }

    const_iterator begin() const {
        if (size_ == 0)
            return end();
        return const_iterator(map_[start_block_] + start_offset_, map_ + start_block_);
    }

    const_iterator cbegin() const {
        return begin();
    }

    iterator end() {
        size_type block, offset;
        get_location(size_, block, offset);
        if (block >= map_size_ || map_[block] == nullptr) {
            /* Return a valid end iterator */
            if (size_ == 0) {
                return iterator(nullptr, nullptr);
            }
            get_location(size_ - 1, block, offset);
            return iterator(map_[block] + offset + 1, map_ + block);
        }
        return iterator(map_[block] + offset, map_ + block);
    }

    const_iterator end() const {
        size_type block, offset;
        get_location(size_, block, offset);
        if (block >= map_size_ || map_[block] == nullptr) {
            if (size_ == 0) {
                return const_iterator(nullptr, nullptr);
            }
            get_location(size_ - 1, block, offset);
            return const_iterator(map_[block] + offset + 1, map_ + block);
        }
        return const_iterator(map_[block] + offset, map_ + block);
    }

    const_iterator cend() const {
        return end();
    }

    reverse_iterator rbegin() {
        return reverse_iterator(end());
    }

    const_reverse_iterator rbegin() const {
        return const_reverse_iterator(end());
    }

    const_reverse_iterator crbegin() const {
        return const_reverse_iterator(cend());
    }

    reverse_iterator rend() {
        return reverse_iterator(begin());
    }

    const_reverse_iterator rend() const {
        return const_reverse_iterator(begin());
    }

    const_reverse_iterator crend() const {
        return const_reverse_iterator(cbegin());
    }

    /* Capacity */
    bool empty() const {
        return size_ == 0;
    }

    size_type size() const {
        return size_;
    }

    size_type max_size() const {
        return static_cast<size_type>(-1) / sizeof(T);
    }

    void shrink_to_fit() {
        /* Not implemented - would require reallocating map and moving blocks */
    }

    /* Modifiers */
    void clear() {
        /* Destroy all elements */
        for (size_type i = 0; i < size_; ++i) {
            size_type block, offset;
            get_location(i, block, offset);
            allocator_traits<Allocator>::destroy(alloc_, &map_[block][offset]);
        }
        /* Deallocate all blocks */
        size_type num_blocks = (size_ + start_offset_ + BLOCK_SIZE - 1) / BLOCK_SIZE;
        for (size_type i = 0; i < num_blocks && (start_block_ + i) < map_size_; ++i) {
            if (map_[start_block_ + i]) {
                deallocate_block(map_[start_block_ + i]);
                map_[start_block_ + i] = nullptr;
            }
        }
        size_ = 0;
        start_block_ = map_size_ / 2;
        start_offset_ = 0;
    }

    void push_back(const T &value) {
        emplace_back(value);
    }

    void push_back(T &&value) {
        emplace_back(move(value));
    }

    template <class... Args> reference emplace_back(Args &&...args) {
        size_type block, offset;
        get_location(size_, block, offset);

        /* Ensure we have space */
        if (block >= map_size_) {
            reserve_map_at_back(1);
            get_location(size_, block, offset);
        }

        /* Allocate block if needed */
        if (map_[block] == nullptr) {
            map_[block] = allocate_block();
        }

        /* Construct element */
        allocator_traits<Allocator>::construct(
            alloc_, &map_[block][offset], forward<Args>(args)...);
        ++size_;
        return map_[block][offset];
    }

    void pop_back() {
        if (size_ == 0)
            return;

        size_type block, offset;
        get_location(size_ - 1, block, offset);
        allocator_traits<Allocator>::destroy(alloc_, &map_[block][offset]);
        --size_;

        /* Free block if now empty */
        if (offset == 0 && size_ > 0) {
            deallocate_block(map_[block]);
            map_[block] = nullptr;
        }
    }

    void push_front(const T &value) {
        emplace_front(value);
    }

    void push_front(T &&value) {
        emplace_front(move(value));
    }

    template <class... Args> reference emplace_front(Args &&...args) {
        if (start_offset_ == 0) {
            /* Need new block at front */
            reserve_map_at_front(1);
            --start_block_;
            if (map_[start_block_] == nullptr) {
                map_[start_block_] = allocate_block();
            }
            start_offset_ = BLOCK_SIZE;
        }

        --start_offset_;
        allocator_traits<Allocator>::construct(
            alloc_, &map_[start_block_][start_offset_], forward<Args>(args)...);
        ++size_;
        return map_[start_block_][start_offset_];
    }

    void pop_front() {
        if (size_ == 0)
            return;

        allocator_traits<Allocator>::destroy(alloc_, &map_[start_block_][start_offset_]);
        ++start_offset_;
        --size_;

        if (start_offset_ == BLOCK_SIZE && size_ > 0) {
            /* Block is now empty, free it and move to next */
            deallocate_block(map_[start_block_]);
            map_[start_block_] = nullptr;
            ++start_block_;
            start_offset_ = 0;
        }
    }

    iterator insert(const_iterator pos, const T &value) {
        return emplace(pos, value);
    }

    iterator insert(const_iterator pos, T &&value) {
        return emplace(pos, move(value));
    }

    iterator insert(const_iterator pos, size_type count, const T &value) {
        difference_type index = pos - cbegin();
        for (size_type i = 0; i < count; ++i) {
            push_back(value);
        }
        /* Rotate elements into position */
        if (index < static_cast<difference_type>(size_ - count)) {
            std::rotate(begin() + index, end() - count, end());
        }
        return begin() + index;
    }

    template <class InputIt> iterator insert(const_iterator pos, InputIt first, InputIt last) {
        difference_type index = pos - cbegin();
        size_type count = 0;
        for (auto it = first; it != last; ++it, ++count) {
            push_back(*it);
        }
        if (index < static_cast<difference_type>(size_ - count)) {
            std::rotate(begin() + index, end() - count, end());
        }
        return begin() + index;
    }

    iterator insert(const_iterator pos, initializer_list<T> ilist) {
        return insert(pos, ilist.begin(), ilist.end());
    }

    template <class... Args> iterator emplace(const_iterator pos, Args &&...args) {
        if (pos == cbegin()) {
            emplace_front(forward<Args>(args)...);
            return begin();
        }
        if (pos == cend()) {
            emplace_back(forward<Args>(args)...);
            return end() - 1;
        }

        difference_type index = pos - cbegin();
        emplace_back(forward<Args>(args)...);
        std::rotate(begin() + index, end() - 1, end());
        return begin() + index;
    }

    iterator erase(const_iterator pos) {
        difference_type index = pos - cbegin();
        std::rotate(begin() + index, begin() + index + 1, end());
        pop_back();
        return begin() + index;
    }

    iterator erase(const_iterator first, const_iterator last) {
        difference_type start_idx = first - cbegin();
        difference_type count = last - first;

        std::rotate(begin() + start_idx, begin() + start_idx + count, end());
        for (difference_type i = 0; i < count; ++i) {
            pop_back();
        }
        return begin() + start_idx;
    }

    void resize(size_type count) {
        while (size_ > count) {
            pop_back();
        }
        while (size_ < count) {
            emplace_back();
        }
    }

    void resize(size_type count, const T &value) {
        while (size_ > count) {
            pop_back();
        }
        while (size_ < count) {
            push_back(value);
        }
    }

    void swap(deque &other) noexcept {
        std::swap(map_, other.map_);
        std::swap(map_size_, other.map_size_);
        std::swap(start_block_, other.start_block_);
        std::swap(start_offset_, other.start_offset_);
        std::swap(size_, other.size_);
        std::swap(alloc_, other.alloc_);
        std::swap(map_alloc_, other.map_alloc_);
    }
};

/* Non-member functions */
template <class T, class Alloc>
bool operator==(const deque<T, Alloc> &lhs, const deque<T, Alloc> &rhs) {
    if (lhs.size() != rhs.size())
        return false;
    for (unsigned long i = 0; i < lhs.size(); ++i) {
        if (lhs[i] != rhs[i])
            return false;
    }
    return true;
}

template <class T, class Alloc>
bool operator!=(const deque<T, Alloc> &lhs, const deque<T, Alloc> &rhs) {
    return !(lhs == rhs);
}

template <class T, class Alloc>
bool operator<(const deque<T, Alloc> &lhs, const deque<T, Alloc> &rhs) {
    return lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end());
}

template <class T, class Alloc>
bool operator<=(const deque<T, Alloc> &lhs, const deque<T, Alloc> &rhs) {
    return !(rhs < lhs);
}

template <class T, class Alloc>
bool operator>(const deque<T, Alloc> &lhs, const deque<T, Alloc> &rhs) {
    return rhs < lhs;
}

template <class T, class Alloc>
bool operator>=(const deque<T, Alloc> &lhs, const deque<T, Alloc> &rhs) {
    return !(lhs < rhs);
}

template <class T, class Alloc> void swap(deque<T, Alloc> &lhs, deque<T, Alloc> &rhs) noexcept {
    lhs.swap(rhs);
}

template <class T, class Alloc, class U>
typename deque<T, Alloc>::size_type erase(deque<T, Alloc> &c, const U &value) {
    auto old_size = c.size();
    auto it = c.begin();
    while (it != c.end()) {
        if (*it == value) {
            it = c.erase(it);
        } else {
            ++it;
        }
    }
    return old_size - c.size();
}

template <class T, class Alloc, class Pred>
typename deque<T, Alloc>::size_type erase_if(deque<T, Alloc> &c, Pred pred) {
    auto old_size = c.size();
    auto it = c.begin();
    while (it != c.end()) {
        if (pred(*it)) {
            it = c.erase(it);
        } else {
            ++it;
        }
    }
    return old_size - c.size();
}

} // namespace std

#endif /* _LIBCPP_DEQUE */
