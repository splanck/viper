// C++ <vector> header for ViperDOS
// Dynamic array container

#ifndef _VIPER_CXX_VECTOR
#define _VIPER_CXX_VECTOR

#include "algorithm"
#include "cstddef"
#include "initializer_list"
#include "iterator"
#include "memory"

namespace std {

// Forward declaration of initializer_list if not defined
template <typename T> class initializer_list;

template <typename T, typename Allocator = allocator<T>> class vector {
  public:
    // Types
    using value_type = T;
    using allocator_type = Allocator;
    using size_type = size_t;
    using difference_type = ptrdiff_t;
    using reference = T &;
    using const_reference = const T &;
    using pointer = T *;
    using const_pointer = const T *;
    using iterator = T *;
    using const_iterator = const T *;
    using reverse_iterator = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;

  private:
    pointer data_;
    size_type size_;
    size_type capacity_;
    Allocator alloc_;

    void destroy_elements() {
        for (size_type i = 0; i < size_; ++i) {
            alloc_.destroy(data_ + i);
        }
    }

    void reallocate(size_type new_cap) {
        pointer new_data = alloc_.allocate(new_cap);

        // Move elements to new storage
        for (size_type i = 0; i < size_; ++i) {
            alloc_.construct(new_data + i, move(data_[i]));
            alloc_.destroy(data_ + i);
        }

        if (data_) {
            alloc_.deallocate(data_, capacity_);
        }

        data_ = new_data;
        capacity_ = new_cap;
    }

    size_type growth_factor(size_type min_cap) const {
        size_type new_cap = capacity_ ? capacity_ * 2 : 1;
        return new_cap > min_cap ? new_cap : min_cap;
    }

  public:
    // Constructors
    vector() noexcept : data_(nullptr), size_(0), capacity_(0), alloc_() {}

    explicit vector(const Allocator &alloc) noexcept
        : data_(nullptr), size_(0), capacity_(0), alloc_(alloc) {}

    explicit vector(size_type count, const T &value = T(), const Allocator &alloc = Allocator())
        : data_(nullptr), size_(0), capacity_(0), alloc_(alloc) {
        if (count > 0) {
            data_ = alloc_.allocate(count);
            capacity_ = count;
            for (size_type i = 0; i < count; ++i) {
                alloc_.construct(data_ + i, value);
            }
            size_ = count;
        }
    }

    vector(size_type count, const Allocator &alloc = Allocator())
        : data_(nullptr), size_(0), capacity_(0), alloc_(alloc) {
        if (count > 0) {
            data_ = alloc_.allocate(count);
            capacity_ = count;
            for (size_type i = 0; i < count; ++i) {
                alloc_.construct(data_ + i);
            }
            size_ = count;
        }
    }

    template <typename InputIt>
    vector(InputIt first, InputIt last, const Allocator &alloc = Allocator())
        : data_(nullptr), size_(0), capacity_(0), alloc_(alloc) {
        for (; first != last; ++first) {
            push_back(*first);
        }
    }

    vector(const vector &other) : data_(nullptr), size_(0), capacity_(0), alloc_(other.alloc_) {
        if (other.size_ > 0) {
            data_ = alloc_.allocate(other.size_);
            capacity_ = other.size_;
            for (size_type i = 0; i < other.size_; ++i) {
                alloc_.construct(data_ + i, other.data_[i]);
            }
            size_ = other.size_;
        }
    }

    vector(const vector &other, const Allocator &alloc)
        : data_(nullptr), size_(0), capacity_(0), alloc_(alloc) {
        if (other.size_ > 0) {
            data_ = alloc_.allocate(other.size_);
            capacity_ = other.size_;
            for (size_type i = 0; i < other.size_; ++i) {
                alloc_.construct(data_ + i, other.data_[i]);
            }
            size_ = other.size_;
        }
    }

    vector(vector &&other) noexcept
        : data_(other.data_), size_(other.size_), capacity_(other.capacity_),
          alloc_(move(other.alloc_)) {
        other.data_ = nullptr;
        other.size_ = 0;
        other.capacity_ = 0;
    }

    vector(vector &&other, const Allocator &alloc)
        : data_(nullptr), size_(0), capacity_(0), alloc_(alloc) {
        if (alloc_ == other.alloc_) {
            data_ = other.data_;
            size_ = other.size_;
            capacity_ = other.capacity_;
            other.data_ = nullptr;
            other.size_ = 0;
            other.capacity_ = 0;
        } else {
            if (other.size_ > 0) {
                data_ = alloc_.allocate(other.size_);
                capacity_ = other.size_;
                for (size_type i = 0; i < other.size_; ++i) {
                    alloc_.construct(data_ + i, move(other.data_[i]));
                }
                size_ = other.size_;
            }
        }
    }

    vector(initializer_list<T> init, const Allocator &alloc = Allocator())
        : data_(nullptr), size_(0), capacity_(0), alloc_(alloc) {
        if (init.size() > 0) {
            data_ = alloc_.allocate(init.size());
            capacity_ = init.size();
            size_type i = 0;
            for (const auto &elem : init) {
                alloc_.construct(data_ + i, elem);
                ++i;
            }
            size_ = init.size();
        }
    }

    // Destructor
    ~vector() {
        destroy_elements();
        if (data_) {
            alloc_.deallocate(data_, capacity_);
        }
    }

    // Assignment operators
    vector &operator=(const vector &other) {
        if (this != &other) {
            destroy_elements();
            if (capacity_ < other.size_) {
                if (data_) {
                    alloc_.deallocate(data_, capacity_);
                }
                data_ = alloc_.allocate(other.size_);
                capacity_ = other.size_;
            }
            for (size_type i = 0; i < other.size_; ++i) {
                alloc_.construct(data_ + i, other.data_[i]);
            }
            size_ = other.size_;
        }
        return *this;
    }

    vector &operator=(vector &&other) noexcept {
        if (this != &other) {
            destroy_elements();
            if (data_) {
                alloc_.deallocate(data_, capacity_);
            }
            data_ = other.data_;
            size_ = other.size_;
            capacity_ = other.capacity_;
            alloc_ = move(other.alloc_);
            other.data_ = nullptr;
            other.size_ = 0;
            other.capacity_ = 0;
        }
        return *this;
    }

    vector &operator=(initializer_list<T> init) {
        assign(init.begin(), init.end());
        return *this;
    }

    void assign(size_type count, const T &value) {
        clear();
        if (count > capacity_) {
            if (data_) {
                alloc_.deallocate(data_, capacity_);
            }
            data_ = alloc_.allocate(count);
            capacity_ = count;
        }
        for (size_type i = 0; i < count; ++i) {
            alloc_.construct(data_ + i, value);
        }
        size_ = count;
    }

    template <typename InputIt> void assign(InputIt first, InputIt last) {
        clear();
        for (; first != last; ++first) {
            push_back(*first);
        }
    }

    void assign(initializer_list<T> init) {
        assign(init.begin(), init.end());
    }

    allocator_type get_allocator() const noexcept {
        return alloc_;
    }

    // Element access
    reference at(size_type pos) {
        return data_[pos];
    }

    const_reference at(size_type pos) const {
        return data_[pos];
    }

    reference operator[](size_type pos) {
        return data_[pos];
    }

    const_reference operator[](size_type pos) const {
        return data_[pos];
    }

    reference front() {
        return data_[0];
    }

    const_reference front() const {
        return data_[0];
    }

    reference back() {
        return data_[size_ - 1];
    }

    const_reference back() const {
        return data_[size_ - 1];
    }

    pointer data() noexcept {
        return data_;
    }

    const_pointer data() const noexcept {
        return data_;
    }

    // Iterators
    iterator begin() noexcept {
        return data_;
    }

    const_iterator begin() const noexcept {
        return data_;
    }

    const_iterator cbegin() const noexcept {
        return data_;
    }

    iterator end() noexcept {
        return data_ + size_;
    }

    const_iterator end() const noexcept {
        return data_ + size_;
    }

    const_iterator cend() const noexcept {
        return data_ + size_;
    }

    reverse_iterator rbegin() noexcept {
        return reverse_iterator(end());
    }

    const_reverse_iterator rbegin() const noexcept {
        return const_reverse_iterator(end());
    }

    const_reverse_iterator crbegin() const noexcept {
        return const_reverse_iterator(end());
    }

    reverse_iterator rend() noexcept {
        return reverse_iterator(begin());
    }

    const_reverse_iterator rend() const noexcept {
        return const_reverse_iterator(begin());
    }

    const_reverse_iterator crend() const noexcept {
        return const_reverse_iterator(begin());
    }

    // Capacity
    bool empty() const noexcept {
        return size_ == 0;
    }

    size_type size() const noexcept {
        return size_;
    }

    size_type max_size() const noexcept {
        return static_cast<size_type>(-1) / sizeof(T);
    }

    void reserve(size_type new_cap) {
        if (new_cap > capacity_) {
            reallocate(new_cap);
        }
    }

    size_type capacity() const noexcept {
        return capacity_;
    }

    void shrink_to_fit() {
        if (size_ < capacity_) {
            if (size_ == 0) {
                if (data_) {
                    alloc_.deallocate(data_, capacity_);
                    data_ = nullptr;
                }
                capacity_ = 0;
            } else {
                reallocate(size_);
            }
        }
    }

    // Modifiers
    void clear() noexcept {
        destroy_elements();
        size_ = 0;
    }

    iterator insert(const_iterator pos, const T &value) {
        size_type idx = pos - data_;
        if (size_ >= capacity_) {
            reallocate(growth_factor(size_ + 1));
        }

        // Shift elements
        for (size_type i = size_; i > idx; --i) {
            if (i == size_) {
                alloc_.construct(data_ + i, move(data_[i - 1]));
            } else {
                data_[i] = move(data_[i - 1]);
            }
        }

        if (idx < size_) {
            data_[idx] = value;
        } else {
            alloc_.construct(data_ + idx, value);
        }
        ++size_;
        return data_ + idx;
    }

    iterator insert(const_iterator pos, T &&value) {
        size_type idx = pos - data_;
        if (size_ >= capacity_) {
            reallocate(growth_factor(size_ + 1));
        }

        for (size_type i = size_; i > idx; --i) {
            if (i == size_) {
                alloc_.construct(data_ + i, move(data_[i - 1]));
            } else {
                data_[i] = move(data_[i - 1]);
            }
        }

        if (idx < size_) {
            data_[idx] = move(value);
        } else {
            alloc_.construct(data_ + idx, move(value));
        }
        ++size_;
        return data_ + idx;
    }

    iterator insert(const_iterator pos, size_type count, const T &value) {
        if (count == 0)
            return const_cast<iterator>(pos);

        size_type idx = pos - data_;
        if (size_ + count > capacity_) {
            reallocate(growth_factor(size_ + count));
        }

        // Shift elements
        for (size_type i = size_ + count - 1; i >= idx + count; --i) {
            if (i >= size_) {
                alloc_.construct(data_ + i, move(data_[i - count]));
            } else {
                data_[i] = move(data_[i - count]);
            }
            if (i == idx + count)
                break;
        }

        // Insert new elements
        for (size_type i = 0; i < count; ++i) {
            if (idx + i < size_) {
                data_[idx + i] = value;
            } else {
                alloc_.construct(data_ + idx + i, value);
            }
        }
        size_ += count;
        return data_ + idx;
    }

    template <typename... Args> iterator emplace(const_iterator pos, Args &&...args) {
        size_type idx = pos - data_;
        if (size_ >= capacity_) {
            reallocate(growth_factor(size_ + 1));
        }

        for (size_type i = size_; i > idx; --i) {
            if (i == size_) {
                alloc_.construct(data_ + i, move(data_[i - 1]));
            } else {
                data_[i] = move(data_[i - 1]);
            }
        }

        if (idx < size_) {
            alloc_.destroy(data_ + idx);
        }
        alloc_.construct(data_ + idx, forward<Args>(args)...);
        ++size_;
        return data_ + idx;
    }

    iterator erase(const_iterator pos) {
        size_type idx = pos - data_;
        alloc_.destroy(data_ + idx);

        for (size_type i = idx; i < size_ - 1; ++i) {
            data_[i] = move(data_[i + 1]);
        }
        alloc_.destroy(data_ + size_ - 1);
        --size_;
        return data_ + idx;
    }

    iterator erase(const_iterator first, const_iterator last) {
        size_type start = first - data_;
        size_type end = last - data_;
        size_type count = end - start;

        if (count == 0)
            return const_cast<iterator>(first);

        // Destroy erased elements
        for (size_type i = start; i < end; ++i) {
            alloc_.destroy(data_ + i);
        }

        // Shift remaining elements
        for (size_type i = start; i < size_ - count; ++i) {
            data_[i] = move(data_[i + count]);
        }

        // Destroy moved-from elements at end
        for (size_type i = size_ - count; i < size_; ++i) {
            alloc_.destroy(data_ + i);
        }

        size_ -= count;
        return data_ + start;
    }

    void push_back(const T &value) {
        if (size_ >= capacity_) {
            reallocate(growth_factor(size_ + 1));
        }
        alloc_.construct(data_ + size_, value);
        ++size_;
    }

    void push_back(T &&value) {
        if (size_ >= capacity_) {
            reallocate(growth_factor(size_ + 1));
        }
        alloc_.construct(data_ + size_, move(value));
        ++size_;
    }

    template <typename... Args> reference emplace_back(Args &&...args) {
        if (size_ >= capacity_) {
            reallocate(growth_factor(size_ + 1));
        }
        alloc_.construct(data_ + size_, forward<Args>(args)...);
        ++size_;
        return data_[size_ - 1];
    }

    void pop_back() {
        --size_;
        alloc_.destroy(data_ + size_);
    }

    void resize(size_type count) {
        if (count > size_) {
            if (count > capacity_) {
                reallocate(count);
            }
            for (size_type i = size_; i < count; ++i) {
                alloc_.construct(data_ + i);
            }
        } else {
            for (size_type i = count; i < size_; ++i) {
                alloc_.destroy(data_ + i);
            }
        }
        size_ = count;
    }

    void resize(size_type count, const T &value) {
        if (count > size_) {
            if (count > capacity_) {
                reallocate(count);
            }
            for (size_type i = size_; i < count; ++i) {
                alloc_.construct(data_ + i, value);
            }
        } else {
            for (size_type i = count; i < size_; ++i) {
                alloc_.destroy(data_ + i);
            }
        }
        size_ = count;
    }

    void swap(vector &other) noexcept {
        pointer tmp_data = data_;
        data_ = other.data_;
        other.data_ = tmp_data;

        size_type tmp_size = size_;
        size_ = other.size_;
        other.size_ = tmp_size;

        size_type tmp_cap = capacity_;
        capacity_ = other.capacity_;
        other.capacity_ = tmp_cap;
    }
};

// Comparison operators
template <typename T, typename Alloc>
bool operator==(const vector<T, Alloc> &lhs, const vector<T, Alloc> &rhs) {
    if (lhs.size() != rhs.size())
        return false;
    for (size_t i = 0; i < lhs.size(); ++i) {
        if (!(lhs[i] == rhs[i]))
            return false;
    }
    return true;
}

template <typename T, typename Alloc>
bool operator!=(const vector<T, Alloc> &lhs, const vector<T, Alloc> &rhs) {
    return !(lhs == rhs);
}

template <typename T, typename Alloc>
bool operator<(const vector<T, Alloc> &lhs, const vector<T, Alloc> &rhs) {
    size_t min_size = lhs.size() < rhs.size() ? lhs.size() : rhs.size();
    for (size_t i = 0; i < min_size; ++i) {
        if (lhs[i] < rhs[i])
            return true;
        if (rhs[i] < lhs[i])
            return false;
    }
    return lhs.size() < rhs.size();
}

template <typename T, typename Alloc>
bool operator<=(const vector<T, Alloc> &lhs, const vector<T, Alloc> &rhs) {
    return !(rhs < lhs);
}

template <typename T, typename Alloc>
bool operator>(const vector<T, Alloc> &lhs, const vector<T, Alloc> &rhs) {
    return rhs < lhs;
}

template <typename T, typename Alloc>
bool operator>=(const vector<T, Alloc> &lhs, const vector<T, Alloc> &rhs) {
    return !(lhs < rhs);
}

// swap specialization
template <typename T, typename Alloc>
void swap(vector<T, Alloc> &lhs, vector<T, Alloc> &rhs) noexcept {
    lhs.swap(rhs);
}

// erase and erase_if (C++20)
template <typename T, typename Alloc, typename U>
typename vector<T, Alloc>::size_type erase(vector<T, Alloc> &c, const U &value) {
    auto it = std::remove(c.begin(), c.end(), value);
    auto count = c.end() - it;
    c.erase(it, c.end());
    return count;
}

template <typename T, typename Alloc, typename Pred>
typename vector<T, Alloc>::size_type erase_if(vector<T, Alloc> &c, Pred pred) {
    auto it = std::remove_if(c.begin(), c.end(), pred);
    auto count = c.end() - it;
    c.erase(it, c.end());
    return count;
}

} // namespace std

#endif // _VIPER_CXX_VECTOR
