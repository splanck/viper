#ifndef _LIBCPP_INITIALIZER_LIST
#define _LIBCPP_INITIALIZER_LIST

#include "cstddef"

namespace std {

/* initializer_list - used for brace-enclosed initializer lists */
template <class E> class initializer_list {
  public:
    using value_type = E;
    using reference = const E &;
    using const_reference = const E &;
    using size_type = size_t;
    using iterator = const E *;
    using const_iterator = const E *;

  private:
    iterator _begin;
    size_type _size;

    /* Called by the compiler */
    constexpr initializer_list(const_iterator b, size_type s) noexcept : _begin(b), _size(s) {}

  public:
    constexpr initializer_list() noexcept : _begin(nullptr), _size(0) {}

    /* Size */
    constexpr size_type size() const noexcept {
        return _size;
    }

    /* Iterators */
    constexpr const_iterator begin() const noexcept {
        return _begin;
    }

    constexpr const_iterator end() const noexcept {
        return _begin + _size;
    }
};

/* Non-member functions */
template <class E> constexpr const E *begin(initializer_list<E> il) noexcept {
    return il.begin();
}

template <class E> constexpr const E *end(initializer_list<E> il) noexcept {
    return il.end();
}

} /* namespace std */

#endif /* _LIBCPP_INITIALIZER_LIST */
