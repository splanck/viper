// C++ <string> header for ViperDOS
// Basic string class implementation

#ifndef _VIPER_CXX_STRING
#define _VIPER_CXX_STRING

#include "cstddef"
#include "cstring"
#include "initializer_list"
#include "iterator"
#include "memory"
#include "string_view"

namespace std
{

// char_traits for character type operations
template <typename CharT> struct char_traits;

template <> struct char_traits<char>
{
    using char_type = char;
    using int_type = int;
    using off_type = long;
    using pos_type = unsigned long;

    static constexpr void assign(char_type &r, const char_type &a) noexcept
    {
        r = a;
    }

    static constexpr bool eq(char_type a, char_type b) noexcept
    {
        return a == b;
    }

    static constexpr bool lt(char_type a, char_type b) noexcept
    {
        return static_cast<unsigned char>(a) < static_cast<unsigned char>(b);
    }

    static constexpr int compare(const char_type *s1, const char_type *s2, size_t n)
    {
        for (size_t i = 0; i < n; ++i)
        {
            if (lt(s1[i], s2[i]))
                return -1;
            if (lt(s2[i], s1[i]))
                return 1;
        }
        return 0;
    }

    static constexpr size_t length(const char_type *s)
    {
        size_t len = 0;
        while (s[len])
            ++len;
        return len;
    }

    static constexpr const char_type *find(const char_type *s, size_t n, const char_type &a)
    {
        for (size_t i = 0; i < n; ++i)
        {
            if (eq(s[i], a))
                return s + i;
        }
        return nullptr;
    }

    static constexpr char_type *move(char_type *dest, const char_type *src, size_t n)
    {
        if (dest < src)
        {
            for (size_t i = 0; i < n; ++i)
                dest[i] = src[i];
        }
        else
        {
            for (size_t i = n; i > 0; --i)
                dest[i - 1] = src[i - 1];
        }
        return dest;
    }

    static constexpr char_type *copy(char_type *dest, const char_type *src, size_t n)
    {
        for (size_t i = 0; i < n; ++i)
            dest[i] = src[i];
        return dest;
    }

    static constexpr char_type *assign(char_type *s, size_t n, char_type a)
    {
        for (size_t i = 0; i < n; ++i)
            s[i] = a;
        return s;
    }

    static constexpr int_type not_eof(int_type c) noexcept
    {
        return eq_int_type(c, eof()) ? 0 : c;
    }

    static constexpr char_type to_char_type(int_type c) noexcept
    {
        return static_cast<char_type>(c);
    }

    static constexpr int_type to_int_type(char_type c) noexcept
    {
        return static_cast<int_type>(static_cast<unsigned char>(c));
    }

    static constexpr bool eq_int_type(int_type c1, int_type c2) noexcept
    {
        return c1 == c2;
    }

    static constexpr int_type eof() noexcept
    {
        return -1;
    }
};

// basic_string template
template <typename CharT,
          typename Traits = char_traits<CharT>,
          typename Allocator = allocator<CharT>>
class basic_string
{
  public:
    using traits_type = Traits;
    using value_type = CharT;
    using allocator_type = Allocator;
    using size_type = size_t;
    using difference_type = ptrdiff_t;
    using reference = CharT &;
    using const_reference = const CharT &;
    using pointer = CharT *;
    using const_pointer = const CharT *;
    using iterator = CharT *;
    using const_iterator = const CharT *;
    using reverse_iterator = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;

    static constexpr size_type npos = static_cast<size_type>(-1);

  private:
    pointer data_;
    size_type size_;
    size_type capacity_;
    Allocator alloc_;

    void deallocate()
    {
        if (data_)
        {
            alloc_.deallocate(data_, capacity_ + 1);
            data_ = nullptr;
        }
    }

    void reallocate(size_type new_cap)
    {
        pointer new_data = alloc_.allocate(new_cap + 1);
        if (data_)
        {
            Traits::copy(new_data, data_, size_);
            deallocate();
        }
        data_ = new_data;
        capacity_ = new_cap;
        data_[size_] = CharT();
    }

    size_type grow_capacity(size_type min_cap) const
    {
        size_type new_cap = capacity_ ? capacity_ * 2 : 16;
        return new_cap > min_cap ? new_cap : min_cap;
    }

  public:
    // Constructors
    basic_string() noexcept(noexcept(Allocator()))
        : data_(nullptr), size_(0), capacity_(0), alloc_()
    {
        data_ = alloc_.allocate(1);
        data_[0] = CharT();
        capacity_ = 0;
    }

    explicit basic_string(const Allocator &alloc) noexcept
        : data_(nullptr), size_(0), capacity_(0), alloc_(alloc)
    {
        data_ = alloc_.allocate(1);
        data_[0] = CharT();
    }

    basic_string(size_type count, CharT ch, const Allocator &alloc = Allocator())
        : data_(nullptr), size_(0), capacity_(0), alloc_(alloc)
    {
        data_ = alloc_.allocate(count + 1);
        capacity_ = count;
        Traits::assign(data_, count, ch);
        size_ = count;
        data_[size_] = CharT();
    }

    basic_string(const basic_string &other, size_type pos, const Allocator &alloc = Allocator())
        : data_(nullptr), size_(0), capacity_(0), alloc_(alloc)
    {
        size_type count = other.size_ - pos;
        data_ = alloc_.allocate(count + 1);
        capacity_ = count;
        Traits::copy(data_, other.data_ + pos, count);
        size_ = count;
        data_[size_] = CharT();
    }

    basic_string(const basic_string &other,
                 size_type pos,
                 size_type count,
                 const Allocator &alloc = Allocator())
        : data_(nullptr), size_(0), capacity_(0), alloc_(alloc)
    {
        if (count > other.size_ - pos)
            count = other.size_ - pos;
        data_ = alloc_.allocate(count + 1);
        capacity_ = count;
        Traits::copy(data_, other.data_ + pos, count);
        size_ = count;
        data_[size_] = CharT();
    }

    basic_string(const CharT *s, size_type count, const Allocator &alloc = Allocator())
        : data_(nullptr), size_(0), capacity_(0), alloc_(alloc)
    {
        data_ = alloc_.allocate(count + 1);
        capacity_ = count;
        Traits::copy(data_, s, count);
        size_ = count;
        data_[size_] = CharT();
    }

    basic_string(const CharT *s, const Allocator &alloc = Allocator())
        : data_(nullptr), size_(0), capacity_(0), alloc_(alloc)
    {
        size_type count = Traits::length(s);
        data_ = alloc_.allocate(count + 1);
        capacity_ = count;
        Traits::copy(data_, s, count);
        size_ = count;
        data_[size_] = CharT();
    }

    template <typename InputIt>
    basic_string(InputIt first, InputIt last, const Allocator &alloc = Allocator())
        : data_(nullptr), size_(0), capacity_(0), alloc_(alloc)
    {
        data_ = alloc_.allocate(1);
        data_[0] = CharT();
        for (; first != last; ++first)
        {
            push_back(*first);
        }
    }

    basic_string(const basic_string &other)
        : data_(nullptr), size_(0), capacity_(0), alloc_(other.alloc_)
    {
        data_ = alloc_.allocate(other.size_ + 1);
        capacity_ = other.size_;
        Traits::copy(data_, other.data_, other.size_);
        size_ = other.size_;
        data_[size_] = CharT();
    }

    basic_string(const basic_string &other, const Allocator &alloc)
        : data_(nullptr), size_(0), capacity_(0), alloc_(alloc)
    {
        data_ = alloc_.allocate(other.size_ + 1);
        capacity_ = other.size_;
        Traits::copy(data_, other.data_, other.size_);
        size_ = other.size_;
        data_[size_] = CharT();
    }

    basic_string(basic_string &&other) noexcept
        : data_(other.data_), size_(other.size_), capacity_(other.capacity_),
          alloc_(std::move(other.alloc_))
    {
        other.data_ = nullptr;
        other.size_ = 0;
        other.capacity_ = 0;
    }

    basic_string(basic_string &&other, const Allocator &alloc)
        : data_(nullptr), size_(0), capacity_(0), alloc_(alloc)
    {
        if (alloc_ == other.alloc_)
        {
            data_ = other.data_;
            size_ = other.size_;
            capacity_ = other.capacity_;
            other.data_ = nullptr;
            other.size_ = 0;
            other.capacity_ = 0;
        }
        else
        {
            data_ = alloc_.allocate(other.size_ + 1);
            capacity_ = other.size_;
            Traits::copy(data_, other.data_, other.size_);
            size_ = other.size_;
            data_[size_] = CharT();
        }
    }

    basic_string(initializer_list<CharT> init, const Allocator &alloc = Allocator())
        : data_(nullptr), size_(0), capacity_(0), alloc_(alloc)
    {
        data_ = alloc_.allocate(init.size() + 1);
        capacity_ = init.size();
        Traits::copy(data_, init.begin(), init.size());
        size_ = init.size();
        data_[size_] = CharT();
    }

    // Construct from string_view
    template <typename T>
    explicit basic_string(const T &t, const Allocator &alloc = Allocator())
        : data_(nullptr), size_(0), capacity_(0), alloc_(alloc)
    {
        basic_string_view<CharT> sv = t;
        data_ = alloc_.allocate(sv.size() + 1);
        capacity_ = sv.size();
        Traits::copy(data_, sv.data(), sv.size());
        size_ = sv.size();
        data_[size_] = CharT();
    }

    // Destructor
    ~basic_string()
    {
        deallocate();
    }

    // Assignment
    basic_string &operator=(const basic_string &other)
    {
        if (this != &other)
        {
            if (capacity_ < other.size_)
            {
                deallocate();
                data_ = alloc_.allocate(other.size_ + 1);
                capacity_ = other.size_;
            }
            Traits::copy(data_, other.data_, other.size_);
            size_ = other.size_;
            data_[size_] = CharT();
        }
        return *this;
    }

    basic_string &operator=(basic_string &&other) noexcept
    {
        if (this != &other)
        {
            deallocate();
            data_ = other.data_;
            size_ = other.size_;
            capacity_ = other.capacity_;
            alloc_ = std::move(other.alloc_);
            other.data_ = nullptr;
            other.size_ = 0;
            other.capacity_ = 0;
        }
        return *this;
    }

    basic_string &operator=(const CharT *s)
    {
        return assign(s);
    }

    basic_string &operator=(CharT ch)
    {
        clear();
        push_back(ch);
        return *this;
    }

    basic_string &operator=(initializer_list<CharT> init)
    {
        return assign(init);
    }

    basic_string &assign(size_type count, CharT ch)
    {
        if (capacity_ < count)
        {
            deallocate();
            data_ = alloc_.allocate(count + 1);
            capacity_ = count;
        }
        Traits::assign(data_, count, ch);
        size_ = count;
        data_[size_] = CharT();
        return *this;
    }

    basic_string &assign(const basic_string &str)
    {
        return *this = str;
    }

    basic_string &assign(const basic_string &str, size_type pos, size_type count = npos)
    {
        if (count > str.size_ - pos)
            count = str.size_ - pos;
        if (capacity_ < count)
        {
            deallocate();
            data_ = alloc_.allocate(count + 1);
            capacity_ = count;
        }
        Traits::copy(data_, str.data_ + pos, count);
        size_ = count;
        data_[size_] = CharT();
        return *this;
    }

    basic_string &assign(basic_string &&str) noexcept
    {
        return *this = std::move(str);
    }

    basic_string &assign(const CharT *s, size_type count)
    {
        if (capacity_ < count)
        {
            deallocate();
            data_ = alloc_.allocate(count + 1);
            capacity_ = count;
        }
        Traits::copy(data_, s, count);
        size_ = count;
        data_[size_] = CharT();
        return *this;
    }

    basic_string &assign(const CharT *s)
    {
        return assign(s, Traits::length(s));
    }

    template <typename InputIt> basic_string &assign(InputIt first, InputIt last)
    {
        clear();
        for (; first != last; ++first)
        {
            push_back(*first);
        }
        return *this;
    }

    basic_string &assign(initializer_list<CharT> init)
    {
        return assign(init.begin(), init.size());
    }

    allocator_type get_allocator() const noexcept
    {
        return alloc_;
    }

    // Element access
    reference at(size_type pos)
    {
        return data_[pos];
    }

    const_reference at(size_type pos) const
    {
        return data_[pos];
    }

    reference operator[](size_type pos)
    {
        return data_[pos];
    }

    const_reference operator[](size_type pos) const
    {
        return data_[pos];
    }

    reference front()
    {
        return data_[0];
    }

    const_reference front() const
    {
        return data_[0];
    }

    reference back()
    {
        return data_[size_ - 1];
    }

    const_reference back() const
    {
        return data_[size_ - 1];
    }

    pointer data() noexcept
    {
        return data_;
    }

    const_pointer data() const noexcept
    {
        return data_;
    }

    const_pointer c_str() const noexcept
    {
        return data_;
    }

    // Convert to string_view
    operator basic_string_view<CharT>() const noexcept
    {
        return basic_string_view<CharT>(data_, size_);
    }

    // Iterators
    iterator begin() noexcept
    {
        return data_;
    }

    const_iterator begin() const noexcept
    {
        return data_;
    }

    const_iterator cbegin() const noexcept
    {
        return data_;
    }

    iterator end() noexcept
    {
        return data_ + size_;
    }

    const_iterator end() const noexcept
    {
        return data_ + size_;
    }

    const_iterator cend() const noexcept
    {
        return data_ + size_;
    }

    reverse_iterator rbegin() noexcept
    {
        return reverse_iterator(end());
    }

    const_reverse_iterator rbegin() const noexcept
    {
        return const_reverse_iterator(end());
    }

    const_reverse_iterator crbegin() const noexcept
    {
        return const_reverse_iterator(end());
    }

    reverse_iterator rend() noexcept
    {
        return reverse_iterator(begin());
    }

    const_reverse_iterator rend() const noexcept
    {
        return const_reverse_iterator(begin());
    }

    const_reverse_iterator crend() const noexcept
    {
        return const_reverse_iterator(begin());
    }

    // Capacity
    bool empty() const noexcept
    {
        return size_ == 0;
    }

    size_type size() const noexcept
    {
        return size_;
    }

    size_type length() const noexcept
    {
        return size_;
    }

    size_type max_size() const noexcept
    {
        return static_cast<size_type>(-1) / sizeof(CharT) - 1;
    }

    void reserve(size_type new_cap)
    {
        if (new_cap > capacity_)
        {
            reallocate(new_cap);
        }
    }

    size_type capacity() const noexcept
    {
        return capacity_;
    }

    void shrink_to_fit()
    {
        if (size_ < capacity_)
        {
            reallocate(size_);
        }
    }

    // Operations
    void clear() noexcept
    {
        size_ = 0;
        if (data_)
            data_[0] = CharT();
    }

    basic_string &insert(size_type pos, size_type count, CharT ch)
    {
        if (size_ + count > capacity_)
        {
            reallocate(grow_capacity(size_ + count));
        }
        Traits::move(data_ + pos + count, data_ + pos, size_ - pos);
        Traits::assign(data_ + pos, count, ch);
        size_ += count;
        data_[size_] = CharT();
        return *this;
    }

    basic_string &insert(size_type pos, const CharT *s)
    {
        return insert(pos, s, Traits::length(s));
    }

    basic_string &insert(size_type pos, const CharT *s, size_type count)
    {
        if (size_ + count > capacity_)
        {
            reallocate(grow_capacity(size_ + count));
        }
        Traits::move(data_ + pos + count, data_ + pos, size_ - pos);
        Traits::copy(data_ + pos, s, count);
        size_ += count;
        data_[size_] = CharT();
        return *this;
    }

    basic_string &insert(size_type pos, const basic_string &str)
    {
        return insert(pos, str.data_, str.size_);
    }

    basic_string &erase(size_type pos = 0, size_type count = npos)
    {
        if (count > size_ - pos)
            count = size_ - pos;
        Traits::move(data_ + pos, data_ + pos + count, size_ - pos - count);
        size_ -= count;
        data_[size_] = CharT();
        return *this;
    }

    iterator erase(const_iterator position)
    {
        size_type pos = position - data_;
        erase(pos, 1);
        return data_ + pos;
    }

    iterator erase(const_iterator first, const_iterator last)
    {
        size_type pos = first - data_;
        size_type count = last - first;
        erase(pos, count);
        return data_ + pos;
    }

    void push_back(CharT ch)
    {
        if (size_ >= capacity_)
        {
            reallocate(grow_capacity(size_ + 1));
        }
        data_[size_++] = ch;
        data_[size_] = CharT();
    }

    void pop_back()
    {
        --size_;
        data_[size_] = CharT();
    }

    basic_string &append(size_type count, CharT ch)
    {
        if (size_ + count > capacity_)
        {
            reallocate(grow_capacity(size_ + count));
        }
        Traits::assign(data_ + size_, count, ch);
        size_ += count;
        data_[size_] = CharT();
        return *this;
    }

    basic_string &append(const basic_string &str)
    {
        return append(str.data_, str.size_);
    }

    basic_string &append(const basic_string &str, size_type pos, size_type count = npos)
    {
        if (count > str.size_ - pos)
            count = str.size_ - pos;
        return append(str.data_ + pos, count);
    }

    basic_string &append(const CharT *s, size_type count)
    {
        if (size_ + count > capacity_)
        {
            reallocate(grow_capacity(size_ + count));
        }
        Traits::copy(data_ + size_, s, count);
        size_ += count;
        data_[size_] = CharT();
        return *this;
    }

    basic_string &append(const CharT *s)
    {
        return append(s, Traits::length(s));
    }

    template <typename InputIt> basic_string &append(InputIt first, InputIt last)
    {
        for (; first != last; ++first)
        {
            push_back(*first);
        }
        return *this;
    }

    basic_string &append(initializer_list<CharT> init)
    {
        return append(init.begin(), init.size());
    }

    basic_string &operator+=(const basic_string &str)
    {
        return append(str);
    }

    basic_string &operator+=(CharT ch)
    {
        push_back(ch);
        return *this;
    }

    basic_string &operator+=(const CharT *s)
    {
        return append(s);
    }

    basic_string &operator+=(initializer_list<CharT> init)
    {
        return append(init);
    }

    int compare(const basic_string &str) const noexcept
    {
        size_type rlen = size_ < str.size_ ? size_ : str.size_;
        int result = Traits::compare(data_, str.data_, rlen);
        if (result != 0)
            return result;
        if (size_ < str.size_)
            return -1;
        if (size_ > str.size_)
            return 1;
        return 0;
    }

    int compare(size_type pos1, size_type count1, const basic_string &str) const
    {
        return substr(pos1, count1).compare(str);
    }

    int compare(const CharT *s) const
    {
        return compare(basic_string(s));
    }

    basic_string &replace(size_type pos, size_type count, const basic_string &str)
    {
        return replace(pos, count, str.data_, str.size_);
    }

    basic_string &replace(size_type pos, size_type count, const CharT *s, size_type count2)
    {
        erase(pos, count);
        insert(pos, s, count2);
        return *this;
    }

    basic_string &replace(size_type pos, size_type count, const CharT *s)
    {
        return replace(pos, count, s, Traits::length(s));
    }

    basic_string &replace(size_type pos, size_type count, size_type count2, CharT ch)
    {
        erase(pos, count);
        insert(pos, count2, ch);
        return *this;
    }

    basic_string substr(size_type pos = 0, size_type count = npos) const
    {
        if (count > size_ - pos)
            count = size_ - pos;
        return basic_string(data_ + pos, count);
    }

    size_type copy(CharT *dest, size_type count, size_type pos = 0) const
    {
        if (count > size_ - pos)
            count = size_ - pos;
        Traits::copy(dest, data_ + pos, count);
        return count;
    }

    void resize(size_type count)
    {
        resize(count, CharT());
    }

    void resize(size_type count, CharT ch)
    {
        if (count > capacity_)
        {
            reallocate(count);
        }
        if (count > size_)
        {
            Traits::assign(data_ + size_, count - size_, ch);
        }
        size_ = count;
        data_[size_] = CharT();
    }

    void swap(basic_string &other) noexcept
    {
        pointer tmp_data = data_;
        data_ = other.data_;
        other.data_ = tmp_data;

        size_type tmp_size = size_;
        size_ = other.size_;
        other.size_ = tmp_size;

        size_type tmp_cap = capacity_;
        capacity_ = other.capacity_;
        other.capacity_ = tmp_cap;
    }

    // Search
    size_type find(const basic_string &str, size_type pos = 0) const noexcept
    {
        return find(str.data_, pos, str.size_);
    }

    size_type find(const CharT *s, size_type pos, size_type count) const
    {
        if (count == 0)
            return pos <= size_ ? pos : npos;
        if (pos >= size_ || count > size_ - pos)
            return npos;

        for (size_type i = pos; i <= size_ - count; ++i)
        {
            if (Traits::compare(data_ + i, s, count) == 0)
            {
                return i;
            }
        }
        return npos;
    }

    size_type find(const CharT *s, size_type pos = 0) const
    {
        return find(s, pos, Traits::length(s));
    }

    size_type find(CharT ch, size_type pos = 0) const noexcept
    {
        for (size_type i = pos; i < size_; ++i)
        {
            if (Traits::eq(data_[i], ch))
                return i;
        }
        return npos;
    }

    size_type rfind(const basic_string &str, size_type pos = npos) const noexcept
    {
        return rfind(str.data_, pos, str.size_);
    }

    size_type rfind(const CharT *s, size_type pos, size_type count) const
    {
        if (count == 0)
            return pos < size_ ? pos : size_;
        if (count > size_)
            return npos;

        size_type last = size_ - count;
        if (pos < last)
            last = pos;

        for (size_type i = last + 1; i > 0; --i)
        {
            if (Traits::compare(data_ + i - 1, s, count) == 0)
            {
                return i - 1;
            }
        }
        return npos;
    }

    size_type rfind(const CharT *s, size_type pos = npos) const
    {
        return rfind(s, pos, Traits::length(s));
    }

    size_type rfind(CharT ch, size_type pos = npos) const noexcept
    {
        if (size_ == 0)
            return npos;
        size_type last = pos < size_ - 1 ? pos : size_ - 1;
        for (size_type i = last + 1; i > 0; --i)
        {
            if (Traits::eq(data_[i - 1], ch))
                return i - 1;
        }
        return npos;
    }

    size_type find_first_of(const basic_string &str, size_type pos = 0) const noexcept
    {
        return find_first_of(str.data_, pos, str.size_);
    }

    size_type find_first_of(const CharT *s, size_type pos, size_type count) const
    {
        for (size_type i = pos; i < size_; ++i)
        {
            if (Traits::find(s, count, data_[i]))
                return i;
        }
        return npos;
    }

    size_type find_first_of(const CharT *s, size_type pos = 0) const
    {
        return find_first_of(s, pos, Traits::length(s));
    }

    size_type find_first_of(CharT ch, size_type pos = 0) const noexcept
    {
        return find(ch, pos);
    }

    size_type find_last_of(const basic_string &str, size_type pos = npos) const noexcept
    {
        return find_last_of(str.data_, pos, str.size_);
    }

    size_type find_last_of(const CharT *s, size_type pos, size_type count) const
    {
        if (size_ == 0)
            return npos;
        size_type last = pos < size_ - 1 ? pos : size_ - 1;
        for (size_type i = last + 1; i > 0; --i)
        {
            if (Traits::find(s, count, data_[i - 1]))
                return i - 1;
        }
        return npos;
    }

    size_type find_last_of(const CharT *s, size_type pos = npos) const
    {
        return find_last_of(s, pos, Traits::length(s));
    }

    size_type find_last_of(CharT ch, size_type pos = npos) const noexcept
    {
        return rfind(ch, pos);
    }

    // starts_with / ends_with (C++20)
    bool starts_with(basic_string_view<CharT> sv) const noexcept
    {
        return size_ >= sv.size() && Traits::compare(data_, sv.data(), sv.size()) == 0;
    }

    bool starts_with(CharT ch) const noexcept
    {
        return !empty() && Traits::eq(front(), ch);
    }

    bool starts_with(const CharT *s) const
    {
        return starts_with(basic_string_view<CharT>(s));
    }

    bool ends_with(basic_string_view<CharT> sv) const noexcept
    {
        return size_ >= sv.size() &&
               Traits::compare(data_ + size_ - sv.size(), sv.data(), sv.size()) == 0;
    }

    bool ends_with(CharT ch) const noexcept
    {
        return !empty() && Traits::eq(back(), ch);
    }

    bool ends_with(const CharT *s) const
    {
        return ends_with(basic_string_view<CharT>(s));
    }

    // contains (C++23)
    bool contains(basic_string_view<CharT> sv) const noexcept
    {
        return find(sv.data(), 0, sv.size()) != npos;
    }

    bool contains(CharT ch) const noexcept
    {
        return find(ch) != npos;
    }

    bool contains(const CharT *s) const
    {
        return find(s) != npos;
    }
};

// Type aliases
using string = basic_string<char>;
using wstring = basic_string<wchar_t>;
using u16string = basic_string<char16_t>;
using u32string = basic_string<char32_t>;

// Comparison operators
template <typename CharT, typename Traits, typename Alloc>
bool operator==(const basic_string<CharT, Traits, Alloc> &lhs,
                const basic_string<CharT, Traits, Alloc> &rhs) noexcept
{
    return lhs.compare(rhs) == 0;
}

template <typename CharT, typename Traits, typename Alloc>
bool operator==(const basic_string<CharT, Traits, Alloc> &lhs, const CharT *rhs)
{
    return lhs.compare(rhs) == 0;
}

template <typename CharT, typename Traits, typename Alloc>
bool operator==(const CharT *lhs, const basic_string<CharT, Traits, Alloc> &rhs)
{
    return rhs.compare(lhs) == 0;
}

template <typename CharT, typename Traits, typename Alloc>
bool operator!=(const basic_string<CharT, Traits, Alloc> &lhs,
                const basic_string<CharT, Traits, Alloc> &rhs) noexcept
{
    return !(lhs == rhs);
}

template <typename CharT, typename Traits, typename Alloc>
bool operator<(const basic_string<CharT, Traits, Alloc> &lhs,
               const basic_string<CharT, Traits, Alloc> &rhs) noexcept
{
    return lhs.compare(rhs) < 0;
}

template <typename CharT, typename Traits, typename Alloc>
bool operator<=(const basic_string<CharT, Traits, Alloc> &lhs,
                const basic_string<CharT, Traits, Alloc> &rhs) noexcept
{
    return lhs.compare(rhs) <= 0;
}

template <typename CharT, typename Traits, typename Alloc>
bool operator>(const basic_string<CharT, Traits, Alloc> &lhs,
               const basic_string<CharT, Traits, Alloc> &rhs) noexcept
{
    return lhs.compare(rhs) > 0;
}

template <typename CharT, typename Traits, typename Alloc>
bool operator>=(const basic_string<CharT, Traits, Alloc> &lhs,
                const basic_string<CharT, Traits, Alloc> &rhs) noexcept
{
    return lhs.compare(rhs) >= 0;
}

// Concatenation
template <typename CharT, typename Traits, typename Alloc>
basic_string<CharT, Traits, Alloc> operator+(const basic_string<CharT, Traits, Alloc> &lhs,
                                             const basic_string<CharT, Traits, Alloc> &rhs)
{
    basic_string<CharT, Traits, Alloc> result = lhs;
    result.append(rhs);
    return result;
}

template <typename CharT, typename Traits, typename Alloc>
basic_string<CharT, Traits, Alloc> operator+(const basic_string<CharT, Traits, Alloc> &lhs,
                                             const CharT *rhs)
{
    basic_string<CharT, Traits, Alloc> result = lhs;
    result.append(rhs);
    return result;
}

template <typename CharT, typename Traits, typename Alloc>
basic_string<CharT, Traits, Alloc> operator+(const CharT *lhs,
                                             const basic_string<CharT, Traits, Alloc> &rhs)
{
    basic_string<CharT, Traits, Alloc> result(lhs);
    result.append(rhs);
    return result;
}

template <typename CharT, typename Traits, typename Alloc>
basic_string<CharT, Traits, Alloc> operator+(const basic_string<CharT, Traits, Alloc> &lhs,
                                             CharT rhs)
{
    basic_string<CharT, Traits, Alloc> result = lhs;
    result.push_back(rhs);
    return result;
}

template <typename CharT, typename Traits, typename Alloc>
basic_string<CharT, Traits, Alloc> operator+(CharT lhs,
                                             const basic_string<CharT, Traits, Alloc> &rhs)
{
    basic_string<CharT, Traits, Alloc> result(1, lhs);
    result.append(rhs);
    return result;
}

// swap
template <typename CharT, typename Traits, typename Alloc>
void swap(basic_string<CharT, Traits, Alloc> &lhs, basic_string<CharT, Traits, Alloc> &rhs) noexcept
{
    lhs.swap(rhs);
}

// Numeric conversions
int stoi(const string &str, size_t *pos = nullptr, int base = 10);
long stol(const string &str, size_t *pos = nullptr, int base = 10);
long long stoll(const string &str, size_t *pos = nullptr, int base = 10);
unsigned long stoul(const string &str, size_t *pos = nullptr, int base = 10);
unsigned long long stoull(const string &str, size_t *pos = nullptr, int base = 10);
float stof(const string &str, size_t *pos = nullptr);
double stod(const string &str, size_t *pos = nullptr);
long double stold(const string &str, size_t *pos = nullptr);

string to_string(int value);
string to_string(long value);
string to_string(long long value);
string to_string(unsigned value);
string to_string(unsigned long value);
string to_string(unsigned long long value);
string to_string(float value);
string to_string(double value);
string to_string(long double value);

// hash specialization
template <> struct hash<string>
{
    size_t operator()(const string &s) const noexcept
    {
        size_t h = 14695981039346656037ULL;
        for (size_t i = 0; i < s.size(); ++i)
        {
            h ^= static_cast<size_t>(s[i]);
            h *= 1099511628211ULL;
        }
        return h;
    }
};

// Literal suffix
inline namespace literals
{
inline namespace string_literals
{
inline string operator""_s(const char *str, size_t len)
{
    return string(str, len);
}
} // namespace string_literals
} // namespace literals

} // namespace std

#endif // _VIPER_CXX_STRING
