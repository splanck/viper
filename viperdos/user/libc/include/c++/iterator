#ifndef _LIBCPP_ITERATOR
#define _LIBCPP_ITERATOR

#include "cstddef"

namespace std {

/* Iterator tags */
struct input_iterator_tag {};

struct output_iterator_tag {};

struct forward_iterator_tag : public input_iterator_tag {};

struct bidirectional_iterator_tag : public forward_iterator_tag {};

struct random_access_iterator_tag : public bidirectional_iterator_tag {};

struct contiguous_iterator_tag : public random_access_iterator_tag {}; /* C++20 */

/* Primary iterator_traits template */
template <class Iterator> struct iterator_traits {
    using difference_type = typename Iterator::difference_type;
    using value_type = typename Iterator::value_type;
    using pointer = typename Iterator::pointer;
    using reference = typename Iterator::reference;
    using iterator_category = typename Iterator::iterator_category;
};

/* Specialization for pointers */
template <class T> struct iterator_traits<T *> {
    using difference_type = ptrdiff_t;
    using value_type = T;
    using pointer = T *;
    using reference = T &;
    using iterator_category = random_access_iterator_tag;
};

/* Specialization for const pointers */
template <class T> struct iterator_traits<const T *> {
    using difference_type = ptrdiff_t;
    using value_type = T;
    using pointer = const T *;
    using reference = const T &;
    using iterator_category = random_access_iterator_tag;
};

/* Base iterator class (deprecated but still useful) */
template <class Category,
          class T,
          class Distance = ptrdiff_t,
          class Pointer = T *,
          class Reference = T &>
struct iterator {
    using iterator_category = Category;
    using value_type = T;
    using difference_type = Distance;
    using pointer = Pointer;
    using reference = Reference;
};

/* Iterator operations */
template <class InputIt>
typename iterator_traits<InputIt>::difference_type distance(InputIt first, InputIt last) {
    typename iterator_traits<InputIt>::difference_type result = 0;
    while (first != last) {
        ++first;
        ++result;
    }
    return result;
}

/* Random access iterator specialization */
template <class RandomIt>
typename iterator_traits<RandomIt>::difference_type distance_impl(RandomIt first,
                                                                  RandomIt last,
                                                                  random_access_iterator_tag) {
    return last - first;
}

template <class InputIt, class Distance> void advance(InputIt &it, Distance n) {
    while (n > 0) {
        ++it;
        --n;
    }
    while (n < 0) {
        --it;
        ++n;
    }
}

template <class InputIt>
InputIt next(InputIt it, typename iterator_traits<InputIt>::difference_type n = 1) {
    advance(it, n);
    return it;
}

template <class BidirIt>
BidirIt prev(BidirIt it, typename iterator_traits<BidirIt>::difference_type n = 1) {
    advance(it, -n);
    return it;
}

/* Reverse iterator */
template <class Iterator> class reverse_iterator {
  protected:
    Iterator current;

  public:
    using iterator_type = Iterator;
    using difference_type = typename iterator_traits<Iterator>::difference_type;
    using value_type = typename iterator_traits<Iterator>::value_type;
    using pointer = typename iterator_traits<Iterator>::pointer;
    using reference = typename iterator_traits<Iterator>::reference;
    using iterator_category = typename iterator_traits<Iterator>::iterator_category;

    constexpr reverse_iterator() : current() {}

    constexpr explicit reverse_iterator(Iterator x) : current(x) {}

    template <class U>
    constexpr reverse_iterator(const reverse_iterator<U> &other) : current(other.base()) {}

    constexpr Iterator base() const {
        return current;
    }

    constexpr reference operator*() const {
        Iterator tmp = current;
        return *--tmp;
    }

    constexpr pointer operator->() const {
        return &(operator*());
    }

    constexpr reverse_iterator &operator++() {
        --current;
        return *this;
    }

    constexpr reverse_iterator operator++(int) {
        reverse_iterator tmp = *this;
        --current;
        return tmp;
    }

    constexpr reverse_iterator &operator--() {
        ++current;
        return *this;
    }

    constexpr reverse_iterator operator--(int) {
        reverse_iterator tmp = *this;
        ++current;
        return tmp;
    }

    constexpr reverse_iterator operator+(difference_type n) const {
        return reverse_iterator(current - n);
    }

    constexpr reverse_iterator &operator+=(difference_type n) {
        current -= n;
        return *this;
    }

    constexpr reverse_iterator operator-(difference_type n) const {
        return reverse_iterator(current + n);
    }

    constexpr reverse_iterator &operator-=(difference_type n) {
        current += n;
        return *this;
    }

    constexpr reference operator[](difference_type n) const {
        return *(*this + n);
    }
};

template <class It1, class It2>
constexpr bool operator==(const reverse_iterator<It1> &lhs, const reverse_iterator<It2> &rhs) {
    return lhs.base() == rhs.base();
}

template <class It1, class It2>
constexpr bool operator!=(const reverse_iterator<It1> &lhs, const reverse_iterator<It2> &rhs) {
    return lhs.base() != rhs.base();
}

template <class It1, class It2>
constexpr bool operator<(const reverse_iterator<It1> &lhs, const reverse_iterator<It2> &rhs) {
    return lhs.base() > rhs.base();
}

template <class It1, class It2>
constexpr bool operator<=(const reverse_iterator<It1> &lhs, const reverse_iterator<It2> &rhs) {
    return lhs.base() >= rhs.base();
}

template <class It1, class It2>
constexpr bool operator>(const reverse_iterator<It1> &lhs, const reverse_iterator<It2> &rhs) {
    return lhs.base() < rhs.base();
}

template <class It1, class It2>
constexpr bool operator>=(const reverse_iterator<It1> &lhs, const reverse_iterator<It2> &rhs) {
    return lhs.base() <= rhs.base();
}

template <class Iterator> constexpr reverse_iterator<Iterator> make_reverse_iterator(Iterator i) {
    return reverse_iterator<Iterator>(i);
}

/* begin/end for arrays */
template <class T, size_t N> constexpr T *begin(T (&array)[N]) noexcept {
    return array;
}

template <class T, size_t N> constexpr T *end(T (&array)[N]) noexcept {
    return array + N;
}

/* begin/end for containers */
template <class C> constexpr auto begin(C &c) -> decltype(c.begin()) {
    return c.begin();
}

template <class C> constexpr auto begin(const C &c) -> decltype(c.begin()) {
    return c.begin();
}

template <class C> constexpr auto end(C &c) -> decltype(c.end()) {
    return c.end();
}

template <class C> constexpr auto end(const C &c) -> decltype(c.end()) {
    return c.end();
}

/* cbegin/cend */
template <class C>
constexpr auto cbegin(const C &c) noexcept(noexcept(begin(c))) -> decltype(begin(c)) {
    return begin(c);
}

template <class C> constexpr auto cend(const C &c) noexcept(noexcept(end(c))) -> decltype(end(c)) {
    return end(c);
}

/* rbegin/rend */
template <class C> constexpr auto rbegin(C &c) -> decltype(c.rbegin()) {
    return c.rbegin();
}

template <class C> constexpr auto rbegin(const C &c) -> decltype(c.rbegin()) {
    return c.rbegin();
}

template <class C> constexpr auto rend(C &c) -> decltype(c.rend()) {
    return c.rend();
}

template <class C> constexpr auto rend(const C &c) -> decltype(c.rend()) {
    return c.rend();
}

template <class T, size_t N> constexpr reverse_iterator<T *> rbegin(T (&array)[N]) {
    return reverse_iterator<T *>(array + N);
}

template <class T, size_t N> constexpr reverse_iterator<T *> rend(T (&array)[N]) {
    return reverse_iterator<T *>(array);
}

/* size, empty, data */
template <class C> constexpr auto size(const C &c) -> decltype(c.size()) {
    return c.size();
}

template <class T, size_t N> constexpr size_t size(const T (&)[N]) noexcept {
    return N;
}

template <class C> constexpr auto empty(const C &c) -> decltype(c.empty()) {
    return c.empty();
}

template <class T, size_t N> constexpr bool empty(const T (&)[N]) noexcept {
    return false;
}

template <class C> constexpr auto data(C &c) -> decltype(c.data()) {
    return c.data();
}

template <class C> constexpr auto data(const C &c) -> decltype(c.data()) {
    return c.data();
}

template <class T, size_t N> constexpr T *data(T (&array)[N]) noexcept {
    return array;
}

/* Back/front insert iterators */
template <class Container> class back_insert_iterator {
  protected:
    Container *container;

  public:
    using iterator_category = output_iterator_tag;
    using value_type = void;
    using difference_type = void;
    using pointer = void;
    using reference = void;
    using container_type = Container;

    explicit back_insert_iterator(Container &x) : container(&x) {}

    back_insert_iterator &operator=(const typename Container::value_type &value) {
        container->push_back(value);
        return *this;
    }

    back_insert_iterator &operator=(typename Container::value_type &&value) {
        container->push_back(static_cast<typename Container::value_type &&>(value));
        return *this;
    }

    back_insert_iterator &operator*() {
        return *this;
    }

    back_insert_iterator &operator++() {
        return *this;
    }

    back_insert_iterator operator++(int) {
        return *this;
    }
};

template <class Container> back_insert_iterator<Container> back_inserter(Container &c) {
    return back_insert_iterator<Container>(c);
}

template <class Container> class front_insert_iterator {
  protected:
    Container *container;

  public:
    using iterator_category = output_iterator_tag;
    using value_type = void;
    using difference_type = void;
    using pointer = void;
    using reference = void;
    using container_type = Container;

    explicit front_insert_iterator(Container &x) : container(&x) {}

    front_insert_iterator &operator=(const typename Container::value_type &value) {
        container->push_front(value);
        return *this;
    }

    front_insert_iterator &operator=(typename Container::value_type &&value) {
        container->push_front(static_cast<typename Container::value_type &&>(value));
        return *this;
    }

    front_insert_iterator &operator*() {
        return *this;
    }

    front_insert_iterator &operator++() {
        return *this;
    }

    front_insert_iterator operator++(int) {
        return *this;
    }
};

template <class Container> front_insert_iterator<Container> front_inserter(Container &c) {
    return front_insert_iterator<Container>(c);
}

} /* namespace std */

#endif /* _LIBCPP_ITERATOR */
