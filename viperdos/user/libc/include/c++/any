// -*- C++ -*-
// ViperDOS C++ Standard Library - any
// Type-erased value container (C++17)

#ifndef _VIPER_ANY
#define _VIPER_ANY

#include "initializer_list"
#include "memory"
#include "type_traits"
#include "utility"

namespace std
{

// Forward declarations
class any;
class bad_any_cast;

// bad_any_cast exception
class bad_any_cast
{
  public:
    const char *what() const noexcept
    {
        return "bad any cast";
    }
};

// Internal implementation details
namespace detail
{

// Type info for stored value
struct any_type_info
{
    const void *type_id; // Simple type identification using function pointer

    bool operator==(const any_type_info &other) const
    {
        return type_id == other.type_id;
    }

    bool operator!=(const any_type_info &other) const
    {
        return type_id != other.type_id;
    }
};

// Get type info for a type
template <typename T> any_type_info get_any_type_info()
{
    static const int type_marker = 0;
    return {&type_marker};
}

// Virtual base for type-erased storage
struct any_storage_base
{
    virtual ~any_storage_base() = default;
    virtual any_storage_base *clone() const = 0;
    virtual any_type_info type_info() const = 0;
    virtual void *get_ptr() = 0;
    virtual const void *get_ptr() const = 0;
};

// Storage implementation for specific types
template <typename T> struct any_storage : any_storage_base
{
    T value;

    template <typename... Args> any_storage(Args &&...args) : value(std::forward<Args>(args)...) {}

    any_storage_base *clone() const override
    {
        return new any_storage<T>(value);
    }

    any_type_info type_info() const override
    {
        return get_any_type_info<T>();
    }

    void *get_ptr() override
    {
        return &value;
    }

    const void *get_ptr() const override
    {
        return &value;
    }
};

// Small buffer optimization size (store small objects inline)
constexpr size_t any_sbo_size = sizeof(void *) * 2;
constexpr size_t any_sbo_align = alignof(max_align_t);

// Check if type fits in small buffer
template <typename T>
constexpr bool any_uses_sbo = sizeof(T) <= any_sbo_size && alignof(T) <= any_sbo_align &&
                              is_nothrow_move_constructible<T>::value;

} // namespace detail

// =============================================================================
// any - Type-erased value container
// =============================================================================

class any
{
  private:
    detail::any_storage_base *storage_;

    template <typename T> friend T *any_cast(any *) noexcept;

    template <typename T> friend const T *any_cast(const any *) noexcept;

  public:
    // Constructors
    constexpr any() noexcept : storage_(nullptr) {}

    any(const any &other) : storage_(nullptr)
    {
        if (other.storage_)
        {
            storage_ = other.storage_->clone();
        }
    }

    any(any &&other) noexcept : storage_(other.storage_)
    {
        other.storage_ = nullptr;
    }

    template <
        typename T,
        typename = typename enable_if<!is_same<typename decay<T>::type, any>::value &&
                                      is_copy_constructible<typename decay<T>::type>::value>::type>
    any(T &&value) : storage_(nullptr)
    {
        using DecayT = typename decay<T>::type;
        storage_ = new detail::any_storage<DecayT>(std::forward<T>(value));
    }

    template <
        typename T,
        typename... Args,
        typename = typename enable_if<is_constructible<typename decay<T>::type, Args...>::value &&
                                      is_copy_constructible<typename decay<T>::type>::value>::type>
    explicit any(in_place_type_t<T>, Args &&...args) : storage_(nullptr)
    {
        using DecayT = typename decay<T>::type;
        storage_ = new detail::any_storage<DecayT>(std::forward<Args>(args)...);
    }

    template <
        typename T,
        typename U,
        typename... Args,
        typename = typename enable_if<
            is_constructible<typename decay<T>::type, initializer_list<U> &, Args...>::value &&
            is_copy_constructible<typename decay<T>::type>::value>::type>
    explicit any(in_place_type_t<T>, initializer_list<U> il, Args &&...args) : storage_(nullptr)
    {
        using DecayT = typename decay<T>::type;
        storage_ = new detail::any_storage<DecayT>(il, std::forward<Args>(args)...);
    }

    ~any()
    {
        reset();
    }

    // Assignment
    any &operator=(const any &other)
    {
        if (this != &other)
        {
            any(other).swap(*this);
        }
        return *this;
    }

    any &operator=(any &&other) noexcept
    {
        if (this != &other)
        {
            reset();
            storage_ = other.storage_;
            other.storage_ = nullptr;
        }
        return *this;
    }

    template <
        typename T,
        typename = typename enable_if<!is_same<typename decay<T>::type, any>::value &&
                                      is_copy_constructible<typename decay<T>::type>::value>::type>
    any &operator=(T &&value)
    {
        any(std::forward<T>(value)).swap(*this);
        return *this;
    }

    // Modifiers
    template <
        typename T,
        typename... Args,
        typename = typename enable_if<is_constructible<typename decay<T>::type, Args...>::value &&
                                      is_copy_constructible<typename decay<T>::type>::value>::type>
    typename decay<T>::type &emplace(Args &&...args)
    {
        using DecayT = typename decay<T>::type;
        reset();
        storage_ = new detail::any_storage<DecayT>(std::forward<Args>(args)...);
        return *static_cast<DecayT *>(storage_->get_ptr());
    }

    template <
        typename T,
        typename U,
        typename... Args,
        typename = typename enable_if<
            is_constructible<typename decay<T>::type, initializer_list<U> &, Args...>::value &&
            is_copy_constructible<typename decay<T>::type>::value>::type>
    typename decay<T>::type &emplace(initializer_list<U> il, Args &&...args)
    {
        using DecayT = typename decay<T>::type;
        reset();
        storage_ = new detail::any_storage<DecayT>(il, std::forward<Args>(args)...);
        return *static_cast<DecayT *>(storage_->get_ptr());
    }

    void reset() noexcept
    {
        if (storage_)
        {
            delete storage_;
            storage_ = nullptr;
        }
    }

    void swap(any &other) noexcept
    {
        std::swap(storage_, other.storage_);
    }

    // Observers
    bool has_value() const noexcept
    {
        return storage_ != nullptr;
    }

    // Type info (simplified - not full RTTI)
    detail::any_type_info type_info() const noexcept
    {
        if (storage_)
        {
            return storage_->type_info();
        }
        return {nullptr};
    }
};

// Non-member functions
inline void swap(any &lhs, any &rhs) noexcept
{
    lhs.swap(rhs);
}

// make_any
template <typename T, typename... Args> any make_any(Args &&...args)
{
    return any(in_place_type_t<T>{}, std::forward<Args>(args)...);
}

template <typename T, typename U, typename... Args>
any make_any(initializer_list<U> il, Args &&...args)
{
    return any(in_place_type_t<T>{}, il, std::forward<Args>(args)...);
}

// any_cast implementations
template <typename T> T *any_cast(any *operand) noexcept
{
    if (!operand || !operand->storage_)
        return nullptr;

    if (operand->storage_->type_info() == detail::get_any_type_info<T>())
    {
        return static_cast<T *>(operand->storage_->get_ptr());
    }
    return nullptr;
}

template <typename T> const T *any_cast(const any *operand) noexcept
{
    if (!operand || !operand->storage_)
        return nullptr;

    if (operand->storage_->type_info() == detail::get_any_type_info<T>())
    {
        return static_cast<const T *>(operand->storage_->get_ptr());
    }
    return nullptr;
}

template <typename T> T any_cast(const any &operand)
{
    using U = typename remove_cv<typename remove_reference<T>::type>::type;
    const U *ptr = any_cast<U>(&operand);
    if (!ptr)
    {
        // Would throw bad_any_cast in standard, but we return default
        return T{};
    }
    return static_cast<T>(*ptr);
}

template <typename T> T any_cast(any &operand)
{
    using U = typename remove_cv<typename remove_reference<T>::type>::type;
    U *ptr = any_cast<U>(&operand);
    if (!ptr)
    {
        return T{};
    }
    return static_cast<T>(*ptr);
}

template <typename T> T any_cast(any &&operand)
{
    using U = typename remove_cv<typename remove_reference<T>::type>::type;
    U *ptr = any_cast<U>(&operand);
    if (!ptr)
    {
        return T{};
    }
    return static_cast<T>(std::move(*ptr));
}

} // namespace std

#endif // _VIPER_ANY
