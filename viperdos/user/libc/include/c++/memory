// C++ <memory> header for ViperDOS
// Smart pointers and memory utilities

#ifndef _VIPER_CXX_MEMORY
#define _VIPER_CXX_MEMORY

#include "cstddef"
#include "type_traits"

namespace std
{

// Forward declarations
template <typename T> class unique_ptr;
template <typename T> class shared_ptr;
template <typename T> class weak_ptr;

// default_delete - default deleter for unique_ptr
template <typename T> struct default_delete
{
    constexpr default_delete() noexcept = default;

    template <typename U> default_delete(const default_delete<U> &) noexcept {}

    void operator()(T *ptr) const
    {
        delete ptr;
    }
};

// default_delete specialization for arrays
template <typename T> struct default_delete<T[]>
{
    constexpr default_delete() noexcept = default;

    template <typename U> default_delete(const default_delete<U[]> &) noexcept {}

    template <typename U> void operator()(U *ptr) const
    {
        delete[] ptr;
    }
};

// unique_ptr - single ownership smart pointer
template <typename T, typename Deleter = default_delete<T>> class unique_ptr
{
  public:
    using pointer = T *;
    using element_type = T;
    using deleter_type = Deleter;

  private:
    pointer ptr_;
    Deleter deleter_;

  public:
    // Constructors
    constexpr unique_ptr() noexcept : ptr_(nullptr), deleter_() {}

    constexpr unique_ptr(nullptr_t) noexcept : ptr_(nullptr), deleter_() {}

    explicit unique_ptr(pointer p) noexcept : ptr_(p), deleter_() {}

    unique_ptr(pointer p, const Deleter &d) noexcept : ptr_(p), deleter_(d) {}

    unique_ptr(pointer p, Deleter &&d) noexcept : ptr_(p), deleter_(static_cast<Deleter &&>(d)) {}

    // Move constructor
    unique_ptr(unique_ptr &&u) noexcept
        : ptr_(u.release()), deleter_(static_cast<Deleter &&>(u.deleter_))
    {
    }

    // Move constructor from compatible type
    template <typename U, typename E>
    unique_ptr(unique_ptr<U, E> &&u) noexcept
        : ptr_(u.release()), deleter_(static_cast<E &&>(u.get_deleter()))
    {
    }

    // Destructor
    ~unique_ptr()
    {
        if (ptr_)
        {
            deleter_(ptr_);
        }
    }

    // No copy
    unique_ptr(const unique_ptr &) = delete;
    unique_ptr &operator=(const unique_ptr &) = delete;

    // Move assignment
    unique_ptr &operator=(unique_ptr &&r) noexcept
    {
        reset(r.release());
        deleter_ = static_cast<Deleter &&>(r.deleter_);
        return *this;
    }

    template <typename U, typename E> unique_ptr &operator=(unique_ptr<U, E> &&r) noexcept
    {
        reset(r.release());
        deleter_ = static_cast<E &&>(r.get_deleter());
        return *this;
    }

    unique_ptr &operator=(nullptr_t) noexcept
    {
        reset();
        return *this;
    }

    // Observers
    pointer get() const noexcept
    {
        return ptr_;
    }

    Deleter &get_deleter() noexcept
    {
        return deleter_;
    }

    const Deleter &get_deleter() const noexcept
    {
        return deleter_;
    }

    explicit operator bool() const noexcept
    {
        return ptr_ != nullptr;
    }

    // Dereference
    typename add_lvalue_reference<T>::type operator*() const
    {
        return *ptr_;
    }

    pointer operator->() const noexcept
    {
        return ptr_;
    }

    // Modifiers
    pointer release() noexcept
    {
        pointer p = ptr_;
        ptr_ = nullptr;
        return p;
    }

    void reset(pointer p = pointer()) noexcept
    {
        pointer old = ptr_;
        ptr_ = p;
        if (old)
        {
            deleter_(old);
        }
    }

    void swap(unique_ptr &other) noexcept
    {
        pointer tmp = ptr_;
        ptr_ = other.ptr_;
        other.ptr_ = tmp;

        Deleter tmp_d = static_cast<Deleter &&>(deleter_);
        deleter_ = static_cast<Deleter &&>(other.deleter_);
        other.deleter_ = static_cast<Deleter &&>(tmp_d);
    }
};

// unique_ptr specialization for arrays
template <typename T, typename Deleter> class unique_ptr<T[], Deleter>
{
  public:
    using pointer = T *;
    using element_type = T;
    using deleter_type = Deleter;

  private:
    pointer ptr_;
    Deleter deleter_;

  public:
    constexpr unique_ptr() noexcept : ptr_(nullptr), deleter_() {}

    constexpr unique_ptr(nullptr_t) noexcept : ptr_(nullptr), deleter_() {}

    explicit unique_ptr(pointer p) noexcept : ptr_(p), deleter_() {}

    unique_ptr(pointer p, const Deleter &d) noexcept : ptr_(p), deleter_(d) {}

    unique_ptr(pointer p, Deleter &&d) noexcept : ptr_(p), deleter_(static_cast<Deleter &&>(d)) {}

    unique_ptr(unique_ptr &&u) noexcept
        : ptr_(u.release()), deleter_(static_cast<Deleter &&>(u.deleter_))
    {
    }

    ~unique_ptr()
    {
        if (ptr_)
        {
            deleter_(ptr_);
        }
    }

    unique_ptr(const unique_ptr &) = delete;
    unique_ptr &operator=(const unique_ptr &) = delete;

    unique_ptr &operator=(unique_ptr &&r) noexcept
    {
        reset(r.release());
        deleter_ = static_cast<Deleter &&>(r.deleter_);
        return *this;
    }

    unique_ptr &operator=(nullptr_t) noexcept
    {
        reset();
        return *this;
    }

    pointer get() const noexcept
    {
        return ptr_;
    }

    Deleter &get_deleter() noexcept
    {
        return deleter_;
    }

    const Deleter &get_deleter() const noexcept
    {
        return deleter_;
    }

    explicit operator bool() const noexcept
    {
        return ptr_ != nullptr;
    }

    T &operator[](size_t i) const
    {
        return ptr_[i];
    }

    pointer release() noexcept
    {
        pointer p = ptr_;
        ptr_ = nullptr;
        return p;
    }

    void reset(pointer p = pointer()) noexcept
    {
        pointer old = ptr_;
        ptr_ = p;
        if (old)
        {
            deleter_(old);
        }
    }

    void swap(unique_ptr &other) noexcept
    {
        pointer tmp = ptr_;
        ptr_ = other.ptr_;
        other.ptr_ = tmp;
    }
};

// Comparison operators for unique_ptr
template <typename T1, typename D1, typename T2, typename D2>
bool operator==(const unique_ptr<T1, D1> &x, const unique_ptr<T2, D2> &y)
{
    return x.get() == y.get();
}

template <typename T1, typename D1, typename T2, typename D2>
bool operator!=(const unique_ptr<T1, D1> &x, const unique_ptr<T2, D2> &y)
{
    return x.get() != y.get();
}

template <typename T1, typename D1, typename T2, typename D2>
bool operator<(const unique_ptr<T1, D1> &x, const unique_ptr<T2, D2> &y)
{
    return x.get() < y.get();
}

template <typename T1, typename D1, typename T2, typename D2>
bool operator<=(const unique_ptr<T1, D1> &x, const unique_ptr<T2, D2> &y)
{
    return x.get() <= y.get();
}

template <typename T1, typename D1, typename T2, typename D2>
bool operator>(const unique_ptr<T1, D1> &x, const unique_ptr<T2, D2> &y)
{
    return x.get() > y.get();
}

template <typename T1, typename D1, typename T2, typename D2>
bool operator>=(const unique_ptr<T1, D1> &x, const unique_ptr<T2, D2> &y)
{
    return x.get() >= y.get();
}

template <typename T, typename D> bool operator==(const unique_ptr<T, D> &x, nullptr_t) noexcept
{
    return !x;
}

template <typename T, typename D> bool operator==(nullptr_t, const unique_ptr<T, D> &x) noexcept
{
    return !x;
}

template <typename T, typename D> bool operator!=(const unique_ptr<T, D> &x, nullptr_t) noexcept
{
    return static_cast<bool>(x);
}

template <typename T, typename D> bool operator!=(nullptr_t, const unique_ptr<T, D> &x) noexcept
{
    return static_cast<bool>(x);
}

// make_unique
template <typename T, typename... Args> unique_ptr<T> make_unique(Args &&...args)
{
    return unique_ptr<T>(new T(static_cast<Args &&>(args)...));
}

template <typename T> unique_ptr<T> make_unique(size_t n)
{
    return unique_ptr<T>(new typename remove_extent<T>::type[n]());
}

// Control block for shared_ptr (simplified)
namespace detail
{

struct control_block_base
{
    unsigned int shared_count;
    unsigned int weak_count;

    control_block_base() : shared_count(1), weak_count(0) {}

    virtual ~control_block_base() = default;
    virtual void destroy() = 0;
    virtual void deallocate() = 0;
};

template <typename T> struct control_block : control_block_base
{
    T *ptr;

    explicit control_block(T *p) : ptr(p) {}

    void destroy() override
    {
        delete ptr;
        ptr = nullptr;
    }

    void deallocate() override
    {
        delete this;
    }
};

} // namespace detail

// Forward declaration for weak_ptr
template <typename T> class weak_ptr;

// shared_ptr - shared ownership smart pointer
template <typename T> class shared_ptr
{
  public:
    using element_type = T;
    using weak_type = weak_ptr<T>;

  private:
    T *ptr_;
    detail::control_block_base *ctrl_;

    template <typename U> friend class shared_ptr;
    template <typename U> friend class weak_ptr;

    void release()
    {
        if (ctrl_)
        {
            if (--ctrl_->shared_count == 0)
            {
                ctrl_->destroy();
                if (ctrl_->weak_count == 0)
                {
                    ctrl_->deallocate();
                }
            }
            ctrl_ = nullptr;
            ptr_ = nullptr;
        }
    }

  public:
    // Constructors
    constexpr shared_ptr() noexcept : ptr_(nullptr), ctrl_(nullptr) {}

    constexpr shared_ptr(nullptr_t) noexcept : ptr_(nullptr), ctrl_(nullptr) {}

    explicit shared_ptr(T *p) : ptr_(p), ctrl_(nullptr)
    {
        if (p)
        {
            ctrl_ = new detail::control_block<T>(p);
        }
    }

    // Copy constructor
    shared_ptr(const shared_ptr &r) noexcept : ptr_(r.ptr_), ctrl_(r.ctrl_)
    {
        if (ctrl_)
        {
            ++ctrl_->shared_count;
        }
    }

    template <typename U> shared_ptr(const shared_ptr<U> &r) noexcept : ptr_(r.ptr_), ctrl_(r.ctrl_)
    {
        if (ctrl_)
        {
            ++ctrl_->shared_count;
        }
    }

    // Move constructor
    shared_ptr(shared_ptr &&r) noexcept : ptr_(r.ptr_), ctrl_(r.ctrl_)
    {
        r.ptr_ = nullptr;
        r.ctrl_ = nullptr;
    }

    template <typename U> shared_ptr(shared_ptr<U> &&r) noexcept : ptr_(r.ptr_), ctrl_(r.ctrl_)
    {
        r.ptr_ = nullptr;
        r.ctrl_ = nullptr;
    }

    // Construct from weak_ptr
    template <typename U> explicit shared_ptr(const weak_ptr<U> &r);

    // Construct from unique_ptr
    template <typename U, typename D>
    shared_ptr(unique_ptr<U, D> &&r) : ptr_(r.get()), ctrl_(nullptr)
    {
        if (ptr_)
        {
            ctrl_ = new detail::control_block<U>(r.release());
        }
    }

    // Destructor
    ~shared_ptr()
    {
        release();
    }

    // Copy assignment
    shared_ptr &operator=(const shared_ptr &r) noexcept
    {
        if (this != &r)
        {
            release();
            ptr_ = r.ptr_;
            ctrl_ = r.ctrl_;
            if (ctrl_)
            {
                ++ctrl_->shared_count;
            }
        }
        return *this;
    }

    template <typename U> shared_ptr &operator=(const shared_ptr<U> &r) noexcept
    {
        release();
        ptr_ = r.ptr_;
        ctrl_ = r.ctrl_;
        if (ctrl_)
        {
            ++ctrl_->shared_count;
        }
        return *this;
    }

    // Move assignment
    shared_ptr &operator=(shared_ptr &&r) noexcept
    {
        if (this != &r)
        {
            release();
            ptr_ = r.ptr_;
            ctrl_ = r.ctrl_;
            r.ptr_ = nullptr;
            r.ctrl_ = nullptr;
        }
        return *this;
    }

    template <typename U> shared_ptr &operator=(shared_ptr<U> &&r) noexcept
    {
        release();
        ptr_ = r.ptr_;
        ctrl_ = r.ctrl_;
        r.ptr_ = nullptr;
        r.ctrl_ = nullptr;
        return *this;
    }

    template <typename U, typename D> shared_ptr &operator=(unique_ptr<U, D> &&r)
    {
        reset(r.release());
        return *this;
    }

    // Observers
    T *get() const noexcept
    {
        return ptr_;
    }

    T &operator*() const noexcept
    {
        return *ptr_;
    }

    T *operator->() const noexcept
    {
        return ptr_;
    }

    long use_count() const noexcept
    {
        return ctrl_ ? static_cast<long>(ctrl_->shared_count) : 0;
    }

    bool unique() const noexcept
    {
        return use_count() == 1;
    }

    explicit operator bool() const noexcept
    {
        return ptr_ != nullptr;
    }

    // Modifiers
    void reset() noexcept
    {
        release();
    }

    template <typename U> void reset(U *p)
    {
        release();
        if (p)
        {
            ptr_ = p;
            ctrl_ = new detail::control_block<U>(p);
        }
    }

    void swap(shared_ptr &r) noexcept
    {
        T *tmp_ptr = ptr_;
        ptr_ = r.ptr_;
        r.ptr_ = tmp_ptr;

        detail::control_block_base *tmp_ctrl = ctrl_;
        ctrl_ = r.ctrl_;
        r.ctrl_ = tmp_ctrl;
    }
};

// weak_ptr - non-owning observer of shared_ptr
template <typename T> class weak_ptr
{
  public:
    using element_type = T;

  private:
    T *ptr_;
    detail::control_block_base *ctrl_;

    template <typename U> friend class shared_ptr;
    template <typename U> friend class weak_ptr;

  public:
    constexpr weak_ptr() noexcept : ptr_(nullptr), ctrl_(nullptr) {}

    weak_ptr(const weak_ptr &r) noexcept : ptr_(r.ptr_), ctrl_(r.ctrl_)
    {
        if (ctrl_)
        {
            ++ctrl_->weak_count;
        }
    }

    template <typename U> weak_ptr(const weak_ptr<U> &r) noexcept : ptr_(r.ptr_), ctrl_(r.ctrl_)
    {
        if (ctrl_)
        {
            ++ctrl_->weak_count;
        }
    }

    template <typename U> weak_ptr(const shared_ptr<U> &r) noexcept : ptr_(r.ptr_), ctrl_(r.ctrl_)
    {
        if (ctrl_)
        {
            ++ctrl_->weak_count;
        }
    }

    weak_ptr(weak_ptr &&r) noexcept : ptr_(r.ptr_), ctrl_(r.ctrl_)
    {
        r.ptr_ = nullptr;
        r.ctrl_ = nullptr;
    }

    template <typename U> weak_ptr(weak_ptr<U> &&r) noexcept : ptr_(r.ptr_), ctrl_(r.ctrl_)
    {
        r.ptr_ = nullptr;
        r.ctrl_ = nullptr;
    }

    ~weak_ptr()
    {
        if (ctrl_)
        {
            if (--ctrl_->weak_count == 0 && ctrl_->shared_count == 0)
            {
                ctrl_->deallocate();
            }
        }
    }

    weak_ptr &operator=(const weak_ptr &r) noexcept
    {
        if (this != &r)
        {
            if (ctrl_ && --ctrl_->weak_count == 0 && ctrl_->shared_count == 0)
            {
                ctrl_->deallocate();
            }
            ptr_ = r.ptr_;
            ctrl_ = r.ctrl_;
            if (ctrl_)
            {
                ++ctrl_->weak_count;
            }
        }
        return *this;
    }

    template <typename U> weak_ptr &operator=(const weak_ptr<U> &r) noexcept
    {
        if (ctrl_ && --ctrl_->weak_count == 0 && ctrl_->shared_count == 0)
        {
            ctrl_->deallocate();
        }
        ptr_ = r.ptr_;
        ctrl_ = r.ctrl_;
        if (ctrl_)
        {
            ++ctrl_->weak_count;
        }
        return *this;
    }

    template <typename U> weak_ptr &operator=(const shared_ptr<U> &r) noexcept
    {
        if (ctrl_ && --ctrl_->weak_count == 0 && ctrl_->shared_count == 0)
        {
            ctrl_->deallocate();
        }
        ptr_ = r.ptr_;
        ctrl_ = r.ctrl_;
        if (ctrl_)
        {
            ++ctrl_->weak_count;
        }
        return *this;
    }

    weak_ptr &operator=(weak_ptr &&r) noexcept
    {
        if (this != &r)
        {
            if (ctrl_ && --ctrl_->weak_count == 0 && ctrl_->shared_count == 0)
            {
                ctrl_->deallocate();
            }
            ptr_ = r.ptr_;
            ctrl_ = r.ctrl_;
            r.ptr_ = nullptr;
            r.ctrl_ = nullptr;
        }
        return *this;
    }

    void reset() noexcept
    {
        if (ctrl_)
        {
            if (--ctrl_->weak_count == 0 && ctrl_->shared_count == 0)
            {
                ctrl_->deallocate();
            }
            ptr_ = nullptr;
            ctrl_ = nullptr;
        }
    }

    void swap(weak_ptr &r) noexcept
    {
        T *tmp_ptr = ptr_;
        ptr_ = r.ptr_;
        r.ptr_ = tmp_ptr;

        detail::control_block_base *tmp_ctrl = ctrl_;
        ctrl_ = r.ctrl_;
        r.ctrl_ = tmp_ctrl;
    }

    long use_count() const noexcept
    {
        return ctrl_ ? static_cast<long>(ctrl_->shared_count) : 0;
    }

    bool expired() const noexcept
    {
        return use_count() == 0;
    }

    shared_ptr<T> lock() const noexcept
    {
        if (expired())
        {
            return shared_ptr<T>();
        }
        shared_ptr<T> sp;
        sp.ptr_ = ptr_;
        sp.ctrl_ = ctrl_;
        if (ctrl_)
        {
            ++ctrl_->shared_count;
        }
        return sp;
    }
};

// shared_ptr constructor from weak_ptr
template <typename T>
template <typename U>
shared_ptr<T>::shared_ptr(const weak_ptr<U> &r) : ptr_(nullptr), ctrl_(nullptr)
{
    if (!r.expired())
    {
        ptr_ = r.ptr_;
        ctrl_ = r.ctrl_;
        if (ctrl_)
        {
            ++ctrl_->shared_count;
        }
    }
}

// Comparison operators for shared_ptr
template <typename T, typename U>
bool operator==(const shared_ptr<T> &a, const shared_ptr<U> &b) noexcept
{
    return a.get() == b.get();
}

template <typename T, typename U>
bool operator!=(const shared_ptr<T> &a, const shared_ptr<U> &b) noexcept
{
    return a.get() != b.get();
}

template <typename T, typename U>
bool operator<(const shared_ptr<T> &a, const shared_ptr<U> &b) noexcept
{
    return a.get() < b.get();
}

template <typename T, typename U>
bool operator<=(const shared_ptr<T> &a, const shared_ptr<U> &b) noexcept
{
    return a.get() <= b.get();
}

template <typename T, typename U>
bool operator>(const shared_ptr<T> &a, const shared_ptr<U> &b) noexcept
{
    return a.get() > b.get();
}

template <typename T, typename U>
bool operator>=(const shared_ptr<T> &a, const shared_ptr<U> &b) noexcept
{
    return a.get() >= b.get();
}

template <typename T> bool operator==(const shared_ptr<T> &x, nullptr_t) noexcept
{
    return !x;
}

template <typename T> bool operator==(nullptr_t, const shared_ptr<T> &x) noexcept
{
    return !x;
}

template <typename T> bool operator!=(const shared_ptr<T> &x, nullptr_t) noexcept
{
    return static_cast<bool>(x);
}

template <typename T> bool operator!=(nullptr_t, const shared_ptr<T> &x) noexcept
{
    return static_cast<bool>(x);
}

// make_shared
template <typename T, typename... Args> shared_ptr<T> make_shared(Args &&...args)
{
    return shared_ptr<T>(new T(static_cast<Args &&>(args)...));
}

// swap specializations
template <typename T, typename D> void swap(unique_ptr<T, D> &a, unique_ptr<T, D> &b) noexcept
{
    a.swap(b);
}

template <typename T> void swap(shared_ptr<T> &a, shared_ptr<T> &b) noexcept
{
    a.swap(b);
}

template <typename T> void swap(weak_ptr<T> &a, weak_ptr<T> &b) noexcept
{
    a.swap(b);
}

// addressof
template <typename T> T *addressof(T &r) noexcept
{
    return reinterpret_cast<T *>(&const_cast<char &>(reinterpret_cast<const volatile char &>(r)));
}

// pointer_traits
template <typename Ptr> struct pointer_traits
{
    using pointer = Ptr;
    using element_type = typename Ptr::element_type;
    using difference_type = ptrdiff_t;

    template <typename U> using rebind = typename Ptr::template rebind<U>;

    static pointer pointer_to(element_type &r)
    {
        return Ptr::pointer_to(r);
    }
};

template <typename T> struct pointer_traits<T *>
{
    using pointer = T *;
    using element_type = T;
    using difference_type = ptrdiff_t;

    template <typename U> using rebind = U *;

    static pointer pointer_to(element_type &r) noexcept
    {
        return addressof(r);
    }
};

// allocator_traits forward declaration
template <typename Alloc> struct allocator_traits;

// Default allocator
template <typename T> class allocator
{
  public:
    using value_type = T;
    using pointer = T *;
    using const_pointer = const T *;
    using reference = T &;
    using const_reference = const T &;
    using size_type = size_t;
    using difference_type = ptrdiff_t;

    template <typename U> struct rebind
    {
        using other = allocator<U>;
    };

    allocator() noexcept = default;
    allocator(const allocator &) noexcept = default;

    template <typename U> allocator(const allocator<U> &) noexcept {}

    ~allocator() = default;

    pointer address(reference x) const noexcept
    {
        return addressof(x);
    }

    const_pointer address(const_reference x) const noexcept
    {
        return addressof(x);
    }

    pointer allocate(size_type n)
    {
        return static_cast<pointer>(::operator new(n * sizeof(T)));
    }

    void deallocate(pointer p, size_type)
    {
        ::operator delete(p);
    }

    size_type max_size() const noexcept
    {
        return static_cast<size_type>(-1) / sizeof(T);
    }

    template <typename U, typename... Args> void construct(U *p, Args &&...args)
    {
        new (static_cast<void *>(p)) U(static_cast<Args &&>(args)...);
    }

    template <typename U> void destroy(U *p)
    {
        p->~U();
    }
};

template <typename T, typename U>
bool operator==(const allocator<T> &, const allocator<U> &) noexcept
{
    return true;
}

template <typename T, typename U>
bool operator!=(const allocator<T> &, const allocator<U> &) noexcept
{
    return false;
}

// uninitialized_copy
template <typename InputIt, typename ForwardIt>
ForwardIt uninitialized_copy(InputIt first, InputIt last, ForwardIt d_first)
{
    for (; first != last; ++first, ++d_first)
    {
        new (static_cast<void *>(addressof(*d_first)))
            typename iterator_traits<ForwardIt>::value_type(*first);
    }
    return d_first;
}

// uninitialized_fill
template <typename ForwardIt, typename T>
void uninitialized_fill(ForwardIt first, ForwardIt last, const T &value)
{
    for (; first != last; ++first)
    {
        new (static_cast<void *>(addressof(*first)))
            typename iterator_traits<ForwardIt>::value_type(value);
    }
}

// uninitialized_fill_n
template <typename ForwardIt, typename Size, typename T>
ForwardIt uninitialized_fill_n(ForwardIt first, Size count, const T &value)
{
    for (Size i = 0; i < count; ++i, ++first)
    {
        new (static_cast<void *>(addressof(*first)))
            typename iterator_traits<ForwardIt>::value_type(value);
    }
    return first;
}

} // namespace std

#endif // _VIPER_CXX_MEMORY
