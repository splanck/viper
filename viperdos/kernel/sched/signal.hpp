//===----------------------------------------------------------------------===//
//
// Part of the Viper project, under the GNU GPL v3.
// See LICENSE for license information.
//
//===----------------------------------------------------------------------===//
/**
 * @file signal.hpp
 * @brief POSIX-like signal handling for ViperDOS.
 *
 * @details
 * This module provides signal delivery for user-mode tasks. Signals can be
 * generated by:
 * - Hardware exceptions (SIGSEGV, SIGBUS, SIGILL, SIGFPE)
 * - User requests via kill() syscall
 * - Kernel events (SIGCHLD, SIGPIPE, etc.)
 *
 * Currently, most signals result in task termination since user-space signal
 * handlers are not yet implemented.
 */
#pragma once

#include "../include/types.hpp"
#include "task.hpp"

// Forward declaration of ExceptionFrame from arch/aarch64/exceptions.hpp
namespace exceptions {
struct ExceptionFrame;
} // namespace exceptions

namespace signal {

/// Signal numbers (POSIX subset)
namespace sig {
constexpr i32 SIGHUP = 1;     ///< Hangup
constexpr i32 SIGINT = 2;     ///< Interrupt (Ctrl+C)
constexpr i32 SIGQUIT = 3;    ///< Quit (Ctrl+\)
constexpr i32 SIGILL = 4;     ///< Illegal instruction
constexpr i32 SIGTRAP = 5;    ///< Trace trap
constexpr i32 SIGABRT = 6;    ///< Abort
constexpr i32 SIGBUS = 7;     ///< Bus error
constexpr i32 SIGFPE = 8;     ///< Floating point exception
constexpr i32 SIGKILL = 9;    ///< Kill (cannot be caught)
constexpr i32 SIGUSR1 = 10;   ///< User defined signal 1
constexpr i32 SIGSEGV = 11;   ///< Segmentation violation
constexpr i32 SIGUSR2 = 12;   ///< User defined signal 2
constexpr i32 SIGPIPE = 13;   ///< Broken pipe
constexpr i32 SIGALRM = 14;   ///< Alarm clock
constexpr i32 SIGTERM = 15;   ///< Termination
constexpr i32 SIGCHLD = 17;   ///< Child status changed
constexpr i32 SIGCONT = 18;   ///< Continue if stopped
constexpr i32 SIGSTOP = 19;   ///< Stop (cannot be caught)
constexpr i32 SIGTSTP = 20;   ///< Stop from terminal (Ctrl+Z)
constexpr i32 SIGTTIN = 21;   ///< Background read from tty
constexpr i32 SIGTTOU = 22;   ///< Background write to tty
constexpr i32 SIGURG = 23;    ///< Urgent I/O condition
constexpr i32 SIGXCPU = 24;   ///< CPU time limit exceeded
constexpr i32 SIGXFSZ = 25;   ///< File size limit exceeded
constexpr i32 SIGVTALRM = 26; ///< Virtual timer expired
constexpr i32 SIGPROF = 27;   ///< Profiling timer expired
constexpr i32 SIGWINCH = 28;  ///< Window size change
constexpr i32 SIGIO = 29;     ///< I/O possible
constexpr i32 SIGSYS = 31;    ///< Bad system call

constexpr i32 NSIG = 32; ///< Number of signals
} // namespace sig

/**
 * @brief Fault information passed with hardware signals.
 */
struct FaultInfo {
    u64 fault_addr;   ///< Faulting address (FAR_EL1)
    u64 fault_pc;     ///< Instruction that caused the fault (ELR_EL1)
    u32 fault_esr;    ///< Exception syndrome register
    const char *kind; ///< Human-readable fault type
};

/**
 * @brief Signal handler type (user-space function pointer).
 */
using SignalHandler = u64;

/// Special signal handler values
constexpr SignalHandler SIG_DFL = 0; ///< Default action
constexpr SignalHandler SIG_IGN = 1; ///< Ignore signal

/// Signal action flags
namespace sa_flags {
constexpr u32 SA_RESTART = (1 << 0);   ///< Restart interrupted syscalls
constexpr u32 SA_SIGINFO = (1 << 1);   ///< Use sa_sigaction instead of sa_handler
constexpr u32 SA_NODEFER = (1 << 2);   ///< Don't block signal during handler
constexpr u32 SA_RESETHAND = (1 << 3); ///< Reset to SIG_DFL after handling
constexpr u32 SA_ONSTACK = (1 << 4);   ///< Use alternate signal stack
} // namespace sa_flags

/**
 * @brief Signal action structure (sigaction).
 */
struct SigAction {
    SignalHandler handler; ///< Signal handler function address (or SIG_DFL/SIG_IGN)
    u32 flags;             ///< Signal action flags (SA_*)
    u32 mask;              ///< Signals to block during handler
};

/**
 * @brief Per-task signal state.
 */
struct SignalState {
    SigAction actions[sig::NSIG]; ///< Signal handlers for each signal
    u32 blocked;                  ///< Blocked signal mask
    u32 pending;                  ///< Pending signals bitmap

    /// Initialize with default actions
    void init() {
        for (int i = 0; i < sig::NSIG; i++) {
            actions[i].handler = SIG_DFL;
            actions[i].flags = 0;
            actions[i].mask = 0;
        }
        blocked = 0;
        pending = 0;
    }

    /// Check if a signal is pending and not blocked
    bool has_deliverable() const {
        return (pending & ~blocked) != 0;
    }

    /// Get the next deliverable signal (0 if none)
    i32 next_signal() const {
        u32 deliverable = pending & ~blocked;
        if (deliverable == 0)
            return 0;
        // Find lowest set bit
        for (i32 i = 1; i < sig::NSIG; i++) {
            if (deliverable & (1u << i))
                return i;
        }
        return 0;
    }
};

/**
 * @brief Get the default action for a signal.
 *
 * @param signum Signal number.
 * @return 'T' for terminate, 'I' for ignore, 'S' for stop, 'C' for continue.
 */
char default_action(i32 signum);

/**
 * @brief Get the name of a signal.
 *
 * @param signum Signal number.
 * @return Human-readable signal name (e.g., "SIGSEGV").
 */
const char *signal_name(i32 signum);

/**
 * @brief Send a signal to a task.
 *
 * @param task Target task.
 * @param signum Signal number.
 * @return 0 on success, -1 on error.
 */
i32 send_signal(task::Task *task, i32 signum);

/**
 * @brief Send a hardware fault signal to the current task.
 *
 * @details
 * Called from the exception handler when a user-mode fault occurs.
 * The fault is logged and the appropriate signal is delivered.
 *
 * @param signum Signal number (SIGSEGV, SIGBUS, SIGILL, etc.).
 * @param info Fault information.
 */
void deliver_fault_signal(i32 signum, const FaultInfo *info);

/**
 * @brief Check if a task has pending signals.
 *
 * @param task Task to check.
 * @return true if signals are pending.
 */
bool has_pending(task::Task *task);

/**
 * @brief Process pending signals for the current task.
 *
 * @details
 * Called before returning to user mode. Currently just terminates
 * the task for fatal signals since user handlers aren't implemented.
 */
void process_pending();

/**
 * @brief Signal frame pushed on user stack during signal delivery.
 *
 * @details
 * This structure is pushed onto the user stack before calling a signal handler.
 * The sigreturn syscall uses this to restore the original context.
 */
struct SignalFrame {
    u64 x[31];         ///< Saved general-purpose registers
    u64 sp;            ///< Saved stack pointer
    u64 elr;           ///< Saved return address
    u64 spsr;          ///< Saved program status
    u32 signum;        ///< Signal number
    u32 blocked_old;   ///< Previous blocked signal mask
    u64 trampoline[2]; ///< Signal return trampoline code
};

/**
 * @brief Set up signal delivery for the current task.
 *
 * @details
 * Called when returning to user mode if a signal is pending. This function:
 * 1. Saves the current context in a SignalFrame on the user stack
 * 2. Sets up the exception frame to call the signal handler
 * 3. When the handler returns, it calls the trampoline which invokes sigreturn
 *
 * @param frame Exception frame to modify for signal delivery.
 * @return true if a signal was delivered, false if no action needed.
 */
bool setup_signal_delivery(exceptions::ExceptionFrame *frame);

/**
 * @brief Restore context after sigreturn syscall.
 *
 * @details
 * Called from sys_sigreturn to restore the pre-signal context.
 *
 * @param frame Exception frame to restore into.
 * @return true if restoration succeeded, false on error.
 */
bool restore_signal_context(exceptions::ExceptionFrame *frame);

} // namespace signal
