//===----------------------------------------------------------------------===//
//
// Part of the Viper project, under the MIT License.
// See LICENSE for license information.
//
//===----------------------------------------------------------------------===//
//
// File: tui/src/term/term_io.cpp
// Purpose: Provide terminal I/O backends for the Viper TUI runtime, covering the
//          real ANSI terminal bridge and a string-backed mock used by tests and
//          headless tooling.
// Key invariants: RealTermIO streams bytes directly to stdout and flushes on
//                 demand without buffering internally; StringTermIO accumulates
//                 writes losslessly and exposes inspection helpers.
// Ownership/Lifetime: Implementations borrow or own only their immediate
//                     buffersâ€”no global state beyond the C stdio handles is
//                     touched.
// Links: docs/architecture.md#vipertui-architecture
//
//===----------------------------------------------------------------------===//

/// @file
/// @brief Implements concrete terminal I/O strategies for the Viper TUI.
/// @details The runtime needs both a production bridge that writes escape
///          sequences to stdout and a capture backend for tests.  This file
///          collects their definitions so callers can switch implementations
///          without duplicating behaviour.

#include "tui/term/term_io.hpp"
#include <cstdio>

namespace viper::tui::term
{

/// @brief Emit raw bytes to the process stdout stream.
/// @details Writes the provided view in a single @ref std::fwrite call when the
///          view is non-empty.  No buffering or newline translation occurs,
///          keeping the implementation safe for arbitrary ANSI escape sequences
///          generated by the renderer.
/// @param s Byte sequence to forward to the terminal.
void RealTermIO::write(std::string_view s)
{
    if (!s.empty())
    {
        std::fwrite(s.data(), 1, s.size(), stdout);
    }
}

/// @brief Flush the stdout stream to ensure pending bytes reach the terminal.
/// @details Delegates directly to @ref std::fflush on @c stdout so embedders do
///          not need to manage stdio state themselves.  No additional error
///          handling is required because failures are surfaced via errno by the
///          C library.
void RealTermIO::flush()
{
    std::fflush(stdout);
}

/// @brief Append the provided string view to the in-memory buffer.
/// @details Extends the backing @ref std::string without modifying @p s, making
///          this implementation ideal for capturing output in tests or logging
///          scenarios.  The buffer retains its contents until @ref clear() is
///          invoked.
/// @param s Byte sequence to capture.
void StringTermIO::write(std::string_view s)
{
    buf_.append(s.data(), s.size());
}

/// @brief String-backed term IO has no flushing side effects.
/// @details The capture buffer is always up-to-date, so flushing is effectively
///          a no-op.  The method exists to honour the @ref TermIO interface.
void StringTermIO::flush() {}

/// @brief Inspect the accumulated terminal output.
/// @details Provides read-only access to the captured bytes so tests can perform
///          assertions without copying.  The reference remains valid until the
///          buffer is mutated by further writes or a call to @ref clear().
/// @return Reference to the internal capture buffer.
const std::string &StringTermIO::buffer() const
{
    return buf_;
}

/// @brief Clear the captured terminal output buffer.
/// @details Resets the buffer to an empty string so subsequent captures start
///          from a clean slate.
void StringTermIO::clear()
{
    buf_.clear();
}

} // namespace viper::tui::term
